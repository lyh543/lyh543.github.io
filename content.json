[{"title":"马克思原理概论","date":"2021-07-05T06:00:00.000Z","path":"others/marx-principle/","text":"哲学理论 三大唯物主义：古代朴素、近代形而上学、现代辩证 两大唯心主义：客观、主观 可知论、不可知论（物质和意识是否具有同一性） 运动和静止 运动：物质变化及其过程 静止：物质运动在一定条件下的稳定状态 概念的关系：对立统一（同一类型）/不可分割（不同类型）。 唯物论：物质、意识和实践 实践：物质和意识间唯一的桥梁 意识：客观世界的主观映像 物质、意识通过实践转化 依赖又相对独立 物质决定意识、意识反作用于物质 物质的统一性原理 世界是统一的（唯物主义、唯心主义） 世界统一的基础是物质（唯物主义） 物质世界的统一是多样性的统一（马克思主义） 辩证法两大总特征 普遍联系 永恒发展 五对范畴 原因和结果：前后相继 &amp; 彼此制约 相互作用 关系复杂多样 必然和偶然 必然是内部，偶然是外部 偶然后面是必然 相互转化 可能和现实 现象和本质 内容和形式 三大规律 对立统一规律 矛盾就是对立统一 质量互变规律 必要准备、必然结果、相互渗透 否定之否定规律 客观辩证法、主观辩证法唯物辩证法 = 客观辩证法 + 主观辩证法 认识论 实践：人类能动地改造世界的客观物质活动 实践主体、实践客体、实践中介 分为物质生产实践、社会政治实践和科学文化实践 认识：主体在实践基础上对客体的能动反映。 认识的第一次飞跃 从实践到认识 从感性认识到理性认识 经验主义 &lt;- 感性认识 &lt;-&gt; 理性认识 -&gt; 教条主义 认识的第二次飞跃 从认识到实践 从理性认识到实践 认识过程中的影响因素：理性因素、非理性因素 理性认识 != 理性因素，感性认识 != 非理性因素 认识的两大规律 反复性 无限性 真理与谬误真理的特点： 客观性 一元性 绝对性 相对性 具体性 生产力和生产关系生产力： 生产力是物质 生产力 = 生产资料 + 劳动者 生产资料 = 劳动资料 + 劳动对象 劳动资料最重要的是生产工具，其反应了经济时代 科学技术是决定性因素、是第一生产力 生产关系：人们在生产过程中的经济关系 = 生产资料所有制关系（最基本、决定性） + 人与人的关系 + 产品分配关系 经济基础和上层建筑 经济基础：生产关系的总和 生产力 --决定-&gt; 生产关系 --决定-&gt; 经济建筑 上层建筑：经济基础上的意识形态 国家政权 --核心-&gt; 政治上层建筑 --主导-&gt; 上层建筑 经济基础 --决定--&gt; 上层建筑 社会基本矛盾：生产力 &lt;-&gt; 生产关系、经济基础 &lt;-&gt; 上层建筑 剩余价值 具体劳动：形成使用价值 抽象劳动：形成价值","tags":[]},{"title":"常用 Python 代码片段","date":"2021-06-27T13:15:25.000Z","path":"python/python-snippets/","text":"文件1234567891011121314151617def tranverse(dir: str): \"\"\" 遍历给定文件夹，并返回所有文件（不含文件夹）路径组成的数组 \"\"\" ret = [] for root, dirs, files in os.walk(dir): for file in files: ret.append(os.path.join(root, file)) return retdef md5_file(file: str) -&gt; str: \"\"\" 计算给定文件的 md5 \"\"\" with open(file, 'rb') as file: return hashlib.md5(file.read()).hexdigest()","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"}]},{"title":"Microsoft Visio 使用技巧","date":"2021-06-21T16:00:00.000Z","path":"microsoft/visio-tips/","text":"连接点 编辑连接线线条、箭头或点 - Visio - Microsoft Support 连接点是形状上的特殊点，可以向它“粘附”连接线和其他形状。 当将连接线或形状粘附至连接点时，即使某个形状发生移动，该连接线和连接点都保持连接状态。 连接点 除了使用系统自带的连接点，我们还可以为自己的图形添加连接点。 添加连接点 更改网格大小 在Visio 中显示、隐藏或更改网格 - Visio - Microsoft Support视频：更改网格间距大小 - Visio - Microsoft Support 上面的添加连接点没有参考线容易弄歪，我们可以使用网格作为参考线。 如果网格太宽或者太窄，我们还可以自己进行调整。","tags":[{"name":"tips","slug":"tips","permalink":"https://blog.lyh543.cn/tags/tips/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://blog.lyh543.cn/tags/Microsoft/"},{"name":"Visio","slug":"Visio","permalink":"https://blog.lyh543.cn/tags/Visio/"}]},{"title":"搭建 Spring Boot REST API 项目 (7) -- 自动生成 REST API 文档","date":"2021-06-18T16:00:00.000Z","path":"java/spring-boot-rest-api-tutorial/7-docs-generator/","text":"系列目录 搭建 Spring Boot REST API 项目 (1) – Hello World 搭建 Spring Boot REST API 项目 (2) – 数据库和测试 搭建 Spring Boot REST API 项目 (3) – 请求和应答 搭建 Spring Boot REST API 项目 (4) – 字段校验 搭建 Spring Boot REST API 项目 (5) – 序列化和反序列化 搭建 Spring Boot REST API 项目 (6) – 认证和安全 搭建 Spring Boot REST API 项目 (7) – 自动生成 REST API 文档 编者按 本节转载自：Spring Boot教程第10篇：restdoc - 方志朋的博客Spring Boot教程第11篇：swagger2 - 方志朋的博客给Swagger升级了新版本，没想到居然有这么多坑！ - Document 一个 API 最好要有面向使用者的文档，因为 API 就是给其他开发者调用的，这是 API 开发和其他应用开发不同的地方。 API 文档生成器的作用就在于，代码和文档是绑定的，更新代码而忘记更新文档的情形会减少很多。 Spring Boot REST API 项目常用的 API 文档有两种： Spring REST Docs：基于测试的文档生成器。需要编写测试样例，测试运行的同时会生成 adoc 格式的测试输入与输出，然后编写文档模板，文档就可以嵌入测试的输入和输出。 Swagger 2：在 Controller 中添加说明程序功能的注解，Swagger 就可以自动生成 API 文档页面。 Spring REST Docs swagger Spring REST Docs创建工程引入依赖，其pom文件： 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt; &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 通过@SpringBootApplication,开启springboot： 1234567@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 在springboot通常创建一个controller: 123456789@RestControllerpublic class HomeController &#123; @GetMapping(\"/\") public Map&lt;String, Object&gt; greeting() &#123; return Collections.singletonMap(\"message\", \"Hello World\"); &#125;&#125; 启动工程，访问localhost:8080，浏览器显示： 1&#123;“message”:”Hello World”&#125; 证明接口已经写好了，但是如何通过restdoc生存api文档呢 通过单元测试生成api文档restdocs是通过单元测试生存snippets文件，然后snippets根据插件生成htm文档的。 建一个单元测试类： 123456789101112131415@RunWith(SpringRunner.class)@WebMvcTest(HomeController.class)@AutoConfigureRestDocs(outputDir = \"target/snippets\")public class WebLayerTest &#123; @Autowired private MockMvc mockMvc; @Test public void shouldReturnDefaultMessage() throws Exception &#123; this.mockMvc.perform(get(\"/\")).andDo(print()).andExpect(status().isOk()) .andExpect(content().string(containsString(\"Hello World\"))) .andDo(document(\"home\")); &#125;&#125; 其中，@AutoConfigureRestDocs注解开启了生成snippets文件，并指定了存放位置。 启动单元测试，测试通过，你会发现在target文件下生成了一个snippets文件夹，其目录结构如下： 1234567└── target └── snippets └── home └── httpie-request.adoc └── curl-request.adoc └── http-request.adoc └── http-response.adoc 默认情况下，snippets是Asciidoctor格式的文件，包括request和reponse，另外其他两种httpie和curl两种流行的命令行的http请求模式。 到目前为止，只生成了Snippets文件，需要用Snippets文件生成文档。 怎么用Snippets创建一个新文件src/main/asciidoc/index.adoc： 123456789= 用 Spring REST Docs 构建文档This is an example output for a service running at http://localhost:8080:.requestinclude::&#123;snippets&#125;/home/http-request.adoc[].responseinclude::&#123;snippets&#125;/home/http-response.adoc[] 这个例子非常简单，通过单元测试和一些简单的配置就能够得到api文档了。 adoc的书写格式，参考:http://docs.spring.io/spring-restdocs/docs/current/reference/html5/，这里不多讲解。 需要使用asciidoctor-maven-plugin插件，在其pom文件加上： 1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt; &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;generate-docs&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;process-asciidoc&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDocumentName&gt;index.adoc&lt;/sourceDocumentName&gt; &lt;backend&gt;html&lt;/backend&gt; &lt;attributes&gt; &lt;snippets&gt;$&#123;project.build.directory&#125;/snippets&lt;/snippets&gt; &lt;/attributes&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 这时只需要通过mvnw package命令就可以生成文档了。 在/target/generated-docs下有个index.html，打开这个html,显示如下，界面还算简洁： adoc 文档 结语通过单元测试，生存adoc文件，再用adoc文件生存html，只需要简单的几步就可以生成一个api文档的html文件，这个html文件你可以通网站发布出去。整个过程很简单，对代码无任何影响。 源码下载：https://github.com/forezp/SpringBootLearning 参考资料 https://spring.io/guides/gs/testing-restdocs/ http://docs.spring.io/spring-restdocs/docs/current/reference/html5/ Swagger 2swagger,中文“拽”的意思。它是一个功能强大的api框架，它的集成非常简单，不仅提供了在线文档的查阅，而且还提供了在线文档的测试。另外swagger很容易构建restful风格的api，简单优雅帅气，正如它的名字。 引入依赖12345678910111213141516&lt;properties&gt; &lt;swagger2.version&gt;2.9.2&lt;/swagger2.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--Swagger-UI API文档生产工具--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger2.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger2.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 写配置类12345678910111213141516171819202122@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.forezp.controller\")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"springboot利用swagger构建api文档\") .description(\"简单优雅的restfun风格，http://blog.csdn.net/forezp\") .termsOfServiceUrl(\"http://blog.csdn.net/forezp\") .version(\"1.0\") .build(); &#125;&#125; 通过@Configuration注解，表明它是一个配置类，@EnableSwagger2开启swagger2。apiINfo()配置一些基本的信息。apis()指定扫描的包会生成文档。 写生产文档的注解swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。 @Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiProperty：用对象接收参数时，描述对象的一个字段 @ApiResponse：HTTP响应其中1个描述 @ApiResponses：HTTP响应整体描述 @ApiIgnore：使用该注解忽略这个API @ApiError：发生错误返回的信息 @ApiParamImplicitL：一个请求参数 @ApiParamsImplicit 多个请求参数 现在通过一个栗子来说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.forezp.controller;import com.forezp.entity.Book;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.*;import springfox.documentation.annotations.ApiIgnore;import java.util.*;/** * 用户创建某本图书 POST /books/ * 用户修改对某本图书 PUT /books/:id/ * 用户删除对某本图书 DELETE /books/:id/ * 用户获取所有的图书 GET /books * 用户获取某一图书 GET /Books/:id * Created by fangzhipeng on 2017/4/17. * 官方文档：http://swagger.io/docs/specification/api-host-and-base-path/ */@RestController@RequestMapping(value = \"/books\")public class BookContrller &#123; Map&lt;Long, Book&gt; books = Collections.synchronizedMap(new HashMap&lt;Long, Book&gt;()); @ApiOperation(value=\"获取图书列表\", notes=\"获取图书列表\") @RequestMapping(value=&#123;\"\"&#125;, method= RequestMethod.GET) public List&lt;Book&gt; getBook() &#123; List&lt;Book&gt; book = new ArrayList&lt;&gt;(books.values()); return book; &#125; @ApiOperation(value=\"创建图书\", notes=\"创建图书\") @ApiImplicitParam(name = \"book\", value = \"图书详细实体\", required = true, dataType = \"Book\") @RequestMapping(value=\"\", method=RequestMethod.POST) public String postBook(@RequestBody Book book) &#123; books.put(book.getId(), book); return \"success\"; &#125; @ApiOperation(value=\"获图书细信息\", notes=\"根据url的id来获取详细信息\") @ApiImplicitParam(name = \"id\", value = \"ID\", required = true, dataType = \"Long\",paramType = \"path\") @RequestMapping(value=\"/&#123;id&#125;\", method=RequestMethod.GET) public Book getBook(@PathVariable Long id) &#123; return books.get(id); &#125; @ApiOperation(value=\"更新信息\", notes=\"根据url的id来指定更新图书信息\") @ApiImplicitParams(&#123; @ApiImplicitParam(name = \"id\", value = \"图书ID\", required = true, dataType = \"Long\",paramType = \"path\"), @ApiImplicitParam(name = \"book\", value = \"图书实体book\", required = true, dataType = \"Book\") &#125;) @RequestMapping(value=\"/&#123;id&#125;\", method= RequestMethod.PUT) public String putUser(@PathVariable Long id, @RequestBody Book book) &#123; Book book1 = books.get(id); book1.setName(book.getName()); book1.setPrice(book.getPrice()); books.put(id, book1); return \"success\"; &#125; @ApiOperation(value=\"删除图书\", notes=\"根据url的id来指定删除图书\") @ApiImplicitParam(name = \"id\", value = \"图书ID\", required = true, dataType = \"Long\",paramType = \"path\") @RequestMapping(value=\"/&#123;id&#125;\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; books.remove(id); return \"success\"; &#125; @ApiIgnore//使用该注解忽略这个API @RequestMapping(value = \"/hi\", method = RequestMethod.GET) public String jsonTest() &#123; return \" hi you!\"; &#125;&#125; 通过相关注解，就可以让swagger2生成相应的文档。如果你不需要某接口生成文档，只需要在加@ApiIgnore注解即可。需要说明的是，如果请求参数在url上，@ApiImplicitParam 上加paramType = “path”。 启动工程，访问：http://localhost:8080/swagger-ui.html ，就看到swagger-ui: swagger-ui 整个集成过程非常简单，但是我看了相关的资料，swagger 没有做安全方面的防护，可能需要我们自己做相关的工作。 参考资料 swagger.io Spring Boot中使用Swagger2构建强大的RESTful API文档","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.lyh543.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.lyh543.cn/tags/Spring/"}]},{"title":"搭建 Spring Boot REST API 项目 (6) -- 认证和安全","date":"2021-06-17T16:00:00.000Z","path":"java/spring-boot-rest-api-tutorial/6-authentication-and-security/","text":"系列目录 搭建 Spring Boot REST API 项目 (1) – Hello World 搭建 Spring Boot REST API 项目 (2) – 数据库和测试 搭建 Spring Boot REST API 项目 (3) – 请求和应答 搭建 Spring Boot REST API 项目 (4) – 字段校验 搭建 Spring Boot REST API 项目 (5) – 序列化和反序列化 搭建 Spring Boot REST API 项目 (6) – 认证和安全 搭建 Spring Boot REST API 项目 (7) – 自动生成 REST API 文档 咕咕咕","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.lyh543.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.lyh543.cn/tags/Spring/"}]},{"title":"搭建 Spring Boot REST API 项目 (5) -- 序列化和反序列化","date":"2021-06-16T16:00:00.000Z","path":"java/spring-boot-rest-api-tutorial/5-serialization/","text":"系列目录 搭建 Spring Boot REST API 项目 (1) – Hello World 搭建 Spring Boot REST API 项目 (2) – 数据库和测试 搭建 Spring Boot REST API 项目 (3) – 请求和应答 搭建 Spring Boot REST API 项目 (4) – 字段校验 搭建 Spring Boot REST API 项目 (5) – 序列化和反序列化 搭建 Spring Boot REST API 项目 (6) – 认证和安全 搭建 Spring Boot REST API 项目 (7) – 自动生成 REST API 文档 咕咕咕","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.lyh543.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.lyh543.cn/tags/Spring/"}]},{"title":"项目开发中的好习惯","date":"2021-06-16T01:03:10.000Z","path":"development/good-habits-in-development/","text":"学校里的程序设计课程只教如何使用编程语言，网上的大多数项目开发教程只教如何开发一个项目。只有在项目开发中才会知道某些潜规则开发项目的好习惯，如合适地使用 Git 分支管理、版本号命名规则等。 合适地使用 Git 分支管理https://zhuanlan.zhihu.com/p/39148914 Git 基础教程推荐廖雪峰：https://www.liaoxuefeng.com/wiki/896043488029600 版本号命名：语义化版本 (Sematic Version) https://semver.org/lang/zh-CN/ Git commit 规范：语义化提交信息 (Semantic Commit Messages) https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716 使用以下风格编写提交信息： 1type(scope): subject 其中 type 为提交类型，推荐从以下 7 个中选择一个： feat: 新功能 (new feature for the user, not a new feature for build script) fix: 修复 bug (bug fix for the user, not a fix to a build script) docs: 文档 (changes to the documentation) style: 修改风格，生产环境代码没有更改 (formatting, missing semi colons, etc; no production code change) refactor: 重构生产环境的代码 (refactoring production code, eg. renaming a variable) test: 增加或重构测试，生产环境代码没有更改 (adding missing tests, refactoring tests; no production code change) chore: 其他琐事，如构建过程或辅助工具的变动，生产环境代码没有更改 (updating grunt tasks etc; no production code change) 三个 commit 信息的例子： 12345docs: 更新文档feat(user): 添加用户注册功能test(user): 添加用户单元测试 Badge 生成器这里有通用的 Badge 生成器： 12https://img.shields.io/badge/&lt;first&gt;-&lt;last&gt;-&lt;color&gt;.svghttps://img.shields.io/badge/Language-Python%203.9-yellow.svg Language All Contributers这是 Contributers 生成器。 中文介绍：https://allcontributors.org/docs/zh-cn/bot/overview","tags":[{"name":"项目开发","slug":"项目开发","permalink":"https://blog.lyh543.cn/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"name":"Git","slug":"Git","permalink":"https://blog.lyh543.cn/tags/Git/"}]},{"title":"搭建 Spring Boot REST API 项目 (4) -- 校验器","date":"2021-06-15T16:00:00.000Z","path":"java/spring-boot-rest-api-tutorial/4-validation/","text":"系列目录 搭建 Spring Boot REST API 项目 (1) – Hello World 搭建 Spring Boot REST API 项目 (2) – 数据库和测试 搭建 Spring Boot REST API 项目 (3) – 请求和应答 搭建 Spring Boot REST API 项目 (4) – 字段校验 搭建 Spring Boot REST API 项目 (5) – 序列化和反序列化 搭建 Spring Boot REST API 项目 (6) – 认证和安全 搭建 Spring Boot REST API 项目 (7) – 自动生成 REST API 文档 校验器 (validator)上面可以看到，Java 能自动将 json 反序列化为 User。但我们可能还需要检查每一个字段的合法性，如注册时要求 email 不为空且唯一；name 不为空；password 不少于 6 位。 使用 javax.validaton12345&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920@Null 被注释的元素必须为 null@NotNull 被注释的元素必须不为 null@AssertTrue 被注释的元素必须为 true@AssertFalse 被注释的元素必须为 false@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max=, min=) 被注释的元素的大小必须在指定的范围内@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式Hibernate Validator提供的校验注解：@NotBlank(message =) 验证字符串非null，且长度必须大于0@Email 被注释的元素必须是电子邮箱地址@Length(min=,max=) 被注释的字符串的大小必须在指定的范围内@NotEmpty 被注释的字符串的必须非空@Range(min=,max=,message=) 被注释的元素必须在合适的范围内","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.lyh543.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.lyh543.cn/tags/Spring/"}]},{"title":"搭建 Spring Boot REST API 项目 (3) -- 请求和应答","date":"2021-06-09T16:00:00.000Z","path":"java/spring-boot-rest-api-tutorial/3-request-and-response/","text":"系列目录 搭建 Spring Boot REST API 项目 (1) – Hello World 搭建 Spring Boot REST API 项目 (2) – 数据库和测试 搭建 Spring Boot REST API 项目 (3) – 请求和应答 搭建 Spring Boot REST API 项目 (4) – 字段校验 搭建 Spring Boot REST API 项目 (5) – 序列化和反序列化 搭建 Spring Boot REST API 项目 (6) – 认证和安全 搭建 Spring Boot REST API 项目 (7) – 自动生成 REST API 文档 请求参数 (request params)上面的 url 并没有自定义参数，接下来我们定义一下请求参数，使得可以通过 http://localhost:8080/api/user/{id} 和 http://localhost:8080/api/user?id={id} 访问到 {id} 的用户。 结论： 12345678// 以 /api/user/&#123;id&#125; 形式访问@GetMapping(\"/api/user/&#123;id&#125;\")public User getUserInfo(@PathVariable(\"id\") int id);// 以 /api/user?id=&#123;id&#125; 形式访问@GetMapping(\"/api/user\")public User getUserInfoByParams(@Param(\"id\") int id); 扩充 UserMapper（数据访问层）： 1234567891011121314// src/main/java/com/lyh543/springbootdemo/mapper/UserMapper.java@Repositorypublic interface UserMapper &#123; @Select(\"SELECT * FROM users WHERE email = #&#123;email&#125;\") User getByEmail(@Param(\"email\") String email); @Select(\"SELECT * FROM users WHERE id = #&#123;id&#125;\") User getById(@Param(\"id\") int id); @Insert(\"INSERT INTO users (email, password, name) VALUES (#&#123;email&#125;, #&#123;password&#125;, #&#123;name&#125;)\") @Options(useGeneratedKeys=true, keyProperty = \"id\") // 注意 insert 的返回值返回仍然是插入行数，而 id 被放自动在了 user.id 里 int insert(User user);&#125; 扩充 UserService（业务逻辑层）： 123456789101112131415// src/main/java/com/lyh543/springbootdemo/service/UserService.java@Servicepublic class UserService &#123; @Autowired UserMapper userMapper; public User getByEmail(String email) &#123; return userMapper.getByEmail(email); &#125; public User getUserById(int id) &#123; return userMapper.getById(id); &#125;&#125; 最后是 UserController（视图层）： 12345678910111213141516171819// src/main/java/com/lyh543/springbootdemo/web/UserController.java@RestControllerpublic class UserController &#123; @Autowired UserService userService; // /api/user/1 @GetMapping(\"/api/user/&#123;id&#125;\") public User getUserInfo(@PathVariable(\"id\") int id) &#123; return userService.getUserById(id); &#125; // /api/user?id=1 @GetMapping(\"/api/user\") public User getUserInfoByParams(@Param(\"id\") int id) &#123; return userService.getUserById(id); &#125;&#125; 然后运行，httpie 测试： 123456789101112131415$ http http://localhost:8080/api/user/1&#123; \"id\": 1, \"email\": \"lyh543@outlook.com\", \"password\": \"123456\", \"name\": \"lyh543\"&#125;$ http http://localhost:8080/api/user/2&#123; \"id\": 2, \"email\": \"test@example.com\", \"password\": \"test\", \"name\": \"test\"&#125; 返回 404 错误在上面的测试中，如果我们 GET 一个不存在的用户，会返回 200 + 空报文。能不能返回 404 呢？ 当然是可以的，我们只需要在 user == null 的时候抛出 ResponseStatusException(HttpStatus.NOT_FOUND) 即可。 mapper、service 和 controller 都可以抛异常，应该在哪里抛出呢？应当是 service。 mapper 只负责单纯地访问数据库； service 主要负责业务的逻辑； controller 只负责将 url 映射到 service、将 service 的返回值转发出去。 于是稍微改一改 service 层： 12345678910111213141516@Servicepublic class UserService &#123; @Autowired UserMapper userMapper; public User getByEmail(String email) &#123; return userMapper.getByEmail(email); &#125; public User getUserById(int id) &#123; User user = userMapper.getById(id); if (user == null) throw new ResponseStatusException(HttpStatus.NOT_FOUND); return user; &#125;&#125; 然后编译，命令行运行 http localhost:8000/api/user/3： 12345678910111213141516$ http localhost:8080/api/user/3HTTP/1.1 404Connection: keep-aliveContent-Type: application/jsonDate: Thu, 10 Jun 2021 08:32:21 GMTKeep-Alive: timeout=60Transfer-Encoding: chunked&#123; \"error\": \"Not Found\", \"message\": \"404 NOT_FOUND\", \"path\": \"/api/user/3\", \"status\": 404, \"timestamp\": \"2021-06-10T08:32:21.775+00:00\", \"trace\": \"org.springframework.web.server.ResponseStatusException: 404 NOT_FOUND .....\"&#125; 对了，如果用浏览器访问，可能会报错。猜测可能是 Spring MVC 的 view 在收到 404 会尝试渲染为 /error，但我们并没有写 /error。 浏览器报错 两种访问方式结果不同的直接原因是浏览器不接受 application/json，Spring MVC 只能返回 text/html；而命令行接收 */*，Spring 就可以返回 application/json 了。 请求体 (request body)上面的例子中，参数都在 URL 中。使用 POST 方法，就可以在 request body 里装东西了。 nb 的是，Spring Boot 也可以对 request body 自动反序列化，太香了！ 123@PostMapping(\"/api/user\")public User createUser(@RequestBody User user) &#123;&#125; 为了看看 Spring Boot 是如何反序列化、序列化的，我们在 UserController 里写一个函数，把参数 user 直接返回回去。 1234567891011121314151617// src/main/java/com/lyh543/springbootdemo/web/UserController.java@RestControllerpublic class UserController &#123; @Autowired UserService userService; @GetMapping(\"/api/user/&#123;id&#125;\") public User getUserInfo(@PathVariable(\"id\") int id) &#123; return userService.getUserById(id); &#125; @PostMapping(\"/api/user\") public User createUser(@RequestBody User user) &#123; return user; &#125;&#125; 下面开始请求： 12345678$ http localhost:8080/api/userHTTP/1.1 405Allow: POSTConnection: keep-aliveContent-Type: application/jsonDate: Thu, 10 Jun 2021 09:27:05 GMTKeep-Alive: timeout=60Transfer-Encoding: chunked httpie 如果没有加 =，就是 GET 方法；如果加了 id=1 或者单单一个的 =，那就是 POST 方法。 这个 url 只给了 PostMapping，所以 GET 方法被打回来了。 123456789101112131415$ http localhost:8080/api/user id=1HTTP/1.1 500Connection: closeContent-Type: application/jsonDate: Thu, 10 Jun 2021 09:25:48 GMTTransfer-Encoding: chunked&#123; \"error\": \"Internal Server Error\", \"message\": \"Type definition error: [simple type, class com.lyh543.springbootdemo.entity.User]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.lyh543.springbootdemo.entity.User` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\\n at [Source: (PushbackInputStream); line: 1, column: 2]\", \"path\": \"/api/user\", \"status\": 500, \"timestamp\": \"2021-06-10T09:25:48.338+00:00\", \"trace\": \"org.springframework.http.converter.HttpMessageConversionException\"&#125; 在网上查了一下，原来是 User 没有加默认构造方法，所以 Spring 的反序列化器就挂掉了。 为 User 加上默认构造方法： 123456789101112131415public class User &#123; private long id; private String email, password, name; public User() &#123;&#125; public User(int id, String email, String password, String name) &#123; this.id = id; this.email = email; this.password = password; this.name = name; &#125; // ...&#125; 再次请求： 1234567891011121314$ http localhost:8080/api/user id=1HTTP/1.1 200Connection: keep-aliveContent-Type: application/jsonDate: Thu, 10 Jun 2021 09:27:00 GMTKeep-Alive: timeout=60Transfer-Encoding: chunked&#123; \"email\": null, \"id\": 1, \"name\": null, \"password\": null&#125; 好耶！可以看到 Spring 为我们创建了一个新的 User 对象，并把参数填进去了。 还请读者尝试，当 key 不正确时（如传递 a=1，甚至什么都不传递、只写一个 =），会发生什么。 处理请求体收到了 User，我们先不考虑验证数据的合法性，直接将收到的数据插入数据库。之前已经写了 UserMapper.insert，我们补一下 UserService 和 UserController。 1234567891011121314151617// src/main/java/com/lyh543/springbootdemo/service/UserService.java@Servicepublic class UserService &#123; public User createUser(User user) &#123; userMapper.insert(user); return user; &#125;&#125;// src/main/java/com/lyh543/springbootdemo/web/UserController.java@RestControllerpublic class UserController &#123; @PostMapping(\"/api/user\") public User createUser(@RequestBody User user) &#123; return userService.createUser(user); &#125;&#125; 编写好以后重启，运行 http 命令 1234567891011121314$ http localhost:8080/api/user email=test@example.com password=123 name=lyhHTTP/1.1 200Connection: keep-aliveContent-Type: application/jsonDate: Fri, 11 Jun 2021 03:02:31 GMTKeep-Alive: timeout=60Transfer-Encoding: chunked&#123; \"email\": \"test@example.com\", \"id\": 10, \"name\": \"lyh\", \"password\": \"123\"&#125; 查一下数据库，发现确实写入数据库了。 返回 201但是创建用户返回 200 也太不 RESTful 了吧，创建用户应当返回 201 Created。 我们只需要在写 Controller 函数的时候多传递一个 HttpServletResponse response，然后修改这个 Response 就可以了。 12345@PostMapping(\"/api/user\")public User createUser(@RequestBody User user, HttpServletResponse response) &#123; response.setStatus(HttpStatus.CREATED.value()); return userService.createUser(user);&#125; 1234567891011121314$ http localhost:8080/api/user email=test2@example.com password=123 name=userHTTP/1.1 201Connection: keep-aliveContent-Type: application/jsonDate: Fri, 11 Jun 2021 03:20:37 GMTKeep-Alive: timeout=60Transfer-Encoding: chunked&#123; \"email\": \"test2@example.com\", \"id\": 12, \"name\": \"user\", \"password\": \"123\"&#125; 用同样的方法，我们还可以获取 request 内容： 12@PostMapping(\"/api/user\")public User createUser(@RequestBody User user, HttpServletRequest request, HttpServletResponse response) &#123;&#125; 我们甚至可以将这两个东西 @Autowired 到类上，以后就不用写这两个参数了。 123456789101112131415@RestControllerpublic class UserController &#123; @Autowired UserService userService; @Autowired HttpServletRequest request; @Autowired HttpServletResponse response; @PostMapping(\"/api/user\") public User createUser(@RequestBody User user) &#123; response.setStatus(HttpStatus.CREATED.value()); return userService.createUser(user); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.lyh543.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.lyh543.cn/tags/Spring/"}]},{"title":"搭建 Spring Boot REST API 项目 (2) -- 数据库和测试","date":"2021-06-08T16:00:00.000Z","path":"java/spring-boot-rest-api-tutorial/2-database-and-test/","text":"系列目录 搭建 Spring Boot REST API 项目 (1) – Hello World 搭建 Spring Boot REST API 项目 (2) – 数据库和测试 搭建 Spring Boot REST API 项目 (3) – 请求和应答 搭建 Spring Boot REST API 项目 (4) – 字段校验 搭建 Spring Boot REST API 项目 (5) – 序列化和反序列化 搭建 Spring Boot REST API 项目 (6) – 认证和安全 搭建 Spring Boot REST API 项目 (7) – 自动生成 REST API 文档 创建数据库在上一次提到的 springbootdemo 数据库中添加一个表 users，并插入两条测试数据： 123456789101112create table users( id int auto_increment, email varchar(100) not null, password varchar(100) not null, name varchar(100) not null, constraint User_email_uindex unique (email), constraint User_id_uindex unique (id));INSERT INTO springtest.users (id, email, password, name) VALUES (1, 'lyh543@outlook.com', '123456', 'lyh543');INSERT INTO springtest.users (id, email, password, name) VALUES (2, 'test@example.com', 'test', 'test'); 简单写一个获取用户信息的 API编写一个 User（模型层），并用 IDEA 自动生成构造函数、Getters 和 Setters： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// src/main/java/com/lyh543/springbootdemo/entity/User.javapublic class User &#123; private long id; private String email, password, name; public User(int id, String email, String password, String name) &#123; this.id = id; this.email = email; this.password = password; this.name = name; &#125; public User(String email, String password, String name) &#123; this.email = email; this.password = password; this.name = name; &#125; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 编写一个 UserMapper（数据访问层）： 1234567// src/main/java/com/lyh543/springbootdemo/mapper/UserMapper.java@Repositorypublic interface UserMapper &#123; @Select(\"SELECT * FROM users WHERE email = #&#123;email&#125;\") User getByEmail(@Param(\"email\") String email);&#125; 编写一个 UserService（业务逻辑层）： 1234567891011// src/main/java/com/lyh543/springbootdemo/service/UserService.java@Repositorypublic class UserService &#123; @Autowired UserMapper userMapper; public User getByEmail(String email) &#123; return userMapper.getByEmail(email); &#125;&#125; 最后是 UserController（视图层）： 1234567891011// src/main/java/com/lyh543/springbootdemo/web/UserController.java@RestControllerpublic class UserController &#123; @Autowired UserService userService; @GetMapping(\"/api/user/1\") public User getUserInfo() &#123; return userService.getByEmail(\"lyh543@outlook.com\"); &#125;&#125; 安装命令行工具 httpie，然后 http http://localhost:8080/api/user/1： 12345678$ sudo apt install httpie$ http http://localhost:8080/api/user/1&#123; \"id\": 1, \"email\": \"lyh543@outlook.com\", \"password\": \"123456\", \"name\": \"lyh543\"&#125; 测试！每次写完一个 API 都得运行好几次 httpie，太麻烦了。有没有运行代码、每次修改以后自动发送 HTTP 请求测试之前的 API 的工具呢？有！那就是测试！ Spring Boot 项目常见的测试形式有单元测试和集成测试。单元测试是对每一层 (Mapper, Service, Controller) 进行测试；而像我们这种发送 HTTP 请求调用 API、需要集成所有层的测试，叫做集成测试。 Spring Boot 单元测试可以参考 SpringBoot Test 人类使用指南- 知乎。 添加测试依赖我们添加以下依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; HSQLDB 是一个小型嵌入式数据库，我们测试的时候使用 HSQLDB，开发和测试时就不会使用同一个数据库。 需要注意的是，MySQL 默认隔离级别为可重复读，HSQLDB 不支持可重复读、默认为读提交，因此在测试的时候可能无法使用事务。 配置测试数据库安装了 HSQLDB 依赖，我们还要进行配置，告诉 Spring Boot 在测试的时候使用 HSQLDB 而不是 MySQL。修改 /src/test/resources/application.yaml： 123456spring: datasource: # sql.syntax_mys 会让 hsqldb 兼容 mysql 的语法，虽然兼容的不完全 url: jdbc:hsqldb:mem:testdb;sql.syntax_mys=true;DB_CLOSE_DELAY=-1 username: sa password: 测试的时候还需要执行生成表结构的 SQL，Spring 也提供了接口（文档），在测试前会依次执行 /src/test/resource/schema.sql 和 /src/test/resource/schema.sql。于是我们写一个 schema.sql： 12345678910/* src/test/resources/schema.sql */create table if not exists users( id int auto_increment, email varchar(100) not null, password varchar(100) not null, name varchar(100) not null, constraint User_email_uindex unique (email), constraint User_id_uindex unique (id)); 编写第一个测试 参考：Getting Started | Testing the Web Layer测试 | docs.spring.ioSpringBoot Test 人类使用指南- 知乎 编写一个测试类 test/UserTest.java： 1234567891011121314151617181920212223242526272829// src/test/java/com/lyh543/springbootdemo/test/UserTest.javapackage com.lyh543.springbootdemo.test;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.boot.web.server.LocalServerPort;import org.springframework.transaction.annotation.Transactional;import static org.junit.jupiter.api.Assertions.*;@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class UserTest &#123; // Spring Boot 会随机指定一个端口运行，如果需要端口号，可以像下面这样注入 // @LocalServerPort // private int port; // 一个可用于测试的 Client @Autowired private TestRestTemplate restTemplate; @Test void test() &#123; assertNull(restTemplate.getForObject(\"/api/user/1\", String.class)); &#125;&#125; 编写完以后，有三个方法运行这个测试： 点击 IDEA test 左边的绿色箭头，可以运行这一个测试函数 点击 IDEA UserTest 左边的绿色箭头，可以运行这一个类的测试 运行 mvn test 命令，或点击右边的 Maven test，可以运行整个项目的测试。 可以看到测试成功通过，因为我们数据库里什么都没有，所以页面什么也没返回。 我们使用 MyBatis Plus 往数据库塞一点数据，然后再测试。 编写第二个测试由于测试需要会向空数据插入数据，所以我们完善一下 UserMapper，加一个 insert： 1234567891011// src/main/java/com/lyh543/springbootdemo/mapper/UserMapper.java@Repositorypublic interface UserMapper &#123; @Select(\"SELECT * FROM users WHERE email = #&#123;email&#125;\") User getByEmail(@Param(\"email\") String email); @Insert(\"INSERT INTO users (email, password, name) VALUES (#&#123;email&#125;, #&#123;password&#125;, #&#123;name&#125;)\") @Options(useGeneratedKeys=true, keyProperty = \"id\") // 注意 insert 的返回值返回仍然是插入行数，而 id 被放自动在了 user.id 里 int insert(User user);&#125; 然后我们就可以编写第二个测试函数了： 12345678910111213141516171819202122232425262728293031323334353637383940// src/test/java/com/lyh543/springbootdemo/test/UserTest.java@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class UserTest &#123; @LocalServerPort private int port; @Autowired private TestRestTemplate restTemplate; @Autowired private UserMapper userMapper; @Test void test() &#123; assertNull(restTemplate.getForObject(\"/api/user/1\", String.class)); &#125; @Test public void test2() &#123; List&lt;Long&gt; userIds = new ArrayList&lt;&gt;(); assertNull(restTemplate.getForObject(\"/api/user/1\", String.class)); for (int i = 0; i &lt; 10; i++) &#123; User user = new User(\"lyh543@outlook.com\" + Math.random(), \"123456\", \"lyh543\"); userMapper.insert(user); userIds.add(user.getId()); &#125; for (Long i : userIds) &#123; assertTrue(restTemplate .getForObject(\"/api/user/\" + i, String.class) .contains(\"lyh543\")); &#125; assertNull(restTemplate.getForObject(\"/api/user/\" + (Collections.min(userIds) - 1), String.class)); assertNull(restTemplate.getForObject(\"/api/user/\" + (Collections.max(userIds) + 1), String.class)); assertEquals(400, restTemplate .getForEntity(\"/api/user/lyh543\", String.class) .getStatusCodeValue()); &#125;&#125; 运行测试类 / mvn test，发现两个测试均成功。 自动清理数据库上面的测试虽然成功运行了，但是好像有点问题：test2 向数据库插入了数据而没有清理。 如果我们的 test 测试是在 test2 后进行的，就会出错。（试试交换两个函数名以交换其执行顺序） 一个解决方案是使用 @Order 指定测试类中每个测试函数的顺序，但是这还需要考虑到不同测试类对数据库造成的影响。 另一个解决方案是事务。但是这种方法目前挂掉了，所以先想想别的办法吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// src/test/java/com/lyh543/springbootdemo/test/UserTest.javapackage com.lyh543.springbootdemo.test;import static org.junit.jupiter.api.Assertions.*;import com.lyh543.springbootdemo.entity.User;import com.lyh543.springbootdemo.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.boot.web.server.LocalServerPort;import org.springframework.http.HttpEntity;import org.springframework.http.ResponseEntity;import org.springframework.transaction.annotation.Transactional;@Transactional@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class UserTest &#123; @LocalServerPort private int port; @Autowired private TestRestTemplate restTemplate; @Autowired private UserMapper userMapper; @Test public void test() &#123; assertNull(restTemplate.getForObject(\"/api/user/1\", String.class)); &#125; @Test public void test2() &#123; List&lt;Long&gt; userIds = new ArrayList&lt;&gt;(); assertNull(restTemplate.getForObject(\"/api/user/1\", String.class)); for (int i = 0; i &lt; 10; i++) &#123; User user = new User(\"lyh543@outlook.com\" + Math.random(), \"123456\", \"lyh543\"); userMapper.insert(user); userIds.add(user.getId()); &#125; for (Long i : userIds) &#123; assertTrue(restTemplate .getForObject(\"/api/user/\" + i, String.class) .contains(\"lyh543\")); &#125; assertNull(restTemplate.getForObject(\"/api/user/\" + (Collections.min(userIds) - 1), String.class)); assertNull(restTemplate.getForObject(\"/api/user/\" + (Collections.max(userIds) + 1), String.class)); assertEquals(400, restTemplate .getForEntity(\"/api/user/lyh543\", String.class) .getStatusCodeValue()); &#125;&#125; 第三个解决方案，是在每次函数执行完成以后手动清空数据库。我们当然不必在每个测试函数以后都加两行代码，直接使用 @AfterEach 就行。 123456import static org.springframework.test.jdbc.JdbcTestUtils.*;@AfterEachpublic void clearDatabase() &#123; deleteFromTables(jdbcTemplate, \"users\");&#125; Spring 在JdbcTestUtils 中提供了五个好用的静态函数，这里我们使用 deleteFromTables 一键清空表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// src/test/java/com/lyh543/springbootdemo/test/UserTest.javaimport static org.junit.jupiter.api.Assertions.*;import static org.springframework.test.jdbc.JdbcTestUtils.*;@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class UserTest &#123; @Autowired private JdbcTemplate jdbcTemplate; @Autowired private TestRestTemplate restTemplate; @Autowired private UserMapper userMapper; @AfterEach public void clearDatabase() &#123; deleteFromTables(jdbcTemplate, \"users\"); &#125; @Test public void test() &#123; assertNull(restTemplate.getForObject(\"/api/user/1\", String.class)); &#125; @Test public void test2() &#123; List&lt;Long&gt; userIds = new ArrayList&lt;&gt;(); assertNull(restTemplate.getForObject(\"/api/user/1\", String.class)); for (int i = 0; i &lt; 10; i++) &#123; User user = new User(\"lyh543@outlook.com\" + Math.random(), \"123456\", \"lyh543\"); userMapper.insert(user); userIds.add(user.getId()); &#125; for (Long i : userIds) &#123; assertTrue(restTemplate .getForObject(\"/api/user/\" + i, String.class) .contains(\"lyh543\")); &#125; assertNull(restTemplate.getForObject(\"/api/user/\" + (Collections.min(userIds) - 1), String.class)); assertNull(restTemplate.getForObject(\"/api/user/\" + (Collections.max(userIds) + 1), String.class)); assertEquals(400, restTemplate .getForEntity(\"/api/user/lyh543\", String.class) .getStatusCodeValue()); &#125; @Test public void test3() &#123; assertEquals(0, countRowsInTable(jdbcTemplate, \"users\")); &#125;&#125; 三个测试都能成功通过。 重构测试类注意到 UserTest 有非常多的重复代码，于是我们简单重构一下： 将判断请求的状态码封装为 assertStatusCodeEquals； 将 @Autowired 放到父类，这样所有的子类就不用再写； 将清空数据库的 clearDatabase 也放到父类。 1234567891011121314151617181920212223242526272829303132333435// src/test/java/com/lyh543/springbootdemo/utils/TestTemplate.javapackage com.lyh543.springbootdemo.utils;import com.lyh543.springbootdemo.mapper.UserMapper;import org.junit.jupiter.api.AfterEach;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.jdbc.core.JdbcTemplate;import static org.junit.jupiter.api.Assertions.*;import static org.springframework.test.jdbc.JdbcTestUtils.*;public abstract class TestTemplate &#123; @Autowired protected JdbcTemplate jdbcTemplate; @Autowired protected TestRestTemplate restTemplate; @Autowired protected UserMapper userMapper; public void assertStatusCodeEquals(int expected, String url) &#123; assertEquals(expected, restTemplate .getForEntity(url, String.class) .getStatusCodeValue()); &#125; @AfterEach public void clearDatabase() &#123; deleteFromTables(jdbcTemplate, \"users\"); &#125;&#125; 重构后的 UserTest 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// src/test/java/com/lyh543/springbootdemo/test/UserTest.javapackage com.lyh543.springbootdemo.test;import com.lyh543.springbootdemo.entity.User;import com.lyh543.springbootdemo.utils.TestTemplate;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;import java.util.ArrayList;import java.util.Collections;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTable;@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class UserTest extends TestTemplate &#123; @Test public void test() &#123; assertStatusCodeEquals(404, \"/api/user/1\"); &#125; @Test public void test2() &#123; assertStatusCodeEquals(404, \"/api/user/1\"); List&lt;Long&gt; userIds = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; User user = new User(\"lyh543@outlook.com\" + Math.random(), \"123456\", \"lyh543\"); userMapper.insert(user); userIds.add(user.getId()); &#125; for (Long i : userIds) assertTrue(restTemplate.getForObject(\"/api/user/\" + i, String.class).contains(\"lyh543\")); for (long i: new long[]&#123;-1, 0, Collections.min(userIds) - 1, Collections.max(userIds) + 1&#125;) assertStatusCodeEquals(404, \"/api/user/\" + i); assertStatusCodeEquals(400, \"/api/user/lyh543\"); &#125; @Test public void test3() &#123; assertEquals(0, countRowsInTable(jdbcTemplate, \"users\")); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.lyh543.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.lyh543.cn/tags/Spring/"}]},{"title":"搭建 Spring Boot REST API 项目 (1) -- Hello World","date":"2021-06-07T03:18:55.000Z","path":"java/spring-boot-rest-api-tutorial/1-hello-world/","text":"系列目录 搭建 Spring Boot REST API 项目 (1) – Hello World 搭建 Spring Boot REST API 项目 (2) – 数据库和测试 搭建 Spring Boot REST API 项目 (3) – 请求和应答 搭建 Spring Boot REST API 项目 (4) – 字段校验 搭建 Spring Boot REST API 项目 (5) – 序列化和反序列化 搭建 Spring Boot REST API 项目 (6) – 认证和安全 搭建 Spring Boot REST API 项目 (7) – 自动生成 REST API 文档 前言当时入门的时候没找到系统的 Spring Boot 入门教程，干脆自己写了一个。 不过后来发现还是有优质教程的，是自己没怎么找了： 雷丰阳2021版SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibiliSpring Boot 参考文档（英文，Chrome 翻译效果还可以） Idea 创建项目 Spring Initializr 是组里要求用 JDK 1.8 的（我也很无奈啊），个人开发可以选择更新版本的 JDK。 选择依赖 如果创建项目、运行以后自动停下来了，可能是没有添加 Spring Web 依赖。可以在 pom.xml 手动添加以下依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; application.yml因为创建项目的时候写了数据库，所以即使不用数据库，也要给定 spring.datasource.url。 这里使用更易读的 yaml 替代 properties，所以如果 Idea 创建了 src/main/resources/application.properties，需要先删掉，然后创建 src/main/resources/application.yaml，添加以下内容： 12345678server: port: 8080spring: datasource: url: jdbc:mysql://127.0.0.1:3306/springbootdemo?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver Hello world! 这里不多讲解 Spring Boot 的工作原理，只讲如何创建一个 Spring Boot 应用。工作原理什么的，可以成功部署一个 Spring Boot 应用后再重新学习，这样就不至于因为东西太多，反而弄得头大。 Idea 还帮我们编写好了 com/lyh543/springbootdemo/SpringBootDemoApplication.java，所以不需要动它，只需要直接编写页面的 Controller。 12345678910111213// src/main/java/com/lyh543/springbootdemo/web/RootController.javaimport org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RootController &#123; @GetMapping(value = \"/api\") public String helloWorld() &#123; return \"Hello, world!\"; &#125;&#125; 启动 Spring Boot： 1234567891011121314151617181920212223 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.5.0)2021-06-07 14:42:06.691 INFO 14280 --- [ main] c.l.s.SpringBootDemoApplication : Starting SpringBootDemoApplication using Java 1.8.0_291 on yanhuiliu-PC0 with PID 14280 (C:\\Users\\yanhuiliu\\Desktop\\test\\spring-boot-demo\\target\\classes started by yanhuiliu in C:\\Users\\yanhuiliu\\Desktop\\test\\spring-boot-demo)2021-06-07 14:42:06.693 INFO 14280 --- [ main] c.l.s.SpringBootDemoApplication : No active profile set, falling back to default profiles: default2021-06-07 14:42:07.186 WARN 14280 --- [ main] o.m.s.mapper.ClassPathMapperScanner : No MyBatis mapper was found in '[com.lyh543.springbootdemo]' package. Please check your configuration.2021-06-07 14:42:07.403 INFO 14280 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2021-06-07 14:42:07.409 INFO 14280 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]2021-06-07 14:42:07.409 INFO 14280 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.46]2021-06-07 14:42:07.466 INFO 14280 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2021-06-07 14:42:07.466 INFO 14280 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 737 ms2021-06-07 14:42:07.938 INFO 14280 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2021-06-07 14:42:07.966 INFO 14280 --- [ main] c.l.s.SpringBootDemoApplication : Started SpringBootDemoApplication in 1.702 seconds (JVM running for 2.346)2021-06-07 14:42:07.968 INFO 14280 --- [ main] o.s.b.a.ApplicationAvailabilityBean : Application availability state LivenessState changed to CORRECT2021-06-07 14:42:07.971 INFO 14280 --- [ main] o.s.b.a.ApplicationAvailabilityBean : Application availability state ReadinessState changed to ACCEPTING_TRAFFIC2021-06-07 14:42:14.037 INFO 14280 --- [nio-8080-exec-2] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet 'dispatcherServlet'2021-06-07 14:42:14.038 INFO 14280 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet'2021-06-07 14:42:14.039 INFO 14280 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet : Completed initialization in 1 ms 访问 localhost:8080，看到 Hello world!。 热更新热更新需要安装 spring-boot-devtools，不过创建项目的时候已经安装过了： 如果是idea，需要改以下两个地方： 勾选 File &gt; Settings &gt; Compiler &gt; Build Project automatically 勾选 ctrl + shift + alt + / &gt; Registry &gt; compiler.autoMake.allow.when.app.running 不过还是要写完以后 10s 左右才会热更新，有点慢。 Stack Overflow 上给出了另外一种解决办法，把 Build 绑定到 Ctrl + S。每次写完以后 Ctrl + S 一下就会立即 Build，Spring Boot 检测到变化后就会在 1s 之后热部署。","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.lyh543.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.lyh543.cn/tags/Spring/"}]},{"title":"PPT 制作注意事项（持续更新...）","date":"2021-06-04T08:36:29.000Z","path":"others/presentation-tips/","text":"逻辑清晰如果可以的话，最好把所有小点分成几个大点，每个大点下面几个小点。 PPT 风格统一 bad example 6-8 的风格不统一 空白可以用图片填充 bad example bad example &amp; good example: good example 同类产品加上对比图同类产品的可以对比一下优缺点，几个产品放在一个图里对比更清晰。 good example","tags":[]},{"title":"浏览器野史 UserAgent列传（转载）","date":"2021-06-04T03:29:16.000Z","path":"computer-science/history-of-browser-useragent/","text":"本文转载至 Litten 博客 的《浏览器野史 UserAgent列传（上）、（下）》，七年过去了依旧是经典好文。 某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。控制台敲下：navigator.userAgent浏览器回应：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 天，这串是啥？你怎么连话都说不清楚？ 我对userAgent并不陌生，但明明一个单词就可以说清楚的事情，却是这么掏心掏肺的回答。怪可怜的，一定有冤情。 后来我查阅了很多资料，发现历史非常的精彩。 大事年表 1990年: Nexus(WorldWideWeb)诞生 1993年1月23日：Mosaic诞生 1994年12月：Netscape(Mozilla)诞生 1995年4月：Opera诞生 1995年8月16日：Internet Explorer诞生 2002年9月23日：Firefox诞生 2003年1月7日：Safari诞生 2008年9月2日：Chrome诞生 一、盘古开天地很久很久之前，上古大神Berners-Lee发明了WorldWideWeb，即万维网。同时，李大神也发明了第一款浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神内心的想法又岂是尔等凡人能够肆意揣摩？ 万万没想到，李大神说，我这浏览器，也叫WorldWideWeb！不行么？行行行。 虽然李大神起名字这么拽，但他后来发觉，还是得赋予一点承上启下的历史意义，就改名成“Nexus”。值得注意的是，这浏览器，居然是可以兼容Unix跟Microsoft DOS的。它在当时流行的各种电脑上跑得飞起，应用也越来越广，被称为“杀手级应用”。杀手级…你们看互联网一开始就是这么的腥风血雨。 但这个浏览器，还不支持图片的显示，这是出现UserAgent的导火索。 二、唐尧虞舜93年，伊利诺大学的NCSA组织认为，浏览器无图无真相，这不好。因而他们发明了第一款可显示图片的浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神就是连起名字都让你惊心动魄。 NCSA组织说，它能显示图片，偏偏我们就要叫它“马赛克(Mosaic)”！不行么？行行行。 但有人就问了，Nexus不显示图片，Mosaic能显示，你们让html提供者怎么写代码？你们是不是想逼死选择困难症患者？有没有考虑过天秤座的感受？ 因而UserAgent就诞生了。Mosaic将自己标志为NCSA_Mosaic/2.0 (Windows 3.1)，大家该怎么写代码就怎么写，但请求会带上这个信息，服务器就知道该不该返回能显示图片的html。UserAgent君，出生时跟我们设想的一样简单，仅仅标明了自己是什么浏览器，在什么系统运行，以及各自的版本号。 新旧浏览器们像彬彬有礼的君王，商议和让位是为了更好的繁荣。但风雨欲来。 三、楚汉争霸像刘邦一样，走出来一个搅局的小流氓。当然他还是很有志向的，他的目标，就是战胜霸主Mosaic。后来，他还真的做到了。如今，所有现代浏览器的UserAgent里都有它的标志，就像汉朝之后，我们都称为“汉”人。一群很有天赋的程序员，一起缔造了它的辉煌。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是让你永远也猜不到他们想了个什么名字。大神们说，叫Mozilla，不行么？行。但什么意思呢？ 含义有二。其一，哥斯拉(Godzilla)谐音，诚然是一头野心勃勃的怪兽；其二，”Mosaic Killa”之意，Killa是俚语中Killer的拼法，即“马赛克的终结者”，赤裸裸的挑战。 惊呆了的Mosaic小心翼翼的念着Mozilla这发音：“Mo…摸咋了？”勃然大怒，“摸你妹！” 鉴于Mosaic当时的权势，Mozilla改名成Netscape Navigator(网景航海家)。小怪兽突然变成有点文艺小清新的名字，郁闷得很，但内心的血液沸腾着。虽然叫大名叫网景，但它把UserAgent偷偷设置成Mozilla/1.0 (Win3.1)。还是摸咋了？咬我？ 四、宋元之战很快，NetScape战胜了Mosaic，成为了新的霸主，因为其更优的展示。NetScape最先支持了html框架显示，就是简单的table布局，内外边距之类，仅仅这点就将Mosaic抛诸身后。区别这两个浏览器，还是用的UserAgent。如果是UserAgent里含有“Mozilla”字样，那就发送支持框架的页面，否则，就发送不含框架的页面。 NetScape帝国日益庞大，歌舞升平，一切风平浪静，直到微软的铁骑挥军南下。 微软发布了一款跟系统强绑定的浏览器，真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？不用想了，就是IE。这命名也相当简单粗暴，Internet Explorer，直接把这工具的用途拍在你脸上。连说明书都可以免了。 IE也是支持html标准框架的，但由于前面的历史原因，人们只会给UserAgent里含有“Mozilla”字样的浏览器发送含框架的页面。但这点小事能难倒我大微软？IE呵呵一笑，把自己的UserAgent改成Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)。看，我这里也有“Mozilla”字样，也能收到含框架的页面了！ 当然，这个小流氓行为，跟后来把IE和Windows捆绑一起销售的大流氓行为比起来，根本不为足道。后面的故事我们也知道了，IE把NetScape干掉了。但它的身体上，却永远的烙上了“Mozilla”的印记。 五、康乾盛世看过奥特曼的都知道，怪兽被打败了会再回来。别忘了NetScape曾拥有一批大神们，失败后，他们围绕着浏览器排版引擎Gecko(壁虎)成立了非正式组织Mozilla。小怪兽再次出发。大神们发明了另一款优秀的浏览器，它在插件拓展和开发调试领域做出的贡献，绝对可以载入互联网历史。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是即使你知道了Mozilla的命名都是野兽，却还是猜不到是什么。Mozilla说，我们浴火重生，叫Phoenix(凤凰)！不行么？真不行。 刚推出就被人告了，原来已经有一家公司叫做“凤凰科技”。Mozilla瀑布汗，改名叫Firebird(火鸟)！还不行么？我们得原谅一下他们的取名，虽然现在看来满满的山寨感，可放在那个时代，Firebird这名字很炫酷。就像你当初的QQ昵称叫赤炎天使感觉依然良好一样。 但是，他们发现，业内有个数据库系统，也叫的Firebird…泪流满面的Mozilla感慨重生好难呀。最后才决定叫Firefox(火狐)。 基于Gecko引擎的Firefox非常优秀，为了告诉大家，我使用了这个引擎，它标志自己的UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0。这时候的UserAgent，虽然长了点，但它并不混乱，准确的标明了系统，排版引擎，浏览器名称等信息。虽然IE这时已经占有了很大的市场份额，但基本停步不前；而Mozilla经过一段时间的修生养息，Firefox在业内广受好评，得到了快速的发展。 时值2003年，web2.0的浪潮前夕，浏览器的发展达到了空前的盛世。然而所谓否极泰来，盛极则衰。涅槃的Firefox迎来盛世，却又恰恰由于盛世，决定了UserAgent纠结的命运。 六、师夷长技前面说到，微软靠Windows系统捆绑IE销售。而Windows自然也有它的对手，Linux。一个技术快速发展的时代，系统的世界里也是战火纷飞。Linux系统自从有了可视化界面，也需要浏览器呀。桌面系统KDE的缔造者们就发明了一个。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是讲究先从文字上占据压垮你的气势。先有Navigator航海家，再有Explorer探索者，咱就叫Konqueror(Conqueror的变体)征服者吧。行行行。我已懒得理这帮大神… 可是，问题来了。Konqueror使用KHTML排版引擎，即使它们认为自己跟Gecko引擎一样优秀，但用户不买单。你UserAgent里没有“Gecko”字样，我就不给你经过优良排版的html。结果，Konqueror思来想去，做了一个艰难但很萌的决定，把UserAgent写成Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)…这就是现代浏览器里like Gecko这一萌词的由来。 就这样，伟大的排版引擎KHTML为了获得更好的资源，师夷长技。这并没什么不好，却造成了UserAgent的越发混乱。KHTML与Gecko这一对，永远卿卿我我比翼双飞在UserAgent里面了。那个满含深意的“like”，有人觉得翻译成“像”，但也有人觉得应该是“喜欢”… 七、世界大战首先是IE冷静下来了，他觉得，你们不带这么玩的？就我年少时不懂事，首先改了个Mozilla字样，后面追究这历史我岂不是成了罪魁祸首？我改还不行吗？在IE6，它明确自己UserAgent为Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)。除去已经注定不可抹去的“Mozilla”字样，其余信息简洁，准确，清晰。 但事态已经不可收拾。 Opera给这狂躁的世界添了一把火。它觉得，易容术非常炫酷呀。Opera直接在菜单提供了Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51，Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51，Opera/9.51 (Windows NT 5.1; U; en)三个选择项。第一个是易容成IE，第二个是易容成火狐，第三个才是自己，选谁就是谁！ 其实这并不是一件坏事。因为Opera是站在能够让用户通过选择，去获得更好的浏览体验的基础上的。你提供选择，或是不提供，混乱的UserAgent还是在这，不离，不弃。再者，这对网页的开发者有极大的好处，在某些情况，你不必同时打开几个不同的浏览器去调试。到目前，最新的Chrome浏览器更加炫酷，能够支持近40种不同的UserAgent，甚至你还可以自定义。当然这是后话。 与此同时，苹果公司依靠内核WebKit，开发出Safari，命名UserAgent为Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5。 有人就会问了，不是Webkit内核吗，怎么还有KHTML, like Gecko？注意，内核Webkit包含了一个排版引擎叫WebCore，而WebCore是KHTML衍生而来的。也就是说，WebCore是KHTML的儿子，子承父业，基因差不多。为了能够正常排版，safari只能这么写。 后来，google也开发了自己的浏览器Chrome，其内核也是Webkit，但它设定UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13。Safari一看，不对劲啊！你怎么也在后面写有Safari？Chrome呵呵一笑，你懂的。 因此，请让我一口气说完下面这一段：Chrome希望能得到为Safari编写的网页，于是决定装成Safari，Safari使用了WebKit渲染引擎，而WebKit呢又伪装自己是KHTML，KHTML呢又是伪装成Gecko的。同时所有的浏览器又都宣称自己是Mozilla。 这就是整个UserAgent世界大战的格局… 八、军阀混战将目光聚焦到国内，更是狼烟四起，混乱不堪。大家都知道，浏览器是互联网的入口，这块肥肉谁也不想丢。因而一个接一个的“国产”浏览器进入斗兽场。360，百度，QQ，UC，搜狗，猎豹，遨游，世界之窗…你能说出一大堆。连淘宝，酷狗，hao123都有浏览器，不信你搜。注意我前面“国产”两个字必须加上双引号，因为这个made in china并不纯。国人并没能像远古大神一样，硬生生发明一个内核出来，我们更擅长“微创新”。 利用Trident（IE的内核），包装一下皮肤，美化一下，就可以说：完美兼容利用Webkit，包装一下皮肤，美化一下，就可以说：极速浏览把两个内核都包起来，就可以说：智能双核 是微创新！读书人的事，能叫偷吗？ 在这插播一下，浏览器的“双核”，并不是你听说手机双核电脑双核那回事。再多个核，速度也不会更快，当然这么说，会显得很厉害的样子。德艺双馨，智勇双全，名利双收，才貌双绝，夫妻双双把家还，你看带“双”字的词都很牛的。 但我上面的叙述，的确有夸张的成分。浏览器的诞生，肯定不仅仅是包一下皮肤那么简单，国内的工程师们，也苦心研究做了许多工作。如果要说优化策略，我可以再写一篇超级长的文章。优化无止境，路漫漫其修远，向同行们致敬。只是我非常讨厌那些不把事实说清楚，纯粹靠文案去忽悠人的产品… 话说回来，这么多国产浏览器，总得靠不同UserAgent标志自己呀。大家自动分为两个阵营：使用Trident内核的，在IE已有UserAgent后添加自己的名称；使用Webkit内核的，就在Chrome的UserAgent后面添加。 前者像QQ浏览器：Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.7.26717.400)。后者像猎豹：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER。当然双核浏览器诚然就是墙头草，切换内核时UserAgent也需要跟着变化。 如此的混战格局，这厢的IE和Chome想必也是醉了。 九、国共内战适者生存是不变的生存法则，国产浏览器们经过一段时间的用户筛选，自然优胜劣汰。时值2010年，真正还在运营和更新的浏览器数量慢慢下降，用户集中在几家表现更优异的厂商手中。就在这时，好看的故事来了——3Q大战爆发。 有人说，腾讯电脑管家的推出是导火索。其实这场仗，大家都忍了好久，推不推出，都一定会在某个事件后爆发。360浏览器是奇虎的重量级产品，用户量众多，2009年它推出一个功能：过滤其它网站的广告。诚然民众们都很喜欢。可是其他互联网公司肯定就不乐意了，用户看不到更点击不到广告，这钱还怎么赚？ 因而在3Q大战爆发后，腾讯的一个手段就是：如果你使用360浏览器，就不能访问QQ的网站（单单QQ空间就有巨大的用户量），也直接反攻360的最大收入来源。一个艰难的决定背后，往往是需要无数种的技术战略支撑的。企鹅判断用户是否使用360浏览器，依靠的就是UserAgent里是否有“360SE”的字样。 战报传来：号外，360浏览器上不了QQ空间！已经买了黄钻的杀马特贵族急了呀！只能换浏览器了呀！感覺侢乜卟哙噯嘞呀！2011年11月3日，腾讯网站封杀360浏览器2011年11月4日，360浏览器访问量仅为昨日一半2011年11月5日，360浏览器访问量几乎为0 有人说，腾讯就这么快赢了？恰恰相反，360浏览器通过一次强制的自动升级，又可以访问QQ的网站了。360的工程师们在5日使用了伪装术——把“360SE”字样从UserAgent中去掉！意思就是，360浏览器的UserAgent跟IE完全一样，你根本判断不出来（因而访问量为0）。就怕流氓有文化！企鹅傻眼了，总不能把大微软的IE也一并给禁了吧… 这场土匪遇恶霸的耍流氓大战，最终通过法律而化解。企鹅在技术侧拿360没办法，而360则得到了一个跟IE一样的身份证。在这场内战中，受伤的除了广大网民们，其实还有令人心疼UserAgent君，以往让它越长越长就算了，这次长了还得阉割掉，真心dan疼呀。 十、明日边缘看到这里，大家会明白一个道理：如果未来不出现一款霸主级别的浏览器（或内核），UserAgent应该不会有大变化了。不过，这道理并不全对。别忘了，移动侧也是有浏览器的。在早期能上网的手机里，内置了各手机厂商自研的浏览器。这些浏览器并不需要像PC一样的复杂设计，可以访问wap网页就足够了。因而它们的UserAgent命名，怎么简单怎么来，就直接叫诺基亚 3100 Nokia3100/06.01 (UCWEB 3.3B) ，PHILIPS755 ObigoInternetBrowser/2.0 这样，有甚者连浏览器叫什么都不带 TCL-3199，三星 E618 SEC-SGHE618。 这样任由发展下去，一种要历史重演，往日重现的即视感压迫而来。web世界的联合国——W3C组织，站在明日边缘，面对着历史和未来，终于发话，它制定UserAgent标准，以后都得按这规范去起名字。详细请阅User Agent Accessibility Guidelines。至此，命运坎坷的UserAgent终于逐步走向规范。W3C大法好，有人说你怎么不早点来拯救世界呀！其实W3C一直在努力，但规范的制定，到推广至大家认可并执行，是一条漫长的道路，需要时间，也需要实践。W3C组织，在制定web标准这件工作之外，再我看来，还有两个身份：1、和事佬；2、背黑锅。和事不成，就得背黑锅。是的就是这样。 彩蛋那么，我们的故事接近尾声。还有一些有趣的小彩蛋。 Chome 28开始，与苹果正式分道扬镳，采用Blink内核，但它的UserAgent并不改变。 淘宝封杀微信打开淘宝页面，靠的就是微信内置浏览器UserAgent里的MicroMessenger字样。其实微信也可以像当初360一样把UserAgent去掉，但微信并不这样做。 360出招之时留有后招。也许，它一开始就想到了腾讯会告他们对于UserAgent的欺瞒，因而它其实提供了设置项。默认设置是“保持跟IE一样的UserAgent”，但用户也可以不勾选。只是这选项比较隐蔽，而且你重启浏览器后…又会变回默认设置。如果没有这个小小的设置，结果大家可以自行想象。 微软又玩新花样了，在泄露版IE 11中，去掉了以往的MSIE字样。初步猜测此举是为了使现有的 CSS hack 失效，避免过去网页设计师对IE差别对待的情况再度发生。但又会引发其他问题啊亲。 End.Litten 2014.10.5","tags":[{"name":"转载","slug":"转载","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"Java 与数据库","date":"2021-06-03T03:02:56.000Z","path":"java/java-and-database/","text":"专业名词说到 Java 访问数据库的方法，就会涉及到非常多的新词，比如： JDBC HikariCP HSQLDB DAO Hibernate JPA MyBatis 作为一个刚学 Java 不到一周的萌新，我看到这堆词的时候直接懵掉了，不知道从哪里开始学起，甚至自闭了几个小时。 所以，我准备先简单讲一下这几个词的概念。 JDBC(Java DataBase Connection)：Java 访问数据库的 API，只提供接口，底层驱动由 MySQL 等提供。绝大部分 Java 访问数据库的包都是基于 JDBC 进行二次开发 HikariCP：一个数据库连接池(Connection Pool)，用于和数据库建立高效、可复用的连接 HSQLDB：一个 Java 编写的嵌入式数据库，类似于 C/C++ 的 SQLite，可用于测试或小型应用 DAO(Data Access Object)：一种编程模式/思想，对于每一个存储在数据库的类（如 User）建立一个类，专门负责访问数据库、对数据库进行 CURD ORM(Object-Relational Mapping)：将对象和关系进行映射的过程。下面三个 Hibernate JPA MyBatis 其实都是在做 ORM JPA(Java Persistence API)：一个 ORM 标准 API，只提供接口，类似于 JDBC。 Hibernate：一个 ORM 框架，能够自动将查询语句映射到 SQL，并将查询结果映射为 Java 对象（Python 的 Django 也提供了类似的 ORM 功能） MyBatis：一个 ORM 框架，可以将查询结果映射为 Java 对象，但还是需要手写 SQL JDBCJDBC：万物之源。 JDBC 的全称是 Java 数据库连接 (Java DataBase Connectivity)，它是 Java 为关系数据库定义了一套标准的访问接口。 JDBC 是接口，这个接口意味着，虽然不同数据库的访问方法不一样，但是不同应用程序（包括不同框架）访问 JDBC 接口、数据库厂商为 JDBC 实现自己的接口，就可以连接应用程序和数据库了。 JDBC 目前几乎所有 Java 程序都是使用 JDBC 访问数据库，包括 JetBrains 的所有 IDE 在链接数据库前，也需要下载对应数据库的 JDBC 驱动。 更详细的使用的教程可见JDBC编程 - 廖雪峰的官方网站。 HikariCPHikariCP 是一个数据库连接池，负责自动管理数据库连接，提高性能。这个没什么好讲的，在高并发下，连接池是标配，Spring Boot 也优先选择 HikariCP 作为连接池。 HSQLDB12345678910List&lt;User&gt; users = userOrm.query(gender=\"M\", grade=3);int userId = userOrm.create(user);int updateCount = userOrm.update(user);int deleteCount = userOrm.delete(user); HSQLDB 其实和 SQLite 是类似的，都是一个小型的、嵌入式的、可以运行于内存或文件的数据库，不需要单独安装，只需要编译的时候将包导入即可。 HSQLDB 和 SQLite 的区别是，HSQLDB 是 Java 写的，而 SQLite 是 C 写的，所以 Java 项目导入 HSQLDB 很方便，而 C++ 项目导入 SQLite 会很方便。 HSQLDB 和 SQLite 都常用于开发、测试环境、中小型系统中。 需要注意的是，MySQL 默认使用可重复读，而 HSQLDB 2 不支持可重复读，默认是读提交 (reference)。所以 HSQLDB 会出现 A 更新但未提交后、B 事务申请读但是卡死的情况。 DAO数据访问对象 (Data Access Object, DAO) 只是一种设计模式，不需要引入新的工具包。 如果不使用 DAO 的话，我们会把访问数据库的逻辑写到业务层里，如果业务逻辑变复杂，就很难管理。 因此，我们可以把数据访问层和控制层进行分离。 如果我们使用面向对象编写数据访问层，就有了数据访问对象 (Data Access Object, DAO) 了。 123456789101112131415161718192021public class UserDao &#123; User getById(long id) &#123; // access database ... &#125;; List&lt;User&gt; getUsers(int page) &#123; // access database ... &#125;; User createUser(User user) &#123; // access database ... &#125;; User updateUser(User user) &#123; // access database ... &#125;; void deleteUser(User user) &#123; // access database ... &#125;;&#125; ORMORM(Object-Relational Mapping)，对象关系映射，就是将 Java 原生对象和关系数据库的数据建立关系的一种思想。 ORM 纯 JDBC 是没有 ORM 的，所以需要手动取出 resultSet 中的每个字段，然后处理，非常麻烦。 下面是使用 JDBC 查询数据库，JDBC 没有 ORM，需要手动将对象字段映射为 SQL 查询条件、将 SQL 查询结果映射为对象。 1234567891011121314try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123; try (PreparedStatement ps = conn.prepareStatement(\"SELECT id, grade, name, gender FROM students WHERE gender=? AND grade=?\")) &#123; ps.setObject(1, \"M\"); ps.setObject(2, 3); try (ResultSet rs = ps.executeQuery()) &#123; while (rs.next()) &#123; long id = rs.getLong(\"id\"); long grade = rs.getLong(\"grade\"); String name = rs.getString(\"name\"); String gender = rs.getString(\"gender\"); &#125; &#125; &#125;&#125; 如果有 ORM（运用现有的 ORM 框架，或者手写 ORM）自动把 resultSet 映射到 Java 原生类，在开发上都会变得简单很多。 12// 理想的 ORMList&lt;User&gt; users = userOrm.query(gender=\"M\", grade=3); Java 的常见 ORM 框架有： JPA(Java Persistence API)：一个 ORM 标准 API，只提供接口，类似于 JDBC。 Hibernate：一个 ORM 框架，能够自动将查询语句映射到 SQL，并将查询结果映射为 Java 对象 MyBatis：一个 ORM 框架，可以将查询结果映射为 Java 对象，但还是需要手写 SQL 下面会分别介绍。 JPAJPA(Java Persistence API Java 持久层 API) 是 JavaEE 的 ORM 标准，大家可以用这个标准提供的接口以 ORM 的形式访问数据库。 值得注意的是，JPA 只是提供了接口，底层的实现不是 JPA 做的，可以使用 EclipseLink 或 Hibernate（没错，你不仅可以使用 Hibernate API 调用 Hibernate，也可以使用 JPA 调用）作为实现。 简单的操作用 JPA 写会非常简单，比如按 id 查询用户： 123456public class User &#123; public User getUserById(long id) &#123; User user = this.entityManager.find(User.class, id); // ... &#125;&#125; 但是复杂的操作看起来就很麻烦了，SELECT * FROM user WHERE email = ? 用 JPA 写： 12345678910public User fetchUserByEmail(String email) &#123; var cb = em.getCriteriaBuilder(); CriteriaQuery&lt;User&gt; q = cb.createQuery(User.class); Root&lt;User&gt; r = q.from(User.class); q.where(cb.equal(r.get(\"email\"), cb.parameter(String.class, \"e\"))); TypedQuery&lt;User&gt; query = em.createQuery(q); query.setParameter(\"e\", email); List&lt;User&gt; list = query.getResultList(); return list.isEmpty() ? null : list.get(0);&#125; 还不如写 SQL 呢。所以，一般来说不会选择这个 API 作为 ORM 的工具。 Hibernate相较于 JPA，Hibernate API 就友好很多了。 上面的 SELECT * FROM user WHERE email = ? 用 Hibernate 可以这么写： 123456public User fetchUserByEmail(String email) &#123; User example = new User(); example.setEmail(email); List&lt;User&gt; list = hibernateTemplate.findByExample(example); return list.isEmpty() ? null : list.get(0);&#125; 相较 JPA 就简单很多了。 顺便一提，如果使用的是 Django 的 ORM，SELECT * FROM user WHERE email = ? 可以这么写： 123def fetchUserByEmail(email : str) -&gt; User: q = User.objects.filter(email=email) return q[0] if len(q) else None 可以看到，Hibernate 和 JPA 可以将查询条件自动转换为 SQL，同时自动将查询结果返回为 Java 对象，而 Hibernate 的语法较 JPA 简单了很多。 但是，Hibernate 为了兼容多种数据库，它使用 HQL 或 JPQL 查询，经过一道转换，变成特定数据库的 SQL，理论上这样可以做到无缝切换数据库，但这一层自动转换除了少许的性能开销外，给 SQL 级别的优化带来了麻烦。 此外，如果有大量表连接操作，不直接用 SQL 写的话，语法上也会非常麻烦。 所以，产生了另一种框架，需要手写 SQL，但是能够将结果自动转换为 Java 对象，MyBatis 就是这么一个 ORM 框架。 MyBatisMyBatis 虽然需要手写 SQL，但是他的语法也相当简洁： 1234public interface UserMapper &#123; @Select(\"SELECT * FROM user WHERE email = #&#123;email&#125;\") User getByEmail(@Param(\"email\") String email);&#125; 写好这个接口以后，MyBatis 甚至可以帮我们创建实现类，我们直接调用就行了： 1User user = userMapper.getByEmail(email); 可见，MyBatis 的优势有： （相较于 JDBC）自动将 ResultSet 转化为 Java 对象 （相较于 Hibernate 和 JPA）执行原生 SQL，不会有效率影响 （相较于 JDBC）自动生成查询函数，语法简洁 Mybatis 的三种风格Mybatis 也有三种风格： 注解风格，将 SQL 写在接口方法的注解里； XML 风格，将 SQL 语句单独放到一个 XML 文件里； MyBatis-Plus 插件，类似 Hibernate API，提供通用的 API，能方便地对单表增删查改。 这三种方案使用哪一种，就见仁见智了。如果使用注解风格，在看方法名的时候顺便就能看到实际的 SQL；使用 XML 风格实现了 SQL 层和 Java 代码的分离；MyBatis Plus 则是类似 Hibernate，可能会有效率问题。 123456&lt;!-- 使用 XML 配置的 MyBatis Mapper --&gt;&lt;mapper&gt; &lt;select id=\"getByEmail\" resultType=\"User\"&gt; SELECT * FROM user WHERE email = #&#123;email&#125; &lt;/select&gt;&lt;/mapper&gt; 123456// 使用注解配置的 MyBatis Mapperpublic interface UserMapper &#123; @Select(\"SELECT * FROM user WHERE email = #&#123;email&#125;\") User getByEmail(@Param(\"email\") String email);&#125;User user = userMapper.getByEmail(email); 123456// 使用 MyBatis Plus 配置的 MyBatis Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(\"email\", email);User user = userMapper.selectOne(queryWrapper); MyBatis Generator 自动生成 XML没错，MyBatis 官方也提供了生成器，能根据数据库表，自动生成实体类 (User) 和映射类 (UserMapper)！ 英文官网：http://mybatis.org/generator/index.html参考：https://juejin.cn/post/6844903982582743048 1234567891011121314151617181920212223&lt;!-- pom.xml --&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;configuration&gt; &lt;!--mybatis的代码生成器的配置文件--&gt; &lt;configurationFile&gt;src/main/resources/mybatis-generator-config.xml&lt;/configurationFile&gt; &lt;!--允许覆盖生成的文件--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt; &lt;includeCompileDependencies&gt;true&lt;/includeCompileDependencies&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt;&lt;/plugins&gt; 123456789101112131415161718192021222324252627282930313233&lt;!-- src/main/resources/mybatis-generator-config.xml --&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;properties resource=\"application.properties\"/&gt; &lt;context id=\"dsql\" targetRuntime=\"MyBatis3DynamicSql\"&gt; &lt;commentGenerator&gt; &lt;!-- 忽略注释 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass=\"$&#123;spring.datasource.driver-class-name&#125;\" connectionURL=\"$&#123;spring.datasource.url&#125;\" userId=\"$&#123;spring.datasource.username&#125;\" password=\"$&#123;spring.datasource.password&#125;\"&gt; &lt;!--高版本的 mysql-connector-java 需要设置 nullCatalogMeansCurrent=true--&gt; &lt;property name=\"nullCatalogMeansCurrent\" value=\"true\"/&gt; &lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage=\"com.lyh543.springbootdemo.entity\" targetProject=\"src/main/java\"/&gt; &lt;javaClientGenerator targetPackage=\"com.lyh543.springbootdemo.mapper\" targetProject=\"src/main/java\" type=\"ANNOTATEDMAPPER\" /&gt; &lt;table tableName=\"users\" domainObjectName=\"User\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 目前 mybatis-generator-config.xml 只支持从 properties 读取数据，因此还要把 application.yaml 改回 application.properties（很多在线工具）： 12345server.port=8080spring.datasource.url=jdbc:mysql://127.0.0.1:3306/springtest?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 然后在 Idea 侧边栏运行 Maven - Plugins - mybatis-generator:generate 即可。","tags":[{"name":"SQL","slug":"SQL","permalink":"https://blog.lyh543.cn/tags/SQL/"},{"name":"Java","slug":"Java","permalink":"https://blog.lyh543.cn/tags/Java/"}]},{"title":"Spring 开发","date":"2021-06-01T07:11:57.000Z","path":"java/spring/","text":"IoCIoC 全称 Inversion of Control，直译为控制反转。又被称为依赖注入（Dependency Injection 或 DI） 传统应用模式下，组件的创建（实例化）、使用和销毁都由程序员维护，非常复杂。IoC 将组件的创建交给 IoC 容器，由容器管理组件的创建、销毁。 IoC 可以使用 XML 进行配置，但更推荐使用注解进行配置，因此只介绍后面一种。 初始代码首先三个组件：User UserService 和 MailService。 1234567891011121314public class User &#123; public long id; public String email; public String password; public String name; public User(long id, String email, String password, String name) &#123; this.id = id; this.email = email; this.password = password; this.name = name; &#125; // 其对应的 get 和 set 方法略&#125; 12345678910111213141516171819202122232425262728293031323334353637public class UserService &#123; private MailService mailService; private List&lt;User&gt; users = new ArrayList&lt;&gt;(Arrays.asList( new User(1, \"bob@example.com\", \"password\", \"Bob\"), // bob new User(2, \"alice@example.com\", \"password\", \"Alice\"), // alice new User(3, \"tom@example.com\", \"password\", \"Tom\") // tom )); public void setMailService(MailService mailService) &#123; this.mailService = mailService; &#125; public List&lt;User&gt; getUsers() &#123; return users; &#125; public User register(String email, String password, String name) &#123; long maxUserId = 0; for (User user: users) &#123; if (user.getEmail().equalsIgnoreCase(email)) &#123; throw new RuntimeException(\"email exists\"); &#125; maxUserId = Math.max(maxUserId, user.getId()); &#125; User user = new User(maxUserId+1, email, password, name); users.add(user); mailService.sendRegistrationMail(user); return user; &#125; public User login(String email, String password) &#123; for (User user: users) &#123; if (user.getEmail().equalsIgnoreCase(email) &amp;&amp; user.getPassword().equals(password)) &#123; mailService.sendLoginMail(user); return user; &#125; &#125; throw new RuntimeException(\"login failed.\"); &#125;&#125; 123456789101112131415161718192021public class MailService &#123; private ZoneId zoneId = ZoneId.systemDefault(); public void setZoneId(ZoneId zoneId) &#123; this.zoneId = zoneId; &#125; public String getTime() &#123; return ZonedDateTime .now(this.zoneId) .format(DateTimeFormatter.ISO_ZONED_DATE_TIME); &#125; public void sendRegistrationMail(User user) &#123; System.err.printf(\"Welcome, %s!\\n\", user.getName()); &#125; public void sendLoginMail(User user) &#123; System.err.printf(\"Hi, %s! You're logged in at %s\\n\", user.getName(), getTime()); &#125;&#125; 装配 Bean基础用法第零步，Maven 安装依赖： 1234567891011&lt;properties&gt; &lt;spring.version&gt;5.2.3.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第一步：对上面三个类都标记上 @Component： 1234@Componentpublic class MailService &#123;// ...&#125; 第二步，注意到 UserService 依赖 MailService 的一个实例，所以我们要在 UserService 定义 mailService 的地方标记上 @Autowired，把两个东西连起来。 Idea 提示 Field injection is not recommended廖雪峰提示 别去管 Idea 的警告。改成 method 注入，要多写好多行代码 123456@Componentpublic class UserService &#123; @Autowired private MailService mailService; // ...&#125; 第三步，在 main 函数中生成 ApplicationContext，这个就是 IoC 容器实例，我们可以使用 getBean 获得上面绑定的任何一个组件。 此外，还需要加上 @ComponentScan 和 @Configuration，表示：这个类搜索当前类所在的包；这个类可以被作为 AnnotationConfigApplicationContext 函数的配置参数。 注意这个类不能放在根目录（即 /src/main/java/）下，否则会扫描所有的包；放在根目录下的任何一层均可。 12345678910@ComponentScan@Configurationpublic class Main &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(Main.class); UserService userService = context.getBean(UserService.class); User user = userService.login(\"bob@example.com\", \"password\"); System.out.println(user.getName()); &#125;&#125; 修改 Bean 的作用域对于Spring容器来说，当我们把一个Bean标记为@Component后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用getBean(Class)获取到的Bean总是同一个实例。 还有一种Bean，我们每次调用getBean(Class)，容器都返回一个新的实例，这种Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的@Scope注解： 123456@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)// or @Scope(\"prototype\")public class MailSession &#123; //...&#125; 注入 List@Autowired 不仅可以注入单个实例，还可以注入多个实例组成的 List。 定义验证接口和三个实现了这个接口的验证类，并对类标记 Component： 123456789101112131415161718192021222324252627282930public interface Validator &#123; void validate(String email, String password, String name);&#125;@Componentpublic class EmailValidator implements Validator &#123; public void validate(String email, String password, String name) &#123; if (!email.matches(\"^[a-z0-9]+\\\\@[a-z0-9]+\\\\.[a-z]&#123;2,10&#125;$\")) &#123; throw new IllegalArgumentException(\"invalid email: \" + email); &#125; &#125;&#125;@Componentpublic class PasswordValidator implements Validator &#123; public void validate(String email, String password, String name) &#123; if (!password.matches(\"^.&#123;6,20&#125;$\")) &#123; throw new IllegalArgumentException(\"invalid password\"); &#125; &#125;&#125;@Componentpublic class NameValidator implements Validator &#123; public void validate(String email, String password, String name) &#123; if (name == null || name.isBlank() || name.length() &gt; 20) &#123; throw new IllegalArgumentException(\"invalid name: \" + name); &#125; &#125;&#125; 最后定义 Validators 作为入口进行验证： 123456789101112@Componentpublic class Validators &#123; // 所有 Validator 均 @Autowired List&lt;Validator&gt; validators; public void validate(String email, String password, String name) &#123; for (var validator : this.validators) &#123; validator.validate(email, password, name); &#125; &#125;&#125; 可选注入123456@Componentpublic class MailService &#123; @Autowired(required = false) ZoneId zoneId = ZoneId.systemDefault(); // ...&#125; 创建第三方 Bean如果一个 Bean 不在我们自己的 package 管理之内，例如 ZoneId，如何创建它？ 答案是我们自己在 @Configuration 类中编写一个 Java 方法创建并返回它，注意给方法标记一个 @Bean 注解： 123456789@Configuration@ComponentScanpublic class AppConfig &#123; // 创建一个Bean: @Bean ZoneId createZoneId() &#123; return ZoneId.of(\"Z\"); &#125;&#125; Spring 对标记为 @Bean 的方法只调用一次，因此返回的 Bean 仍然是单例。 注入资源文件在 Java 程序中，我们经常会读取配置文件、资源文件等。使用 Spring 容器时，我们也可以把“文件”注入进来，方便程序读取。 例如，AppService 需要读取 logo.txt 这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开 InputStream。 Spring 提供了一个 org.springframework.core.io.Resource（注意不是 javax.annotation.Resource），它可以使用 @Value 注入： 123456789101112131415@Componentpublic class AppService &#123; @Value(\"classpath:/logo.txt\") private Resource resource; private String logo; @PostConstruct public void init() throws IOException &#123; try (var reader = new BufferedReader( new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) &#123; this.logo = reader.lines().collect(Collectors.joining(\"\\n\")); &#125; &#125;&#125; 上述工程结构如下： 123456789101112spring-ioc-resource├── pom.xml└── src └── main ├── java │ └── com │ └── itranswarp │ └── learnjava │ ├── AppConfig.java │ └── AppService.java └── resources └── logo.txt 也可以直接指定文件的路径，例如：@Value(&quot;file:/path/to/logo.txt&quot;)。但使用 classpath 是最简单的方式。 使用 Maven 的标准目录结构，所有资源文件放入 src/main/resources 即可。 注入配置文件注入配置 - 廖雪峰的官方网站 123456789101112@Configuration@ComponentScan@PropertySource(\"app.properties\") // 表示读取classpath的app.propertiespublic class AppConfig &#123; @Value(\"$&#123;app.zone:Z&#125;\") String zoneId; @Bean ZoneId createZoneId() &#123; return ZoneId.of(zoneId); &#125;&#125; 上述代码读取 classpath 下的 app.properties 文件，然后找到 zone=X，令 zoneId 为 X。如果没有找到 zone 就设置为 Z。 条件注入Spring 容器可以条件注入。 @Profile(&quot;test&quot;) 表示在 &quot;test&quot; 时注入 @Profile(&quot;!test&quot;) 表示在不是 &quot;test&quot; 时注入 Spring 运行时可以指定多个 Profile 1-Dspring.profiles.active=test,master 也可以判断编写判断类，然后在需要条件注入的 Bean 上加 @Conditional(OnSmtpEnvCondition.class)。","tags":[{"name":"Java","slug":"Java","permalink":"https://blog.lyh543.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.lyh543.cn/tags/Spring/"}]},{"title":"腾讯成都游记","date":"2021-05-25T16:00:00.000Z","path":"others/something-about-tencent/","text":"腾讯生活中午十二点熄灯到两点好评，还有很多人在走廊边上放了折叠床，中午可以美美的睡上一觉。这点吊打字节。 图片经过后期处理，和实际情况比较接近 午饭晚饭都要付费，不过每天晚上八点以后打卡回家的时候会自动获得一张夜宵券，可以用于抵扣一顿晚饭。所以我们一般中午出去吃，晚上吃食堂。味道倒是还不错。 茶水间有免费的茶包、咖啡机（有咖啡、牛奶、豆浆、奶茶）、板蓝根等。每一层也有零食，只是有点难找，而且我们这层楼平时好像没多少人去拿，每次去的时候都有很多。夏天也会有雪糕供应~ 不定期（一个月一两次）会有下午茶、生日会活动，秘书在群里通知了就可以去拿啦。 下午茶 厕所的话，我这里一层楼几百人只有三个坑位，而且坑位的体验非常一般（无 wifi 很暗很闷）。懂的都懂。 软件授权 Office 365 和 Jetbrains 家的所有软件，所有人随便使用，无需授权 其他软件的使用需要申请，岗位需要的话肯定过，其他情况不清楚 Adobe 全家桶 Sketch AutoDesk 全家桶 Visual Studio Unity 源码及 Pro MATLAB 还有一些没听过的就布列区了 没有的软件还可以自己购买然后申请报销 常用网站OA (Office Asistant) 仅限内网访问，包含海量资源。 下面列举常用但不好找的网站： （内网访问）员工业务自助体验系统，可领取腾讯产品的代金券：http://tiyan.oa.com/ （内网访问）腾讯标识系统，可下载腾讯图标、字体：http://dcloud.oa.com/wiki/vi_tencent 代码规范：https://git.woa.com/standards 腾讯邮箱激活 （内网访问）邮箱 Web 端：https://email.tencent.com/ （内网访问）手机端（以及 Windows 10 邮箱）配置邮箱：https://8000.woa.com/v2/KnowledgeStore/Article/KB201310240001 无论手机端还是客户端，第一次成功登陆都会被隔离。教程会推荐你去 8000.oa.com，但是那个很不好用。其实也可以在 手机MOA-应用-8000助手-移动办公设备 解除隔离，这个会好用得多。 腾讯邮箱垃圾邮件工作邮箱平均每天都能收到十五封垃圾邮件（就是那种收件人是整个组、甚至是整个 BG 的邮件，颇有 QQ 群管理一天到晚 @全体成员 的意思）。 最近逛论坛，发现大家都是使用“收件箱规则”来做的，所以我也晒一下我的规则： 登录 https://email.tencent.com/, 打开顶栏的齿轮图标 -&gt; 选项 找到 邮件 -&gt; 自动处理 -&gt; 收件箱和整理规则 添加收件箱规则，我的规则如图。 收件箱和整理规则 我的收件箱规则 用了一天下来，群发邮件都被丢到垃圾邮件啦。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://blog.lyh543.cn/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"moment.js -- JavaScript 时间处理神器","date":"2021-05-07T08:33:21.000Z","path":"front-end/moment-js/","text":"简介JavaScript 自带 Date 类，也带了非常多的工具，但是可能真要用的时候，却发现这个功能没有、那个功能也没有。于是就有了 moment.js（英文官网|中文网）。相较 Date 类，moment 对格式化输出、多语言、多时区的支持更加友好，还有很多小工具，十分安利。 安装官网说的很明白了： 123456npm install moment --save # npmyarn add moment # YarnInstall-Package Moment.js # NuGetspm install moment --save # spmmeteor add momentjs:moment # meteorbower install moment --save # bower (废弃) 引入为了把默认时区配置为 zh-CN，可以另起一个 utils/moment.js，编写如下内容： 12345678import moment from 'moment'moment.locale('zh-cn');// 可以使用 moment(datetime).toChinese() 转换为展示给用户的时间moment.prototype.toChinese = function() &#123; return this.format('YYYY 年 MM 月 DD 日 HH:mm');&#125;window.moment = moment; // 可以在浏览器中测试 momentexport default moment; 之后引入 moment 都从 utils/moment.js 中引入： 1import moment from \"@/utils/moment\"; 使用这里仅记录我在开发过程中用到的方法。 读入读取当前时间moment 和 Date 类似： 123456789Date()// Fri May 07 2021 16:47:52 GMT+0800 (中国标准时间)moment()// Moment &#123;_isAMomentObject: true, _isUTC: false, _pf: &#123;…&#125;, _locale: Locale, _d: Fri May 07 2021 16:47:50 GMT+0800 (中国标准时间), …&#125;Date.now();// 1620377346488moment.now();// 1620377349595 读取 ISO 格式时间Django 后端给的时间是以 ISO 8601 格式给的，类似于 2021-05-07T08:43:17+00:00 或 2021-05-07T08:43:17Z（零时区可以使用 Z 表示）。 Date 是可以直接读取识别的，moment 也是一样。 1234Date('2021-05-07T08:43:17+00:00')// \"Fri May 07 2021 16:49:41 GMT+0800 (中国标准时间)\"moment('2021-05-07T08:43:17+00:00')// Moment &#123;_isAMomentObject: true, _i: \"2021-05-07T08:43:17+00:00\", _f: \"YYYY-MM-DDTHH:mm:ssZ\", _tzm: 0, _isUTC: false, …&#125; 输出输出为 ISO 格式Date 可以用 Date.prototype.toISOString() 格式化为 UTC 时区。想要格式化为当地时区，还得靠 moment.prototype.format()。 12345new Date().toISOString()// \"2021-05-07T08:55:44.282Z\"moment().format()// \"2021-05-07T16:56:08+08:00\" 格式化输出可以在 moment().format() 的参数中自定义格式。具体的格式可以见 文档。 12moment().format('YYYY-MM-DD HH:mm:ss')// \"2021-05-07 17:56:58\" 输出为 x 年前 / x 分钟前使用 moment.prototype.fromNow()： 12moment('2000-01-01T00:00Z').fromNow()// 21 年前 其他使用方法将时间长度转为 HH:mm:ss比如想要把 1000s 转为 00:16:40。 moment 并不记录时间段，但是由于它的时间戳是从 1970.1.1 00:00 开始经过的毫秒数，所以可以以毫秒形式输入 1000*1000 然后 format 成 HH:mm:ss。 不过这种方法不支持一天以上的时间 2333 123456moment.utc(1000000).format('HH:mm:ss')// \"00:16:40\"moment.utc(10000000).format('HH:mm:ss')// \"02:46:40\"moment.utc(100000000).format('HH:mm:ss')// \"03:46:40\" 如果需要支持的话，还是自己提前算一下天数吧。或者判断一下，如果大于 86400000 就显示 大于一天。","tags":[{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.lyh543.cn/tags/JavaScript/"}]},{"title":"Gravatar 镜像","date":"2021-04-28T11:55:40.000Z","path":"back-end/gravatar-mirror/","text":"最近写的项目用到了 Gravatar 服务，但是 Gravatar 几个服务器都在外国，考虑到项目的用户有相当规模是没有梯子的国内用户，我开始寻找 Gravatar CDN。 网上 Gravatar CDN 参差不齐，有大站建的 CDN，也有网友自建的 CDN，于是简单写了一个 Python 脚本用于测速。 测试内容是两项：图片命中，和图片不命中后跳转到 GitHub 上的图片。各测试十次，取时间平均值，如果出现一次超时等 error 即报错。 脚本和测试结果均写于 2021.4.29，部分信息可能已失效。 1234567891011121314151617181920212223242526272829303132333435363738from timeit import timeitimport requestsimport osdef tester(base_url: str, number: int = 10): # 成功获取 url1 = base_url + 'fd8b773755459a02294bffc322796b5d?size=300&amp;default=https%3A%2F%2Fraw.githubusercontent.com%2Fuestc-msc%2Fuestcmsc_webapp_backend%2Flyh543%2Fstatic%2Fruanweiwei.jpg' # 获取失败，跳转到 default url2 = base_url + \"2333333?size=300&amp;default=https%3A%2F%2Fraw.githubusercontent.com%2Fuestc-msc%2Fuestcmsc_webapp_backend%2Flyh543%2Fstatic%2Fruanweiwei.jpg\" try: print('%.6f' % timeit(lambda: requests.get(url1), number=number), end=' ') except: print('error ', end=' ') try: print('%.6f' % timeit(lambda: requests.get(url2), number=number)) except: print('error ')if __name__ == '__main__': mirrors = [ \"https://gr.mirror.hardrain980.com/\", \"http://gravatar.azureedge.com/avatar/\", \"https://gravatar.w3tt.com/avatar/\", \"https://dn-qiniu-avatar.qbox.me/avatar/\", \"https://gravatar.zeruns.tech/avatar/\", \"https://cdn.v2ex.com/gravatar/\", \"https://gravatar.loli.net/avatar/\", \"https://sdn.geekzu.org/avatar/\", \"https://www.gravatar.com/avatar/\", \"https://cn.gravatar.com/avatar/\", \"https://en.gravatar.com/avatar/\", \"https://secure.gravatar.com/avatar/\", ] for mirror in mirrors: print(f'%-40s' % mirror, end=' ') tester(mirror) 我的测试结果： 网站 命中 未命中，重定向 评价 https://sdn.geekzu.org/avatar/ 6.261718 6.096203 极客族自建，推荐 https://gravatar.w3tt.com/avatar/ 6.598301 7.006393 w3tt 自建，推荐 https://dn-qiniu-avatar.qbox.me/avatar/ 1.828716 不支持 七牛自建，延迟最低，推荐，但不支持参数 https://cdn.v2ex.com/gravatar/ error error v2ex 自建，可惜人家也在国外 https://gravatar.loli.net/avatar/ 10.047769 9.787379 免费个人图床，延迟较高 https://gravatar.zeruns.tech/avatar/ 9.166306 7.800450 网友自建 https://gr.mirror.hardrain980.com/ 7.885361 8.984500 网友自建 http://gravatar.azureedge.com/avatar/ 5.792183 5.848405 本人自建（说不定什么时候就跑路了） https://www.gravatar.com/avatar/ error error 官方，没法用 https://cn.gravatar.com/avatar/ error error 即使 cn 也是在德国的官方 https://en.gravatar.com/avatar/ error error 官方，没法用 https://secure.gravatar.com/avatar/ error error 官方，没法用","tags":[{"name":"后端","slug":"后端","permalink":"https://blog.lyh543.cn/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Vue 的调试方法","date":"2021-04-22T14:11:39.000Z","path":"front-end/vue-debug/","text":"写算法、写后端开发的时候，在 IDE 打断点、条件断点、检测变量用的飞起，但是在 JS 以及 Vue 的前端开发中，这一套就有一些变化了。一是因为调试工具从各家 IDE 变为了浏览器，二是因为 Vue 的每个组件的变量不能在浏览器中直接访问，三是因为 Vue 代码需要转化为原生 JS 执行，所以看报错总会有一堆 vue.runtime.esm.js 之类的、来自 Vue 框架本身代码的报错，而不是指向具体某一行的报错。 vue.runtime.esm.js 报错 经过一段时间的摸索，博主发现了几种调试的方法。 输出变量调试法在刚学 C 语言、还不会用 IDE 的时候，我很喜欢使用 printf 输出变量进行调试。在 JavaScript 里，可以使用 console.log() 输出变量。 能不能在浏览器里的 Console 进行调试呢？答案也是可以的，只要在调试的时候，在代码里把 Vue 组件绑在 window 上。 在 Vue 组件的 activated 或 onload 函数开头加上一行： 1window.my_component = this; 然后就可以在浏览器 Console 窗口使用 window.my_component 访问到组件的 this 及其变量啦~ 在 Console 中查看变量 断点调试法通过打断点进行调试，也是常见的调试方法之一。我们在浏览器找到自己写的代码，然后就可以在代码上打断点了。 不过，我们的代码不是在 localhost:8080 目录，而是在 webpack:\\\\ 目录下： webpack 下的代码 不过这也是因为我配置了 webpack。如果实在找不到，还可以在 Source 这个页面按 Ctrl+Shift+F 全局搜索自己的代码内容；或者在你的代码的某个地方 console.log(1)，然后在 Console 部分找到对应的超链接跳转到代码。 通过 console.log 找到源码 Chrome 插件 Vue.js devtoolsVue 也提供了 Chrome 和 Firefox 插件，利用插件，可以方便的查看当前页面的结构，以及观察 Vuex、Vue Router 的状态。 Vue.js devtools","tags":[{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.lyh543.cn/tags/Vue/"}]},{"title":"面试相关知识","date":"2021-03-26T16:00:00.000Z","path":"carrers/interview-notes/","text":"以下知识均在后台开发面试中实际出现过、总结而来。 C++多态的实现即虚函数表。 STL 容器库容器库 - cppreference.com unordered_map 和 map 的区别略。 multimap 和 map 的区别略。 智能指针智能指针（现代C++） | Microsoft Docs 智能指针是对普通指针的一个封装。普通指针 new 了以后一定要 delete，而智能指针是一个类，当这个类的对象超出作用域以后，会自动调用析构函数，因此不再需要 delete，也不会因为忘记 delete 而发生内存泄露。 智能指针和普通指针的对比： 12345678910111213141516171819202122void UseRawPointer()&#123; // Using a raw pointer -- not recommended. Song* pSong = new Song(L\"Nothing on You\", L\"Bruno Mars\"); // Use pSong... // Don't forget to delete! delete pSong; &#125;void UseSmartPointer()&#123; // Declare a smart pointer on stack and pass it the raw pointer. unique_ptr&lt;Song&gt; song2(new Song(L\"Nothing on You\", L\"Bruno Mars\")); // Use song2... wstring s = song2-&gt;duration_; //...&#125; // song2 is deleted automatically here. 智能指针体现什么机制：封装。 unique_ptr：unique_ptr 的出现是为了替代 C++98 的 auto_ptr (而 auto_ptr 于 C++11 中被弃用)。如果不知道用什么，默认用 unique_ptr 就对了。unique_ptr 只占一个指针大小的空间 shared_ptr：shared_ptr 的管理类似于 Python 的垃圾回收机制：对变量进行计数（如下图）。拷贝构造 auto sp3(sp2); 和赋值 auto sp4 = sp2; 都会使得计数++。shared_ptr 占两个指针大小的空间 weak_ptr：shared_ptr 中如果有循环引用，导致二者的计数都不为 0，会导致内存泄露。可以在引用的地方使用 weak_ptr 并将 shared_ptr 赋给它，这不会使得 shared_ptr 计数++，之后能被正确地回收。例子 例子2 shared_ptr 数据结构快排算法、快排的时间复杂度（平均、最坏）数据库MySQL 数据库引擎 MyISAM：读性能高，但不支持外键、行级锁和事务，MySQL 5.5 默认 InnoDB：读性能稍弱，支持外键、行级锁和事务，MySQL 5.5.5 及以后默认 二者都使用 B+ 树作为存储的数据结构。 B 树和 B+ 树B 树B 树 | 维基百科面试官问你B树和B+树，就把这篇文章丢给他- SegmentFault 思否 先要纠正两个常见误区： B 树 (B-Tree) 不是二叉树 (Binary Tree)。B 的全称，可能起源于其发明者，不过理解成平衡 (balanced) 或宽的(broad) 或 茂密(bushy) 也不错。 没有 B 减树！B 减树的出现可能是翻译人员错误地将 B 树 (B-Tree) 翻译成了 B 减树。 B 树 概述：B 树是是一种自平衡的树，能够保持数据有序（听起来就是在说平衡二叉树）。其与平衡二叉树的不同在于，B 树的一个节点可以拥有 2 个以上的子节点，且节点数在某范围内可变。这样的好处有： 子结点的增多能够降低深度，减少定位记录时所经历的中间过程，运用在磁盘、数据库中可以加快存取速度； 由于节点数在范围内可变，因此 B 树不需要像其他平衡二叉查找树那样经常进行平衡 定义：一棵 m 阶 B 树的定义： 每个节点最多有 m-1 个 key； 根节点最少可以只有 1 个 key，非根节点至少有 m/2 个 key（根节点的 key 数量范围：[1, m-1]，非根节点的 key 数量范围：[m/2, m-1]。）； 每个节点中的 key 都按照从小到大的顺序排列，每个 key 的左子树中的所有 key 都小于它，而右子树中的所有 key 都大于它； 所有叶子节点都位于同一层（即根节点到每个叶子节点的长度都相同）； 每个节点都存有索引和数据，也就是对应的 key 和 value。 B 树插入的规则：插入的时候，判断当前结点key的个数是否小于等于 m-1，如果满足，直接插入即可，如果不满足，将节点的中间的 key 将这个节点分为左右两部分，中间的节点放到父节点中即可。 B+ 树B+ 树具有上述 B 树的前四个特点。除此之外，B+ 树还有以下特点： B 树的所有结点都存储数据，而 B+ 树只有叶子结点存储数据，内部节点（或非叶子结点、索引节点）只存放索引； B+ 树每个叶子结点存有下一个叶子结点的指针，而 B 树无，所以所有叶子结点形成了一条有序链表，遍历整棵树只需要遍历链表，而不需要从树根往下遍历。 B+ 树较 B 树的优点就是遍历快吧。 慢查询MySQL索引原理及慢查询优化- 美团技术团队 慢查询：超过指定时间的 SQL 语句查询。 优化方法： 查看日志查看慢查询 添加索引、修改索引（如先查区分度大的） 分库、分表 聚簇索引 &amp; 非聚簇索引 聚簇索引 & 非聚簇索引 非聚簇索引（二级索引、辅助索引）：表数据和索引分成两部分存储，叶子结点存主键和索引键 聚簇索引：表数据和主键一起存储，主键索引的叶子结点存行数据 (包含主键值) InnoDB 为什么推荐使用 auto_increment 作为主键 auto_increment 保证能新加入的数据的主键永远是最大的，加入的数据会被放在最后。在写入量大的时候，插入数据时是连续写入，而不是随机 I/O auto_increment 使得主键和业务分离，这样即便业务上出现调整，也不需要重构数据库 事务的 ACIDACID，是指数据库管理系统 (DBMS) 在写入或更新资料的过程中，为保证事务 (transaction) 是正确可靠的，所必须具备的四个特性： 原子性 (atomicity)：一个事务要么全做要么全不做； 一致性 (consistency)：数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。最常见的例子是转帐：从帐户 A 转一笔钱到帐户 B 上，如果帐户 A 上的钱减少了，而帐户 B 上的钱却没有增加，那么我们认为此时数据处于不一致的状态； 隔离性 (isolation)：一个事务不影响其他事务的运行效果； 持久性 (durability)：事务一旦提交，则其结果就是永久性的，即使故障也能恢复。 从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说 ACID 四大特性之中，C 是目的，AID 是手段，是为了保证一致性，数据库提供的手段。 事务的原子性和持久性的保证 将所有事务开始、提交、终止，以及数据的更新操作（记录数据更新前的值即前像，或更新后的值即后像）计入 log 系统崩溃后重启，先读取日志对已提交的事务进行 REDO（保证持久性） 然后对尚未提交的的事务进行 UNDO（保证原子性） InnoDB 事务隔离级别MySQL 事务隔离级别和锁– IBM Developer SQL 标准定义了四种隔离，隔离程度由高到低依次为： 读未提交/脏读：未提交事务的数据也可以被读，这也被称为脏读； 读提交/不可重复读：提交了的东西就可以被读，但若一个事务两次读取过程中，有事务更新了数据，会导致不可重复读； 可重复读/幻读（默认）：同一个事务中，select 的结果是事务开始时的状态，因此可重复读。但由于 insert 语句等不受影响，所以可能出现幻读（本事务开始后，别的事务提交了数据 pk=1，本事务 select 不到 pk=1，但 insert pk=1 会报错主键冲突，像是读到了幽灵） 序列化：如果要完全解决上面的三种问题，就只能让事务串行化了，也就是把多个事务变成一个序列。 有/无问题 脏读 不可重复读 幻读 读未提交 有 有 有 读提交 无 有 有 可重复读 无 无 有 序列化 无 无 无 InnoDB 锁MySQL 事务隔离级别和锁 - IBM Developer Innodb中的事务隔离级别和锁的关系 - 美团技术团队（很有意思，推荐认真阅读） 数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁） 加锁阶段：在该阶段可以进行加锁操作。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。 解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。 这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。 行锁InnoDB 实现了两种类型的行级锁： 共享锁 (S)：在对任何数据进行读操作之前要申请并获得 S 锁。其它事务可以继续加共享锁，但不能加排它锁； 独占锁 (X)：在进行写操作之前要申请并获得 X 锁。其它事务不能再获得任何锁； 表锁InnoDB 支持多粒度锁，因此 S 和 X 锁还可以锁表（如使用 ALTER TABLE 等语句会给表上 X 锁）。 另外还设计了两个意向锁，注意意向锁都是表级的： 意向共享锁 (IS)：表明事务即将给表中的行设置 S 锁。事务给行加 S 锁前必须获得该表的 IS 锁。 意向排它锁 (IX)：表明事务即将给表中的行设置 X 锁。事务给行加 X 锁前必须获得该表的 IX 锁。 综上，MySQL 支持两种行锁和四种表锁。 四种表锁的兼容表如下： 锁类型 X IX S IS X 冲突 冲突 冲突 冲突 IX 冲突 兼容 冲突 兼容 S 冲突 冲突 兼容 兼容 IS 冲突 兼容 兼容 兼容 总结一下就是： 意向锁之间相互不冲突 互斥锁和所有锁都冲突 共享锁和互斥意向锁冲突 行锁的算法 Record Locks：锁（单条）记录 Rocord Gaps：锁范围 Next-Key Locks：锁范围+锁记录 乐观锁和悲观锁，以及多版本并发控制一文读懂数据库中的乐观锁和悲观锁和MVCC | MySQL 技术论坛乐观锁和 MVCC 的区别？ - 用心阁的回答 - 知乎 乐观锁和悲观锁都不是数据库锁，而是两种用于解决写-写冲突的思想。 乐观锁（又称乐观并发控制）是乐观地假设，事务间的竞争没有那么多。 乐观并发控制的一种实现是基于版本号。首先进行修改，在提交事务前，检查一下事务开始后是否有别的提交，如果没有就提交，如果有就放弃并回滚重做。 乐观并发控制多用于读多写少的场景，由于没有上锁解锁（此处指数据库锁）的过程，读的性能会很高；但在读少写多的场景，需要反复回滚重做，所以效率会变低。 悲观锁（又称悲观并发控制）是悲观地假设，事务间的竞争很多。 悲观并发控制的一种实现就是利用数据库锁，在数据库层对数据进行上锁。 悲观并发控制多用于读少写多的场景，这种场景下，不需要回滚重做而是等待，会比乐观锁好；但是上锁解锁需要消耗一定性能。 多版本并发控制（MVCC）和上面的区别是，MVCC 解决的是读-写冲突。 MVCC 在各数据库中有不同的实现，在 InnoDB 中是一种无锁并发控制。InnoDB MVCC 为事务分配递增的时间戳（或者 version），更新时 version++，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。 计算机网络OSI 七层就是把应用层拓展为（自底向上）会话层、表示层（加密相关）、应用层。 TCP 三次握手与四次挥手TCP 三次握手与四次挥手 三次握手： 客户端：发送 SYN，进入 SYN_SENT 状态 服务器：收到包后发送 SYN ACK，进入 SYN_RCVD 状态 客户端：收到包后发送 ACK，进入 ESTABLISHED 状态（服务器接收后也进入 ESTABLISHED 状态） 三个包的 seq 和 ACKnum 数值有如下关系： SYN ACK 的 ACKnum = SYN 的 seq+1 ACK 的 ACKnum = SYN ACK 的 seq+1 TCP 三次握手 四次挥手并不一定是客户端发起，也可以由服务端发起。故下面用 主动关闭 和 被动关闭 称呼： 主动关闭方：发送最后一个数据包后，发送 FIN，进入 FIN_WAIT_1； 被动关闭方：收到包后发送 ACK，进入 CLOSE_WAIT；客户端收到后进入 FIN_WAIT_2，此时客户端到服务端的单方连接被关闭； 被动关闭方：发送最后一个数据包后，发送 FIN，进入 LAST_ACK； 主动关闭方：收到包后发送 ACK，进入 TIME_WAIT，一段时间后关闭通信；服务端收到后立即关闭通信。 可以理解为两对 FIN - ACK，且每个 ACK 的 ACKnum = 对方的 FIN 的 seq+1。 CLOSE_WAIT 可以理解成对方主动关闭了连接，但本方还没有关闭，在等待关闭连接 (wait close)； TIME_WAIT 首先发出 FIN 的一侧，如果给对侧的 FIN 响应了 ACK，那么就会超时等待 2*MSL 时间，然后关闭连接(time wait)。在这段超时等待时间内，本地的端口不能被新连接使用；避免延时的包的到达与随后的新连接相混淆。RFC793 定义了 MSL 为2分钟（即 TIME_WAIT 等待 4 分钟）。 TCP 四次挥手 被动关闭的一方也可以把 ACK 和 FIN 合并为 FIN ACK，实现三次挥手。 TCP 流量控制TCP流量控制、拥塞控制 流量控制：考虑到可能接收方处理的比较慢，需要限制发送方的发送速度。方法是，接收方发回的 ACK 中会包含自己接收窗口的大小。 流量控制死锁：当发送者收到了一个窗口为 0 的应答，便停止发送，等待接收者的下一个应答。但如果之后接受者发送的窗口不为 0 的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。 流量控制死锁避免：TCP 使用持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器，时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送。 TCP 快速重传 在没有快速重传机制下，如果发送方的某报文丢失，即使接受方发送了多个重复确认，发送方仍需等待重传计时器到期才会重传； 快速重传机制下，发送方一旦收到三个重复确认，就重传报文，无需等待计时器到期。 TCP 拥塞控制TCP流量控制、拥塞控制 发送方维持一个变量：拥塞窗口 (congestion window, cwnd)，取决于网络拥塞情况，且动态变化。 发送方使自己的发送窗口为 $\\min(cwnd, wnd_{接收方})$。 慢启动阶段，cwnd=1，每成功传输一次则 cwnd*=2，直至 cwnd 到达慢启动阈值 (slow-start threshold, ssthresh)，进入拥塞避免状态。 拥塞避免状态，每成功传输一次则 cwnd++ 任何时刻，出现发送方对某报文的计时器超时，令 ssthresh=cwnd/2，cwnd=1，重新进入慢启动 快速恢复：任何时刻，出现发送方接收到三个重复确认，并不按照上一条执行，而是令 ssthresh=cwnd/2, cwnd=cwnd/2+3，进入拥塞避免状态（能收到重复报文，说明网络没那么拥堵，超时才是真的拥堵） 用户从输入域名到获取到信息过程中发生了什么a. DNS 解析的过程：计算机先检查 DNS 缓存，如果没有缓存则向 DNS 服务器查询域名对应的 IP，查询的过程分为迭代和递归两种方式；面试官接着问了 DNS 基于什么协议，答案是 UDP，服务器一般使用 53 端口；b. 获取到 IP 以后就可以发包了，需要对包进行一层层的封装，自顶向下的封装顺序为：HTTP、TLS、TCP、IP。c. HTTP 协议的内容大致为 HTTP/1.1 GET /；d. TLS 协议会进行 TLS 握手，主要是客户端、服务端交换密钥；e. 再往下是 TCP 和 UDP 协议。经典一问：TCP 和 UDP 的区别（TCP 面向连接、拥塞控制、流量控制），顺便还简单问了一下拥塞控制；f. 再往下就是 IP 层，主机会向向路由器发 IP 包、路由器根据路由表和选路算法进行转发的过程；面试官又问了有那些选路算法（分为域内和域间协议，域内有 OSPF 和 RIP，域间使用 BGP）；以及路由表的最长前缀匹配原则；e. 再往下就是物理层了。 操作系统进程和线程的区别 调度并分派的单位称为线程（或轻量级进程 LWP） 资源所有权的单位称为进程 进程会创建进程控制块 (PCB)，而线程是线程控制块 (TCB)。由于线程没有父子进程、资源控制等结构，所以 TCB 比 PCB 简单得多，这也导致线程的创建比进程的创建快得多，大概有一个数量级的区别。 这也是平时开发中，为了利用 CPU 多线程，我们常使用多线程开发，而不是多进程开发的原因。 用户态和内核态的区别，这样有什么好处 用户模式：优先权较少，用于运行用户程序 内核模式：优先权更高，用于运行内核，且某些指令、内存只能在特权模式下运行/访问，如： 读取/修改 PSW 等控制寄存器 原始 I/O 指令 内存管理相关 区分用户模式和内核模式的原因：保护 OS 和重要操作系统表不受程序干扰 用户级线程和内核级线程 用户级线程和内核级线程 用户级线程：线程、线程的创建、销毁全部由库函数实现。内核不知道用户级线程的存在，依旧按照进程为单位进行调度。 优点：线程切换不需要内核模式，快；调度策略因应用程序不同而不同；可以运行在任何操作系统上 缺点：系统调用将阻塞同一进程中的其他线程；不能利用多处理器技术 内核级线程：管理线程的所有工作均由内核完成。 Windows是这种方法的一个例子。 优点：ULT 两个缺点反过来说；内核本身也可以是多线程的 缺点：ULT 三个优点反过来说； 进程七状态 运行 就绪 阻塞 就绪/挂起 阻塞/挂起 New Exit 僵尸进程和孤儿进程二者都是进程派生后，父子进程其中一个退出的情况。僵尸进程是子进程退出，孤儿进程是父进程退出。 孤儿进程：父进程派生出子进程。父进程退出，但子进程还在运行，子进程就被称为孤儿进程。Unix 系统下，孤儿进程会被 init 进程收养，并在孤儿进程退出后由 init 进程对它们完成状态收集工作。孤儿进程没有什么危害。 僵尸进程：父进程 fork 出子进程。子进程退出，父进程并没有获取子进程的状态信息，子进程的进程描述符仍然留在系统中，子进程被称为僵尸进程，在 htop 的状态一栏会被标记为 Z。大量僵尸进程会占用内存空间，需要把父进程 kill 掉，僵尸进程转为孤儿进程，进而被 init 回收。 进程调度算法 先来先服务 First Come First Served, FCFS 时间片轮转 Round Robin, RR 短进程优先 Shortest Process Next, SPN 剩余时间最短优先 Shortest Remaining Time, SRT 响应比高者优先 Highest Response Ratio Next, HRRN 反馈 Feedback 进程切换算法 保存处理器上下文（寄存器） 更新当前进程的 PCB（状态、数据结构等变化） 将 PCB 的指针移至相应队列（就绪、阻塞、挂起等） 选择另一进程执行 线程间通信方式同一进程的线程共享内存地址空间，没有必要依赖 OS 进行通信，但要做好同步/互斥，保护共享的全局变量。 锁机制：三种常见的锁的实现包括互斥锁、读写锁、条件变量 互斥锁：提供了以排他方式防止数据结构被并发修改的方法 读写锁：允许多个线程同时读共享数据，而对写操作是互斥的 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止（对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用） 信号量 (Semaphore) 信号机制 (Signal)：类似进程间的信号处理 进程间通信方式 管道(pipe)，分为无名管道和有名管道 信号(signal) 消息队列 共享内存 信号量 套接字(socket) 记住上面的六个词就可以对付 60% 的面试了，30% 的可能会问一下有名管道和无名管道的区别，剩下 10% 的面试可能每个都会问一下。 如何保证缓存一致性缓存一致性就是保证内存和缓存中的内容相同。 实现上，每一行的缓存用一个 modified 标记了是否被修改。当这行缓存将被替换时，就会将这行内容写回内存。 开发深拷贝和浅拷贝 浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。 浅拷贝 深拷贝 如何进行调试 利用标准输出 / log 调试； 利用 IDE 单步调试； 利用 assert 语句调试。 设计模式设计模式- 廖雪峰的官方网站 范围/目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法 (类）适配器 模板方法、解释器 对象模式 单例原型抽象工厂建造者 代理(对象）适配器桥接装饰外观享元组合 策略命令职责链状态观察者中介者迭代器访问者备忘录 设计模式的原则 开闭原则：对扩展开放、对修改关闭 里氏替换原则：如果对父类的调用可以成功，对子类的调用也应该成功，这也是面向对象编程的基础 创建型模式 工厂方法：工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品 12345678┌─────────────┐ ┌─────────────┐│ Product │ │ Factory │└─────────────┘ └─────────────┘ ▲ ▲ │ │┌─────────────┐ ┌─────────────┐│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │└─────────────┘ └─────────────┘ 抽象工厂：抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品： 1234567891011121314151617 ┌────────┐ ─ &gt;│ProductA│┌────────┐ ┌─────────┐ │ └────────┘│ Client │─ ─&gt;│ Factory │─ ─└────────┘ └─────────┘ │ ┌────────┐ ▲ ─ &gt;│ProductB│ ┌───────┴───────┐ └────────┘ │ │ ┌─────────┐ ┌─────────┐ │Factory1 │ │Factory2 │ └─────────┘ └─────────┘ │ ┌─────────┐ │ ┌─────────┐ ─ &gt;│ProductA1│ ─ &gt;│ProductA2│ │ └─────────┘ │ └─────────┘ ┌─────────┐ ┌─────────┐ └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│ └─────────┘ └─────────┘ 生成器模式（Builder）：使用多个“小型”工厂来最终创建出一个完整对象。 原型模式（Prototype）：创建新对象的时候，根据现有的一个原型来创建。 单例模式（Singleton）：保证在一个进程中，某个类有且仅有一个实例。 结构型模式 适配器（Adapter）：转换器，即负责将 A 类转换为 B 类的类 InputStreamReader 就是 Java 标准库提供的 Adapter，它负责把一个 InputStream 适配为 Reader。类似的还有 OutputStreamWriter。 桥接模式（Bridge）：不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243桥接前： ┌───────┐ │ Car │ └───────┘ ▲ ┌──────────────────┼───────────────────┐ │ │ │┌───────┐ ┌───────┐ ┌───────┐│BigCar │ │TinyCar│ │BossCar│└───────┘ └───────┘ └───────┘ ▲ ▲ ▲ │ │ │ │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐ ├─│ BigFuelCar │├─│ TinyFuelCar │├─│ BossFuelCar │ │ └───────────────┘│ └───────────────┘│ └───────────────┘ │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐ ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│ │ └───────────────┘│ └───────────────┘│ └───────────────┘ │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐ └─│ BigHybridCar │└─│ TinyHybridCar │└─│ BossHybridCar │ └───────────────┘ └───────────────┘ └───────────────┘桥接后： ┌───────────┐ │ Car │ └───────────┘ ▲ │ ┌───────────┐ ┌─────────┐ │RefinedCar │ ─ ─ ─&gt;│ Engine │ └───────────┘ └─────────┘ ▲ ▲ ┌────────┼────────┐ │ ┌──────────────┐ │ │ │ ├─│ FuelEngine │┌───────┐┌───────┐┌───────┐ │ └──────────────┘│BigCar ││TinyCar││BossCar│ │ ┌──────────────┐└───────┘└───────┘└───────┘ ├─│ElectricEngine│ │ └──────────────┘ │ ┌──────────────┐ └─│ HybridEngine │ └──────────────┘ 组合（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 12345678public interface Node &#123; // 添加一个节点为子节点: Node add(Node node); // 获取子节点: List&lt;Node&gt; children(); // 输出为XML: String toXml();&#125; 装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。类似于这样的方法 A decorator(A a);。顺带一提，Python 的装饰器就玩得很好。 123456789101112// 创建原始的数据源:InputStream fis = new FileInputStream(\"test.gz\");// 增加缓冲功能:InputStream bis = new BufferedInputStream(fis);// 增加解压缩功能:InputStream gis = new GZIPInputStream(bis);// 或者一次性写成这样：InputStream input = new GZIPInputStream( // 第二层装饰 new BufferedInputStream( // 第一层装饰 new FileInputStream(\"test.gz\") // 核心功能 )); 外观模式（Facade）：将复杂的流程包装成一个函数并暴露给调用方。 1234567891011// 将 register, openAccount, applyTaxCode 三个步骤包装成一个函数public class Facade &#123; public Company openCompany(String name) &#123; Company c = this.admin.register(name); String bankAccount = this.bank.openAccount(c.getId()); c.setBankAccount(bankAccount); String taxCode = this.taxation.applyTaxCode(c.getId()); c.setTaxCode(taxCode); return c; &#125;&#125; 享元模式（Flyweight）：通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。如 Integer.valueOf()。 代理模式（Proxy）：将 A 接口转换成 A 接口，可在调用 A 的方法前后加一些额外的代码，实现对 A 的控制。 装饰器和代理的区别代理模式和装饰器模式的区别 - 知乎 装饰器和代理很相似，都是接收 A 接口，返回 A 接口。其区别主要是思想上的区别： 装饰模式是为装饰的对象增强功能； 而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强； 行为型模式 责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递： 1234567891011121314151617181920212223 ┌─────────┐ │ Request │ └─────────┘ │┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐ ▼│ ┌─────────────┐ │ │ ProcessorA ││ └─────────────┘ │ ││ ▼ │ ┌─────────────┐│ │ ProcessorB │ │ └─────────────┘│ │ │ ▼│ ┌─────────────┐ │ │ ProcessorC ││ └─────────────┘ │ │└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘ │ ▼ 命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。好处是可以对请求排队、记录请求日志，以及支持可撤销的操作。 解释器模式（Interpreter）：如 Python 解释器、正则表达式匹配等。 迭代器模式（Iterator） 中介模式（Mediator）：在多个组件的相互交互中，添加一个中介，所有组件和中介交互，实现组件间的松耦合。 备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。简单的实现是，编写这个类的 getState() 和 setState() 方法，负责导出、导入信息即可。 观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe, Pub/Sub）：发布方搞一个 Observer 数组；订阅操作就是将订阅者加入数组中；当发布方需要告知订阅者时，对数组中每个对象调用通知方法 void onEvent(Event event); 即可。 状态（State） 策略（Stategy）：即排序算法时使用的 Comparator 模板方法（Template Method）：使用抽象类定义流程，流程中的部分细节让子类实现 访问者（Visitor）： Linux 命令 命令 用途 top 任务管理器 free 查看剩余内存等（不过为什么不用 top 呢） ps 查看进程，可使用 `ps aux kill -9 &lt;pid&gt; 杀进程 lsof -i:8000 查看 8000 端口的占用进程 nload 查看流量大小 wc (word count) 统计文件的字数、行数、字符数 tail --follow 实时输出（日志）文件内容 journalctl -f -u &lt;unit.service&gt; 实时输出日志内容 grep word file.txt 在 find.txt 查找 word 字符串，-i 大小写不敏感 find &lt;directory&gt; -name &#39;file.txt&#39; 在目录下查找 file.txt df -h 查看文件剩余空间 低频考点以下是低频考点，但是在真实面试中问过一次，读者可以按需掌握。 C++C 语言获取当前文件夹、函数名、行数中望龙腾 C++ 岗笔试考过。 123456789101112#include&lt;iostream&gt;#include&lt;direct.h&gt;using namespace std;int main()&#123; cout &lt;&lt; _getcwd(0, 0) &lt;&lt; endl // 获取当前文件夹 &lt;&lt; \"__FUNCSIG__:\" &lt;&lt; __FUNCSIG__ &lt;&lt; endl // 获取函数完整签名 &lt;&lt; \"__FUNCTION__:\" &lt;&lt; __FUNCTION__ &lt;&lt; endl // 获取函数名 &lt;&lt; \"__LINE__:\" &lt;&lt; __LINE__; // 获取行数&#125; 输出： 1234C:\\Users\\liu\\Desktop\\test\\cpp__FUNCSIG__:int __cdecl main(void)__FUNCTION__:main__LINE__:11 C 语言字节对齐cv 限定符cv（const 与 volatile）类型限定符 | cppreference.com cv 限定符是 const 和 volatile 的合称。 当对象最初被创建时，所用的 cv 限定符决定对象的常量性或易变性。 const 大家都懂，就是不能修改的常量 (constant)，直接修改会编译报错，间接修改（如利用 const_cast&lt;int&amp;&gt; 等手段）为未定义行为。还有一点，就是写为 const 之后，编译器会进行优化。 而 volatile 翻译过来是“易变”的，表明该变量可能通过软件甚至硬件方式变化。这会阻止编译器对这个变量进行任何优化，包括但不限于：不会将变量放到寄存器中；不会对 const volatile 变量当做 const 进行优化。（不过，CPU 仍可以将变量放入缓存中，因为缓存对程序员是透明的） 代码例子见 const_cast 部分。 static 用处C 语言的 static 有三个用处： 对函数内变量使用，扩展其生存期； 对函数外变量和函数使用，使其他文件不能通过 extern 访问到该变量/函数（默认是可以的）； 对类的成员/方法使用，使得该变量/函数属于类（其他的都是属于每个对象），可以直接由类名 Classname:: 调用； 禁止继承C++ 11 引入了 final 关键字。 1234567class A final &#123;&#125;;class B : public A &#123;&#125;; // error: 不能选择 final 类作为基类 禁止拷贝构造函数和赋值构造函数C++11 加入了 = delete 控制类默认函数。 1234567891011121314class Thing&#123;public: Thing(const Thing&amp;) = delete; Thing&amp; operator = (const Thing&amp;) = delete;&#125;;int main(int)&#123; Thing t1; // 错误 E0291：类 \"Thing\" 不存在默认构造函数 Thing t2(t1); // 错误 E1776：无法引用 函数 \"Thing::Thing(const Thing &amp;)\" (已声明 所在行数:4) -- 它是已删除的函数 Thing t2 = t1; // 错误 E1776：无法引用 函数 \"Thing::Thing(const Thing &amp;)\" (已声明 所在行数:4) -- 它是已删除的函数 return 0;&#125; C++98 前可以定义为 private。 123456789101112131415class Thing &#123;public:private: Thing (const Thing &amp;); Thing &amp; operator = (const Thing &amp;);&#125;;int main(int)&#123; Thing t1; Thing t2(t1); //error C2248: “Thing::Thing”: 无法访问 private 成员 Thing t2 = t1; //error C2248: “Thing::Thing”: 无法访问 private 成员 return 0;&#125; std::vector 和 std::array vector 和 array 都是可以通过 [] 访问下标对应元素的数组； vector 是变长数组，可以通过 push_back insert 和 erase 修数组大小。（注意 insert 和 erase 都是 $O(n)$ 的）； C++ vector 内存分配与回收机制； array 则是 C++11 引入的、对标准数组的封装，是定长数组。 Lambda 捕获值列表Modern C++ zh-cn 分为三种： 值捕获 [value] 或 [=value]：与参数传值类似，值捕获的前提是变量可以拷贝。不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝。 引用捕获 [&amp;value]：与引用传参类似，引用捕获保存的是引用，值会发生变化。 隐式捕获 [=] 或 [&amp;]：手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 &amp; 或 = 向编译器声明采用引用捕获或者值捕获。（很多地方说的是捕获 this，我觉得还是这个好理解一些，毕竟如果在 main 函数中，也没有 this 一说） 总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是： [] 空捕获列表 [name1, name2, ...] 捕获一系列变量 [&amp;] 引用捕获, 让编译器自行推导引用列表 [=] 值捕获, 让编译器自行推导值捕获列表 数据结构堆的复杂度面腾讯的时候被问到，建堆的复杂度是多少，还好之前写过博客，还有一点点印象不是 $O(n\\log n)$，而是 $O(n)$。回顾了一下博客，果然是，顺便重温了一下证明。 计算机网络TIME_WAIT 快速回收与复用time-wait快速回收与复用 - rosewind的博客 | BY Blogtime_wait的快速回收和重用NAT环境下tcp_timestamps问题_〓☆〓 清风徐来918 （QQ:89617663）-CSDN博客_tcp_timestamps 这是腾讯主管问的问题，一般第二次考到的概率很小，但作为一个知识了解也不错。 TIME_WAIT 状态产生的原因在上面部分提到了，这里不再赘述。如果 TIME_WAIT 太多，导致无法对外建立新 TCP 连接。 在 Linux 下，可以从系统层面，或从应用程序层面解决这个问题。 系统层面上，也有三种方法。 一是提高 tcp_max_tw_buckets，就能接受更多的 TIME_WAIT，但是治标不治本。 二是开启 TIME_WAIT 快速回收 tcp_tw_recycle（需同时开启 tcp_timestamps，系统默认开启）。原理是在 TCP 报文中加入时间戳（时间戳在 TCP 报文中的可选字段），然后系统缓存每个连接最新的时间戳。如果收到的 TCP 报文的时间戳早于缓存值，就丢弃数据包 (RFC1323)。 快速回收的问题在于，搭配 NAT 可能会出现问题。现在很多公司都用 LVS 做负载均衡，通常是前面一台 LVS，后面多台后端服务器，这其实就是 NAT，当请求到达 LVS 后，它修改地址数据后便转发给后端服务器，但不会修改时间戳数据，对于后端服务器来说，请求的源地址就是 LVS 的地址，加上端口会复用，所以从后端服务器的角度看，原本不同客户端的请求经过 LVS 的转发，就可能会被认为是同一个连接，加之不同客户端的时间可能不一致，所以就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的 SYN，但服务端就是不响应 ACK。如果服务器身处 NAT 环境，安全起见，通常要禁止 tcp_tw_recycle，至于TIME_WAIT连接过多的问题，可以通过 TIME_WAIT 复用解决。 三是开启 TIME_WAIT 复用 tcp_tw_reuse（也需要同时开启 tcp_timestamps）另外复用也是也是有条件的：协议认为复用是安全的。与 tcp_tw_recycle 选项相比，本选项一般不会带来副作用。 应用层面上，有两种解决办法：一是将 TCP 短连接改造为长连接，二是快速关闭 socket。 HTTP 状态码HTTP 状态码 1xx： 102 Processing (WebDAV) 用于表明 WebDAV 服务器收到了请求，但请求的操作比较费时，服务器正在处理（如遍历当前文件夹）。为了防止客户端 TCP 超时、假设请求丢失，于是服务器可以发送一个没有信息的 102 应答。 2xx： 200 OK 201 Created 202 Accepted 表示正在进行一个异步操作。用于 1. 重置密码时，服务器返回 202，然后将重置邮件发送给邮箱；2. Onedrive 分段上传时，如果完成了一部分的上传，会返回 202。 204 No Content 206 Partial Content 3xx： 301 302 307 308 见后 304 Not Modified 4xx： 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 405 Method Not Allowed 409 Conflict 415 Unsupported Media Type 5xx： 500 Internal Server Error 502 Bad Gateway 常见于 Nginx 反代的服务出锅了 504 Gateway Timeout 永久重定向 Permanently 暂时重定向 Temporarily 允许将 POST 方法改为 GET 301 Moved Permanently 302 Moved Temporarily 不允许将 POST 方法改为 GET 308 Permanent Redirect 307 Temporary Redirect HTTPS 原理及握手过程SSL/TLS协议运行机制的概述 - 阮一峰的网络日志 客户端发送：ClientHello + 随机数 client random 服务端发送：ServerHello + 随机数 server random + 证书 （客户端验证证书有效性） 客户端发送：随机数 premaster secret (经公钥加密) （服务器和客户端使用三个随机数生成一个会话密钥） 客户端发送：finished (经会话密钥加密) 服务端发送：finished (经会话密钥加密) NginxNginx为什么快到根本停不下来？ - 知乎 Nginx 的进程模型 Nginx 多进程一个 Master 进程配合多个 Worker 进程 Master 进程：管理 Worker 进程 对外接口：接收外部的操作（信号） 对内转发：根据外部的操作的不同，通过信号管理 Worker 监控：监控 worker 进程的运行状态，worker 进程异常终止后，自动重启 worker 进程 Worker 进程：所有 Worker 进程都是平等的 实际处理：网络请求，由 Worker 进程处理； Worker 进程数量：可在 nginx.conf 中配置，一般设置为核心数； Nginx IO 多路复用Nginx 使用epoll 多路复用 Nginx 均衡负载算法共五种： 轮询 (Round Robin) 加权轮训，权越大表示服务器的能力越强，能承受更大负载 最小连接数 (Least Connections) IP Hash，保证同 IP 映射到同一服务器，在集群不同享 Session 时很好用 URL Hash，保证同 URL 映射到同一服务器，在有 URL 缓存时效率高 DockerDocker 底层Docker 的底层技术 概要：Docker 使用 Linux 命名空间实现容器的隔离，使用控制组实现对容器的资源限制，使用联合文件系统提高存储效率。 和虚拟机不同，Docker 进程和宿主机进程共用一个内核和某些系统库等。而彼此各个进程的方法是 Linux 上的**命名空间 (Namespaces)**。 Docker 使用名称空间来为容器提供隔离的工作空间。当一个容器运行时，Docker 就会为该容器创建一系列的名称空间，并为名称空间提供一层隔离。 Docker 引擎也依赖另一项叫 Control groups (cgroups，控制组) 的技术。控制组可以对程序进行资源限定，并允许 Docker 引擎在容器间进行硬件资源共享以及随时进行限制和约束，如内存等。 联合文件系统 (UnionFS) 是一种分层、轻量级并且高性能的文件系统，它支持将文件系统的修改作为一次提交来一层层地叠加。不同 Docker 容器可以共享基础的文件系统层，与自己独有的改动层一起使用，可以大大提高存储效率。 I/O 多路复用内存零拷贝","tags":[{"name":"打工人","slug":"打工人","permalink":"https://blog.lyh543.cn/tags/%E6%89%93%E5%B7%A5%E4%BA%BA/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.lyh543.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"面经集合","slug":"面经集合","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E7%BB%8F%E9%9B%86%E5%90%88/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"安卓刷机记录","date":"2021-03-12T01:37:36.000Z","path":"others/android-flashing-notes/","text":"手机选择如果是为了刷原生而买手机，买一加，或者小米吧。这两个适配的很快（还是用户群体比较给力），一加 8T 在发布后一个半月后就有了官方 Pixel Experience，而一年前的小米 10 现在还只有 Unofficial PE。 一定要买膏通削龙的 SoC，联发科和麒麟目前暂时别想用原生了。 ROM 选择有条件还是搞个梯子，不然 ROM 很难下的。 Lineage OS，不过似乎已经很久没有适配新机型了 Pixel Experience，自带 Gapps，主推（当然前提是你有梯子并且想用 Google Play 服务）。 CRDroid，没用过、 ArrowOS Recovery 选择无脑选 TWRP。 Root 选择Magisk 在 Magisk v22 搞了一个 MAGIC™🌈 操作，把 Manager 和 zip 包集成到一个 apk 里了，卡刷前把 apk 改为 zip 即可刷入。 数据备份敢玩原生的，应该对重要数据应该一直都有数据备份吧。 需要备份的： 联系人（导出为 vcf） 图片视频（安利 Syncthing，可以自动和电脑双向同步文件夹，并且可以 p2p 内网穿透） 200 个 apps（使用钛备份专业版备份 apk + 数据，不过需要旧手机拿到 root；备份前推荐清理一下缓存，减少备份大小） xykey（密码本子，无联网权限，只能导出文件进行备份） Nova Launcher 的布局（导出一个 .novabackup） WiFi 密码，后面会细说 驱动安装如果不安装驱动，adb 和 fastboot 就不能识别到手机。注意 adb 和 fastboot 的驱动是两种驱动，adb 能工作不代表 fastboot 能工作。 安装原始设备制造商 (OEM) USB 驱动程序 | Android 开发者 | Android Developers 最下面有各个厂商的驱动 adb fastboot 命令进入 fastboot 状态后 123fastboot devicesfastboot flash recovery &lt;twrp.img&gt;fastboot reboot 我的小米 Mix 2s 一刷就报错，换电脑换线都没用，很奇怪。后来发现一个解决方法： 手机进入 fastboot 不连接电脑 电脑 fastboot flash recovery twrp.img，卡在 &lt;waiting for any devices&gt; 手机连接电脑，连接以后就会自动刷入，不会报错 进入 recovery图形界面，比较好操作，但是由于系统等原因可能还是会比较复杂。可能会有以下一些操作： 格式化 /data：如果原分区有加密，twrp 显示无法挂载 /data，就需要格式化 /data（注意，这不等于清除 /data）。 Pixel Experience 等类原生会对 /data 加密，密码为开机密码。在 TWRP 3.5 以上输入密码即可解密，而 TWRP 3.4 是不支持解密的，故尽量使用 3.5 以上的 TWRP 用 adb 批量安装 apps200+ 个 app 安装起来可不是说着玩的。由于 apk 全部备份在电脑，就直接走 adb 安装了： 123:: 在 App 同目录下执行adb devicesfor /f \"delims=\" %i in ('dir /b /a-d /s .') do adb install \"%%~nxi\" Wifi 密码备份、恢复这里只讨论通过 config 文件对 Wifi 密码进行备份、恢复。Google 账户似乎有同步功能，但我的没法用。 Wifi 密码的存储路径，几个安卓版本都稍有区别。据不完全统计，Android 不同版本的 Wifi 存储路径如下表。 Android 版本 存储路径 Android 7.1 (N) /data/misc/wifi/wpa_supplicant.conf Android 9 (P) /data/misc/wifi/WifiConfigStore.xml Android 11 (R) /data/misc/apexdata/com.android.wifi/WifiConfiStore.xml 不同系统还可能有差别，具体以你的系统为准。 其中 wpa_supplicant.conf 到 WifiConfigStore.xml 需要转换，可参考万能的 GitHub。 密码的备份无非就是把文件复制出来，而恢复就会稍微麻烦一点了，如果直接覆盖后重启，会发现文件又被改回去了。 万能的 GitHub 也给出了方案，以下是中文描述： 关闭 Wifi 将 WifiConfigStore.xml 复制并覆盖对应文件 修改 WifiConfigStore.xml 的权限为 600，owner 为 system:system 删除 /data/misc/wifi/WifiConfigStore.xml.encrypted-checksum（我的 Android 11 并没有这个文件，于是跳过） 重启，重启后可以看到连过的 Wifi 都回来啦 开启 Wifi 原生管理原生确实流畅，不过上了原生就得自己控制国内 app 自启了。常用工具有： 冰箱（需 root，也可以用空调狗代替） 黑阈（每次开机需要连电脑 adb，也可以用 root 替代 adb） 绿色守护（需 root） 国内 OS 工具的替代 计算器–小米计算器 日历–Gmail 也有节假日，但是没有农历。觉得不好用的可以试试软媒的云日历 相册–（付费）简易图库 - 图片管理 &amp; 编辑（Google 相册不支持长图，对文件夹支持也不好） 备份–Syncthing，跨平台同步文件夹的开源 app，p2p 连接，能够把文件在电脑、手机端双向同步，官网或 Google Play 下载 文件管理器–（付费，不过没安装 Google Play 能白嫖）Solid Explorer 桌面–（高级版付费）Nova Launcher 录音机–（免费版够用）录音笔 便签–（免费版够用）便签 支持 Webdav 备份和 Markdown","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://blog.lyh543.cn/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"面经集合 - 2021","date":"2021-03-07T16:00:00.000Z","path":"carrers/interview-experience/2021/","text":"推荐搭配 面试相关知识 食用。 2021春 腾讯成都 CSIG 后台开发 暑期实习这次是腾讯云负责数据库的组。一面的时候没咋看数据库，后面得赶紧了解和复习。 一面 自我介绍 自我介绍的时候我提到了晚上八点的夜宵券，面试官说晚上九点半下班是常态，大概是 995 的作息。emmm 不是 996，而且报销打车费，还能接受。 会 Java 吗，不会（我简历上也没写会啊） 给一个数据流，要求维护 Top n 的数组，每输入一个数就输出前 10 大的数。 本来第一反应是堆 (C++ priority queue) 的，但是堆只能输出前 10 大的。于是就还是用数组来做，对每个新来的数进行冒泡排序就行。时间复杂度 $O(n)$。 有没有更快的？这么说就只有 $O(\\log n)$ 了。想到这点以后去寻找 $O(\\log n)$ 的方法，不难想到平衡二叉树 (C++ set/map) 就可以搞定。 给定两个数组，要求两个数组相同的元素。 第一反应是两个集合的交集 (C++ set_intersection)，但是建立两个集合可是 $o(m\\log m + n\\log n)$ 的。所以认真想一下吧。 如果是有序的情况，最简单的就是双指针分别把数组遍历一遍，$O(m + n)$ 简单易懂。不过，如果 $n &gt;&gt; m$ 时，可以考虑遍历 $m$ 数组，对 $n$ 使用二分，复杂度是 $O(m\\log n)$。 如果无序，最简单的就是排序后再按上面的方法，复杂度 $O(m\\log m + n\\log n)$。如果 $n &gt;&gt;m$，也可以只排 $m$，然后遍历 $n$，二分 $m$，复杂度 $O(m\\log m + n\\log m) = O(n\\log m)$。 CAP 是什么。我甚至没听说过。问了才知道是分布式的概念。不会。 三次握手的过程，老生常谈了。 TIME_WAIT 和 CLOSE_WAIT 是什么。这是四次挥手的过程，但是我正好只记了过程，没记这两个是啥。危 ACID 是什么。数据库的东西，我还没复习。危 RAFT 是什么。依旧是没听过的概念。后来才查到也是分布式的。 总结挂了。毕竟 Java 和分布式都不会。不过我简历上也没写会这两个，不懂为什么要捞我面试 hhhh。 2021春 阿里成都 研发工程师 C/C++ 暑期实习生笔试投完阿里，马上就会去做一个类似于行测的东西，以及参加一场笔试。 今年的行测的形式是： 10 道语文文段阅读理解（类似于高考语文的第 1 题） 10 道图表数据题（这题有点阴间，全是给五年的数字，让你判断这五年的增长率变大了还是变小了，而且给的时间很短，每题只有 60s，可能都来不及用计算器） 10 道找规律（图形的那种，看不出来规律就只能随便选） 98 道性格测评（每个题给三个选项，可能有好有坏，让你从三个选一个最符合自己的、一个最不符合自己的） 然后就是笔试，是牛客网测试，需要电脑录屏+摄像头录像+手机监控消息，两个题给一个小时。 第一个题是一个水题，给一个类似下面的迷宫： 1234@....#....###... 其中 @ 是初始点，# 是墙。然后给四条指令（上北下南左西右东），问最后到达的坐标。如： 1234EASTSOUTHWESTNORTH 将会走 -&gt; (1, 4) -&gt; (2, 4) -&gt; (2, 3) -&gt; (1, 3)。输出 1 3。 直接模拟就可以了。 二题有点意思。后来查了一下发现是原题 LeetCode 1388. 3n 块披萨。 我是按 dp 做的 $O(n^2)$，不过似乎还有贪心+算法能做到 $O(n\\log n)$，这种做法不要求掌握。 一面 自我介绍 项目，哪些是自己兴趣 哪些是课程要求 C++ Python 区别 C++ 面向对象的核心 C++ 为什么要封装 C++ 为什么要多态 C++ 哪些方面有多态 C++ 自己的多态 new delete malloc free const #define，const 的好处 进程和线程的区别 进程交互方式，有没有写过 多个线程读写同一块数据会有线程 有没有了解死锁 数据库索引，优点及其缺点 使用数据库开发的时候要注意什么点 聊聊事务 聊聊事务的特性 分布式事务有了解吗 聊聊 UDP 和 TCP TCP 流量控制和拥塞控制 描述一个数据结构 C++ unoredered_map 扩容过程 随便讲一种排序 从项目背景、目标、方案聊一个项目 有没有逛什么技术社区 反问 考得不完全按照套路出牌，感觉答得不怎么样（和美团一个水平，感觉铁挂），但是居然过了。 二面 自我介绍 进程的状态，以及转换状态，在什么时候会转换状态 线程和进程的区别 进程的通信方式 线程的同步方式 索引的作用 InnoDB 索引结构，其特点是什么 所有查询都可以用到索引吗（必须索引命中） 事务的概念 ACID MySQL 如何保证事务（锁机制） redo log 和 undo log 乐观锁 和 悲观锁 tcp/ip 每一层，以及其作用 三次握手和四次挥手的过程 链表结构，以及其查找、插入、删除复杂度 快速排序描述，以及其最好、平均、最坏复杂度 项目（为什么要写、怎么选择技术栈、遇到了什么问题） 有没有后来居上的经历，觉得自己能达到目标吗 有没有啃硬骨头的经历 反问 三面这个三面直接拖了两个月，早拿到腾讯 offer 了，去阿里实习肯定是去不了了，但是据说阿里面试过了不去，秋招也可以直通终面，就还是面一下。 自我介绍 为什么不读研 项目 竞赛经历 哪儿 学生工作的一些经历，难在哪里 有没有和其他人合作、沟通 对未来有什么期待 有投其他大厂吗 挂掉的有自己总结经验吗 反问 阿里的三面更加偏向项目、克服困难、合作、沟通，技术这方面考的不多。 2021春 腾讯深圳 PCG 后台开发 暑期实习得知 CSIG 挂掉的当天晚上 11 点，腾讯的 HR 打电话问我拒绝面试的原因。哈？ 问了一下，原来是另一个部门的 HR 想捞我（猜测可能是我正在 CSIG 的面试流程，于是系统自动拒绝了面试）。简单了解了一下，便约了第二天的面试。 一面一面一个小时。 自我介绍 C++ 智能指针（不会 赶紧说自己最近用 Python） 最近 Python 写了什么项目，以及某一个项目中遇到了什么困难 Python 的垃圾回收机制 MySQL 的数据引擎（MyISAM, InnoDB） InnoDB 用的是什么数据结构（B+ 树） B+ 树和 B 树有什么区别（不会） 聚簇索引和非聚簇索引有什么区别（不清楚 口胡） 索引的结构是什么（口胡） MySQL 数据库中的事务隔离性如何保证（不会 还被反问一句 基础的都不会吗 呜呜呜别骂了别骂了，还没学结果又考到了） 线程和进程的区别 进程的消息队列是什么（口胡） 进程的同步和互斥是什么 用户级线程和系统级线程是什么 僵尸进程和孤儿进程是什么 TCP 四次挥手，以及其中客户端、服务端的状态 TCP 拥塞控制 （简历上提到 Docker）Docker 的使用程度（能够安装） （简历上提到 Nginx）Nginx 的功能 Nginx 的负载均衡算法（只会轮训和加权轮训） （Nginx 提到 HTTPS）HTTPS 加密方式和握手过程（口胡） LeetCode 322. 零钱兑换 一面过了，果然不管人多菜，只要面得够多，总有一家会捞你。这一面很多问题都是面试官追问的，所以没答上也影响。当然，复盘的时候了解一下这些知识也挺好。 二面二面一个半小时（然而算法题写了一个小时）。 自我介绍 上来问我是不是搞过 ACM，我连忙说只是参加了集训后面没去了，然后面试官给了一道硬核算法题（LeetCode 480. 滑动窗口中位数），我写了一个多小时（面试官说要不不写了说下思路，我说再调试最后一次，然后过了） TCP 三次握手，少握手一次可以吗（不可以，反例是第二次握手丢包了，客户端不知道） TCP 拥塞控制（一面问过了hhh） Nginx 为什么这么快（不知道） 有没有了解过 Nginx 的底层（无） Nginx 的 Master 和 Worker 分别做什么（不知道） 数据库事务的性质 (ACID) 数据库的原子性是怎么实现的（记录日志，回滚） 数据库的日志是什么 数据库的持久性是怎么实现的（记录日志，重做） 线程和进程的区别（一面问过了hhh） 进程通信的方法（五个） 进程通信的管道分为有名管道和无名管道，二者的区别 OS 的缓存一致性怎么实现（在缓存上标记是否被修改） 三面三面半个小时，应该是主管面。 自我介绍 问一面不会的东西：僵尸进程和孤儿进程 MySQL 事务隔离级别 B+ 树的结构 Docker 原理 Linux top 命令 Linux free 命令 Linux 查询端口占用命令 (lsof -i:8000) 多路复用 Select C++中将基类对象赋值给派生类指针这个操作是允许的吗？派生类对象赋值给基类指针呢？ 调用函数时发生的过程（计算机组成原理？） 调试的方法 vector 内存管理 深拷贝和浅拷贝的区别 设计 hashmap 从项目出发：问 Scrapy 底层 JS 闭包是什么 决策树是什么 2021春 微软苏州 SDE - STCA Summer Intern笔试笔试使用的 Codility 平台还挺不错，答完就能出分，小数据的 Correctness 和大数据的 Performance 是分开计算的。不过只能提交一次，最后搞的一套题也没有拿满分主要还是太菜了。 给一个非负整数 n，重新排列 n 中每个数字的顺序，使之组成一个最大的整数（如果结果大于 1e9 就返回 -1）。由于给定的 n 是 int，所以很小，转成 string 排序再转回 int 就可以了。但我应该是没考虑到 n 溢出 int 的情况，导致挂了。 类似于 LeetCode 56. 合并区间，不过不是要求输出区间，而是每个区间代表一个吊车能运送的范围，给定起点和终点，问起点的东西能否通过吊车运送到终点。这个题小数据 Correctness 也没过，可能是两个点重合的情况，应该直接输出 true。 给一个数组，问其中长度大于等于 3 的连续子序列的数量，如 [1, 2, 3, 3, 3, 4, 5, 6] 应当返回 5（注意，长度为 4 的子序列包含两个长度为 3 的子序列）。如果结果大于 1e9 就返回 -1。结果这题是因为忘了判这个情况，导致 Performance 只拿了 60 分。 2021春 中望龙腾 C++研发之前也没听说这公司，只是看到学校贴了招聘，就随手扫了码投了简历，宣讲会也没去。昨天 HR 晚上十一点联系我今天十一点半面试，我说有课。晚上十二点 HR 又给我打电话，让我下午一点来面，地点在学校附近的酒店。 本来不是很想去线下的，但是人家专门为了我拖到了下午，有点不好有意思，于是还是去了。就当是第一次线下面试的练习。 第二天过去了，发现没啥人来，签到表上只有四个人（也就是说上午只有四个人来面试了），感觉我也是来走个过场。没想到这公司还挺有意思。 一面关于技术方面只问了 C++，具体不记得了，包括但不限于： 多继承 虚函数实现 动态指针 用过的 STL unordered_map 和 map 的底层实现 然后简单聊了一下项目。 然后就是面试官（似乎是主管）介绍自己公司，本来我来也就图一乐，但是听他说的还真有点心动。 中望是一家民企，不是做互联网的，而是做工业软件的，所以相较于互联网公司的急功急利，中望更加养生，一是 955、加班有加班费，二是越老越吃香。 感觉还有点想去，不过 base 只有北京、深圳和武汉，而且走了这条路以后，很难再转互联网企业，只能一条路走到黑。但是，如果不想走互联网公司的 996 的话，它的优点也能和这些抵消；而且，国内也有同类软件（苏州的浩辰），即使就算倒闭了，也不至于没饭吃。 笔试是关于 C++ 的，10 个选择和 7 个简答。简答题如下： 看代码读结果，一个小的计算题 如何防止对象被拷贝 如何显示代码所在文件名、函数名、行数 简述快排原理，什么时候达到最坏复杂度，是多少 给定球（球心在 (0,0,0)，半径 R）和射线（(0,0,0) -&gt; (x0, y0, z0)），编程求解球和射线的交点 给定 1970/01/01 是周四，编程求解给定日期是星期几 以字符串形式给一个数，求其重新排序后，最小的合法（即不能 0 开头）的数（如 123320 输出 102233） 二面 聊一个 C++ 项目 用过什么 STL 容器 const 作用 docker 用到什么程度 是否有虚构造函数 C++ 最近看过什么书，看了多少 平时什么写 C++（VS），哪个版本的 VS VS 下断点的快捷键（平时用鼠标，正解是 F9） 确认不准备考研 下来有了解过我们公司吗 描述一个自己性格方面的缺点 老家是哪的 为什么想来外地工作，有没有什么顾虑（没办法，老家这边软件开发搞不起来） 有北上广的 offer 吗 反问 2021春 美团成都 后台开发笔试感觉比阿里、MS 的要难一点。 112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;/*小美最近在学习操作系统。流是操作系统中一个重要的概念。在 Linux 操作系统中，/dev/random 和 /dev/urandom 是两个重要的设备，它们可以提供永不为空的随机字节数据流。小美自己也实现了一个类似于 /dev/random 的设备 /dev/crandom，但是它只能提供预先设定好但循环不断的某个小写字母排列。例如预先设定的字符串为 abcdefgh...xyz，那么这个设备会提供永不为空的字符串流 abcdefgh...xyzabcdefg...xyzabc...。小美想利用这个设备生成一段文字，但她想知道恰好生成完这段文字时，浪费了这个流的多少个字符。样例说明拿取生成流中字母的情况如下，拿取的字母用下划线表示。abcde...lmn...def...hij...stu..zab...mno...在生成好最后一个 n 的时候，浪费了没有标下划线的 59 个字符。输入描述第一行一个长为 26 的字符串 s，表示预先设置在设备中的小写英文字母排列。第二行一个长为 n 的字符串 a，表示小美想要生成的字符串。1 ≤ n ≤ 105，保证 s 一定是一个小写字母的排列，且 a 中只包含小写英文字母。输出描述输出一行一个整数，表示恰好生成完这个字符串时，浪费了这个流的多少个字符。qwertyuiopasdfghjklzxcvbnmmeituan59*/int main()&#123; ios::sync_with_stdio(0); cin.tie(0); vector&lt;vector&lt;int&gt;&gt; dis(26, vector&lt;int&gt;(26, 26)); string t, s; cin &gt;&gt; t; int len = t.length(); t += t; for (int i = 0; i &lt; len; i++) &#123; int chi = t[i] - 'a'; dis[chi][chi] = 25; for (int d = 1; d &lt; len; d++) &#123; int chj = t[i + d] - 'a'; dis[chi][chj] = d - 1; &#125; &#125; cin &gt;&gt; s; int ans = s[0] == t[0] ? 0 : dis[t[0] - 'a'][s[0] - 'a'] + 1; for (int i = 1; i &lt; s.length(); i++) ans += dis[s[i - 1] - 'a'][s[i] - 'a']; cout &lt;&lt; ans;&#125; 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;/*题目描述：学校正在举行喝奶茶比赛。这次比赛准备了 n 杯奶茶（为了比赛公平，奶茶里没有珍珠，椰果等各种小料，也就是纯奶茶），编号为 1 到 n。第 i 杯奶茶有 ai 毫升，这 n 杯奶茶准备的吸管都是一样的，每秒最多能吸上来 C 毫升奶茶，选手只能通过吸管吸奶茶，不能捅破包装把奶茶倒进嘴里，这样对其他选手不公平。选手按队伍参赛，小团所在的队伍有 m 个人，比赛要求队内的每个人选取编号在一个连续区间的奶茶喝，当然参赛选手也可以不喝任何奶茶。但是选定一杯奶茶喝就一定要喝完，不然的话这杯奶茶就被浪费了。如果小团所在队打破了校记录，那么她们队的每个人都将获得一年的奶茶畅饮卷，所以她想知道所有奶茶都被喝完的最短用时。输入描述第一行三个整数 n, m, C，意义如题目描述。第二行 n 个整数，第 i 个整数为 ai。1 ≤ n, m ≤ 105, 1 ≤ C ≤ 50, 1 ≤ ai ≤ 104。输出描述输出一行一个整数，表示所有奶茶都被喝完的最短用时，为了保证精度，请输出答案上取整后的结果。样例输入5 3 45 8 3 10 7样例输出4*/int n, m, c, ans;int a[int(1e5+5)];bool ok(int tc)&#123; int remain = tc, cur_m = 1; for (int i = 0; i &lt; n; i++) &#123; if (remain &gt;= a[i]) remain -= a[i]; else &#123; if (tc &lt; a[i]) return false; remain = tc - a[i]; cur_m++; &#125; &#125; return cur_m &lt;= m;&#125;bool _ok(int tc)&#123; bool ans = ok(tc); cout &lt;&lt; tc &lt;&lt; (ans ? \": true\" : \": false\") &lt;&lt; \"\\n\"; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); int sum = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; c; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; int low_t = sum / m / c, high_t = sum / c + 1; while (low_t &lt; high_t) &#123; // assert low_t &lt;= ans &lt;= high_t int mid_t = (low_t + high_t) / 2; if (ok(mid_t * c)) high_t = mid_t; else low_t = mid_t + 1; &#125; cout &lt;&lt; low_t;&#125; 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;/*时间限制： 1000MS内存限制： 262144KB题目描述：小团现在有两个等大的多重集合（与集合的区别仅是在可以在集合中出现重复元素）A 和 B。她现在想让 A 集合与 B 集合相等。她会先选择一个非负整数 x，然后让 A 集合中的所有数都加上 x 并对 m 取模。也就是说，对于 A 中的全部元素 a，都把 a 变成 (a + x) mod m。她想知道这个最小的 x 是多少，才能使经过变换后 A = B。并且她保证至少存在一个满足条件的 x。输入描述第一行两个正整数 n, m，n 表示 A, B 两集合分别有 n 个元素；第二行 n 个非负整数 ai，表示 A 多重集。第三行 n 个非负整数 bi，表示 B 多重集。1 ≤ n ≤ 2000, 1 ≤ m ≤ 109, 0 ≤ ai , bi &lt; m。输出描述输出一个非负整数，表示最小的 x 值。样例输入6 81 1 4 5 1 43 0 4 0 3 0样例输出7*/typedef pair&lt;int, int&gt; P;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); map&lt;int, int&gt; m1, m2; int n, mod; cin &gt;&gt; n &gt;&gt; mod; for (int i = 0; i &lt; n; i++) &#123; int temp; cin &gt;&gt; temp; m1[temp]++; &#125; for (int i = 0; i &lt; n; i++) &#123; int temp; cin &gt;&gt; temp; m2[temp]++; &#125; vector&lt;P&gt; v1(m1.begin(), m1.end()), v2(m2.begin(), m2.end()); int len = v2.size(); int ans = mod; for (int dis = 0; dis &lt; len; dis++) &#123; int curans = (v2[dis].first - v1[0].first + mod) % mod; for (int i = 0; i &lt; len; i++) &#123; int j = (i + dis) % len; if (v1[i].second != v2[j].second || (v2[j].first-v1[i].first+mod)%mod != curans) break; if (i == len - 1) ans = min(ans, curans); &#125; &#125; cout &lt;&lt; ans;&#125; 412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;/*小美和小团的班上有 n 个人，分别编号为 1 到 n。其中小美的编号为 1，小团的编号为 2。班上有个值日表 ai,j。第一天由小美值日，第二天由小团值日。接下来的每一天，如果今天是 i 值日，昨天是 j 值日，那么明天就是 ai,j 值日。值日表是已经规划好的，保证今天值日的同学明天一定不值日。小美想知道，第 m 天值日的同学的编号。输入描述第一行两个整数 n, m，表示班上有 n 个同学和小美想知道的天数。接下来 n 行，每行 n 个整数，表示值日表 ai,j (0 ≤ ai,j ≤ n)。保证有且仅有对角线上的数字是 0。1 ≤ n ≤ 500, 1 ≤ m ≤ 1018。输出描述输出一行一个整数，表示第 m 天值日的同学的编号。样例输入3 70 3 23 0 32 1 0样例输出1*/#define int long longtypedef pair&lt;int, int&gt; P;signed main()&#123; ios::sync_with_stdio(0); cin.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; table(n, vector&lt;int&gt;(n, 0)), last(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; table[j][i]; if (m &lt;= 2) &#123; cout &lt;&lt; m; return 0; &#125; m -= 2; int day[3] = &#123; 1, 2, 0 &#125;; while (m) &#123; day[2] = table[day[0]-1][day[1]-1]; //cout &lt;&lt; \"m=\" &lt;&lt; m &lt;&lt; \" people=\" &lt;&lt; day[2] &lt;&lt; \"\\n\"; int&amp; _last = last[day[0]-1][day[1]-1]; if (_last == 0) &#123; _last = m; &#125; else &#123; int diff = _last - m; m %= diff; &#125; day[0] = day[1]; day[1] = day[2]; m--; &#125; cout &lt;&lt; day[2];&#125; 5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;/*小美在做化学实验，这个实验需要配置很多种浓度溶液，因此配溶液之前需要详细计算溶液浓度（用质量分数表示），避免误操作。实验初始溶液质量和质量分数分别为 m0 , ω0%。小美会进行如下两种操作：1、A(m, ω) 表示向目前的溶液中加入质量为 m 质量分数为 ω% 的溶液；2、B 表示撤销上一步 A 操作。对于每一步操作，小美都想知道当前溶液的质量与质量分数。质量分数 ω 按如下方式计算：设溶液中溶质质量为 x，溶液总质量为 y，则输入描述第一行两个整数 m0 , ω0。第二行一个整数 n，表示操作数。接下来 n 行，每行一条操作，格式为：A m ω 或 B，保证 m 和 ω 都是整数。如果当前操作是撤销，但是没有可撤销的 A 操作，那么忽略这条撤销操作。1 ≤ n ≤ 5×104, 1 ≤ m0, m ≤ 104, 0 ≤ ω0, ω ≤ 100。输出描述n 行，第 i 行表示第 i 次操作以后的溶液质量和质量分数 mi, ωi，其中 mi 为整数，ωi 为浮点数（保留 5 位小数），之间用一个空格隔开。样例输入20 504A 30 0BBA 80 14样例输出50 20.0000020 50.0000020 50.00000100 21.20000*/class Liquid&#123;private: double m1; // 溶质 int m0; // 溶质+水public: Liquid(int m0, int omega) &#123; this-&gt;m0 = m0; this-&gt;m1 = (double)m0 * omega / 100; &#125; Liquid() &#123; this-&gt;m0 = 0; this-&gt;m1 = 0; &#125; int get_m0() &#123; return m0; &#125; double get_omega() &#123; return m1 / m0 * 100; &#125; void add(int m0, double omega) &#123; this-&gt;m0 += m0; this-&gt;m1 += m0 * omega / 100; &#125;&#125;;const int max_n = (int)5e4 + 5;Liquid liquid[max_n];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); int m0, omega, n, cur = 0; cin &gt;&gt; m0 &gt;&gt; omega; liquid[0] = Liquid(m0, omega); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; char operation; cin &gt;&gt; operation; if (operation == 'A') &#123; cin &gt;&gt; m0 &gt;&gt; omega; liquid[cur + 1] = liquid[cur]; liquid[cur + 1].add(m0, omega); cur++; &#125; else &#123; if (operation == 'B') if (cur &gt; 0) cur--; &#125; printf(\"%d %.5f\\n\", liquid[cur].get_m0(), liquid[cur].get_omega()); &#125;&#125; 一面 聊项目，详细地聊了两个项目 有了解过哪些设计模式 设计模式的原则 MySQL 的事务隔离级别 MySQL 的两种引擎 介绍 InnoDB 的索引结构（B+ 树） InnoDB 索引分类（聚簇索引 非聚簇索引） 已知表结构 order(id, code, name) 且以 code 建立了索引，编写 SQL 查询按 code 降序、第 10000 页（每页 10 个）的结果：SELECT * FROM order ORDER BY code DESC LIMIT 99991, 10 上述 SQL 在效率方面有什么问题，以及如何优化（MySQL Limit 优化） code 上的索引（即非聚簇索引）记录了什么 InnoDB 行锁的分类 InnoDB 行锁的实现 (Record Locks, Gap Locks 和 Next-Key Locks) Next-Key Locks 有死锁问题吗 介绍一下悲观锁和乐观锁 OSI 的七层 HTTP 在哪一层 GET 和 POST 的区别 TCP 和 UDP 的区别 TCP 在哪一层 TCP 的可靠性是如何实现的 用户从输入 url 到获取到信息过程中发生了什么 进程和线程的区别 线程的通信方式 进程的通信方式 内存缓冲区溢出会发生什么（不清楚面试官问的是什么，栈溢出/内存不够发生交换） 分段和分页有什么区别 有哪些进程调度策略 链表内指定区间反转，限时 15 分钟 有一个 5 升的桶和一个 3 升的桶，如何得到 4 升的水？ 有9个球，体积、外观完全一样，其中有一个球里面有一个珍珠，这个球比其它8个球质量要重一些；现在有一个天平，如何用2次机会将这个球称出来？ 反问 2021春 滴滴 后端研发工程师（C++/Go）笔试选择题就是面试的一堆常考题，但有不少 Java 题，还有 Java 看代码写结果（？可我是面 C++/Go 啊） 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;/*时间限制： 1000MS内存限制： 65536KB题目描述：给一个字符串s，你可以至多选择两个不同位置的字符进行交换（可以选择不交换，保留原串），问所有可能中字典序最小的串。有关字典序：对于长度相同的串a和串b，串a的字典序小于串b当且仅当存在一个位置i使得串a和串b的前i-1个字符完全相同且串a的第i个字符小于串b的第i个字符。即a1=b1,a2=b2,...ai-1=bi-1且ai&lt;bi。输入描述一行一个字符串s，保证串中都为小写字母('a'~'z')。字符串长度&lt;=200000输出描述输出一个串t，表示所有可能中字典序最小的串。样例输入aaazbcdeadcd样例输出aaaabcdezdcd*/int main()&#123; string t; cin &gt;&gt; t; int front = 0, end; for (char cur = 'a'; cur &lt;= 'z'; cur++) &#123; // front 为第一个不等于 cur 的字母 // front 从上一次地方开始 for (; front &lt; t.length() &amp;&amp; t[front] == cur; front++); // end 为第一个等于 cur 的字母 for (end = t.length() - 1; end &gt;= front &amp;&amp; t[end] != cur; end--); if (end &gt; front) &#123; swap(t[end], t[front]); break; &#125; &#125; cout &lt;&lt; t; return 0;&#125; 2应该是个假题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;/*时间限制： 1000MS内存限制： 65536KB题目描述：X星是宇宙中一个非常敬畏生命和热爱生命的星球。在X星上建有一个规模很大而且设备很先进的救援站。为了方便救援工作的开展，X星规定：任意两点之间的一条边（即两个点之间的一条道路）出现问题，都不会将救援站和居民点之间的联系完全切断。也是说救援站到其他顶点都有两条或者两条以上的路线，这样在救援过程中，即使某一条路线出现问题，还可以通过其他路线到达目的地。已知救援站和部分居民点之间，以及某些居民点之间有直接的边相连（所有的边均为无向边）。现在请你编写一个程序，根据给出的救援站和居民点之间，以及某些居民点之间的连接信息，判断每一组输入数据是否满足X星的规定。如果满足规则请输出“Yes”，否则输出“No”。输入描述多组输入，第1行输入一个正整数T表示输入数据的组数。对于每一组输入数据：第1行输入两个正整数N和M，其中N表示救援点和居民点的数量，对应N个顶点。其中编号为1的顶点表示救援点，编号为2到N表示(N-1)个居民点。M表示救援站和居民点之间，以及某些居民点之间边的数量。（N&lt;=1000，M&lt;=100000）接下来M行每行包含两个正整数，分别为相邻的两个顶点（救援点或居民点）的编号，两个正整数之间用空格隔开。输出描述针对每一组输入数据，如果输入数据满足X星的规定，任意一条边的断开都不会影响到救援站到居民点之间的连通性，输出“Yes”，否则输出“No”。样例输入24 41 22 33 44 14 41 22 33 41 3样例输出YesNo*/struct UnionFindSet&#123; int n; vector&lt;int&gt; father; UnionFindSet(int n) &#123; this-&gt;n = n; father = &#123; 0 &#125;; for (int i = 1; i &lt;= n; i++) father.push_back(i); &#125; int getFather(int n) &#123; return father[n] == n ? n : (father[n] = getFather(father[n])); &#125; void merge(int i, int j) &#123; father[i] = getFather(j); &#125; int haveSameFather(int i, int j) &#123; return getFather(i) == getFather(j); &#125;&#125;;bool solve()&#123; int m, n; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; neighbors(n + 1); vector&lt;pair&lt;int, int&gt;&gt; p; for (int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; p.push_back(&#123; a, b &#125;); neighbors[a].push_back(b); neighbors[b].push_back(a); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (neighbors[i].size() &lt; 2) return false; &#125; UnionFindSet ufs(n); for (auto i : p) &#123; ufs.merge(i.first, i.second); &#125; for (int i = 2; i &lt;= n; i++) &#123; if (!ufs.haveSameFather(i, 1)) return false; &#125; return true;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); int T; cin &gt;&gt; T; for (int t = 0; t &lt; T; t++) cout &lt;&lt; (solve() ? \"Yes\" : \"No\") &lt;&lt; \"\\n\";&#125; 一面 平时用什么语言开发（C++ 和 Python） 指针和引用的区别 智能指针，以及几种智能智能的区别 memcpy memmove strcpy 的区别 多态的实现 VTABLE 在什么时候生成 B 类继承于 A 类，B 类有三个对象，问 A 类虚函数的 VTABLE 有几项 const 作用于成员函数有什么用（分为放在前面和放在后面） new 的内存可以 free 吗（未定义行为，且 free 不会调用析构函数） 用过哪些 stl vector 的底层 map 的底层及其优点 unordered_map 和 map 的区别 vector 迭代器什么时候会失效（原来 push_back、erase、insert 都可能会失效，这也太拉了吧） 析构函数应该什么时候都定义为虚函数吗（我回答是，面试官提示在不允许被继承时就不用定义了） Python pass 的作用 Python xrange 和 range 的区别（这可是 Python2 的东西，Python3 range == Python2 xrange 已经没有内存占用的问题了，面试官不会真的就是打开题库 -&gt; 念完题目吧） Python GIL 多线程编程 TCP 四次挥手 为什么四次挥手是四次而不是三次 为什么有 TIME_WAIT 状态 有了解过 epoll 吗（没有） 有无阻塞编程的经历吗 有用过 MySQL 和 Redis 的经历吗 MySQL 的引擎，默认是哪个 InnoDB 的数据结构 Linux 查看某进程的 CPU 占用使用什么命令，使用 top 命令怎么按 CPU 降序排序（我用支持鼠标操作的 htop，面试官觉得可） Linux 实时输出文件内容（tail -f） 聊项目 Nginx 的结构（一 Master 多 Worker） 了解 I/O 多路复用吗 口胡快排算法 口胡一个在一个旋转排序数组查找某数。我的思路是寻找旋转排序数组中的最小值，找到最小值以后即可标准二分查找 刚开始坐着信号不好，后来站着面完了，面试官看情况没有让我写题，只用口胡，很 nice~ 二面 聊项目，四个项目一个一个聊 Docker 原理 口胡算法：合并两个有序数组，以及如何在合并的时候去重 平时用 Nginx 吗（平时用 Caddy，夸了一波 Caady 自动申请 TLS，再反过来吹 Nginx 高并发强） Nginx 负载均衡算法 自己未来的规划 三面 聊项目 多态（一面聊过了吧） 内存分配算法（算是冷门知识点了，还好学了 OS 写了博客，有点印象） 有过网络编程（socket 编程）经验吗 tcp 三次握手 用过哪些 STL 库 set unordered_set 区别 vector 插入的复杂度 两个数如果满足 a * 2 &lt; b，我们称 (a, b) 为一个数对。给定数组，求数组中有多少个数对（每个数只能被用一遍）。 这个题排序后无脑贪心会有问题：考虑 1 3 5 7，a 选 1 时不能选最合适的 3 作为 b，正解是 (1 ,5) (3, 7) 两对。 不过有一个性质，如果一开始找到了 (1, 3) 而后面又需要这个 3，可以在数对中把 3 换成更大的数（或把 1 换成更小的数），并没有破坏之前的数对。 面试没写出来，面试尝试找了一下原题，没找到，只找到一个有一点类似的题。后来突然发现，可以仿照这个题，把这个数组排序后切成两半，然后双指针贪心，在左边从大到小找 a，在右边从大到小找 b。 贪心算法的正确性需要证明，如果按此法找到某 b 对应的某 a，而最优解中 b 对应的是 a 左边的数（或 a 右边的数），这两个解是等价的。 1234567891011121314151617181920int solve(vector&lt;int&gt; arr)&#123; sort(arr.begin(), arr.end()); int n = (int)arr.size(); int i = n / 2 - 1, j = n - 1, ans = 0; while (i &gt;= 0 &amp;&amp; j &gt;= n / 2) &#123; if (arr[i] * 2 &lt; arr[j]) &#123; i--; j--; ans++; &#125; else &#123; i--; &#125; &#125; return ans;&#125; 我还为该函数编写了一些测试，可见代码。 2021春 腾讯深圳 IEG 后台开发一面地点：深圳上班时间：995 22点以后报销打车腾讯八月会有集体转正，建议在七月之前工作 问项目 C++ map 和 set 的区别 有没有比 map 效率更高的，查询时间复杂度是多少 C++ 如何调试 深拷贝和浅拷贝是什么（不考虑语言） 内存零拷贝是什么（不知道） 字节对齐是什么 C++ 智能指针 快排复杂度 描述快排算法。给定样例 3 5 1 2，选择 3 为基准值，简单描述如何快排 快排是稳定排序吗（是） 给定 10 亿个数，求前 10 大（小根堆） 向堆插入一个数的复杂度和最坏复杂度（都是 $O(\\log n)$） 堆排序是稳定排序吗（是） 建立一个堆的复杂度 （$`O(n)$） 进程通信方式 了解进程通信的概念吗（下面五连问警告） 匿名管道是什么（不知道） 常用信号（没了解过） 共享内存（也不知道） socket（想了一下，发现也不知道） socker server 流程（放弃了） 32 位 OS 的内存寻址空间多大，怎么算的（2^32B=4GB） 确认单位是字节吗（对，因为内存按字节编址） 缺页中断是什么 缺页替换有哪些算法（FIFO、LRU、时钟） MySQL 有哪两种引擎（MyISAM、InnoDB） 两种都有外键吗（MyISAM 还真不支持） 两种引擎锁的粒度（MyISAM 只支持表级，InnoDB 支持表级和行级） 索引的底层架构及其好处（B+） 慢查询是什么 有什么优化方法吗 有用过、听说过其他的数据库吗 有使用过 Go 吗 Linux 查询进程 pid：ps aux | grep pid 有什么用（进程唯一标识符） 查看进程信息：top 查看每个 CPU 核的利用率：在 top 中按 1，或使用 htop 查看磁盘空间适用情况：df -h 查看端口占用：lsof -i:8000 有编写过多线程、多进程程序吗 有编写过 C++ 多线程、多进程吗 为什么要使用线程池（线程创建慢，线程池可以复用） 创建线程为什么慢（需要系统中断、创建线程控制块等） 2021春 腾讯成都 CSIG 后台开发之前都是 HR 来捞我，这次是一面面试官来捞我，还主动让我加微信。（可能是真缺人） 一面 自我介绍 确认工作地点、不读研、毕业以后想在成都发展，还确认了一下我是哪里人（应该是真缺长期工作的人） 介绍你的项目 想做前端还是后端 介绍一下 REST API 输入域名到显示页面的过程（梅开 n 度） 介绍一下 HTTPS 加密的原理和过程 HTTPS 是对称还是非对称（都有吧） MySQL 的引擎是什么（InnoDB） InnoDB 的数据结构（B+ 树），以及它的好处 InnoDB 叶子结点存的是什么 为什么 InnoDB 推荐主键使用 auto_increment ACID 是什么 Linux 命令行如何查看进程（top 或 ps） 进程状态的 S R Z 是什么 Linux 命令行如何监控流量大小（nload） 简述 Docker 原理 平时用什么语言开发 简述 C++ 虚函数表 算法题，本地开 IDE 写，应该有手就行 1234567891011求二维数组（元素为int类型）内横向的所有平衡线，平衡线的意思是该线上面的所有数之和和下面的所有数之和相等比如数组int a[][] = &#123;&#123;1,1,0&#125;,&#123;1,2,1&#125;,&#123;1,1,3&#125;,&#123;3,2,1&#125;&#125;;1,1,01,2,11,1,3 ---&gt; 这就是一个平衡线3,2,1其中第3行就是一个平衡线，只需要打印出3（或者2，index从0开始）注意需要找到所有的平衡线，语言不限，假设二维数组是a[m][n], 需要写出完整的代码20分钟内完成 算法题 两数之和，口胡就行 反问（问了一下工作时间是 10-9.5-5） 加一下面试官微信 加了微信以后面试官还帮我推进进度，还发了关于实习生报销打车费的政策，人非常 nice~ 二面我以为推进进度就是尽快（实际也没有快多少）的意思，结果 10:40 面完不到一个小时就约二面了，约在当天 17 点。后来才知道这还是主管面。第一次感受到腾讯的效率 2333 自我介绍 聊项目，聊遇到了什么问题（主管面，聊得比较深入，可以多聊一点） 聊一个开发调试过程比较困难的经历 有没有接触过 HTTP 底层的东西（我说没有，这里就没往下聊了） 知道 TCP 四次挥手的 TIME_WAIT 吧，HTTP 短连接会导致 TIME_WAIT 过多，如何解决这个问题（即 TIME_WAIT 的快速回收和重用，不会） 优化一个特定场景（主管说这个场景没有正解，应该是他们实际业务的场景）的快排中选择 pivot 的算法，使得快排的时间复杂度更稳定。十分钟的问题我大概有五分钟都在纠结这个场景到底是什么，大概是从别的服务查到了一批数据，是以一个数据包的形式发送过来，可以读第一个，可以读最后一个，但是不能随机定位到中间读一个（所以也没法直接用三者取中法）。最后我也没想到什么办法（毕竟没怎么了解过排序方面的优化），提了一句追求复杂度稳定的话，我更喜欢归并排序。 最后三个问题我都没咋答上来，觉得自己铁挂了。面完官网以后看了一眼，过了，真是有惊无险，也可能是我的项目经历聊得比较深入。 HR 面 毕业不打算考研吗，为什么 个人更注重什么（短期利益、职场关系、个人成就等等） 什么时候能实习 能接受加班吗 哪儿人 在腾讯有直系亲属吗 身体健康吗 有投其他大厂吗，走到哪一步流程了 你是一个什么样的人 周围的人如何评价你 你的缺点 反问 最后也是拿到了这个实习 Offer~","tags":[{"name":"打工人","slug":"打工人","permalink":"https://blog.lyh543.cn/tags/%E6%89%93%E5%B7%A5%E4%BA%BA/"},{"name":"面经集合","slug":"面经集合","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E7%BB%8F%E9%9B%86%E5%90%88/"}]},{"title":"编译原理 课程笔记","date":"2021-03-02T02:51:02.000Z","path":"computer-science/compile-principle/","text":"第一章 绪论一到四章的概念也就图一乐，真学习还得看第五章 引言语言语言：一组规则的组合 字母表的定义 词法规则：单词符号的形成规则 语法规则：（短语、从句、句子、段落、文章）语法单位的形成规则 语义规则：单词符号和语法单位的含义规则 语用规则：语义规则的发展和延伸。在一定的语境中，单词和语法单位体现出来的具体意义，需要根据上下文进行明确 机器语言、汇编语言、高级语言机器语言 -&gt; 汇编语言 -&gt; 高级语言 机器语言：由二进制指令组成。计算机可以直接执行 汇编语言：将机器语言符号化的结果 低级语言：与机器有关的语言（指令的操作码、指令格式、寻址方式、数据格式） 高级语言：和机器无关的语言 翻译 翻译：等价的变换 计算机只可直接执行用机器语言编写的程序。而用汇编语言和高级语言编写的程序，机器不能直接执行。必须将它们翻译成完全等价的机器语言程序才能执行。 翻译过程： 机器语言 &lt;–汇编程序– 汇编语言 &lt;–编译程序– 高级语言 实现：编写一个高级语言的编译程序的工作，通常称为对这个语言的实现 与编译有关的三种语言、三种程序： 源语言、宿主语言、目标语言 源程序、编译程序、目标程序高级语言涉及的三类人： 设计者、实现者、使用者 解释 BASIC 是最简单的高级语言。BASIC 程序不是编译执行，而是对源程序进行解释（分析），直接计算出结果。 解释需要解释程序(解释器) LISP，ML，Prolog 和 Smalltalk 均是解释型的语言。 Java 被当作一种解释型语言。翻译产生字节码的中间代码， 可以在 Java 虚拟机上运行。 解释执行特别适合于动态语言和交互式环境，便于人机对话。 重复执行的语句需要重复翻译，比编译执行要花去更多的时间，执行效率较低。 强制式语言、函数式语言、逻辑式语言、对象式语言程序设计语言按设计的理论基础分为四类语言: 强制式语言:基础是冯·诺依曼模型 函数式语言:基础是数学函数(函数运算) 逻辑式语言:基础是数理逻辑、谓词演算 对象式语言:基础是抽象数据类型 绑定 实体：程序的组成部分，如变量，表达式、程序单元等 属性：实体具有的特性 绑定：实体与其各种属性建立起联系的过程称为绑定（约束） **描述符(表)**：描述实体属性的表格 静态和动态 静态特性：编译时能确定的特性 动态特性：运行时才能确定的特性 静态绑定：绑定在编译时完成，且在运行时不会改变。 动态绑定：绑定在运行时完成。 静态作用域绑定:按照程序的结构定义变量的作用域（C语言等）。依据定义变量的位置进行确定。 动态作用域绑定:按照过程的调用关系动态地定义变量的作用域（SNOBL4 语言等） 变量的四个属性 作用域：全局变量、局部变量、非局部变量 生存期 值 类型 快进到第四章 第二章 数据类型略 第三章 控制结构略 第四章 程序语言的设计前言语言 = 语法 + 语义 描述语法的方法：文法 or 语法图 文法和语法图是语言语法的等价表示。 文法： 12345&lt;标识符&gt;→&lt;字母&gt;&lt;标识符&gt;→&lt;标识符&gt;&lt;字母&gt;&lt;标识符&gt;→&lt;标识符&gt;&lt;数字&gt;&lt;字母&gt;→A|…|Z|a|…|z&lt;数字&gt;→0|…|9 语法图 描述语义的方法：许多语言仍采用自然语言描述语义。 文法文法的形式定义文法的形式定义： $G = (V_T, V_N, S, P)$ $V_T$ 为终结符的非空有限集； $V_N$ 为非终结符的非空有限集； $V=V_T \\bigcup V_N$ $S$ 是文法的开始符号，有 $S\\in V_N$ ； $P$ 为产生式 $\\alpha\\to\\beta$ 的非空有限集，其中： $\\alpha$ 和 $\\beta$ 是由终结符、非终结符组成的串，且 $\\alpha$ 至少应含有一个非终结符。即 $\\alpha=V^*V_NV^*, \\beta=V^*$ $^*$ 表示前面的符号重复零次或多次（这很正则表达式） G: GrammarT: Terminal SymbolsN: Non-Terminal SymbolsS: Start SymbolP: Production 产生式的简化$$\\left.\\begin{aligned}\\alpha&amp;\\to\\beta_1 \\\\\\alpha&amp;\\to\\beta_2 \\\\&amp;…\\\\\\alpha&amp;\\to\\beta_n\\end{aligned}\\right\\}\\alpha\\to\\beta_1|\\beta_2|\\beta_n$$ $\\beta_1, \\beta_2, \\beta_n$ 称为 $\\alpha$ 的候选式。 文法的表示描述文法，直接给出产生式集合 (P) 即可。 $$\\begin{aligned}E &amp;→ E+T | E-T | T \\\\T &amp;→ T*F | T/F | F \\\\F &amp;→ (E) | i\\end{aligned}$$ 文法的分类分为 0 型文法、1 型文法、2 型文法、3 型文法。数字越大，规定越严格，越规范。 文法 （在上一级基础上增加）限制 中文 0型文法(PSG) $\\alpha\\to\\beta$ 无限制 1型文法(上下文有关文法CSG) $α$ 长度小于 $β$ 长度（$S→ε$例外） 右边的表达式长于左边 2型文法(上下文无关文法CFG) $A→β$ 左边是独立的非标识符 3型文法(正则文法RG,或右线性文法RLG) $A→u$或$A→wB$, $u\\in V_T^*, w\\in V_T^+$ 右边不以非标识符开头 推导的表示 直接推导（由产生式右边替换产生式左边）： $wαγ\\Rightarrow wβγ$ 任意步推导（0 步或多步）：$y \\Rightarrow^* z$ 多步推导（1 步或多步）：$y \\Rightarrow^+ z$ 例 1 例 2 -- 最右推导 最右推导：总是展开最右边的非终结符 句型、句子、语言$G = (V_T, V_N, S, P)$ 句型：S 能推导出的 $w$ 句子：S 能推导出的只含终结符的 $w$ 语言：G 产生的所有句子的集合 $L(G)=\\{α│S\\Rightarrow^+α 且 α\\in V_T^*\\}$ 例 2 -- 标识符 例 3 例 4 有点难。 例 4，需要上下有关文法表示，难点 文法等价两个文法 $G$ 和 $G’$，如果有 $L(G)=L(G’)$，则称 $G$ 和 $G’$ 等价 推导树对于文法 $E→E+E|E*E|(E)|i$，句子 $i+i*i$，其两棵推导树： i+i*i 的推导树 文法的二义性：一个句子有两棵不同的推导树。 第五章 编译复习概念 源语言、宿主语言、目标语言 源程序、编译程序、目标程序 自驻留：若编译程序生成宿主机执行的机器代码，称为自驻留的编译程序 自编译：若编译程序是用源语言编写的，则为自编译的编译程序 交叉编译：若编译程序生成的不是宿主机(别的机器)执行的机器代码，称为交叉编译 编译步骤逻辑上： 源程序的分析 目标程序的合成 具体： 词法分析 语法分析 语义分析与中间代码生成 中间代码优化 目标代码生成 编译的每个步骤都需要进行符号表管理和出错处理。 词法分析 分析输入字符串 根据词法规则识别出单词符号：基本字、标识符、字面常量、运算符和界符 语法分析 根据语法规则，识别各类语法单位：表达式、语句、程序单元和程序 进行语法检查 语义分析与中间代码生成 根据语义规则，对语法正确的语法单位进行翻译 可以直接生成目标程序 但目标程序的执行效率低 因此，生成中间代码 中间代码： 大多数编译器采用中间代码来描述源程序的语义。 这种中间语言对应某种抽象机 结构简单，语义明确，易于翻译成目标代码，同时也便于优化和移植。 优化 对中间代码进行等价变换，提高代码的时空效率。 语义分析产生的中间代码不依赖于实际机器，易于实现一些等价变换，使生成的目标程序占用空间更少，执行更快。 目标代码生成 根据优化后的中间代码及有关信息，可生成较为有效的目标代码： 目标机的机器语言程序或汇编语言程序 若生成的是汇编语言程序，还需由将其汇编成机器语言程序。 编译器的结构 完整的程序处理过程从分析源程序到建立一个可执行的目标程序，处理过程还需要其它工具程序的配合： 预处理器 汇编器 连接器 装入器 完整的程序处理过程 编译前端和后端 在现代编译器中，通常将编译过程划分为前端和后端两大部分，分别加以实现。 前端和后端通过中间代码连接，可极大的提高编译器设计与实现的效率。 前端：主要是与源程序相关的部分，包括词法、语法分析、语义分析和中间代码生成等。 后端：主要是与目标程序相关的部分，包括优化、目标代码生成等。 第六章 词法分析从这里才开始变难。 概述词法分析：扫描源程序的字符串,按照词法规则,识别出单词符号作为输出；对识别过程中发现的词法错误(非法的字符、不正确常量、程序括号等) 进行处理。 词法分析器和编译器的关系（1） 词法分析器和编译器的关系（2） 单词的种类 标识符 关键字 常量 运算符 分界符 12345678910111213while(*pointer!='\\0') pointer++;while 关键字 ( 界符 * 运算符 pointer 标识符 != 运算符 '\\0' 常量 ) 界符 pointer 标识符++ 运算符 ; 界符 '\\n' 界符 单词的输出形式采用二元式：(单词类别，单词) 单词类别：区分单词所属的类(整数编码) 单词：单词的属性值 单词类别的划分单词的编码随类别不同而不同。基本字、运算符、界符的数目是确定的，一字一码，它的第二元可以空缺。 标识符通归一类。 常量可按整型、实型、字符型、布尔型等分类。 常量或标识符将由第二元—-单词的属性值来区别： 通常将常数在常量表中的位置（编号）作为常量的属性值； 将标识符在符号表中的位置（编号）作为标识符的属性值。 单词符号的编码表 状态转换图 状态转换图 例 标识符的状态转换图 整数的状态转换图 词法分析器的转换图 词法分析器的转换图(1) 词法分析器的转换图(2) 词法分析器略，看 PPT 吧 第七章 自上而下的语法分析 编译理论中，语法分析是对高级语言的语法单位的结构进行分析。 语法单位结构可以用上下文无关文法来描述。 下推自动机可用于识别上下文无关文法所描述的语法单位。 上下文无关文法及下推自动机是语法分析的理论基础。 语法分析：对无关文法 $G = (V_T, V_N, S, P)$ 及符号串 $w$，判断 $w$ 是否是文法 $G$ 的一个合法句子，即：$$S\\Rightarrow^*w$$ 引言 语法分析的功能 语法分析的方法通常有两类： 自上而下(自顶向下)的分析方法（第七章）：从 $S$ 出发，能否找到一个最左推导序列，使得 $S\\Rightarrow^*w$；或者从根结点 $S$ 开始，能否构造一棵语法树，使得该语法树的叶结点自左至右的连接正好是 $w$。 自下而上(自底向上)的分析方法（第八章）：从 $w$ 出发，能否找到一个最左规约（最右推导的逆过程）序列，逐步进行规约，直至文法的开始符号 $S$。 自上而下的语法分析可分为不确定和确定的两类。 回溯分析法是不确定的分析方法。 递归下降分析法和预测分析法属于确定的分析方法。 回溯分析法其实就是 DFS。 实例： $$\\begin{aligned}S&amp;→xAy \\\\A&amp;→ab│a\\end{aligned}$$ 输入串为 $xay$。 回溯分析的动画过程看 PPT。 采取试探的方法来分析每一个候选式，分析的过程很可能产生回溯。 可能产生回溯的原因有： (1)公共左因子 (2)左递归 (3)$ε$ 产生式 公共左因子公共左因子，是指在文法的产生式集合中，某个非终结符的多个候选式具有相同的前缀。 $$A→αβ_1│αβ_2$$ 若所有候选式都没有公共左因子，就可以选择惟一匹配的候选式，减少不必要的回溯 左递归 左递归：$A\\Rightarrow^+Aβ$ 直接左递归：$A\\Rightarrow Aβ$ 回溯分析法特点回溯分析法是一种不确定的方法：使用试探的方法穷举每一种可能，当分析不成功时，则回退到适当位置再重新试探其余可能的推导。穷尽所有可能的推导，仍不成功，才能确认输入串不是该文法的句子。 主要缺陷 选择候选式进行推导是盲目的 若文法存在左递归，语法分析还可能产生无限递归 引起时间和空间的大量消耗 无法指出语法错误的确切位置 针对产生回溯的原因，提出消除回溯的方法：引进确定的语法分析方法——递归下降分析法和预测分析法。 为了消除回溯，对任何一个非终结符和当前的待匹配符号，期望 要么只有一个候选式可用 要么没有候选式可用 递归下降分析法方法步骤 提取公共左因子（看 PPT） 消除左递归 消除直接左递归（改写为右递归） 间接左递归（$A\\Rightarrow^+Aα$）的消除利用算法进行a. 将文法 $G$ 的所有非终结符按任一给定的顺序排列为 $A_1，A_2，…，A_n$b. 消除可能的左递归（算法见后）c. 化简：删除多余产生式 123456// 消除左递归for i:=1 to n do for j:=1 to i-1 do 把形如Ai→Ajα的产生式改写为 Ai→δ1α|δ2α|...|δkα 消除Ai产生式可能的直接左递归 消除例子中的左递归： $$\\begin{aligned}S&amp;→Qc│c \\\\Q&amp;→Rb│b \\\\R&amp;→Sa│a \\\\\\end{aligned}$$ 题解 题解 2 递归下降分析器的构造在文法 G 中，如果 没有任何公共左因子 没有任何左递归则有可能构造出不带回溯的分析程序 预测分析法构造 First 集 A -&gt; aB，A 就有 {a} A -&gt; B，A 可以把 B 的复制过来 A -&gt; BC，若 B 可以为 ε，A 就还能复制 C 的 构造 Follow 集 S FIRSTVTE + ( * iT * ( iF ( i 第八章 自下而上语法分析概念 短语：某个祖先的所有没孩子的子孙组成的语句 直接短语：某个没有孙子的爸爸的孩子组成的语句 句柄：最左直接短语 素短语：短语至少有一个终结符，且不不含更小的素短语（若 i 是素短语，则 Fi* 不是素短语） 算符优先分析法构造 FIRSTVT 集 A -&gt; aBc 或 A -&gt; Bac，A 就有 {a} A -&gt; BC，A 可以把 B 的复制过来 A -&gt; BC，若 B 可以为 ε，A 就还能复制 C 的 构造 LASTVT 集 A -&gt; caB 或 A -&gt; cBa，A 就有 {a} A -&gt; BC，A 可以把 C 的复制过来 A -&gt; BC，若 C 可以为 ε，A 就还能复制 B 的 算符优先关系表 优先：先归约的符号被称为优先级高。 先看行，再看列。如 + 行 i 列为 &gt;，则 + &gt; i。 规则：若 E+T，则 LASTVT(E) &gt; +，+ &lt; FIRSTVT(T)。 还要添加 #S# 这个文法 这里的大于、小于没有对称性（a&gt;b 不能推出 b&lt;a） 推荐先填等号，再按行填小于，再按列填大于 LR 分析法第九章 语义分析符号表符号表： 1名字 | 信息 常用的符号表结构：线性表、Hash 表 语义分析概论语义分析的主要工作语义分析 = 静态语义检查 + 语义处理 静态语义检查：(1) 类型检查：数据的使用应与类型匹配(2) 控制流检查：用以保证控制语句有合法的转向点:如不允许goto语句转入case语句流; break语句需要在switch或循环语句.(3) 一致性检查：如数组维数是否正确; 变量是否已经定义；变量是否重名；case常量不能相同等。 语义处理：说明语句: 登记信息；执行语句：生成中间代码。 语法制导翻译为每个产生式配上一个语义子程序 在语法分析过程中，根据每个产生式对应的语义子程序（语义动作）进行翻译（生成中间代码）的方法称为语法制导翻译。 语法分析采用自底向上的LR分析法(1) 语法分析采用自底向上的LR分析法(2) 语法分析采用自底向上的LR分析法(3) 语义值在描述语义动作时，需要赋予每个文法符号以各种不同的“值”，这些值统称为“语义值”.如，“类型”，“种属”，“地址”或“代码”等。通常用X.TYPE,X.CAT,X.VAL来表示这些值。 picture 7 中间代码中间代码一种与具体机器无关的抽象代码，有多种形式。四元式形式: (op,ARG1,ARG2,RESULT) op—运算符ARG1—第一运算量ARG2—第二运算量RESULT—结果 如: A:=（-B）*(C+D) 翻译成 1234(@,B,_,t1)(+,C,D,t2)(*,t1,t2,t3)(:=,t3,_,A) 四元式出现顺序和表达式计值顺序一致;四元式之间的联系通过临时变量来实现。 简单赋值语法分析的翻译语义变量及过程 X.a：文法符X相应属性a,如i.name,E.place。E.place:表示E所代表的变量在符号表的入口地址。 newtemp：语义函数，每调用一次产生一个新的临时变量。 entry(i)：语义函数，查符号表，返回变量i的入口。 IP：指令指针，初始化为0，也可以是指定的初值。 gen(OP,ARG1,ARG2,RESULT)：语义过程，生成一个四元式(OP,ARG1,ARG2,RESULT),并填入四元式表中。同时 ip:=ip+1 翻译方案12A → i:=EE → E1 op E2 | -E1 |(E1)| i 123456789101112131415161718192021222324252627A→i:=E&#123; P=entry(i.NAME); If(P!=0) gen ( :=, E.place, _, P) Else error();&#125;E→E1 op E2&#123; E.place:=newtemp; gen(op,E1.place,E2.place,E.place)&#125;E →-E1 &#123; E.place:=newtemp; gen(@,E1.place,_,E.place)&#125;E →(E1)&#123; E.place:= E1.place &#125;E →i &#123; P=entry(i.NAME); If(P!=0) E.place:=P Else error(); a:=-b*(c+d)的移进-归约过程 类型转换对表达式E增加类型属性E.type;引进类型转换指令 (itr,x,_,t) 12345678910111213141516171819202122232425262728t:=newtemp;if E1.type=integer and E2.type=integer then begin gen(opi,E1.place,E2,place,t); E.type:=integer endelse if E1.type=real and E2.type=real then begin gen(opr,E1.place,E2.place,t); E.type:=real endelse if E1.type=integer then begin t1:=newtemp; gen(itr,E1.place,_,t1); gen(opr,t1,E2.place,t); E.type:=real endelse begin t1:=newtemp; gen(itr,E2.place,_,t1); gen(opr,E1.place,t1,t); E.type:=realend;E.place:=t; 说明语句的翻译不产生可执行指令仅负责填表：将被说明对象的类型及相对存储位置记入各自的符号表中 文法12D→D;D│i:TT→real│integer│array[num] of T1│↑T1 语义变量和过程负责填下面两个东西！ (1)offset:相对位移量,初值为0,是一个全局变量(2)T.type:数据类型(3)T.width:数据宽度(4)enter:语义过程,将变量名及其类型和相对存储位置记入符号表中。 翻译方案12345S →MDM →ε &#123; offset:=0 &#125;D → D1;D2D →i:T &#123; enter(i.name,T.type,offset); offset := offset+T.width &#125;T→integer &#123; T.type:=integer; T.width:=4 &#125; 控制语句的翻译布尔表达式的翻译文法123456B→iB→i1 rop i2（1）if B then S（2）if B then S else S（3）while B do S 语义变量 B.T：真出口，记录B为真的转移语句的地址； B.F：假出口，记录B为假的转移语句的地址。 转移语句的四元式123(jrop,P1,P2,0) (jnz,P1,-,0)(j,-,-,0) 0 是转移地址，从上往下分析的时候可能不知道要转义到哪里，所以会挖坑，后面会填坑。 翻译方案123456789101112131415B→i&#123; B.T:=ip; gen(jnz,entry(i),-,0); B.F:=ip; gen(j,-,-,0)&#125;B→i1 rop i2&#123; B.T:=ip; gen(jrop,entry(i1),entry(i2),0); B.F:=ip; gen(j,-,-,0)&#125; 无条件转移语句翻译goto L，L 已经定义1234…L: ... /*此时，将L登记入符号表*/…goto L; /*查表，发现L已定义，生成四元式*/ goto L，L 未定义12345678…goto L; /*将L记入符号表，定义否标记为“否”， 地址栏写当前IP，生产无条件转移 */…goto L; /*拉链，即生成向上指的链表*/…L: … /*定义否标记改为“是”，回填，即根据链表依次改写跳转的地址栏*/… 拉链 标号语句的处理方法文法： 1label →i: i（假定为L）不在符号表中：则把它填入，置“类型”栏为“标号”，“定义否”栏为“已”，“地址”栏为ip的当前值； 若L已在符号表中，“类型” 为“标号”, “定义否”栏为“否” :把“定义否”改为“已”，然后把“地址栏”中的链首q取出，同时把ip当前值填入其中，最后执行 backpatch（q，ip）语义过程进行回填 若L已在符号表中，但“类型”不为“标号”,或“定义否” 为“已”：则“名字重定义” backpatch（q，ip）为语义过程：把q为链首的链上所有四元式的第四区段都填为ip If 条件语句的翻译文法1S→if B then S1 │ if B then S1 else S2 if B then S1：S1的第一条四元式用以“回填”if B then S1 else S2：S1、S2的第一条四元式用以“回填” (1)B具有真假出口B为真假时的转向不同在翻译B时其真假出口有待“回填”(2)因if语句的嵌套,必须记录不确定转移目标的四元式的地址—拉链技术 语义变量及过程 N.CHAIN：记录不确定转移目标的四元式形成的，不确定 label 地址时就调用这个；一般来说，N.CHAIN 的含义是 N 结束以后要跳的位置 merge(t1,t2): 语义函数，合并链表，返回合并后的链头t2，用于合并链表/拉链 backpatch(t1,code): 语义过程，用code回填t1，确定 label 地址时就调用这个 如: 123456(p) (j, -, -, 0) (u) (j, -, -, 0) …… ……(q) (j, -, -, p) (v) (j, -, -, u) …… ……(r) (j, -, -, q) (w) (j, -, -, v)t1=r t2=w 执行merge(t1,t2)后 1234567(p) (j, -, -, 0) (u) (j, -, -, r) …… ……(q) (j, -, -, p) (v) (j, -, -, u) …… ……(r) (j, -, -, q) (w) (j, -, -, v)链头t2=w 执行backpatch(t2,120)后 12345(p) (j, -, -, 120) (u) (j, -, -, 120) …… ……(q) (j, -, -, 120) (v) (j, -, -, 120) …… ……(r) (j, -, -, 120) (w) (j, -, -, 120) 翻译方案if-then 不负责生成四元式，只负责填 0！！！ 12345678910111213141516171819202122S→if B then S1S→M S1M→if B thenM→if B then&#123; backpatch(B.T, ip); // B.T 即为下一句的地址，所以可以直接填当前 ip M.CHAIN:=B.F // B.F 在后面，所以创建链表&#125;/* * 另外,在图9-3中，整个语句翻译完成后,B.F仍不能确定,只能 * 将它作为S的语义值S. CHAIN暂时保留下来。如果S,本身也是控 * 制语句(比如另一个嵌套的条件语句),它也有语义值S. CHAIN未 * 确定,则B.F和S.CHAIN应转到同一个地方,因此要将它们链 * 接起来,组成一个新的链,链首地址记录在S的语义值S. CHAIN * 中,这项工作由语义函数merge()完成。 */S→M S1&#123; S.CHAIN:=merge(M.CHAIN, S1.CHAIN) // B.F&#125; 例 这里还有一个 bug：S 执行完以后还没有回填 S.CHAIN。这一步其实是交给 S 后面的分号来做的，而这是执行语句的文法，已经脱离了本节讨论的控制语句文法。因此上面的例子（以及后面的例子）并没有提及。 分号时的回填 if-then-else 只需要生成一个四元式：then 后的语句执行完以后要 jump 到 else 后 1234567891011121314151617181920212223S→if B then S1 else S2 M→if B thenN→M S1 elseS→N S2M→if B then&#123; backpatch(B.T, ip); M.CHAIN:=B.F&#125;N→M S1 else&#123; q:=ip; gen(j,-,-,0); backpatch(M.CHAIN,ip); N.CHAIN:=merge(S1.CHAIN , q)&#125;S→N S2&#123; S.CHAIN:=merge(N.CHAIN, S2.CHAIN)&#125; 例子 While 语句的翻译文法1S→while B do S1 翻译方案while 语句其实就是 if-then 语句多了一个 jump 12345678910111213141516171819202122W→whileD→W B doS→D S1W→while&#123; W.code := ip;&#125;D→W B do&#123; backpatch(B.T, ip); D.CHAIN = B.F; D.code = W.code; // 子变量值传给父变量&#125;S→D S1&#123; backpatch(S1.CHAIN,D.code); gen(j,-,-,D.code); S.CHAIN:=D.CHAIN;&#125; 例子 可以看出,许多语句的最后都有一个S.CHAIN链,然而对赋值语句来说,没有需要返填的三地址语句,为了统一，我们给赋值语句赋一个空链。语义程序如下: 12S-&gt;A&#123;S.CHAIN=0;&#125; For 循环语句的翻译文法1S→for i:=1 to N do S1 其语义为： 123456 i:=1;again: if i&lt;=N then begin S1; i:=i+1; goto again end 代码结构可为： 1234567F+0:（:=，'1'，-，i）F+1: (j&lt;=,i,N,F+3)F+2: (j,-,-,0)F+3: (S1的四元式序列)...D+0: (+,i, ‘1’,i)D+1: (j,-,-,F+1) 语义变量为了在生成S1的代码之前生成i:=1等三个语句,必须改写文法。 12F→for i:=1 to N doS→F S1 F.again:记录F+1 F.CHAIN:记录前述F+2的地址 F.place:记录i在符号表入口 翻译方案1234567891011121314151617F→for i:=1 to N do&#123; gen(:=,'1',-,entry(i)); F.again:=ip; gen(j&lt;=,entry(i),N,F.again+2); F.CHAIN:=ip; gen(j,-,-,0); F.place:=entry(i)&#125;S→F S1&#123; backpatch(S1.CHAIN,ip); gen(+,F.place,'1',F.place); gen(j,-,-,F.again); S.CHAIN:=F.CHAIN&#125; 例题 另一道例题：写出下面代码的中间代码序列。 1for i=1 to 10 do if A&gt;100 then C=C+1; 12345678910100: (=, 1, -, i)101: (J&lt;=, i, 10, 103) F.again=103102: (J, -, -, 109)103: (J&gt;, A, 100, 105)104: (J, -, -, 107)105: (+, C, 1, t1)106: (=, t1, -, C)107: (+, i, 1, i)108: (J, -, -, 103)109: 更多例题： 1if (A&lt;X) &amp; (B&gt;0) then while C&gt;0 do C:=C+D; 1234567891011100 (j&lt;， A， X， 102)101 (j， -， -， 109)102 (j&gt;， B， 0， 104)103 (j， -， -， 109)104 (j&gt;， C， 0， 106)105 (j， -， -， 109)106 (+， C， D， T1)107 (:=， T1， -， C)108 (j， -， -， 104)109 123456789z := 3;while j&lt; 10 do begin j := x+1; if x &lt;10 then y:= A+m; else y:= A-m;end 12345678910111213100 (=, 3, _, z)101 (J&lt;, j, 10, 103)102 (J, -, -, 113)103 (+, x, 1, t1)104 (=, t1, -, j)105 (J&lt;, x, 10, 107)106 (J, -, -, 110)107 (+, A, m, t2)108 (=, t2, -, y)109 (J, -, -, 112)110 (-, A, m, t3)111 (=, t3, -, y)112 (J, -, -, 101) 过程的的翻译（自学）第十章 代码优化和目标代码生成优化是一种等价的，有效的程序变换等价——不改变程序运行结果有效——时空效率要高 优化按阶段分类： 源程序阶段的优化：优化数据结构和算法 编译优化：中间代码和目标代码优化 中间代码优化：便于移植（与机器无关）。又分为： 局部优化：在基本块内的优化 全局优化：超越基本块，基本块之间的优化 局部优化划分基本块(1)寻找入口语句 程序的第一条语句 由转向语句转移到的语句 紧跟在条件转向语句后的那个语句(2)寻找出口语句 转向语句 停止语句(3)基本块为： 每个入口地址（含）到下一个入口地址（不含） 每个入口地址（含）到下一个出口地址（含）(4)不在任何基本块中的代码可以被删除 例题 构造流图下面是正确的废话： $$G = (N, E, n_0)$$(1)基本块集即为结点集N;(2)包含程序第一个语句的基本块，为首结点n0;(3)设基本块 Bi , Bj ∈ N ，若满足下列条件之一，则Bi -&gt;Bj Bj 紧跟在 Bi 之后，且 Bi 的出口语句不是无条件转向或停止语句 Bi 的出口语句为转向语句，其转向点恰为Bj 的入口语句 刚才那道例题 基本块内的优化合并已知量1234567// 优化前B := 1C := 2A := B + C// 优化后A := 3 删除公共子表达式12345678// 优化前B := 1C := 2A := B + CD := B + C// 优化后D := A 删除无用赋值123456// 优化前A := 1A := 2// 优化后A :=2 删除死代码若某个基本块实际不可能被执行，该基本块为死代码，可以删除。 例题 例题 全局优化（自学）本节只讨论对循环进行的优化。 循环的定义循环：程序流图中，有唯一入口结点的强连通子图。 强连通子图：子图里面任意两个结点可以互通。 程序流图 {5, 6, 7, 8, 9} 是循环：所有点都互通，且 5 是唯一入口。 循环的查找 必经结点：从流图的首结点出发，到达结点n的任一通路都必须经过的结点d，称为n的必经结点。记为 d DOM n 每个结点是它本身的必经结点，即n DOM n 首结点是任一结点的必经结点，即n0 DOM n 上图的必经节点集： 12345678910D(1)=&#123;1&#125;D(2)=&#123;1,2&#125;D(3)=&#123;1,2,3&#125;D(4)=&#123;1,2,4&#125;D(5)=&#123;1,2,4,5&#125;D(6)=&#123;1,2,4,5,6&#125;D(7)=&#123;1,2,4,5,6,7&#125;D(8)=&#123;1,2,4,5,6,8&#125;D(9)=&#123;1,2,4,5,6,9&#125;D(10)=&#123;1,2,4,10&#125; 回边：若 d 是 n 必经节点，且存在边 n-&gt;d，则该边为回边。 上图有三条回边： 1235-&gt;49-&gt;510-&gt;2 若 n-&gt;d 是回边，则图里能到n且不经过d的点的集合+n+d 就是由 n-&gt;d 组成的循环 程序流图 上图的循环有： 1235-&gt;4 组成 &#123;5, 4, 6, 7, 8, 9&#125;9-&gt;5 组成 &#123;9, 5, 6, 7, 8&#125;10-&gt;2 组成 &#123;10, 2, 3, 4, 5, 6, 7, 8, 9&#125; 循环优化方法代码外提12345678910111213// 优化前for (int i = 0; i &lt; n; i++)&#123; float pi = acos(-1); // ...&#125;// 优化后float pi = acos(-1);for (int i = 0; i &lt; n; i++)&#123; // ...&#125; 强度削弱123456789101112// 优化前for (int i = 1; i &lt; 10; i++)&#123; int j = i * 10 + 5;&#125;// 把乘法优化成加法后int j = 5;for (int i = 1; i &lt; 10; i++)&#123; j += 10;&#125; 例子中，i=循环次数+c 叫做基本归纳变量；j=循环次数*c1+c2 叫做同族归纳变量。强度削弱把基本归纳变量变为同族归纳变量，将乘法变为加法，还可以将普通加法变为变址器加法。 删除归纳变量即改用同族归纳变量作为判断条件 12345678910111213// 优化前int j = 5;for (int i = 1; i &lt; 10; i++)&#123; j += 10;&#125;// 优化后int j = 5;for (; j &lt; 5 + 10*10;)&#123; j += 10;&#125; 例题优化前： 123456789101112(1)PROD := 0(2)I := 1(3)T1 := 4 * I(4)T2 := a0 – 4(5)T3 := T2[T1](6)T4 := 4 * I(7)T5 := b0 – 4(8)T6 := T5[T4](9)T7 := T3 * T6(10)PROD := PROD + T7(11)I := I + 1(12)if I ≤ 20 goto (3) 优化后： 12345678910(1)PROD := 0(2)T1 = 0;(3)T2 := a0 – 4(4)T5 := b0 – 4(5)T1 := T1 + 4;(6)T3 := T2[T1](7)T6 := T5[T1](8)T7 := T3 * T6(9)PROD := PROD + T7(10)if T1 ≤ 80 goto (5) 目标代码生成目标代码生成的主要问题： 选择合适的指令 生成最短的代码 充分利用有限的寄存器 如何充分利用寄存器（自学） 第十一章 运行时存储空间的组织变量及存储分配","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.lyh543.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"并行计算 课程笔记","date":"2021-03-02T02:41:36.000Z","path":"computer-science/parallel-and-distributed-computing/","text":"1 Introduction什么是并行计算 并行计算 (parallel computing)：在同一个计算机体系的多个处理器/电脑一起工作解决一个问题 分布式计算 (distributed computing)：分布在多个计算机体系（异地）的处理器/电脑一起工作解决一个问题 并行计算机 (parallel computer)：一个多核的计算机系统 并行计算机分为多计算机系统和中心化多处理器 多计算机系统 (multicomputer)：多个计算机通过内部网络连接 中心化多处理器 (centralized/symmetrical multiprocessor, SMP)：一个计算机系统，其中所有 CPU 共享一个全局内存 并行计算多用于科学计算，分布式计算多用于可靠性、可用性、性价比高的计算。 为什么需要并行计算 微处理器性能增长越来越慢 同样的性能下，并行系统功耗更低 并行计算关心的问题不懂的地方都给出英文原文…… 架构上的问题： Pipline, ILP… 缓存一致性 单共享总线 or 网络 UMA, NUMA, CC-NUMA, Cluster… 编程模型上的问题： 单寻址空间 or 多寻址空间 进程使用锁、消息传递 or 其他方法进行同步 分布式 or 中心化内存 故障可靠性 性能表现上的问题： 指标：规模、加速比、可扩展性 Models: PRAM，BSP，PPRAM… 并行计算的评价方法 其他问题： 编程语言 编程工具 可移植性 Automatic programming of parallel computers Education of parallel computing philosophy 如何编写并行程序 需要明确告诉不同处理器如何分工 需要把串行程序改写为并行 有时候直接改写的效率非常低，需要设计全新的算法 举个栗子例子：求 n 个函数值的和，其串行算法如下： 123456sum = 0;for (i = 0; i &lt; n; i++)&#123; x = compute_next_value(...); sum += x;&#125; 假设我们有 p 个核 (p &lt; n)，每个核计算一部分： 12345678my_sum = 0;my_first_i = ...;my_last_i = ...;for (my_i = my_first_i; my_i &lt; my_last_i; my_i++)&#123; my_x = compute_next_value(...); my_sum += my_x;&#125; 计算后的结果存在私有变量 my_sum 中。 所有核计算完成后，他们将结果发送至班长（一般就设 0 号核为班长），班长负责计算最终的总和。 123456789if (I am the master core) &#123; sum = my_x; for each core other than myself &#123; receive value from core; sum += value; &#125;&#125; else &#123; send my_x to the master;&#125; 更好的并行策略是，不要让班长核做所有的合并工作，而是均摊高每个核上。 对于这个问题，可以两两组合： Work with odd and even numbered pairs of cores. Pair the cores so that core 0 adds its result with core 1’s result，Core 2 adds its result with core 3’s result, etc.Repeat the process now with only the evenly ranked cores. Core 0 adds result from core 2. Core 4 adds the result from core 6, etc.Now cores divisible by 4 repeat the process, and so forth, until core 0 has the final result. 两两组合的求和算法 这种算法中，班长只进行了 3 次通信 + 3 次求和，相较刚开始的 7 次通信 + 3 次求和。如果核数更多，这样优化的效果会更加显著。 但是，越复杂的问题，并行的难度会更大（比如翻译程序）。所以我们需要编写并行程序来提高多核的利用率。 并行程序的编写方向 任务并行：将整个任务分成很多不同的小任务 数据并行：将数据进行分块，每个核在自己分到的数据上做相似的任务 例子：3 个老师（A、B、C）批改 300 张试卷，每张试卷 15 题。 任务并行（将试卷按题目进行划分）：A 老师批改 1-5 题，B 老师批改 6-10 题，C 老师批改 11-15 题 数据并行（将试卷按张数进行划分）：每位老师各批改 100 张试卷 习题在求和的栗子中，设计一个分配任务的函数（该函数负责计算每个核的 my_first_i 和 my_last_i），使得 $n$ 个任务尽量均匀地分布在 $p$ 个核上。 （这个题目后面应该会讲） 一个优秀的算法是： $$my\\_first\\_i = \\lfloor\\frac{i*n}{p}\\rfloor\\\\my\\_last\\_i = \\lfloor\\frac{(i+1)*n}{p}\\rfloor - 1$$ 其中 $i$ 为当前核的下标，从 0 开始。 my_last_i 比较好理解，因为任务分配是连续的，my_last_i 就是 下一个核的 my_first_i 减 1。 至于 my_first_i 的由来我也没想清楚，但是它可以保证所有任务的数量差不超过 1，很均匀。 各位不妨写一个程序模拟一下分配情况，看看每个在不同的 n、p 下，每个核被分了多少个任务、规律是怎么样的。如，在 n=30，p=9 时，该算法会这样分配： 13 3 4 3 3 4 3 3 4 2 Parallel Programming Platform对冯诺依曼体系的改进 冯诺依曼体系 冯诺依曼的核心是：存储程序，顺序执行。 该体系的瓶颈一般是 CPU 和内存分离。 改进分为三个方向： 缓存 虚拟存储 底层的并行（指令集并行、线程级并行） 缓存缓存：比主存更快的存储。一版用户存放物理上接近、且经常使用的数据和指令。 局部性原理略。 缓存分为 3 级。 3 级缓存 Cache 命中（Cache hit）和不命中（Cache miss） 缓存的写策略当 CPU 更新缓存的数据时，缓存数据可能会和主存不同。此时有两种策略： Write-through（写直达）：更新缓存的同时更新主存；缓存和主存始终一致，但每次写缓存的速度会变慢。 Write-back（写回）：更新缓存时标记缓存为脏数据（dirty），当该行缓存被替换时，脏数据会被写回至主存；写缓存的速度不受影响，但缓存替换时的速度会变慢。 缓存的映射方法 全映射：每行内存可以映射在缓存的任意位置 直接映射：每行内存只能映射在缓存的固定位置（一般是内存行数下标 % 缓存总行数） n 路组相联映射：将缓存每 n 行分为一组，每行内存可以映射在缓存的固定的组的 n 行中任意一行（一般组号 = 内存行数下标 % 缓存总行数 % n） 使用全映射或 n 路组相联映射，还需要考虑替换策略，常见的可以使用 LRU。 缓存优化的技巧缓存对于应用程序和程序员是透明的（不能直接控制缓存），但如果知道局部性原理，可以通过改变程序顺序、间接控制缓存，进而优化速度。 合并数组（data merge）：通过将两个独立数组合并为一个复合元素的数组来改进空间局部性 循环交换（loop interchange）：通过改变循环嵌套来按序访问存储器中存储的数据 循环合并（loop fusion）：将两个具有相同循环类型且有一些变量重叠的独立循环合并 块化（blocking）：通过不断使用一些数据块（而不是完整地遍历一行和一列）来改进时间局部性 循环优化前后的代码 假设缓存大小为 4。第一种循环会发生 4 次缓存未命中、第二种循环会发生 16 次缓存未命中。（注：缓存的机制是，每次缓存不命中会将所在行的 4 个元素全部装进缓存） 虚拟内存虚拟内存的大小大于主存，会将不活跃的程序换到磁盘，活跃的程序放到主存，加快速度。 指令级并行 流水线技术，参考计算机系统结构 某些情况下，多条指令也可以被同时发射 分支预测 线程级并行略。 并行计算的硬件 SISD（传统冯诺依曼模型） SIMD：对多个数据进行相同操作，1 个控制单元 + 多个 ALU MISD（尚未开发） MIMD：使用多个指令流同时操作多个数据流，多个独立操作单元 + 各自的 ALU MIMD 物理组织从上到下越来越离散： 共享缓存架构（Shared Cache Architecture），多为单芯片多处理器 共享缓存架构 统一内存寻址（Uniform Memory Access，UMA） 统一内存寻址（UMA） 独立内存寻址（Non-Uniform Memory Access，NUMA） NUMA 并不是处理器完全不能访问其他块的内存，而是处理器可以直接访问一部分内存+通过处理器内置的特殊硬件访问其他内存。 独立内存寻址（NUMA） 分布式系统/内存、集群（Distributed System/Memory） 分布式系统/内存 共享内存系统略。 互连网络网络的类型、网络的性能指标的一堆概念略。 多维 Mesh 网络Mesh：将一维线性的网络拓展到二维、三维或更高维度，结点之间只能和邻居进行交流。 超立方体结构超立方体结构：$d$ 维的超立方体有 $p=2^d$ 个结点。 对超立方体进行编号，可以按照如图的规律： 三维及以下的超立方体 每个 $d$ 维的超立方体可以分成两个相同的 $d-1$ 维超立方体，编号分别以 0 和 1 开头，且两个子超立方体对应结点的编号除第一位外相同。 按此法可以构造出四维超立方体。 四维超立方体 该编号方案还有一个性质：两个结点的距离等于这两个结点的汉明距离（不同的位的数量）。如在图中，0110 和 0101 的距离为 2。该性质在使用超立方体构造并行算法时会很有用。 缓存一致性缓存的写策略有 Write-back 和 Write-through。在 UMA 架构下，多个处理器有各自的缓存，共用内存。 UMA 架构下的缓存一致性协议 于是，出现了两个新的概念： Write Invalidate：处理器写自己的缓存时，使其他缓存失效；Write-through 下还需要更新内存，Write-back 下需要使内存失效。 Write Update：处理器写自己的缓存时，立即更新其他缓存；Write-through 下还需要更新内存，Write-back 下需要标记缓存为脏，在缓存失效的时候写回内存。 两种策略在什么情况下性能更好？（猜测是在不同核频繁更新不同数据时，写失效更好；多个核都在频繁写同一个数据时，写更新更好。） 现代计算机都默认使用写失效策略。（猜测是因为局部性原理，多核读不同数据的情况更多） 写失效协议三种状态：Shared、Invalid、Modified（MSI） Shared：存在多份有效的数据（写会导致其他失效） Modified：只有当前数据有效（写不会导致其他失效） Invalidate：数据无效（读会请求数据） 三状态转换图 硬件条件：所有核共享一个总线，可以用于广播。当 0 号处理器更新了 x，会广波这个消息，其他核听到（snoop）以后就会把自己的 x 标记为 Invalid。 当一个数据是 Modified 后，所有操作都直接在本地进行，无需向外部广播。 多个核读入一个数据时，所有缓存的内容都会变为 Shared，随后所有的读操作都直接在本地进行，无需向外部广播。 多个核同时读和写时，会出现（在带宽上的）瓶颈 基于目录的缓存一致性协议 基于目录：共享的状态都存储在（位于内存的）“目录” 目录里用一位表示 shared/dirty 状态（State） 目录里用一个 bitmap 表示数据被缓存在哪些处理器（Presence Bits） 目录 处理器 0 和处理器 1 读 x，此时状态为 shared，0 和 1 的 presence bits 均为 1 处理器 0 写变量，状态变为 dirty，1 的 presence bits 为 0 处理器 2 读变量，将会请求处理器 0 写回，随后 0 和 2 的 presence bits 均为 1 该方案的开销主要是通信开销、以及可能出现频繁的争端。 如果一个并行程序需要大量的一致性操作（大量的读/写共享数据块），目录最终会限制它的并行性能。 还可以分布式的目录系统，但是这里就学了。 False Sharing不懂 并行计算的软件并行软件也有区别： 内存共享系统上，一个进程 fork 出多个线程 分布式系统上，需要多个进程 SPMD: single program multiple data，MPI 和 CUDA 都是用的都是这种。 解决并行软件的不一致性：给数据加锁 SPMD 的写法： 12345678910char message [ 1 0 0 ] ;. . .my_rank = Get_rank ( ) ;if ( my_rank == 1) &#123; sprintf ( message , \"Greetings from process 1\" ) ; Send ( message , MSG_CHAR , 100 , 0 ) ;&#125; else if ( my_rank == 0) &#123; Receive ( message , MSG_CHAR , 100 , 1 ) ; printf ( \"Process 0 &gt; Received: %s\\n\" , message ) ;&#125; 输入输出Google 翻译 yyds 当我们的并行程序需要进行 I/O 时，做出这些假设并遵循这些规则：在分布式内存程序中，仅进程0将访问stdin。 在共享内存程序中，只有主线程或线程 0 会访问 stdin。在分布式内存和共享内存程序中，所有进程/线程都可以访问 stdout 和 stderr。然而，由于输出到 stdout 的顺序不确定，在大多数情况下，除了调试输出之外，只有一个进程/线程将用于所有输出到 stdout。调试输出应始终包括生成输出的进程/线程的等级或 ID。只有单个进程/线程会尝试访问除 stdin、stdout 或 stderr 之外的任何单个文件。 因此，例如，每个进程/线程都可以打开自己的私有文件进行读取或写入，但没有两个进程/线程会打开同一个文件。 3 Parallel Program DesignFoster 四步走注意这四步，是设计算法的过程的四步，而不是并行算法的先后步骤。 Partitioning：分块 Communication：通信 Agglomeration：组合 Mapping：映射 Foster’s Design Methodology 分块Domain vs. Functional Decomposition 其实就是数据并行 vs. 任务并行 通信通信方法可以分为局部通信和邻居通信 Local communication Global communication 例子：对求和问题进行分治，只需要 logN 步 分治求和问题 通信方法也可以分为结构化通信（通信网络有一定结构）和非结构化通信（通信网络可能是任意图）。 如果通信网络还在变化，负载均衡算法就必须频繁地更新。 Unstructured communication 聚合聚合可以减少通信成本：任务的通信需求与其操作的子域的表面成正比，而计算需求与子域的体积成正比。有时我们可以权衡复制计算以减少通信需求和/或执行时间。 映射映射：将任务映射到处理器上。 目标：最大化处理器利用（即负载均衡） &amp; 最小化处理器间通信（即需要通信的进程可以映射到同一处理器） 奇奇怪怪的图的一种映射方法 不同情况下映射策略：略。 Agglomeration 例题 公式： $\\chi$：更新一个元素的时间 $\\lambda$：一个元素通信的时间 $n$：结点数 $m$：需要的迭代次数 $p$：处理器数 有一下结论： 串行执行时间：$m(n-1)\\chi$ 并行执行时间：$m\\lceil(n-1)/p\\rceil+2\\lambda$ 有点不懂。是在这个问题下的时间公式吗？ 4 Performance性能指标：运行时间、加速比、效率、可扩展性等 加速比和效率指标$$S_p = \\frac{T_s}{T_p}$$ $T_s$：串行时间 $T_p$：$p$ 个进程时的并行时间（按最长时间的进程计算） $S_p$ or $\\psi(n, p)$：$p$ 个进程时的加速比 (Speedup) 加速比是速度的正比，是时间的反比 $$\\psi(n, p) \\leq \\frac{\\sigma(n)+\\varphi(n)}{\\sigma(n)+\\varphi(n) / p+\\kappa(n, p)}$$ 好的加速比：（相较进程数）线性加速、亚线性加速、超线性加速 好的加速比 超线性加速出现在：多级内存、缓存影响、DFS 遍历树算法等。 $$\\psi(n, p) \\leq \\frac{\\sigma(n)+\\varphi(n)}{\\sigma(n)+\\varphi(n) / p+\\kappa(n, p)}$$ $\\sigma(n)$：不能被并行执行的的串行时间 $\\varphi(n)$：可以被并行执行的串行时间 $\\kappa(n, p)$：并行执行带来的通信时间 比较显然，公式的意思是：并行算法的时间为：串行时间+并行部分/p+通行时间 这个公式一定要记住，后面的推导都是基于这个公式！ $$E_p=\\frac{S_p}{p}$$ $E_p$ or $\\varepsilon(n, p)$：效率 线性加速比程序的效率为 100%。 将 $S_p$ 代入即有： $$\\varepsilon(n, p) \\leq \\frac{\\sigma(n)+\\varphi(n)}{p\\sigma(n)+\\varphi(n)+p\\kappa(n, p)}$$ 可以推出 $0 \\leq \\varepsilon(n, p) \\leq 1$。 Amdahl 定律Amdahl 定律和 Gustafson-Barsis 定律都把通信成本放缩掉了。两个求的都是加速比，但是注意条件不一样（一个是 $f$ 一个是 $s$） $$\\psi(n, p) \\leq \\frac{\\sigma(n)+\\varphi(n)}{\\sigma(n)+\\varphi(n) / p+\\kappa(n, p)}$$ 令 $f$ 为串行部分占比（占改进之前的比），即 $f=\\frac{\\sigma(n)}{\\sigma(n)+\\varphi(n)}$，有： $$\\psi \\leq \\frac{1}{f+(1-f)/p}$$ 加速比不大于“串行占比+p倍并行占比”的反比 例题：95% of a program’s execution time occurs inside a loop that can be executed in parallel. What is the maximum speedup we should expect from a parallel version of the program executing on 8 CPUs? 注意题目说的是串行在改进前需要执行 5% 的时间，这就符合 Amdahl 的条件。答案是 5.9。 Gustafson-Barsis 定律令 $s$ 为串行部分占比（占改进之后的比），即 $s = \\frac{\\sigma(n)}{\\sigma(n)+\\varphi(n)/p}$，有： $$\\psi \\leq p + (1-p)s$$ 可以看到，如果 $s$ 小，$\\psi \\approx p$，并行效率很好。 例题：An application running on 10 processors spends 3% of its time in serial code. What is the scaled speedup of the application? 注意题目说的是串行代码在改进后需要执行 3% 的时间，这就符合 Gustafson-Barsis 的条件。答案是 9.73。 Karp-Flatt Metric 指标Amdahl 和 Gustafson-Barsis 都忽略了通信成本，会高估放大比。Karp-Flatt 从另一个角度来进行分析。 但是这个公式起手就很怪异。 令$e = \\frac{\\sigma(n) + \\kappa(n,p)}{\\sigma(n)+\\varphi(n)}$ 串行时间 + 通信时间 / 串行时间 + 可并行的时间？ 能够推出 $$e = \\frac{1/\\psi - 1/p}{1 - 1/p}$$ 这个公式很奇怪，结合例题我大概看懂了： 结论 1：注意到 $n$ 一定的情况下，串行时间、可并行的时间 是恒定的，所以 $e$ 和 通信时间 的增长趋势是一样的。即，在不同的 $p$ 下，如果 $e$ 恒定，说明通信时间恒定；$e$ 稳定增长，说明通信时间也稳定增长。 结论 2：随 $p$ 的增大，$e$ 不能先增大后减小（只能一直增大/不变或一直减小/不变：一直增大是次线性加速比，而一直减小就是超线性加速比） 例 1： $p$ 2 3 4 5 6 7 8 $\\psi$ 1.8 2.5 3.1 3.6 4.0 4.4 4.7 计算可得 $e$ 0.1 0.1 0.1 0.1 0.1 0.1 0.1 为什么 8 核的加速比只有 4.7？注意到 $e$ 不随 $p$ 变化，说明问题不是通信成本，是串行代码耗时太高。 例 2： $p$ 2 3 4 5 6 7 8 $\\psi$ 1.9 2.6 3.2 3.7 4.1 4.5 4.7 计算可得 $e$ 0.07 0.075 0.08 0.085 0.09 0.095 0.1 为什么 8 核的加速比只有 4.7？注意到 $e$ 不随 $p$ 变化，说明问题不是通信成本，是串行代码耗时太高。 例 3： $p$ 4 8 12 $\\psi$ 3.9 6.5 ？ ? 处能否为 10？ 假设 ?=10，算得 $e$ 先增大后减小，不可能。 等效率不会，看 PPT 可扩展性不会，看 PPT 5 Message-Passing ProgrammingMPI 常用函数 1234567891011//First MPI function called by each processMPI_Init (&amp;argc, &amp;argv);// First argument is communicator// Number of processes returned through second argumentMPI_Comm_size (MPI_COMM_WORLD, &amp;p);// Process rank (in range 0, 1, …, p-1) returned through second argumentMPI_Comm_rank (MPI_COMM_WORLD, &amp;id);// Call after all other MPI library callsMPI_Finalize(); 1234567891011// reduce 操作int MPI_Reduce ( void *operand, /* addr of 1st reduction element */ void *result, /* addr of 1st reduction result, only root get result */ int count, /* reductions to perform */ MPI_Datatype type, /* type of elements */ MPI_Op operator, /* reduction operator */ int root, /* process getting result(s) */ MPI_Comm comm /* communicator */)MPI_Reduce (&amp;count, &amp;global_count, MPI_INT, 0, MPI_COMM_WORLD); 12345678// Benchmarking the Programdouble elapsed_time;MPI_Init (&amp;argc, &amp;argv);MPI_Barrier (MPI_COMM_WORLD);elapsed_time = - MPI_Wtime();// ...MPI_Reduce (…);elapsed_time += MPI_Wtime(); 附 MPICH 中文教程https://scc.ustc.edu.cn/zlsc/cxyy/200910/MPICH/ 6 The Sieve of Eratosthenes因为这部分做了实验，所以不多说算法原理了。 1234567int MPI_Bcast ( void *buffer, /* Addr of 1st element */ int count, /* # elements to broadcast */ MPI_Datatype datatype, /* Type of elements */ int root, /* ID of root process */ MPI_Comm comm) /* Communicator */MPI_Bcast (&amp;k, 1, MPI_INT, 0, MPI_COMM_WORLD); 分块算法这个问题需要按数据分块。可以使用循环分配，可以按块分配。 使用循环分配， $$my\\_first\\_i = i * \\lfloor\\frac{n}{p}\\rfloor + \\min(i,r)\\\\my\\_last\\_i = (i+1)* \\lfloor\\frac{n}{p}\\rfloor + \\min(i+1,r) - 1 \\\\count= \\min(\\lfloor \\frac{j}{\\lfloor n / p \\rfloor+1}\\rfloor, \\lfloor \\frac{j-r}{\\lfloor n / p \\rfloor}\\rfloor)$$ 使用按块分配，就是第一章的习题中提到的： $$my\\_first\\_i = \\lfloor\\frac{i*n}{p}\\rfloor\\\\my\\_last\\_i = \\lfloor\\frac{(i+1)*n}{p}\\rfloor - 1 \\\\count=\\lfloor \\frac{p(j+1)-1}{n}\\rfloor$$ 两种算法都可以，后面一种表达式更简单，所以选择这一种。 算法性能分析 时间复杂度 7 Floyd’s AlgorithmFloyd 算法伪代码： 1234567for k = 0 to n-1 for i = 0 to n-1 for j = 0 to n-1 a[i,j] = min (a[i,j], a[i,k] + a[k,j]) endfor endforendfor 分块把矩阵 A 的每个元素视为一个任务，分解成 $n^2$ 个任务。 通信 通信 聚合和映射 按行或者按列聚合 按行或者按列聚合。最后选择按行聚合，在读文件的时候会容易的多。 点对点通信 点对点通信 123456789101112131415161718int MPI_Send ( void *message, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm)int MPI_Recv ( void *message, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status) Send 和 Recv 需要约定相同的 tag，以及对方的 id (作为自己的 source/dest)。 send/recv 原理 MPI_Send 函数会一直阻塞直至 message_buffer 空了。 MPI_Recv 函数会一直阻塞直至收到消息。 这就很容易造成死锁。 死锁123456789if (id == 0) &#123; MPI_Recv (&amp;b,...); MPI_Send (&amp;a,...); c = (a + b)/2.0; &#125; else if (id == 1) &#123; MPI_Recv (&amp;a,...); MPI_Send (&amp;b,...); c = (a + b)/2.0; &#125; Process 0 blocks waiting for message from 1, but 1 blocks waiting for a message from 0.Deadlock! 123456789if (id ==0) &#123; MPI_Send(&amp;a, ... 1,MPI_COMM_WORLD); MPI_Recv(&amp;b, ... 1, MPI_COMM_WORLD,&amp;status); c = (a+b)/2.0; &#125;else if (id ==1) &#123; MPI_Send(&amp;a, ... 0,MPI_COMM_WORLD); MPI_Recv(&amp;b, ... 0, MPI_COMM_WORLD,&amp;status); c = (a+b)/2.0;&#125; Both processes send before they try to receive, but they still deadlock. Why?The tags are wrong. Process 0 is trying to receive a tag of 1, but Process 1 is sending a tag of 0. Ssend依赖 buffer 的 MPI_send 是不安全的，因为 MPI 标准允许 MPI_Send 可以提供/不提供 buffer。 两种问题可能会出问题： 双方都是先发后收，并且发的数据都很大 生产者/消费者问题，且生产者生产的比消费者块 MPI 标准定义了 MPI_Ssend，保证发送会被阻塞（s 表 synchronous）。 SendRecv如果需要同时发送接收，可以通过代码逻辑使大家按照某种顺序，避免死锁，但也可以使用 MPI_SendRecv 同时发送和接收，中间的调度由 MPI 实现。 MPI_SendRecv 并行 Floyd 算法 核心部分 计算时间复杂度：$\\Theta(n^3/p)$ 通信时间复杂度：$n^2 \\log p$ 执行时间（其中 $\\beta$ 是显存带宽，其他变量见第三章）： $$n \\lceil n / p \\rceil n \\chi +n \\lceil \\log p \\rceil (\\lambda + 4n / \\beta)$$ CUDA 部分结构 Thread – Register Warp Block – 对应一个 Streming Multiprocessors，Shared Memory Grid – 对应一个 Kernel Device – Global Memory 代码思路用 Block 处理二维图像： 123456789101112131415__global__ void PictureKernel(float* d_Pin, float* d_Pout, int height, int width)&#123; int Row = blockIdx.y*blockDim.y + threadIdx.y; int Col = blockIdx.x*blockDim.x + threadIdx.x; if ((Row &lt; height) &amp;&amp; (Col &lt; width)) &#123; d_Pout[Row*width+Col] = 2.0*d_Pin[Row*width+Col]; &#125;&#125;int main()&#123; dim3 DimGrid((n-1)/16 + 1, (m-1)/16+1, 1); dim3 DimBlock(16, 16, 1); PictureKernel&lt;&lt;&lt;DimGrid,DimBlock&gt;&gt;&gt;(d_Pin, d_Pout, m, n);&#125; Block 大小For Matrix Multiplication using multiple blocks, should I use 8X8, 16X16 or 32X32 blocks for Fermi? For 8X8, we have 64 threads per Block. Since each SM can take up to 1536 threads, which translates to 24 Blocks. However, each SM can only take up to 8 Blocks, only 512 threads will go into each SM! For 16X16, we have 256 threads per Block. Since each SM can take up to 1536 threads, it can take up to 6 Blocks and achieve full capacity unless other resource considerations overrule. For 32X32, we would have 1024 threads per Block. Only one block can fit into an SM for Fermi. Using only 2/3 of the thread capacity of an SM. CGMACGMA = 从全局内存中取一个数，多少次运算用到了这个数 CGMA 越大越好 Shared Memory And Threading Shared Memory And Threading OpenACC 部分GPU 占用率 GPU Occupancy is: How much parallelism is running / How much parallelism the hardware could run 100% occupancy is not required for, nor does it guarantee best performance. Less than 50% occupancy is often a red flag","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"并行计算","slug":"并行计算","permalink":"https://blog.lyh543.cn/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"}]},{"title":"计算机系统结构 复习笔记","date":"2021-03-01T06:40:25.000Z","path":"computer-science/computer-architecture/","text":"第一章 量化设计与分析基础引言处理器惊人的性能改进 处理器惊人的性能改进 分析： 每年 25%（1978-1986）: 性能增长主要依赖实现技术的进步 每年 52%（1986-2003）: 性能增长依赖两方面： 系统结构革新（RISC，指令级并行 (ILP) 技术与Cache）； 实现技术的进步 每年 22%（2004-2010）: ILP 开发的限制，功耗限制，因此其后性能提升手段出现了以下趋势： ILP 变为 TLP and DLP（线程级并行和数据级并行） 更快的单核处理器 变为 单芯片多处理器（多核） 隐含在编译器和硬件的硬件级并行处理 变为 显示的程序级并行 计算机的分类基于指令流和数据流数量分类 (XIXD)基于市场分类计算机系统结构定义与计算机的设计任务计算机系统结构（原始定义）计算机系统结构的原始慨念： 由程序员看见的计算机系统，就是慨念性结构和功能行为，以区分数据流动和控制逻辑设计的组成及物理实现。 – Amdahl, Blaaw, and Brooks, 1964 指令系统 下面讨论计算机系统结构、计算机组成和物理实现及其关系关系。 经典的计算机系统结构是机器语言程序员所看到的传统机器级所具有的属性。它确定计算机系统的软、硬件界面。计算机组成指的是计算机系统结构的逻辑实现，包括五大功能部件组成以及逻辑设计等。它着眼于机器级内各事件的排序方式与控制方式，各部件的功能以及各部件的联系。计算机实现指的是计算机组成的物理实现，包括处理机、主存等部件的物理结构，器件的集成度和速度功耗，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。它着眼于器件技术和微组装技术，其中器件技术在实现技术中占主导作用。 ① 主存容量与编址方式(按位、按字节、按字访问等)的确定属于计算机系统结构。② 为达到所定性能价格比，主存速度应多快，在逻辑结构上需采用什么措施(如多体交叉存储等)属于计算机组成。③ 主存系统的物理实现，如存储器器件的选定、逻辑电路的设计、微组装技术的选定属于计算机实现。 具有相同计算机系统结构(指令系统相同)的计算机，因为速度要求不同等因素可以采用不同的计算机组成。例如，AMD Opteron 64与 Intel Pentium 4的指令系统相同，即两者的系统结构相同；但内部组成不同，流水线和Cache结构是完全不同的，相同的程序在两个机器上的的运行时间可能不同。一种计算机组成可以采用多种不同的计算机实现。例如，主存器件可以采用SRAM芯片，也可以采用DRAM芯片。 系列机（family machine）：是指由一个制造商生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的计算机。主要缺点：系列机为了保证软件的向后兼容，要求体系结构基本不改变，这无疑又妨碍了计算机体系结构的发展。 软件兼容性：同一个软件可以不加修改地运行于系统结构相同的各档机器上，而且运行结果一样，差别只是运行时间不同。向后兼容：在某一时间生产的机器上运行的目标软件能够直接运行于更晚生产的机器上。向上兼容：在低档机器上运行的目标软件能够直接运行于高档机器上。 计算机系统结构（现代定义） 计算机系统结构（现代定义）：是在满足功能、性能和价格目标的条件下，设计、选择和互连硬件部件构成计算机。 系统结构覆盖了： 指令系统设计 组成（Organization）：计算机设计方面的高层次 CPU内部结构、存储器、I/O系统、多处理器、网络 硬件: 计算机的具体实现技术 详细逻辑设计、封装、冷却系统、板级设计，功耗等 计算机系统结构（单处理器） 绿色部分 (ILP) 本课程不讲，只讲黄色部分。 计算机系统结构（多处理器） 第三章结构冒险数据冒险解决办法： 软件方法：编译器插入NOP（暂停相关流水线） 硬件方法1：硬件插入 stall（暂停相关流水线） 硬件方法2：内部前推 硬件方法3：stall+内部前推（针对 store 指令） 硬件插入 stall核心：ID 指令等前面的指令走完 WB （写寄存器）以后再继续（读寄存器） 停顿条件：(ID 级指令 rs1/2 == EXE/MEM 级指令 rd) &amp;&amp; (EXE/MEM 级指令要写寄存器) &amp;&amp; (ID 级要读寄存器) 123456DEPEN=(ID_rs1==EXE_rd)(EXE_WREG==1)(ID_rs1IsReg)+ (ID_rs1==MEM_rd)(MEM_WREG==1)(ID_rs1IsReg)+ (ID_rs2==EXE_rd)(EXE_WREG==1)(ID_rs2IsReg)+ (ID_rd==EXE_rd)(EXE_WREG==1)(store)+ (ID_rs2==MEM_rd)(MEM_WREG==1)(ID_rs2IsReg)+ (1D_rd==MEM_rd)(MEM_WREG==1)(store) ID_rs1IsReg 条件是为了排除转移指令 12ID_rs1IsReg=and+andi+or+ori+add+addi+sub+subi+load+storeID_rs2IsReg=and+or+add+sub（排除立即数运算指令） 进行简单改写： 12345678910DEPEN = A_DEPEN + B_DEPENA_DEPEN = EXE_A_DEPEN + MEM_A_DEPENB_DEPEN = EXE_B_DEPEN + MEM_B_DEPENEXE_A_DEPEN = (ID_rs1==EXE_rd)(EXE_WREG==1)(ID_rs1IsReg)MEM_A_DEPEN = (ID_rs1==MEM_rd)(MEM_WREG==1)(ID_rs1IsReg)EXE_B_DEPEN = (ID_rs2==EXE_rd)(EXE_WREG==1)(ID_rs2IsReg) + (ID_rd==EXE_rd)(EXE_WREG==1)(store)MEM_B_DEPEN = (ID_rs2==MEM_rd)(MEM_WREG==1)(ID_rs2IsReg) (1D_rd==MEM_rd)(MEM_WREG==1)(store) 内部前推 forwading 内部前推 初版 内部前推 时序图 注意时序图里 forwarding 箭头的写法！ 上一个计算结果可以直接从 ALU 里拿出来，至于多路选择哪个值，就是 ADEPEN 和 BDEPEN 的事情了。 MEM_WREG EXE_rs1=MEM_rd WB_WREG EXE_rs1=WB_rd ADEPEN ALU 输入选择(A端) 1 1 x x 2 MEM_R 1 0 1 1 3 WB_C 0 x 1 1 3 WB_C 其他情况 0 A 还是比较显然的。 B 端就比 A 端多一个条件：当 EXE_rs2IsReg 成立时就走立即数 (BDEPEN=2)；其他情况下，按 A 端规则进行判断。 和 stall 不同的是： forwarding 考虑的是 EXE 指令和 MEM/WB 指令的关系，stall 考虑的是 ID 指令和 EXE/MEM 指令的关系 forwading 不需要考虑转移指令，因为这类指令走不到 EXE 级 进行改进：将检测数据相关的时间从 EXE 级提前到 ID 级。 内部前推 改进 处理 load 指令: stall + forwarding1 stall + 1 forwading 可以解决 EXE 级 store 和 ID 级 ALU 的数据冲突（称为 load 冒险）。 0 stall + 1 forwading 可以解决 MEM 级 store 和 ID 级 ALU 的数据冲突。 stall + forwarding 总结 指令 stall/nop forwarding ALU 指令 2 stalls 0 stalls + 1 forwarding store 指令 2 stalls 1 stall + 1 forwarding 控制冒险三种解决方法 暂停流水线（插 nop 或使用硬件方法） 假定转移不发生（针对条件转移） 暂停流水线使用软件方法的话，beq bne需要前插 1 个 nop，后插一个 nop；branch 需要后插一个 nop。 插入 nop 使用硬件方法就要麻烦一些了。 首先要终止后面一条指令的执行，不然转移发生的时候，后一条指令已经到 ID 了，还将继续执行。 解决办法和 stall 类似，封锁指令的 WZ、WMEM、WREG。 解决办法 假定转移不发生这个其实很简单，就是在装流水线的时候，假设转移不发生，该咋装咋装。 所以，如果真的没有转移，1 次停顿都不会有；如果真的转移了，此时在流水线的指令全部要停掉（这个时候，其实就是硬件方法暂停流水线）。 例题 假设某机器的流水线，转移目标地址计算需要2个流水段，转移条件形成需要3个流水段，完成一个流水段的操作用一个时钟周期。假定解决控制冒险有三种方法：停顿流水线、转移预测未选中、转移选中。试计算条件转移指令采用这三种方法在转移发生与转移不发生所产生的停顿时钟周期数 停顿周期数 条件转移发生 条件转移未发生 停顿流水线 2 2 预测转移未选中 2 0 预测转移选中 1 2 延迟转移注意到 branch/beq/neq 后的代码一定会被执行。前面的解决办法是在这个位置放一个 nop 或 stall 解决问题禁止它产生效果。但是能不能利用这个特性，让它在这个时候执行一点代码呢？ 这个就和没有流水线的 MIPS 有点不一样了： 12345678Lop： load r1, 20(r2) nop addi r3, r1, 30 store r3, 40(r4) subicc r5, r5, 1 nop bne lop ；如果Z标志为0，即r6的内容不为0，则转Lop nop 上面没有优化的代码需要 3 个 nop。（假设除了 subicc 以外，其他指令不修改标志位，所以 subicc 不需要放在 bne 前）优化以后，一个 nop 都不需要！ 12345Lop： load r1, 20(r2) subicc r5, r5, 1 addi r3, r1, 30 bne lop ；如果Z标志为0，即r6的内容不为0，则转Lop store r3, 40(r4) 非常神奇的是，store 指令摆在 bne 以后，但每次跳转仍然会被执行。这是和单周期 CPU 非常不同的一点。","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"}]},{"title":"后端利用 REST API 对接 Onedrive","date":"2021-02-25T08:41:13.000Z","path":"back-end/onedrive-rest-api/","text":"最近写的后端项目需要云盘，由于各种原因，最终选择了 Onedrive。Onedrive 的一个优点是文档是中文的，但缺点是中文也看不懂。。。。 于是借助文档、博客、示例代码等等，慢慢摸索过来，并把摸索的这个过程形成一篇博文。 注册应用、用户登录授权 参考博客：zhangguanzhang’s Blog参考文档：Microsoft Graph 中的 OneDrive 授权和登录 Onedrive 的认证（以及 MS 家的其他功能）都统一使用 Microsoft Graph 进行认证，而 Microsoft Graph 似乎只支持 OAuth2（必须让用户在浏览器完成登录，不能拿到密码然后在后台登录），不支持 OAuth1（可以在后台利用用户密码发起请求完成登录），所以会麻烦一些。 在 Azure 创建应用第一件事，是按照上面的博客所说，注册应用。这个应用其实就是一个 API，以下引用并修改了 zhangguanzhang’s Blog： 我们首先要创建一个应用程序。 https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade 到上面链接里去注册一个应用程序，属性为： 受支持的帐户类型记得选 任何组织目录(任何 Azure AD 目录 - 多租户)中的帐户和个人 Microsoft 帐户(例如，Skype、Xbox) 重定向 URI (可选) 我用的是 http://localhost:8000/getAToken，在摸索的时候这个随便写就行。另外，这个值要存在代码里，命名为 redirect_uri。 然后设置权限。点击左边侧边栏的 “API 权限”，点击中间的“添加权限”，然后在右边点“Microsoft Graph” - “委托的权限”，搜索并找到以下三个权限，勾选上。 123Files.ReadWriteFiles.ReadWrite.Alloffline_access 勾选权限 然后在侧边栏的“概述”里面，把应用程序(客户端) ID 复制下来（在代码里存为 client_id）。 然后在侧边栏“证书和密码”里面，点击“新客户端密码”，生成一个 ID 和值，把值存到代码里，命名为 client_secret。 用户在浏览器登录，获取 auth_token在 Azure 创建应用以后，就是授权直至拿到 refresh_token 的过程。这个过程就是参考 Microsoft Graph 中的 OneDrive 授权和登录 了，这里我用 Python requests 实现。 现在文档迁移到了 Microsoft Graph 身份验证概述而且更加详细了。而上述链接不再提供中文文档。 首先设置上述变量： 1234567import requestsheaders = &#123;'Content-Type':'application/x-www-form-urlencoded'&#125;scope = \"Files.ReadWrite offline_access\"client_id = \"3aea792a-f5f5-49a6-b64d-e1a45d375323\"redirect_uri = \"http://localhost:8000/getAToken\"client_secret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" 然后是生成登录链接。这个链接需要在浏览器里访问然后输入账号密码，于是就不用 requests.get 而是把链接 print 出来，我们复制到浏览器里面。 12login_link = f\"https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=&#123;client_id&#125;&amp;scope=&#123;scope&#125;&amp;response_type=code&amp;redirect_uri=&#123;redirect_uri&#125;\"print(login_link) 打开 print 的链接，成功登录并授权后，跳转到 localhost，其中的参数的 code 字段就是我们需要的 auth_token，729个字符，有点长。 1http://localhost:8000/getAToken?code=0.AAAApOutbSzcpEiz8KuV1mGJ2ip56jr19aZJtk3hpF03UyM-AI4.AQABAAIAAAD--DLA3VO7QrddgJg7Wevry9C8xxU0YmDl1t3kRL1Rt8c4ZYINbxBW_X7KGMwL80bFg2I99rHKlQuC_bwGWIMjn1C4GjZg8fR2v2r-9J6fffSYUVMmrA5tGJ-7AUyulg076ViCOLWvtDzUh1T09f3Tt2Q8TpgCgO8P-0PqGMPqNOivzAxQz8WH5ZKSTMaI7WeOSBGe9yrpdjskO4pJrZv62E-jl2udaTBSXJAG4hKc18feCvuhJk27gT4H1W7ZiONqwMMkpzK6nlMhBgRP7-hTBNIU82Y0ASNOsOu2aAzrCQJmmbDdPHvsEYIq5jDnlOqeoNNFh-0v_AEbf-YfUfvIxN79eGpgrXvH19sLstDqFagJaOayNm6sf4HHuo2ikAot5kLZoBwYus57BaWeLI2IA_jDKd9T899Pv_Gfc_fwkgI9PynaHfoDRHb9A-6fXaJYPE5IYkTEnunNDaBf6jKtoTPub5LFIZv3OP38c3zJrTBZL5Wr5dpo3-pa0FFkbYPgHGC5APlWFNiBx-OECd4OJnbdzM7hrA2YzCLa6Bwl7SG4KTVXv2fwW1gFLgCZdI_xYBEDHfYuKUnlC5eqcebWwtkfJ8roFj9p3hzJ_GQSgEKjTgrdSUMaxrYwhSnAzS06H4BqnLKL-FrKsDBWJXuAIAA&amp;session_state=697ec6eb-a4b9-4567-9873-6065f156164b# 在之后开发 WebApp 时，我们需要把 redirect_url 设置为我们能路由到的链接，在路由到的 View 中获取 uri 参数，就可以获得 auth_token 了。不过现在还是手动赋值吧。 12# 赋值auth_token = \"0.AAAApOutbSzcpEiz8KuV1mGJ2ip56jr19aZJtk3hpF03UyM-AI4.AQABAAIAAAD--DLA3VO7QrddgJg7WevrnDiEeOedZvv94_iCOZdHtunnh-HD4-yA7CnKCnlskkTcXuD_nVujxrzDErLOPO5Kdba-gLFaUgOCxScnphpTmaR-bJbb6KCOJ6WEsecTZhdoBVvhgG8SzPAmolHemGaOOymSx1L3opaGXSo6YolsgwSCYcokocf9jl9Jq8pOAfg4tuZTYh1uX6f-IvQgLoIhUhE8i7GoaLIFhel9ICjiWgO9imtgNiLIjMX-MMRxqEKbcvbjVi9vnat1LE29v7uX_0Ogs6feGFzKEZOvT8pNlbm1t0frSwSIktQeIELEU3kzbDX7TEp1b_Cguj2u7wqF-kLv3P9w2_Gzhi-lzdRph1h9SW-RFYyWtdoCfhQgFf5m8K7aUGUEKgDK0RomoPvuZ1jfoNxe5JWQdcHqNo-LcHblYGRI1azy-p1fp28aBB6qKZ_0pcRTb4BrU5qLi9ze4RJ5kPajodTSSloUSVkf64B9OEdPeBvT8XU8_to0aVeHXOUTlsgVSlliatLPx9pFhsOZ4ec2-7fQMr8_CBhPlY4rjMfl8plefsfwcIsDBc0PRPITcsxA7OYSxZXvSchHA6XmCSzdl1413mTh7d0cvLYnBmzJm1tc6z6PEW270mtL_enHuzbtZpK9D1Epu0HIIAA\" 用 auth_token 换 access_token 和 refresh_token赋值以后，就可以请求拿 access_token 和 refresh_token 了。 1234567891011121314151617181920headers=&#123;'Content-Type':'application/x-www-form-urlencoded'&#125;response = requests.post( 'https://login.microsoftonline.com/common/oauth2/v2.0/token', data=&#123; 'client_id': client_id, 'redirect_uri': redirect_uri, 'client_secret': client_secret, 'code': auth_token, 'grant_type': 'authorization_code' &#125;, headers=headers)response # &lt;Response [200]&gt;eval(response.content)# &#123;'token_type': 'Bearer',# 'scope': 'Files.ReadWrite profile openid email',# 'expires_in': 3599,# 'ext_expires_in': 3599,# 'access_token': 'eyJ0eXAiOiJKV1QiLCJub25jZSI6ImZCREdZc3JfSzVYLXBkU2o5ZWotUUJMc2JGRGFDVGFBQ0lvSk90T3I2UlEiLCJhbGciOiJSUzI1NiIsIng1dCI6Im5PbzNaRHJPRFhFSzFqS1doWHNsSFJfS1hFZyIsImtpZCI6Im5PbzNaRHJPRFhFSzFqS1doWHNsSFJfS1hFZyJ9.eyJhdWQiOiIwMDAwMDAwMy0wMDAwLTAwMDAtYzAwMC0wMDAwMDAwMDAwMDAiLCJpc3MiOiJodHRwczovL3N0cy53aW5kb3dzLm5ldC82ZGFkZWJhNC1kYzJjLTQ4YTQtYjNmMC1hYjk1ZDY2MTg5ZGEvIiwiaWF0IjoxNjE0MjYyMDgzLCJuYmYiOjE2MTQyNjIwODMsImV4cCI6MTYxNDI2NTk4MywiYWNjdCI6MCwiYWNyIjoiMSIsImFjcnMiOlsidXJuOnVzZXI6cmVnaXN0ZXJzZWN1cml0eWluZm8iLCJ1cm46bWljcm9zb2Z0OnJlcTEiLCJ1cm46bWljcm9zb2Z0OnJlcTIiLCJ1cm46bWljcm9zb2Z0OnJlcTMiLCJjMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsImM4IiwiYzkiLCJjMTAiLCJjMTEiLCJjMTIiLCJjMTMiLCJjMTQiLCJjMTUiLCJjMTYiLCJjMTciLCJjMTgiLCJjMTkiLCJjMjAiLCJjMjEiLCJjMjIiLCJjMjMiLCJjMjQiLCJjMjUiXSwiYWlvIjoiRTJaZ1lORGY2OWJFVUxnd3BkR0FMM2J5aHZRZCsxNkg2THppdUwvNGxPejYrR25mbE1VQSIsImFtciI6WyJwd2QiXSwiYXBwX2Rpc3BsYXluYW1lIjoi6Ziu6JaH6JaH54K55ZCN5ZWmIiwiYXBwaWQiOiIzYWVhNzkyYS1mNWY1LTQ5YTYtYjY0ZC1lMWE0NWQzNzUzMjMiLCJhcHBpZGFjciI6IjEiLCJpZHR5cCI6InVzZXIiLCJpcGFkZHIiOiIxNTQuMTcuNy44NCIsIm5hbWUiOiLnlLXlrZDnp5HmioDlpKflraZNU0MiLCJvaWQiOiIyZDU1MTQyNS01Mzk2LTQxNTktOTQ1MC0wNzU2MzdiMDE2N2IiLCJwbGF0ZiI6IjMiLCJwdWlkIjoiMTAwMzIwMDA1N0RCODYzRSIsInJoIjoiMC5BQUFBcE91dGJTemNwRWl6OEt1VjFtR0oyaXA1NmpyMTlhWkp0azNocEYwM1V5TS1BSTQuIiwic2NwIjoiRmlsZXMuUmVhZFdyaXRlIHByb2ZpbGUgb3BlbmlkIGVtYWlsIiwic3ViIjoid2R3RDhmLXM0ajJDWHlmQ2phOWd1LXpVdk91V0ZUWFg2bXk1d0ZGODROcyIsInRlbmFudF9yZWdpb25fc2NvcGUiOiJBUyIsInRpZCI6IjZkYWRlYmE0LWRjMmMtNDhhNC1iM2YwLWFiOTVkNjYxODlkYSIsInVuaXF1ZV9uYW1lIjoidWVzdGNtc2NAZGVtbzRjLm9ubWljcm9zb2Z0LmNvbSIsInVwbiI6InVlc3RjbXNjQGRlbW80Yy5vbm1pY3Jvc29mdC5jb20iLCJ1dGkiOiJFQ0Vaei1LeEprZVhOMDRTYlVNa0FBIiwidmVyIjoiMS4wIiwid2lkcyI6WyJiNzlmYmY0ZC0zZWY5LTQ2ODktODE0My03NmIxOTRlODU1MDkiXSwieG1zX3N0Ijp7InN1YiI6Inl0WGtlTWM0dFVnV3dpMmJLbS1xc3JMazJuY3Zjc3lrYVFYcm1Zdm1lRE0ifSwieG1zX3RjZHQiOjE0OTcyNDg0OTN9.EjpbLnqwdSsjeQwy5oVWjqHfSjFyHwQHcwNNvVhq8w9J96PQEjx6xpyIc-VgrQc0h1DdfikzyOVkMEHSVifM_KZoaaUIcW3T4xgXjgZVeEtznAKEqSDB4PN5qR45hsZbJLoVFBxaRZsQrEiPK7m2F4-4_VCK-I6Dfhvhm2_XTiBXnbqSsQ87VhF01BqSVXBIlJwSS1mQKEYHJGCjKnTB5yToDzJvoh4p7GGY3SCmfWY-pDMsAvMlJbErfhXh9Hxc41eBESSEmoajZAnxFOJU5LRtVHqPQW6PwlSTHL2nlGfdXFpspTc6hy4pSyVDNq6I3HJRFXl1cW0L6DjD2FoWMw',# 'refresh_token': '0.AAAApOutbSzcpEiz8KuV1mGJ2ip56jr19aZJtk3hpF03UyM-AI4.AgABAAAAAAD--DLA3VO7QrddgJg7WevrAgDs_wQA9P_bTRjPRZzMorqH901Y19Ppp0sTRQdBBKFPHBjjxCNhD6fQlBevSxmidflskapxgyxbPlJysKnmnXMvEw6oy9tTRGn5QAB6kuYsP9BVFNiEpqeyqyyABuuiZZXHfMVSiqcIuUYdC5Cbt-meckpgVSC9Dfhvr50ilZ99m5iUHDkFVJLdPQLlrgdHqV8Mhe1V6Eh7F5Mfqrg1xb-K-QLZ3EGrcBUsDarXTkKPWP_9rKgukN_PTFerEBaM90u--8iytv0RJAui31HTa4yIInU0g7vZ16fhaEvJSXQjMSc5TYeepCHkK2fi3UpJe8TOoQ-qpORU_CJl83YMF59_enWxi0f_5ouV_9CPpeZ0xReU1Nb2y4g7uBYVPPNyroVlSmU0zV9c_rgs-dkSXK3b6r-AN-c5msS_ZoGvjiL3qBevNKo3Ws4w4IBWO-wQV8arNtNSuCAv5u9z41gITSDDg1Z8EYizTjQHjVaP095n5CWcBghqboVL4H2AAzW1SIgDJIs7ybwhg0oVsjUW4s9FQguPe9lj3HrAHzk5_NMRJsuGIZpDJ3ENz2pldXaRBqk42X07_y549Aw3qmgd8UY2KqsbA0EMNharkf-3q0_4AyeyxtqSqJETF5F3wy0bQ0RViS5W5mVobaRU90ia-zHzOjvXtxvenaY-r2ANjh_yg3qiV2D8Z7ODW50YzLL9SgiFqMm7zg7RYd4jjpdTYOik2yCX7cn_sSaA29KAqkbWKZNqX2Ds_ZRyby8RYeHBOC_I0XbrngLHnTszik-eKI3rHBv7UdTXCM9PHJwl2X4pocIREzfFPOTnLauiyfAS_zpb2Lsw8exVEqIpesVZt1S8uMvaEPctk7P22myx-vdxrk937c9z368vGpN6dBS--LPq5ZaxX9TuxCRbfCesT6KpkgLMq6Ywho59Tc6cAeE18sw'&#125; 好耶！ MS 还提供了网址对 access_token 进行解密：https://jwt.ms/。 用 refresh_token 换新的 access_token 和新的 refresh_token然后，我们把上面 response 里的 refresh_token 取出来，然后请求刷新 access_token 和 refresh_token： 123456789101112131415161718192021refresh_token = eval(response.content)['refresh_token']response_refresh = requests.post( 'https://login.microsoftonline.com/common/oauth2/v2.0/token', data = &#123; 'client_id': client_id, 'redirect_uri': redirect_uri, 'client_secret': client_secret, 'refresh_token': refresh_token, 'grant_type': 'refresh_token' &#125;, headers = headers)response # &lt;Response [200]&gt;eval(response.content)# &#123;'token_type': 'Bearer',# 'scope': 'Files.ReadWrite profile openid email',# 'expires_in': 3599,# 'ext_expires_in': 3599,# 'access_token': 'eyJ0eXAiOiJKV1QiLCJub25jZSI6ImhFSy1UT0xyZC1WZVNQOGVCU3plTURzeW1EODk5RWdlMEJzVDM5ak5uZEkiLCJhbGciOiJSUzI1NiIsIng1dCI6Im5PbzNaRHJPRFhFSzFqS1doWHNsSFJfS1hFZyIsImtpZCI6Im5PbzNaRHJPRFhFSzFqS1doWHNsSFJfS1hFZyJ9.eyJhdWQiOiIwMDAwMDAwMy0wMDAwLTAwMDAtYzAwMC0wMDAwMDAwMDAwMDAiLCJpc3MiOiJodHRwczovL3N0cy53aW5kb3dzLm5ldC82ZGFkZWJhNC1kYzJjLTQ4YTQtYjNmMC1hYjk1ZDY2MTg5ZGEvIiwiaWF0IjoxNjE0MjYyNjg4LCJuYmYiOjE2MTQyNjI2ODgsImV4cCI6MTYxNDI2NjU4OCwiYWNjdCI6MCwiYWNyIjoiMSIsImFjcnMiOlsidXJuOnVzZXI6cmVnaXN0ZXJzZWN1cml0eWluZm8iLCJ1cm46bWljcm9zb2Z0OnJlcTEiLCJ1cm46bWljcm9zb2Z0OnJlcTIiLCJ1cm46bWljcm9zb2Z0OnJlcTMiLCJjMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsImM4IiwiYzkiLCJjMTAiLCJjMTEiLCJjMTIiLCJjMTMiLCJjMTQiLCJjMTUiLCJjMTYiLCJjMTciLCJjMTgiLCJjMTkiLCJjMjAiLCJjMjEiLCJjMjIiLCJjMjMiLCJjMjQiLCJjMjUiXSwiYWlvIjoiQVNRQTIvOFRBQUFBcFB5WUtCamlUK2kxWnVaY3BLNitudHh2ektkMGovNGtvSVhGVnBwOE5vQT0iLCJhbXIiOlsicHdkIl0sImFwcF9kaXNwbGF5bmFtZSI6IumYruiWh-iWh-eCueWQjeWVpiIsImFwcGlkIjoiM2FlYTc5MmEtZjVmNS00OWE2LWI2NGQtZTFhNDVkMzc1MzIzIiwiYXBwaWRhY3IiOiIxIiwiaWR0eXAiOiJ1c2VyIiwiaXBhZGRyIjoiMTU0LjE3LjcuODQiLCJuYW1lIjoi55S15a2Q56eR5oqA5aSn5a2mTVNDIiwib2lkIjoiMmQ1NTE0MjUtNTM5Ni00MTU5LTk0NTAtMDc1NjM3YjAxNjdiIiwicGxhdGYiOiIzIiwicHVpZCI6IjEwMDMyMDAwNTdEQjg2M0UiLCJyaCI6IjAuQUFBQXBPdXRiU3pjcEVpejhLdVYxbUdKMmlwNTZqcjE5YVpKdGszaHBGMDNVeU0tQUk0LiIsInNjcCI6IkZpbGVzLlJlYWRXcml0ZSBwcm9maWxlIG9wZW5pZCBlbWFpbCIsInN1YiI6Indkd0Q4Zi1zNGoyQ1h5ZkNqYTlndS16VXZPdVdGVFhYNm15NXdGRjg0TnMiLCJ0ZW5hbnRfcmVnaW9uX3Njb3BlIjoiQVMiLCJ0aWQiOiI2ZGFkZWJhNC1kYzJjLTQ4YTQtYjNmMC1hYjk1ZDY2MTg5ZGEiLCJ1bmlxdWVfbmFtZSI6InVlc3RjbXNjQGRlbW80Yy5vbm1pY3Jvc29mdC5jb20iLCJ1cG4iOiJ1ZXN0Y21zY0BkZW1vNGMub25taWNyb3NvZnQuY29tIiwidXRpIjoiUjZERXd0TWlBazJsaTVXaWRIOGpBQSIsInZlciI6IjEuMCIsIndpZHMiOlsiYjc5ZmJmNGQtM2VmOS00Njg5LTgxNDMtNzZiMTk0ZTg1NTA5Il0sInhtc19zdCI6eyJzdWIiOiJ5dFhrZU1jNHRVZ1d3aTJiS20tcXNyTGsybmN2Y3N5a2FRWHJtWXZtZURNIn0sInhtc190Y2R0IjoxNDk3MjQ4NDkzfQ.GdgiFzmdXNFuBqaDSsLzalQU0QULm1fAYZw-mKw5D1KdR4j9WSl6sIa9vPcuogg1x7oLMujcgfdyY0Cf4KNLk3fQ3vzLo395R5GDbg-djBREWCBBgFvcgbu8AyH7yj6MxdXsY59U9nFqVdeIfqEZxxxFCT2F2Nc-CfrDsI8PZQL3kn0VFcvSiUwuOMlH06ydKwyyBNhCRh5yc9x32XWwlRde-GPZCd1SdyvcPvo_mUcEJxh97tRfehHNTDltXGFsAZqcYaz18iJk9MqZ4tlyOIIWPX_lXGRtNe2dUDQE6g6znWY0ClGvU3X9mdScUUtfblmnfmzMj-ECBkAjmjKBnA',# 'refresh_token': '0.AAAApOutbSzcpEiz8KuV1mGJ2ip56jr19aZJtk3hpF03UyM-AI4.AgABAAAAAAD--DLA3VO7QrddgJg7WevrAgDs_wQA9P89XPzxfnsn8nWMuIFittfpaEqpEzvy5sSPvkBHSIgu_y7Ppazm1F3l2nJ6hEWraRomalXRdwDi1Y78yIC_yA1xAspMEEuoxejDjoBhcWqOWLUTfXkfKk7i6pugNA-a_GOH9-EvKc_g9NvuCK4QgK6FQadMUf62wpoCkB53kgnH8GtOYKW34AutKaFi-N3v8RstrJRtsT3ZXanWmlA_q2WbDSou3-L_H6MS62u3Fr_mxnaKx4lKyy4cXaWbb_29dbx_yVO4zd_x5WHbcnrkfk3qoxD_b5kxHOMlKpVHtX_NthQvg8ZekDZ0pLawRsCDhJ8NFGwJvIXKxaMAyCbhHsyklnw97sU3M9jg08oAbaoQ0JA7eDZ4gd4juSzvkdGVK77unbROzOC1GjR12MWd9n_lYz4KMv_ErKx8wN2MHMAVK-QBBkJUsdB4JbBzSVgneD3jaDvWQRyz4BJMMx5e8qjR-bRwCBjm4Y1aK7vYNBGl2DVR1sVbf8eRZje6AxRQYy3rjdDod_30IqjNhDzX-eILlXR570RmoOGZgaWNPf-3-_3AaDGtsBE8tlCGux8lIR7jIxIKeBjfp1S5ymiofVirYYJiAg17KHy_W9FHUHS9CIs6CrKEvPesjDuFmerE14hzmJ4LCJarZSy2AsV6XiTMmamzaKX-WwFSzGXpipOwPbcO4tjcq5tFWz7-1TzDKsaAyvvh-K3fQiD2GUAv4v9zgRVczUQXN0Z37RULpnSGhj2eXaOenNXl9EoIgBLKXpj-lOshEyRbL2P3WzgvS1MUaXH31IHt-NiQuMpmeBfGg-gxrc9inQ0n7ATfD0T5vZ8YodjccP_rJvzI1Ntfl1yQs0g2h2JyZp694MOqc7Clv8W0P8F-uJIVWK2yv3iPRz-_nBM3im0A9OrCaugArHGPJ9gRt03nHzUHeJIAMc2Xqg'&#125; 至此，关于 token 的申请方法就讲完了。 Django 实现我把上面的过程改成了一个 OnedriveAuthentication 类（代码见 GitHub，views 部分在 views.py 中）。 另外，MS 也给了一个利用 requests_oauthlib.OAuth2Session 封装的示例，也可以参考。 另外需要注意的是，如果在 Django 后端中使用 requests 请求 Onedrive，会使得线程等待，在 Onedrive 相关请求并发量高的时候很容易造成数秒甚至数十秒的延迟。 可以在部署的时候使用更多线程缓解这个症状。想要根本改变这个问题，就不得不提到异步了。 异步请求可以使用 aiohttp 库。Django 3.1 也提供了异步视图的支持（但没有提供异步数据库访问的支持，不过也提供了临时解决办法）。但是，Django REST Framework 3.2.3 还不支持异步视图，想要使用异步视图，还得使用纯 Django 视图。 所以，目前我的解决办法，是把并发最高的一个 API 改写为纯 Django 视图然后异步化，并对该视图用到的 requests 请求改为 aiohttp 请求。 在前后端分离的情况下使用 Onedrive API完成登录授权，拿到 Access Token 以后，就可以用 MS Graph 的 API 进行操作了。可以在 Graph Explorer 进行测试。 而具体使用方法，就直接看文档啦。这文档蛮详细的，边写边看就行。 由于 REST API 的寻址部分比较麻烦，我使用 Python 对 API 进行了简单封装，代码在 GitHub。 这里只写了自己在开发过程中遇到的一些场景，以及解决方案。 项目的场景是使用一个账户的云盘作为整个项目的共有云盘，文件上传、删除等操作全部交给后端完成。后端判断前端登录的用户权限后，使用该账户的 access_token 执行操作。 上传为了省去文件经过后端服务器的流量，后端可以使用 Onedrive 的通过上传会话上传大文件 方案上传文件。前后端和 Onedrive 的交互过程如下： 在登陆状态下，前端向后端 POST /api/cloud/file 发起请求，后端请求 Onedrive 生成一个临时上传对话，并将 Onedrive 的应答（格式见上面的链接）转发给前端； 前端按照上面链接所述方法，直接向 Onedrive 上传文件。上传完成后，Onedrive 返回文件的 id 等信息，文件将位于 /(应用文件夹)/temp/{userid}/ 文件夹； 前端根据需求（如上传沙龙相关文件、沙龙照片）向对应接口发起请求（请求需包含文件 id），后端将文件移动至每个功能对应的文件夹，并完成后续操作（录入数据库等）。 前端交互前端交互原理很简单好像也不简单，对于错误处理就更麻烦了，虽然 MS Graph 最后给了对各种错误处理的详细策略，但是没有示例代码还是很麻烦。 因此，这里放一个我的 JavaScript 实现，其中 createUploadSession 是创建上传会话的接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 调用后端接口，将文件上传至 onedrive。// 参考文档：https://docs.microsoft.com/zh-cn/graph/api/driveitem-createuploadsessionexport async function uploadFile(file) &#123; let res = await createUploadSession(&#123;\"filename\": file.name&#125;); const uploadUrl = JSON.parse(res.data).uploadUrl; let size = file.size; const totalRetryTimes = 5; // 4xx 导致的上传失败的重试次数 const firstDelay = 1000; // 5xx 导致的上传失败的第一次等待时间（之后采用 * 2 的指数退避策略） // MS 直接给了上传时错误处理的策略，nb！ // https://docs.microsoft.com/zh-cn/graph/api/driveitem-createuploadsession#best-practices async function uploadPart(start, end, retryTimes = 0, nextDelay = firstDelay) &#123; // console.log(`uploadPart: start=$&#123;start&#125;, end=$&#123;end&#125;, retryTimes=$&#123;retryTimes&#125;, nextDelay=$&#123;nextDelay&#125;`); let headers = &#123;&#125;; let status = 0; headers['Content-Range'] = `bytes $&#123;start&#125;-$&#123;end - 1&#125;/$&#123;size&#125;`; headers['Content-Type'] = file.type; let config = &#123; withCredentials: false, timeout: 0, headers &#125;; try &#123; res = await axios.put(uploadUrl, file.slice(start, end), config); status = res.status; &#125; catch (err) &#123; status = 500; &#125; if (status &gt;= 500) &#123; // 继续或重试由于连接中断或任意 5xx 错误而失败的上载 // 请使用指数退避战略 console.warn(`上传失败，等待 $&#123;nextDelay / 1000&#125;s 后上传...`); await sleep(nextDelay); return await uploadPart(start, end, retryTimes, nextDelay * 2); &#125; else if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; // 成功上传该段，返回 return res; &#125; else &#123; // 对于其他错误，不应使用指数退避战略，而应限制尝试重试的次数 if (retryTimes &gt; 0) &#123; if (retryTimes &gt; totalRetryTimes) &#123; console.warn(`上传失败 $&#123;retryTimes&#125; 次，取消上传`); throw res; &#125; else &#123; console.warn(`上传失败 $&#123;retryTimes&#125; 次，重试中...`); return await uploadPart(start, end, retryTimes+1, nextDelay); &#125; &#125; &#125; &#125; let status = 0; let start = 0; // 200 为上传成功（覆盖），201 为上传成功（新建） while (status !== 200 &amp;&amp; status !== 201) &#123; let end = Math.min(start + maxFileContentLength, file.size); res = await uploadPart(start, end); start = end; status = res.status; &#125; return res.data.id;&#125; 这段代码还没有加上传进度等功能，不过上传的大体思路就是这样的。 下载为了省去文件经过后端服务器的流量，本后端只提供下载链接。由于 Onedrive API 限制，提供两种下载链接： 永久链接，但需在浏览器中访问 临时链接（Onedrive 链接有效期 15min，但本后端提供即时获取链接并重定向的 REST API） 永久链接有网友发现，手动或利用 Onedrive API 生成分享链接后，在分享链接后追加 ?download=1 参数，在浏览器访问该链接即可自动下载文件。 但该链接对应的 html 需要运行 JavaScript，因此不能通过 Python requests 或 JavaScript XMLHTTPRequest 直接下载。推荐使用后面的 API，或者在 JavaScript 使用 window.open() 在新窗口打开这个链接。 临时链接利用 Onedrive API 下载文件 时，响应报文为 302 Found，Location 为一个下载 URL。该 URL 仅在较短的一段时间 （几分钟后）内有效，不需要认证即可下载。 本后端提供 /cloud/file/{id}/download/ API，该 API 调用上述 API 后将报文返回给前端。","tags":[{"name":"后端","slug":"后端","permalink":"https://blog.lyh543.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://blog.lyh543.cn/tags/Microsoft/"}]},{"title":"和 CSRF 与 CORS 斗智斗勇","date":"2021-02-23T04:28:15.000Z","path":"back-end/handle-cors-and-csrf/","text":"写前后端的时候遇到了这个问题，花了三天时间解决，就还是简单地写一写。写到最后才发现，这里面涉及的知识量也太大了，也请各位读者耐心阅读。 前言CORS 和 CSRF 这两个概念很容易混淆，即使我在这篇博客前也不是很清楚二者的区别，于是就再搜了一下，顺便把另外两个概念也聊一聊。 浏览器、前端和后端的关系大概是：前端 &lt;-&gt; 浏览器 &lt;-&gt; 后端。前端告诉浏览器它需要访问什么，浏览器就向后端发请求，然后把应答给前端。 而同源策略、CORS、CSRF、HttpOnly 和 SameSite 都在围绕一件事情：如何防止恶意前端误导用户和浏览器，在用户不知情的情况下以用户的身份恶意访问后端（删除数据、转账等等）。 同源策略浏览器的同源策略 - Web 安全| MDN 同源：两个 Protocol、Port 和 Host 都相同的 URL 是同源的；跨域：两个 Protocol、Port 和 Host 不都相同的 URL 是跨域的； MDN 上举了几个同源和跨域的例子，这里不再赘述。 同源策略是一个比较笼统的概念，它是为了限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。就是说，它限制 baidu.com 的脚本不能访问到 taobao.com 的资源。 现代浏览器同时采用了两种同源策略： DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。 XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。 可见，同源策略就是浏览器用来防止恶意前端的策略。 不过请注意，浏览器并不限制 &lt;img&gt; &lt;tag&gt; &lt;form&gt; 等标签等进行跨域访问。 Cookie 的源Cookie 也有源的概念，但它的“源”和同源策略的“源”念有所区别。 [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E8%B7%A8%E6%BA%90%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE} Cookie 的 set：一个页面可以为本域和其父域设置 cookie，只要是父域不是公共后缀（public suffix）即可。Cookie 的 get：浏览器都允许给定的域以及其任何子域名 (sub-domains) 访问 cookie。当你设置 cookie 时，你可以使用 Domain、Path、Secure、和 HttpOnly 标记来限定其可访问性。 理解起来有点绕，可以用一个例子来解释。假设前端域名为 app.example.com，后端域名为 api.example.com： 如果后端对发来的域名不加以设置，后端的 cookie 的 domain 就是默认的 api.example.com。此时，前端并不能访问该 cookie，因为前端域名不是后端域名（或其子域名）； 正确的解决办法是，后端把 cookie 的 domain 设置为 example.com（一个页面可以为父域设置 cookie）然后发给前端，前端也可以访问到这个 cookie（浏览器都允许 example.com 的子域名 (sub-domains) 访问 这个 cookie） 上面的访问都进行了加粗，注意到这个访问的含义是：前端使用 document.cookie 可以看到这个 cookie。在实际操作中，可能你虽然看不到这个 cookie，但是发 XMLHttpRequest 时浏览器会提交这个 cookie，这不叫访问。 CORS 跨域资源共享跨源资源共享（CORS）- HTTP | MDN 同源策略屏蔽了所有的跨域访问。但是，并不是所有跨域访问都是恶意的，比如 tmall.com 前端想要向 taobao.com 后端发起 HTTP 请求这种情况，该怎么处理呢？ 所以，CORS（Cross-Origin Resource Sharing，跨域资源共享）出现了。CORS 由一系列 HTTP 头组成，当前端想要跨域访问后端时，浏览器将会利用这些 HTTP 头与后端交互，让后端告诉浏览器决定是否阻止前端获取跨域请求的响应。 在 MDN 可以看到，CORS 一共只规定了九个 HTTP 头，除掉 Origin 以外，其余的全部以 Access-Control- 打头。 下面是一次跨域请求的示例，前端 localhost:8080 向后端 uestcmsc-webapp.lyh543.cn 发出了 HTTP 请求。浏览器使用了两次请求，第一次被称为预请求，第二次被称为正式请求： 浏览器第一次预请求 浏览器首先在预请求中告诉后端：正式请求中的 HTTP 方法是 access-control-request-method: POST 以及会用到的报头为 access-control-request-headers: content-type，还有前端的源是 origin: http://localhost:8080。后端的应答中表明允许的源、报头、HTTP 方法，还有一个允许携带认证信息 access-control-allow-credentials: true（认证信息有三类，包含 Cookie、authorization 头和 TLS 客户端证书）。 浏览器第二次正式请求 收到后端的报文后，浏览器立刻向后端发出 CORS 的正式请求。在正式请求中，浏览器使用了 POST 和 content-type，以及 origin: http://localhost:8080，后端返回 access-control-allow-credentials: true access-control-allow-origin: http://localhost:8080 从上面可以看出，如果需要支持 CORS，主要是后端需要进行单独配置。前端没有什么要配置的，但是因为： Credentials必须在前后端都被配置（即the Access-Control-Allow-Credentials header 和 XHR 或Fetch request中都要配置）才能使带credentials的CORS请求成功。– MDN 前端需要配置的只有这一个点。 前端的配置很简单，对于 axios 来说，就是加上一行 withCredentials: true。 123456789import axios from \"axios\";const service = axios.create(&#123; baseURL: 'https://uestcmsc-webapp.lyh543.cn/api', timeout: 5000, // 请求的超时时间 withCredentials: true, // 允许携带 cookie sessionid 做认证&#125;);export default service; 后端 Django 配置就要麻烦一些了，需要安装 django-cors-headers，然后在 settings.py 里添加： 1234567891011121314151617181920212223242526272829303132333435363738INSTALLED_APPS = [ # ... 'corsheaders', #...]MIDDLEWARE = [ 'corsheaders.middleware.CorsMiddleware', # CORS 中间件，需注意与其他中间件顺序，这里放在最前面即可 #...]# CORS headers# 这里的 CORS 策略是允许所有源的前端跨站访问# 也可以根据自己需要设置 CORS 源白名单，然后阻止白名单以外的CORS_ORIGIN_ALLOW_ALL = TrueCORS_ALLOW_CREDENTIALS = TrueCORS_ALLOW_METHODS = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'VIEW',)CORS_ALLOW_HEADERS = ( 'XMLHttpRequest', 'X_FILENAME', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with', 'Pragma',) 配置好以后就可以了。 CSRF 跨站伪造请求攻击CSRF（Cross-site request forgery）跨站请求伪造，是一种常见的攻击方式。是指 A （前端、后端）网站正常登陆后，cookie 正常保存，恶意前端网站 B 通过某种方式访问 A 网站的后端进行操作，而浏览器向 A 后端请求时会自动带上 Cookie、造成危害的攻击方式。 好，到这里我就懵了，同源策略不就是用来防止 B 前端访问到 A 后端的吗？但请注意以下两点： 同源策略不限制通过 &lt;img&gt; &lt;tag&gt; &lt;form&gt; 加载/上传跨域资源 一个公共的后端 API 应当允许所有人使用，但它应当恶意前端误导用户的情况（如 Google Mail 就曾因为没有配置 CSRF 导致恶意前端诱导用户发送邮件），同源策略 + CORS 显然不能做到这一点 所以，仅有同源策略 + CORS 是不够的，还需要有 CSRF 防御。 针对 CSRF 这种攻击行为的防御方式有很多种，其实很常见的要求输入验证码等也能算作一种。Django 采用的策略如下所述： 默认对 HTTP GET、HEAD、OPTIONS 或 TRACE 这类安全请求不要求 CSRF 检查，对其他请求要求 CSRF 检查。可以通过 @csrf_exempt 和 @csrf_protect 自定义这个白名单； 在登录成功的应答中，会有 Set-Cookie 报头，除了给会话的 sessionid 以外，还会给 csrftoken，如下图所示； 登录成功给 csrftoken 有了 Set-Cookie 报头，浏览器会自动把 csrftoken，以及 sessionid 存为 Cookie，在 Chrome 很容易就能看到，如下图所示。 Chrome 查看 Cookie 在需要 CSRF 检查的请求，前端应当做以下几件事情： 在请求报头添加 csrftoken 的 Cookie； 在请求报头添加 X-CSRFToken 字段，其内容等同于 csrftoken Cookie（注：在实际操作中不一定要相等，只需要保证 cookie 和报头都是有效的 CSRF Token 即可）； 对于 HTTPS 请求，还需要包含 Referer 报头，一般来说都是自带了的，不会出问题。等实际出问题的时候（我怎么这么惨，什么 bug 都能遇见），我们再讨论 Referer 和 Referrer Policy。 HTTP 请求通过 CSRF 检查 对了对了，为什么 Cookie 还不够，还需要在报文添加 X-CSRFToken 字段呢？CSRF 开头举的例子说到，浏览器向 A 后端请求时会自动带上 A 的 Cookie，所以光有 csrftoken Cookie 是没有用的，恶意的 B 前端来请求，也会带上 csrftoken Cookie。但是，B 前端读不了 A 后端为 A 前端设置的 Cookie（见 Cookie 的源）。没办法读 csrftoken，也就没有办法设置 X-CSRFToken 为有效值了。 前端响应地要做如下改变： 设置 Cookie，对于 axios 添加 withCredentials: true 就可以了，和上面 CORS 是一样的； 在请求报头添加 X-CSRFToken 字段， axios 也有提供配置，但由于各后端的 Cookie 名和报头名不同，所以自己手动设定一下名字即可； Referer 报头一般不需要自己配置，默认即可（实际上，在特殊的情况下会出错，这个放到 Referer 和 Referrer Policy 部分讨论）。 修改的代码如下： 1234567891011import axios from \"axios\";const service = axios.create(&#123; baseURL: 'https://uestcmsc-webapp.lyh543.cn/api', timeout: 5000, // 请求的超时时间 withCredentials: true, // 允许携带 cookie: sessionid &amp; csrftoken 做认证 xsrfCookieName: 'csrftoken', // 添加 CSRF token xsrfHeaderName: 'X-CSRFToken'&#125;);export default service; 然后是后端的配置。如果没有跨域需求，配置比较简单，只需要把 csrf 加入 settings.py 就行了，这个其实在 django-admin startproject 时已经默认生成了： 123MIDDLEWARE = [ 'django.middleware.csrf.CsrfViewMiddleware',] 对于有跨域需求的情况，我们还需要将前端域名加入 CSRF_TRUSTED_ORIGINS： 12# settings.pyCSRF_TRUSTED_ORIGINS = ['.uestc-msc.com'] 如果前后端的跨域拥有相同的根域名（设为 .uestc-msc.com），那么还可以设置 CSRF_COOKIE_DOMAIN（还可以顺便把 SESSION_COOKIE_DOMAIN 也设置了）： 12345# settings.pyCSRF_TRUSTED_ORIGINS = ['.uestc-msc.com']if not DEBUG: CSRF_COOKIE_DOMAIN = FRONTEND_TRUSTED_ORIGINS[0] SESSION_COOKIE_DOMAIN = FRONTEND_TRUSTED_ORIGINS[0] 前后端不拥有相同根域名（如 a.com 和 b.com）的情况，不建议这种情况直接进行跨域访问，原因见文末。 另外，后端还要把 X-CSRFToken 放入 CORS_ALLOW_HEADERS。不过，这一点我们在配置 CORS 的时候就顺便做了。 SameSite 的源上面的一切看上去都是那么完美，对于同源的前后端就只有以上这么一点，但对于非同源的前后端，麻烦事才刚刚开始。 在本地开发环境下非常完美，但是一部署到生产环境就开始出锅，表现在登录成功后，任何 POST/PATCH 操作（修改信息、登出）均显示未登录。 检查一下 Cookie，发现什么都没有！ 没有 Cookie 是 Set-Cookie 没有成功吗？查一下登录的应答，发现 Chrome 提示： This Set-Cookie was blocked because it had the “SameSite=Lax” … Set-Cookie 失败 是这个 SameSite 的问题！ 有关 SameSite 的知识可以参考 即将到来的Chrome新的Cookie策略 - 知乎 和 SameSite cookies - MDN - Mozilla。 所以，SameSite（同站）是和 Same Origin（同源）不同的概念。 同源：两个 Protocol、Port 和 Host 都相同的 URL 是同源的；跨域：两个 Protocol、Port 和 Host 不都相同的 URL 是跨域的；同站：两个 eTLD+1 相同的网站是同站的。同站设置的 Cookie 称为一方 Cookie；跨站：两个 eTLD+1 不同的网站是跨站的。跨站设置的 Cookie 称为三方 Cookie。 eTLD(effective Top Level Domain) 指的是 .com .cn .xyz .com.cn 这类域名。而 eTLD+1 指的就是 baidu.com pconline.com.cn 这类域名。 缕清 SameSite 的概念以后，我们再来说 Set-Cookie 中 SameSite 的作用。 一个 Cookie 的 SameSite 属性决定了是否限制跨站请求携带这个 Cookie。SameSite 有三种取值： None，即不限制，所有跨站请求（前端和后端跨站的请求）都会携带这个 Cookie； Strict，这种情况下，所有跨站请求都不会携带这个 Cookie，只有同站请求可以携带； Lax，某些跨站请求（导航到目标网址的 GET 请求，包括链接，预加载请求和 GET 表单）可以携带，其他跨站请求不能携带。 需要注意一个细节是，如果要设置 SameSite=None，需要同时给 Cookie 加上 Secure 属性，否则 SameSite=None 失效。而 Secure 意味着后端必须启用了 https。 另外，SameSite 也是一个 CSRF 防御的方案。依旧是针对 CSRF 开头举的例子，如果 A 的认证 Cookie 设置了 SameSite 为 Strict 或 Lax，B 前端再向 A 后端发送请求时就不会携带这个 Cookie 了。 具体到代码上，在 Django settings.py 加上以下代码即可： 1234567if not DEBUG: CSRF_COOKIE_SAMESITE = 'None' CSRF_COOKIE_SECURE = True LANGUAGE_COOKIE_SAMESITE = 'None' LANGUAGE_COOKIE_SECURE = True SESSION_COOKIE_SAMESITE = 'None' SESSION_COOKIE_SECURE = True CSRF 和跨站 Cookie如果你以为上面的配置就可以了，那你就大错特错了。 在进行了上面的配置以后，发现 Django 提示 CSRF cookie not set.。读取 CSRF 和 session不会给 CSRFtoken Referer 和 Referrer Policy12345678&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt; &lt;head&gt; &lt;!-- ... --&gt; &lt;meta name=\"referrer\" content=\"strict-origin-when-cross-origin\"&gt; &lt;!-- ... --&gt; &lt;/head&gt;&lt;/html&gt; 后记：三方 Cookie 的去路上面似乎解决了所有问题，但是，还有一个问题，是越来越多的浏览器开始默认禁用第三方 Cookie 了，现在有 Safari、Firefox，以后估计还会有更多。 禁用三方 Cookie，意味着你即使完成了上面所有配置，也不能将跨域后端的 Cookie 存到浏览器中，这套认证方法直接失效。毕竟，各种广告商也是通过三方 Cookie 定位用户然后精准投放广告的。 从长久考虑，可以采用其他方法替代： 使用同一个根域名（如使用 app.test.com 和 api.test.com）。这样虽然是同源策略下的跨域，但不是 Cookie 概念下的跨域。把后端的 Cookie 域设置为 test.com 后，前端就可以直接读取、修改了； 如果前端服务器支持反代，可以把后端 api 反向代理到 app.test.com/api/ 下，这样就是完全同源了。后端服务器支持反代的话也是同理； 不使用 Session 认证，因为 Session 是基于 Cookie 的；可以改为 Token（如 JSON Web Token）等认证方案，这样的认证方式就完全不需要 Cookie，可以回避跨域 Cookie 引发的一系列问题。","tags":[{"name":"后端","slug":"后端","permalink":"https://blog.lyh543.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"RESTful","slug":"RESTful","permalink":"https://blog.lyh543.cn/tags/RESTful/"},{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Django","slug":"Django","permalink":"https://blog.lyh543.cn/tags/Django/"}]},{"title":"记一次 DNS 劫持","date":"2021-02-11T05:34:24.000Z","path":"others/dns-hijacking-experience/","text":"今天访问 https://twitter.com/ 时，显示 SSL Error 了。 第一反应是它 SSL 证书挂掉了（因为自己经常把服务器证书搞挂）。看了一眼证书，发现是 VMWare 的。 简单搜了一下，发现不少人也遇到了这个问题： https://blog.csdn.net/watercatmiao/article/details/85957864 https://www.bilibili.com/read/cv6490694/ 但是我检查了 Hosts，把 DNS 改为了 8.8.8.8，问题依然存在，ping twitter.com 依然是 127.0.0.1。 我尝试 nslookup 查 DNS： 12345678&gt; nslookup twitter.com服务器: groupclient.qq.comAddress: fe80::1非权威应答:名称: twitter.comAddresses: 2001::a2dc:ce2 127.0.0.1 这个 DNS groupclient.qq.com 非常诡异，我自己解析不了它的 ip 地址，在网上也没有搜到这个域名。 不过 Address 倒提醒我了，我改了 IPv4 的 DNS，但是它走的是 IPv6 进行解析，而 IPv6 的 DNS 我并没有配置。 在 Google Public DNS 网站 找到了 Google Public DNS IPv6 地址： 2001:4860:4860::8888 2001:4860:4860::8844 配置好以后就 ok 了。当然国内的话，也可以用别家的，比如阿里的 2400:3200::1。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://blog.lyh543.cn/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"MySQL 每日备份","date":"2021-02-06T06:31:36.000Z","path":"sql/mysql-daily-backup/","text":"转载备份。 以下脚本保存为 /etc/mysql_backup/mysql_backup.sh： 12345678910111213141516171819202122232425#!/bin/bashdbserver='127.0.0.1'dbuser='root'dbpasswd='password'dbname='test_db'backtime=`date +%Y%m%d`logfile='/etc/mysql_backup/mysql_backup.log'datapath=\"/etc/mysql_backup/data\"echo \"\" &gt;&gt; $&#123;logfile&#125;echo \"-------------------------------------------------\" &gt;&gt; $&#123;logfile&#125;echo \"备份时间为$&#123;backtime&#125;,备份数据库表 $&#123;dbname&#125; 开始\" &gt;&gt; $&#123;logfile&#125;for table in $dbname; do cd $datapath source=`mysqldump -h $&#123;dbserver&#125; -u $&#123;dbuser&#125; -p$&#123;dbpasswd&#125; $&#123;table&#125; &gt; $&#123;backtime&#125;.sql` 2&gt;&gt; $&#123;logfile&#125;; if [ \"$?\" == 0 ];then tar zcf $&#123;backtime&#125;-$&#123;table&#125;.tar.gz $&#123;backtime&#125;.sql &gt; /dev/null # 进行压缩 rm -f $&#123;backtime&#125;.sql find $datapath -name \"*.tar.gz\" -type f -mtime +30 -exec rm -rf &#123;&#125; \\; &gt; /dev/null 2&gt;&amp;1 # 删除 30 天前备份 echo \"数据库表 $&#123;dbname&#125; 备份成功!!\" &gt;&gt; $&#123;logfile&#125; else echo \"数据库表 $&#123;dbname&#125; 备份失败!!\" &gt;&gt; $&#123;logfile&#125; fidone 然后加入 crontab，凌晨四点执行： 10 4 * * * /etc/profile; bash /etc/mysql_backup/mysql_backup.sh crontab 的使用方法可以参考 crontab","tags":[{"name":"转载","slug":"转载","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"SQL","slug":"SQL","permalink":"https://blog.lyh543.cn/tags/SQL/"}]},{"title":"Vue 学习笔记","date":"2021-02-01T08:29:59.000Z","path":"front-end/vue-tips/","text":"Vue.js 是一个用于创建用户界面的开源 JavaScript 框架，也是一个创建单页应用的 Web 应用框架。目前正式版迭代到了 v2。值得一提的是，Vue 的作者是国人尤雨溪，最大的好处就是文档的中文支持非常快，目前还在 v3.x-beta 的教程仅支持中英文。 Vuetify 是一个纯手工精心打造的 Material 样式的 Vue UI 组件库。目前迭代到了 v2。 我开发的第一个（目前也是唯一一个） Vue 应用使用的组件库就是 Vuetify。可以说，Vue + Vuetify 让我入了前端的门。在本文中，我将聊聊作为一个前端萌新，在使用 Vue 和 Vuetify 的过程中，学到的前端技巧。 Vue 教程？零基础开始学习 Vue，我自然想到的是看官方教程。然而官方教程并不是那么好懂：刚看到安装部分，教程给出的数种安装方法就让我傻了眼，无从下手。 于是尝试去找别的教程，居然发现了尤雨溪在知乎上给出的学习路线：新手向：Vue 2.0 的建议学习顺序，其中第二点的 就只用最简单的 &lt;script&gt;，把教程里的例子模仿一遍，理解用法。不推荐上来就直接用 vue-cli 构建项目，尤其是如果没有 Node/Webpack 基础。 这句，对真·零基础新手非常友好。 Vue 开发环境我刚入坑时，想试试使用 Typescript 来开发 Vue。有人说 WebStorm 对 TS 的支持不行，得用 VS Code，于是我就用 VS Code 写了几天 Typescript。最后，还没写完账户管理部分，就放弃 Typescript 了。 Typescript 的静态类型确实很不错，但是写 Typescript 的时候，是各种 TSLint 报类型错。我也尝试写 .d.ts 文件，但是又遇到了没法引入等等问题。还有就是 TSLint 认为 this.$router 是 undefined，所以 this.$router.push() 等等都会报错。 上面这些问题或许有方法解决，但是问题实在太多，我最后还是选择使用 JavaScript + WebStorm 开发。 回来发现，WebStorm 还对 Vue Router 和 Vuex 有支持，输入 store.commit() 的时候居然能够提示函数名。真香。 WebStorm 对 Vuex 的支持 部署 Vue 应用如果你的 Vue App 使用了 vue-router 的 history 模式，目前 (2021.2) 是不能使用 GitHub Pages 部署的。 从 uri 的角度理解，是因为 GitHub Pages 服务器会默认将对 /activities/create 的请求理解为 /activities/create/index.html，而 vue-router history 模式想要服务器理解为 /index.html。于是， GitHub Pages 会返回 404。 我尝试了网上的 hack 404.html 和 200.html 的方法，但均无效。 一个解决方案是改用 hash 模式，此模式下链接会变为 /#/activities/create，这个 #(hash) 的存在，会让服务器将这个链接理解为 /index.html#/activities/create。但此法会让链接变丑。 另一个解决方案是用一台服务器来部署前端。Vue Router 文档中针对不同服务器提供了部署方法。不过对于 Caddy，我使用 Vue Router 文档提供的 rewrite 法不能正常运行。于是改用了 try_files，只对 Not Found 的文件进行 rewrite： 12345example.com &#123; root * /path/to/dist try_files &#123;path&#125; /index.html file_server&#125; 最后一个解决方案是我最后采用的，就是白嫖 Azure 的静态 Web 应用。Microsoft Learn 还写了一篇 教程 供大家参考。与 GitHub Pages 不同的是，Azure Static Web App 允许使用路由，只需要在开发 Vue 应用时，将以下 route.json 放在 /public/ 目录下即可（抄 MS Learn 的作业真爽）。 123456789&#123; \"routes\": [ &#123; \"route\": \"/*\", \"serve\": \"/index.html\", \"statusCode\": 200 &#125; ]&#125; 后来了解到，Vercel App 也支持部署。 Vue 页面间数据传递页面间需要传递数据，该怎么办呢？ 对于 C 语言，不同函数传递数据无非是两个办法，使用全局变量和传递参数。 在 Vue 中也是类似的思想：全局变量（window 或 Vuex.store）和传递参数（params 或 query）。 1. windowwindow 就是 DOM 中的全局变量，你可以通过赋值，把任何数据（当前用户信息）、甚至函数和对象（如 Vue 组件）挂到 window 下。 2. VuexVuex Vuex.Store 类似于 window，可以在不同的页面中使用、更改这些里面的数据。那为什么还需要这个工具呢？ 个人理解，Store 更强调的是状态。因此，它和 window 有两个区别： Store 存储的状态是需要在定义 Store 时就给出的，而不是像 window 一样，随时都可以为其添加新的数据、删除数据。 Store 可以随心所欲地读取，但是不能随心所欲地修改。为了防止对数据的错误修改，Store 要求将修改数据的操作，作为函数提前写入 Store 里（这些操作函数被称为 mutation），然后要求页面调用这些 mutation 来修改数据。在严格模式下，无论何时发生数据变更且不是由 mutation 函数引起的，将会抛出错误。 3. Vue Router 路由时添加 params 参数可以传递任何对象，但参数不会出现在链接中（除非在 Router 中专门设置了）。 发送方： 12345678let profile = &#123;id: 1&#125;;$this.router.push(&#123; name: 'NextPage', params: &#123; user_profile: profile, user_id: 233 &#125;&#125;) 接收方： 12$this.route.params.user_id // 233$this.route.params.user_profile // &#123;id: 1&#125; 如果 RouteConfig 中定义如下： 12345678const routes = [ &#123; path: '/user/:user_id', name: 'UserDetail', component: UserDetail, props: true, // props 表示 activityId 参数可以传到组件 &#125;,] url 会变为 /user/233。 4. Vue router 路由时添加 query 参数和上一种方法类似，但是这种方法的参数会出现在 url 中，且只能传递字符串。 发送方： 123456$this.router.push(&#123; name: 'NextPage', query: &#123; id: '1' &#125;&#125;) 接收方： 1$this.route.params.query.id // 1 同时链接会变为：原url?id=1。 Vue 生命周期之迷惑钩子函数生命周期，最大的作用，就是进入一个页面的时候，对这个页面进行初始化；还有就是，从别的页面切换到这个页面的时候，对这个页面的数据初始化。 如果是一个没有缓存的页面，每进入一个页面都需要进行创建并挂载，那么 created 和 mounted 这两个生命周期钩子函数，二选一，在里面写上自己的初始化代码就可以了。 而对于 Vue 来说，如果使用 &lt;keep-alive&gt; 包裹组件，它会缓存不活动的组件实例，等再次调用时（即使不是同一个 url）并不会发生第二次 created 或 mounted。这可能会导致下面这种场景：对于用户信息页面，我们进入用户 1 的页面，此时发生 created 和 mounted，页面信息显示为用户 1 的信息；然后我们切换到用户 2 的页面，此时并没有发生 created 或 mounted，页面仍显示为用户 1 的信息。 因此，我们要采取别的方法。对于 &lt;keep-alive&gt; 包裹的组件，官方文档直接指明使用 activated 和 deactivated。的确，把初始化代码放在 activated 里，就能代替 created 的初始化功能了。 不过有个地方很奇怪，如果用 &lt;keep-alive&gt; 包裹了一个带有 &lt;v-tab&gt; 的组件（tab 下有几个子组件）。我发现，第一次加载这个页面以及子组件时，子组件并不会触发 activated。 经过测试后发现，第一次加载这个页面以及子组件时，子组件并不会触发 activated只会触发 created；而在后面几次进入时，每次都会触发 activated，而不会触发 created。 目前尚不清楚不清楚为什么会这样。不过这样的话，可以改用 created 加 activated：将初始化函数封装为组件的一个 method，然后把 created 和 activated 写成调用这个 method： 123456789101112131415161718192021export default &#123; //... methods: &#123; //... fetchData() &#123; // 初始化代码 // ... // ... &#125; &#125;, created() &#123; this.fetchData(); &#125;, activated() &#123; this.fetchData(); &#125;&#125;; 在单向数据流中实现双向同步数据父组件使用 .sync 修饰符： 1&lt;text-document v-bind:title.sync=\"myTitle\"&gt;&lt;/text-document&gt; 子组件使用 computed： 12345678910computed: &#123; indexInternal: &#123; get() &#123; return this.index; &#125;, set(val) &#123; this.emit('update:index', val); &#125; &#125;,&#125; 子组件也可以使用 watch： 123456789101112131415watch: &#123; // 外部变量 index() &#123; if (this.indexInternal !== this.index) &#123; this.indexInternal = this.index; &#125; &#125;, // 内部变量 indexInternal() &#123; if (this.indexInternal !== this.index) &#123; this.$emit('update:index', this.indexInternal); &#125; &#125;,&#125; Vuex 模块化太难用？尝试一下 vuex-pathify！其核心语法就如下图： vuex-pathify 另外还直接提供了 get（类似于 mapGetters 的单向数据流）和 sync（这是 Vuex 没有的双向数据流！）。 但是啊但是，Webstorm 完全不支持对 vuex-pathify 进行自动补全，重构代码太麻烦了，再加上不熟悉 vuex-pathify，最终还是放弃了 vuex-pathify。快进到放弃 Vue 2 Vuetify 间距系统在抄 Vuetify 示例组件的时候常常看到 class = &quot;ma-0&quot; 等此类标识，这个是什么呢？ Vuetify 深受 Bootstrap 的启发，在这部分也一样。我在 Google 找到了 Bootstrap 的间距。大概意思是： ma-0 m 表示 margin；也可以取 p 表示 padding； a 表示 all；也可以取 t b l r 分别表示四边；也可以使用 x 和 y 分别表示左右和上下； 0 表示设置为 0；也可以取 1~5，间距从 0 依次增大；还可以取 auto。 所以，可以理解为 class=&quot;ma-0&quot; 是 style=&quot;margin: 0 !important&quot; 的简写。 而 Vuetify 的 ma-1 和 Bootstrap 有一点不同，在最后的数字上： Vuetify 的数字取值范围在 0~16，且每个单位都代表 4px（即 16 代表 64px），还可以使用 n16 表示负 64px；而 Bootstrap 的 0 到 5 是从 0 到 $spacer * 3 不均匀增加的。 在 vuetify.css 也能看到这部分的定义： vuetify.css Vuetify 网格系统Vuetify 网格深受 Bootstrap 网格的启发，所以如果有 Bootstrap 基础，Vuetify 上手应该会很快，反之亦然。可惜我都没有 Vuetify 网格系统包含四个核心子组件： v-container 代表一个网格 v-row 代表一行 (row) v-col 代表一列 (column)。注意 v-col 必须是 v-row 的子组件，即一定是 v-container &gt; v-row &gt; v-col 的顺序 v-spacer：可以在 v-row 之间或 v-col 之间放置一个 v-spacer，这样父子组件之间的剩余宽度就会被分配到这里 下面我将借助两个实际的例子聊聊网格系统的作用。 网格系统 例 1 问：上图中用个几个网格 v-container？ 答案是两个。 我刚接触 Vuetify 的时候，也觉得只需要一个网格将表单框起来、每个 row 对应一个输入项就可以了。 然而，当我只使用一个 v-container 时，效果图是这样的： 使用一个网格系统的效果 可以看到，最外层的 v-card 和边框合为一体了。而如果在 v-card 外面加一层 v-container v-row v-col，就可以把 v-card 框在中间的位置。 第一张图的部分代码如下： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;!-- 外层的 container、row、col 是为了限制 card 的布局 --&gt; &lt;v-container&gt; &lt;v-row class=\"justify-center\"&gt; &lt;v-col xs=\"12\" md=\"8\"&gt; &lt;v-card&gt; &lt;v-card-text&gt; &lt;v-form @submit.prevent=\"register\"&gt; &lt;!-- 内层的 container、col 是为了限制 form 的布局 --&gt; &lt;v-container&gt; &lt;v-col&gt; &lt;v-text-field/&gt; &lt;/v-col&gt; &lt;!-- 更多 text-field --&gt; &lt;v-col&gt; &lt;v-text-field/&gt; &lt;/v-col&gt; &lt;/v-container&gt; &lt;/v-form&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-container&gt;&lt;/template&gt; 完整代码 顺便一提，Vuetify 网格系统文档中介绍到，Vuetify 配备了一个使用 flexbox 构建的 12 格网格系统。&lt;v-col xs=&quot;12&quot; md=&quot;8&quot;&gt; 表示，对于 md 的屏幕，这列将占 8 格，也就是 2/3；对于 xs 的屏幕，这列将占据 12 格，也就是全部。 这和 Bootstrap 是也类似的，所以如果在 Vuetify 中遇到不懂的概念，除了在 Vuetify 文档中搜索，还可以尝试在 Bootstrap 里搜索。 再来一个例子，下图中用了几个网格系统？ 网格系统 例 2 答案是 3 个，在下图中有标出： 三个网格系统 完整代码： 把别人的组件封装成自己的无脑复制大多数后端项目的缩进都是 4 spaces，但前端则是使用 2 spaces。因为前端实在是太容易套娃了，随随便便就能搞个五层、十层以上。上面的例子用了三个网格系统，每一个网格系统对应一个 v-container、v-row 和 v-column，光是网格系统也有九层缩进了…… 所以，将别人的组件封装成自己的，不仅能减少重复代码量，还能大幅减少缩进。 比如，上面的网格部分提到，最外层的 v-card 都需要加一个网格系统。所以我做了如下封装： 1234567891011121314151617181920&lt;!-- /src/components/ui/base/simple-card.vue --&gt;&lt;template&gt; &lt;v-container&gt; &lt;v-row class=\"justify-center\"&gt; &lt;v-col xs=\"12\" md=\"8\"&gt; &lt;v-card&gt; &lt;v-card-text&gt; &lt;slot/&gt; &lt;!-- 这里会把调用 SimpleCard 处的 &lt;SimpleCard&gt; &lt;/SimpleCard&gt; 之间的代码插入 --&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-container&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt; 这样，网格系统例 1 的部分代码就可以缩减为如下： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;SimpleCard&gt; &lt;v-form @submit.prevent=\"register\"&gt; &lt;!-- 内层的 container、col 是为了限制 form 的布局 --&gt; &lt;v-container&gt; &lt;v-col&gt; &lt;v-text-field/&gt; &lt;/v-col&gt; &lt;!-- 更多 text-field --&gt; &lt;v-col&gt; &lt;v-text-field/&gt; &lt;/v-col&gt; &lt;/v-container&gt; &lt;/v-form&gt; &lt;/SimpleCard&gt;&lt;/template&gt;&lt;script&gt;import SimpleCard from \"@/components/ui/base/simple-card\";export default &#123; components: &#123;SimpleCard&#125;,&#125;&lt;/script&gt; 直接少了 4 层缩进。 把父组件 props 传递给子组件 props现在的需求是，有些页面不想用 xs=&quot;8&quot;，而想用 xs=&quot;6&quot;。用编程中的函数来讲，就是想要默认参数。我们想要使用： 12345678&lt;template&gt; &lt; SimpleCard md=\"6\" &gt; &lt;!-- ... --&gt; &lt;SimpleCard&gt;&lt;/template&gt; 就能在子组件中渲染出 &lt;v-col md=&quot;6&quot;&gt;。而在其他时候，依然渲染 &lt;v-col md=&quot;8&quot;&gt;。 只需要使用在子组件的 component 定义中添加 props 即可。 123456789101112131415161718192021222324252627282930&lt;!-- /src/components/ui/base/simple-card.vue --&gt;&lt;template&gt; &lt;v-container&gt; &lt;v-row class=\"justify-center\"&gt; &lt;v-col :xs=\"xs\" :md=\"md\"&gt; &lt;v-card&gt; &lt;v-card-text&gt; &lt;slot/&gt; &lt;!-- 这里会把调用 SimpleCard 处的 &lt;SimpleCard&gt; &lt;/SimpleCard&gt; 之间的代码插入 --&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-col&gt; &lt;/v-row&gt; &lt;/v-container&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; xs: &#123; type: Number, default: 12 &#125;, md: &#123; type: Number, default: 8 &#125; &#125;&#125;;&lt;/script&gt; props 就类似于函数的参数，default 即是默认参数。 将父组件所有多余的 props 自动传给子组件这个问题出现在我想要封装 tooltips 和 fab 的时候。 首先我们依照 Vuetify 给的模板编写的可用的代码如下： 12345678910111213141516171819&lt;template&gt; &lt;!-- 鼠标放置按钮之上可以看到提示 --&gt; &lt;v-tooltip top&gt; &lt;template v-slot:activator=\"&#123; on, attrs &#125;\"&gt; &lt;v-btn fab large buttom absolute right v-bind=\"attrs\" v-on=\"on\" &gt; &lt;v-icon&gt;mdi-home&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/template&gt; &lt;span&gt;Tooltips&lt;/span&gt; &lt;/v-tooltip&gt;&lt;/template&gt; 我们先按上文，将 Tooltips 和 图标的内容改为 props： 12345678910111213141516171819202122232425262728293031323334&lt;!-- /src/components/ui/base/floating-action-button.vue --&gt;&lt;template&gt; &lt;v-tooltip bottom&gt; &lt;template v-slot:activator=\"&#123; on, attrs &#125;\"&gt; &lt;v-btn fab large buttom absolute right v-bind=\"attrs\" v-on=\"on\" &gt; &lt;v-icon&gt;mdi-home&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/template&gt; &lt;span&gt;&#123;&#123; tooltip &#125;&#125;&lt;/span&gt; &lt;/v-tooltip&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; icon: &#123; type: String, default: 'mdi-plus' &#125;, tooltip: &#123; type: String, default: '' &#125; &#125;,&#125;;&lt;/script&gt; 这样就可以通过下面的形式调用这个组件了。 1234567891011&lt;template&gt; &lt;FloatingActionButton /&gt;&lt;/template&gt;&lt;script&gt;import FloatingActionButton from \"@/components/ui/base/floating-action-button\";export default &#123; components: &#123;FloatingActionButton&#125;,&#125;&lt;/script&gt; 自定义了 tooltip 和 icon 后我们发现，由于 v-btn 上能设置的属性可就太多了（如 disabled color loading 等等），把这些一个一个写到 props 里，实在不美观。有没有简洁的方法，使得我写 &lt;FloatingActionButton loading disabled/&gt; 就能把这两个参数传给子组件的 v-btn 中呢？ Vue 文档中提到了这种情况。Vue 把这里的 disabled color 等称为非 Prop 的 Attribute。 一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。 文档指出，这些非 prop 的 attribute，会默认替换/合并根组件已有的 attribute。不巧的是，我们的 &lt;FloatingActionButton&gt; 的根组件是 &lt;v-tooltips&gt;，所以这些 attribute 被默认放到了 &lt;v-tooltips&gt; 上。 为了打破这种默认情况，我们需要先在 component 定义中加入 inheritAttrs: false 禁止继承给根组件 &lt;v-tooltips&gt;，然后手动给需要的组件绑定 $attrs，类似于下面： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- /src/components/ui/base/floating-action-button.vue --&gt;&lt;template&gt; &lt;!-- 鼠标放置按钮之上可以看到提示 --&gt; &lt;v-tooltip top&gt; &lt;template v-slot:activator=\"&#123; on, attrs &#125;\"&gt; &lt;v-btn fab large buttom absolute right v-bind=\"attrs\" v-bind=\"$attrs\" v-on=\"on\" &gt; &lt;v-icon&gt;&#123;&#123; icon &#125;&#125;&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/template&gt; &lt;span&gt;&#123;&#123; tooltip &#125;&#125;&lt;/span&gt; &lt;/v-tooltip&gt;&lt;/template&gt;&lt;script&gt;export default &#123; inheritAttrs: false, // 不让组件的根元素继承 attribute，而手动将 $attrs 赋给 v-btn props: &#123; icon: &#123; type: String, default: 'mdi-plus' &#125;, tooltip: &#123; type: String, default: '' &#125; &#125;,&#125;;&lt;/script&gt; 对于其他组件，就是这个效果。然而，对于这个组件，问题在于 Vuetify 的模板代码包含了一个 v-bind=&quot;attrs&quot;，和我们的 v-bind 冲突了。我们需要把这两个 v-bind 合并。 而对于 JS，可以使用 {...$attrs, ...attrs} 的语法合并这两个 Object 为一个。于是，我们将 template 部分代码改为： 1234567891011121314151617181920&lt;!-- /src/components/ui/base/floating-action-button.vue --&gt;&lt;template&gt; &lt;!-- 鼠标放置按钮之上可以看到提示 --&gt; &lt;v-tooltip top&gt; &lt;template v-slot:activator=\"&#123; on, attrs &#125;\"&gt; &lt;v-btn fab large buttom absolute right v-bind=\"&#123;...$attrs, ...attrs&#125;\" v-on=\"on\" &gt; &lt;v-icon&gt;&#123;&#123; icon &#125;&#125;&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/template&gt; &lt;span&gt;&#123;&#123; tooltip &#125;&#125;&lt;/span&gt; &lt;/v-tooltip&gt;&lt;/template&gt; 就可以使用了。 123456&lt;FloatingActionButton icon=\"mdi-pencil\" color=\"primary\" tooltip=\"编辑\" @click=\"gotoEditUserDetail\"/&gt; 让子组件 click 事件能触发父组件的 v-on:click 事件还是接着上面的 tooltips + fab。 其实非常简单，只需要在 template 中添加一行 @click=&quot;$emit(&#39;click&#39;)&quot;，让子组件 &lt;v-btn&gt; 的 v-on:click 事件设置为触发 click 事件，让其向上传递即可，如下： 123456789101112131415161718192021&lt;!-- /src/components/ui/base/floating-action-button.vue --&gt;&lt;template&gt; &lt;!-- 鼠标放置按钮之上可以看到提示 --&gt; &lt;v-tooltip top&gt; &lt;template v-slot:activator=\"&#123; on, attrs &#125;\"&gt; &lt;v-btn fab large buttom absolute right v-bind=\"&#123;...attrs, ...$attrs&#125;\" v-on=\"on\" @click=\"$emit('click')\" &gt; &lt;v-icon&gt;&#123;&#123; icon &#125;&#125;&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;/template&gt; &lt;span&gt;&#123;&#123; tooltip &#125;&#125;&lt;/span&gt; &lt;/v-tooltip&gt;&lt;/template&gt; &lt;script&gt; 部分则完全不需要修改。 嵌套 slot这里的场景是想要把某个自定义组件封装成一个组件（下称为中间层），以供（外层）复用。该自定义组件中用到的 Vuetify 组件（内层）用到了 slot 语法，想把这个内层的 slot 暴露给外层。 外层的写法和 Vuetify 的写法一样： 12345678910111213&lt;PasswordEditDialog :user=\"userProfile\"&gt; &lt;template v-slot:activator=\"&#123;on, attrs&#125;\"&gt; &lt;v-btn color=\"warning\" v-bind=\"attrs\" v-on=\"on\" &gt; 修改密码 &lt;/v-btn&gt; &lt;/template&gt;&lt;/PasswordEditDialog&gt; 中间层需要注意的是， v-bind 的东西是整个插槽 prop： 12345678&lt;v-dialog v-model=\"dialog\" transition=\"dialog-bottom-transition\"&gt; &lt;template v-slot:activator=\"defaultProps\"&gt; &lt;slot name=\"activator\" v-bind=\"defaultProps\"/&gt; &lt;/template&gt;&lt;/v-dialog&gt; Vuetify 网格居中对于我来说，居中、向右对齐一直是个头疼的问题。各种组件的对齐方法都不同，况且对齐还分为了上下对齐和左右对齐。网上似乎也没有什么总结性的帖子，就只好记录一下自己编码的时候遇到的坑了。 但是最后发现遇到的大部分问题都可以用网格系统来解决。 网格系统中的居中理论网格系统中，如果想要上下对齐，可以使用 &lt;v-row&gt; 的 align 和 align-content 属性；想要左右对齐，可以使用 &lt;v-row&gt; 的 justify 属性。 v-row 文档 对于 align 和 align-content 的区别，请看：知乎 - 弹性盒子 align-items 与 align-content 的区别。简单来说，align 或 CSS 中的 align-items 控制当前行中的列的行为，而 align-content 控制的是所有行的行为。 illustration of align-items 上图是 align，下图是 align-content。 illustration of align-content 而 &lt;v-col&gt; 也提供了一个 align-self，不过不知道有什么用。v-col 文档 利用 css text-align 居中但是以上都没有解决我的需求。我的需求是让下面的 button 能在网格居中，而不是像下图一样靠左。 错误示范 在 Google “按钮居中 css” – 跳转到 csdn 找到了一种方法：在按钮的上一层（在这里就是 &lt;v-col&gt;）加一个 css: text-align: center： 1&lt;v-col style=\"text-align: center\"&gt; 添加 css 但是这个方法并不能使右边的 v-switch 居中（可能只能居中文字？）。 顺便一提，Vuetify 中，style=&quot;text-align: center&quot; 可以用 class=&quot;text-center&quot; 简写。 利用 v-row justify center真正的解决方法在 GitHub issue 上找到了：在 &lt;v-col&gt; 内 再添加一层 &lt;v-row justify=&quot;center&quot;&gt;： 正确示范 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;v-container&gt; &lt;v-row align=\"center\"&gt; &lt;v-col cols=\"4\"&gt; &lt;v-row justify=\"center\"&gt; &lt;v-fade-transition&gt; &lt;v-btn color=\"warning\" @click=\"showChangePasswordForm=!showChangePasswordForm\" &gt; &#123;&#123; showChangePasswordForm ? '不想改了' : '修改密码' &#125;&#125; &lt;/v-btn&gt; &lt;/v-fade-transition&gt; &lt;/v-row&gt; &lt;/v-col&gt; &lt;v-col cols=\"4\"&gt; &lt;v-row justify=\"center\"&gt; &lt;v-switch label=\"订阅邮件推送\" v-model=\"userProfile.subscribe_email\" :disabled=\"submitting\" /&gt; &lt;/v-row&gt; &lt;/v-col&gt; &lt;v-col cols=\"4\"&gt; &lt;v-row justify=\"center\"&gt; &lt;v-btn :disabled=\"!formValid\" :loading=\"submitting\" :color=\"submitColor\" @click=\"submit\" &gt; &lt;v-icon v-if=\"success\"&gt; mdi-check &lt;/v-icon&gt; &lt;template v-else&gt; 更新信息 &lt;/template&gt; &lt;/v-btn&gt; &lt;/v-row&gt; &lt;/v-col&gt; &lt;/v-row&gt;&lt;v-container&gt; 利用 v-row fill-height 上下居中在阅读 利用 &lt;v-img&gt; 构建一个 Gallery 的代码中注意到，示例代码能让 &lt;v-progress-circular&gt; 上下和左右居中。 使用 v-row 就可以完成左右居中，而必须同时加上 v-row class=&quot;fill-height ma-0&quot; 才可以上下居中。 Vuetify 显示头像Vuetify 用一个 v-card 来展示头像、用 v-responsive 控制 card 为正方形、再配上 v-skeleton-loader 作为占位符会比较舒服。 1234567891011121314151617181920212223&lt;v-container&gt; &lt;v-row align=\"end\"&gt; &lt;v-col cols=\"4\"&gt; &lt;v-row justify=\"start\"&gt; &lt;v-card&gt; &lt;v-responsive aspect-ratio=\"1\" width=\"200px\"&gt; &lt;v-img :src=\"userProfile.avatar_url\" aspect-ratio=\"1\" &gt; &lt;template v-slot:placeholder&gt; &lt;v-responsive&gt; &lt;v-skeleton-loader type=\"image@3\"/&gt; &lt;!-- 一个 image 固定 200px，要想 height 变大，就得多几个 image --&gt; &lt;/v-responsive&gt; &lt;/template&gt; &lt;/v-img&gt; &lt;/v-responsive&gt; &lt;/v-card&gt; &lt;/v-row&gt; &lt;/v-col&gt; &lt;/v-row&gt;&lt;/v-container&gt; 效果图 额 就是编码 gif 的时候颜色有点失真。 编辑页面弹窗阻止用户退出直接 Google 没搜到结果，过几天换了一个关键词搜，居然就搜到了。 文档 文档说的很清楚了。放在 Vue 里面，如果放弃老浏览器的兼容，直接在 activated 函数加一行即可。另外，退出页面时也记得取消这个函数。 1234567891011121314&lt;script&gt;export default &#123; //... activated() &#123; window.onbeforeunload = () =&gt; '系统可能不会保存您所做的更改。'; // 其他 activated 触发的事件 &#125;, deactivated() &#123; window.onbeforeunload = null; &#125;,&#125;&lt;/script&gt; 顺便一提，由于安全问题，弹窗显示的内容在较新的浏览器中都不允许自定义。 to 和 href对于超链接和路由，可以使用 Vue Router 提供的 to 属性，也可以使用 html 提供的 href 属性。to 属性经过编译后也会变成 href 属性。 二者的区别在于： to 只能针对 Vue 内的页面，href 对 Vue 内外的页面都可以使用； to 跳转 Vue 内页面不会刷新、不会丢失 Store 数据，而 href 会； 二者对不同 url 的表现如下： 属性-值 to href / 开头的页内链接，如 /foo/bar 跳转 跳转 完整 url，如 https://google.com/ 强行解释为站内链接，错误错误 跳转 Vue Router 语法，如 {name: &#39;foo&#39;} 跳转 不跳转 所以，结论就是：对站内的链接用 to，对站外的链接用 href。 如果一个 Array（比如侧边栏）包含跳转到站内的 item，也包含跳转到站外的 item 呢？ 答案是：混用 to 和 href！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- 部分 html --&gt;&lt;template v-for=\"item in items\"&gt; &lt;v-list-item :to=\"item.to\" :href=\"item.href\" ripple active-class=\"grey lighten-3\" &gt; &lt;v-list-item-action&gt; &lt;v-icon&gt;&#123;&#123; item.icon &#125;&#125;&lt;/v-icon&gt; &lt;/v-list-item-action&gt; &lt;v-list-item-content&gt; &lt;v-list-item-title&gt;&#123;&#123; item.title &#125;&#125;&lt;/v-list-item-title&gt; &lt;/v-list-item-content&gt; &lt;/v-list-item&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; items: [ &#123; title: '活动', icon: 'mdi-compass', to: '/activity', &#125;, &#123; title: '用户', icon: 'mdi-account-multiple', to: '/user', &#125;, &#123; title: '相册', icon: 'mdi-image-multiple', to: '/gallery', &#125;, &#123; title: '云盘', icon: 'mdi-cloud', href: 'https://drive.google.com/', &#125; ] &#125; &#125;&#125; 编译出来后，每个标签都包含且包含一个 href 属性。","tags":[{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.lyh543.cn/tags/Vue/"}]},{"title":"HTTP 状态码","date":"2021-01-30T15:08:30.000Z","path":"back-end/http-status-code/","text":"MDN Web Docs维基百科 1xx 请求已被接受，需要继续处理1 打头的其实不是很常用。 不过有一个 102 Processing (WebDAV) 挺有意思，用于表明 WebDAV 服务器收到了请求，但请求的操作比较费时，服务器正在处理（如遍历当前文件夹）。为了防止客户端 TCP 超时、假设请求丢失，于是服务器可以发送一个没有信息的 102 应答。 2xx 请求已被服务器接收、理解、并接受最常用的就是 200 OK 了，这是绝大多数 GET 方法、以及部分 POST PUT PATCH 成功后的返回值。它表示（一般时获取或修改）请求成功了，应答中会包含 GET 所请求的 Object，或者 POST PUT PATCH 成功后新的 Object。 201 Created 也非常常用，这主要用于 POST 创建一个 Object 这类请求的应答。它表示创建的请求成功了，应答中会包含 Object 的内容，或者应答的 Location 首部会包含这个 Object 的链接。 202 Accepted 表示服务器端已经收到了请求，但是还没有处理。一个非常典型的场景就是用户忘记了密码，申请重置密码。服务器应当发送一份邮件到用户的邮箱，但发送邮箱是一个很慢的过程，因此服务器可以在收到用户的请求后，立即响应 202，同时尝试发送邮件。202 同时意味着，发送邮件到底有没有成功，用户是无法得知的，服务器并不能通过 HTTP 协议告知用户成功与否。再换句话说，就是服务器不保证请求的处理结果。这和 102 有点像，区别在于服务器发送 102 以后，可以稍后再发送一个应答说明情况，而 202 就不能了。 除此之外还有 204 No Content 表示没有返回信息，这是绝大多数 DELETE 方法成功后（以及 PUT 请求更新资源，但是不需要改变当前的用户页面）的返回值。如果想要改变 PUT 请求的用户的当前页面，应当选用 201 或 202。 以及 206 Partial Content 表示报文包含的是请求的内容的一部分，这一般用于上传/下载的文件相当大的时候（下载的时候抓一下包就能看到很多的 206）。 3xx 客户端需要进一步操作通常来说，“进一步操作”就是指的重定向，因此最常用的也就是 301 302 307 308 这四个。 即 301 Moved Permanently、302 Found (或 302 Moved Temporarily)、307 Temporary Redirect、308 Permanent Redirect。 Stack Overflow 上有一个表格非常形象： 永久重定向 Permanently 暂时重定向 Temporarily 允许将 POST 方法改为 GET 301 Moved Permanently 302 Moved Temporarily 不允许将 POST 方法改为 GET 308 Permanent Redirect 307 Temporary Redirect 何谓 Permanently 和 Temporarily? 字面上理解：Permanently 指的是用户访问的网站永久迁移到新网址了，而 Temporarily 指的是用户访问的网站暂时（可能是 24-48 小时内）迁移到新网址； 对于浏览器： 对于 Permanently 的结果，浏览器会缓存 original_url 和 redirect_url1。下次用户访问 original_url 时，浏览器会直接向 redirect_url1 发送请求（而不会请求 original_url） 对于 Temporarily，浏览器不会缓存。下次用户访问 original_url 时，浏览器仍会向 original_url 发送请求 对于搜索引擎： 对于 Permanently 的结果，搜索引擎会记录跳转后的网址和内容； 对于 Temporarily 则有些尴尬，搜索引擎不知道应该记录跳转后还是跳转前的网址（比如 A 网址很短，但是它做了一个 302 重定向到 B 网址，而 B 网址是一个很长的乱七八糟的 URL，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而 B 网址既难看，又不用户友好；Google 家就选择记录 A 网址）这样就导致了 网址 URL 劫持：B 网站的很好的内容在 Google 上却显示的是网址 A。 所以，尽量选择 Permanently 吧。 除此之外，还有 304 Not Modified，一般是缓存服务器向目标服务器请求，询问请求的资源是否和缓存的版本一致（请求头中加上 If-Modified-Since），服务器返回 304 表示确实没有修改过，这种情况下，由于缓存服务器仍然具有以前下载的副本，因此不需要重新传输资源。 4xx 客户端错误这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。 400 Bad Request 是明显的客户端错误（例如，请求格式错误，size 太大，无效的请求消息或欺骗性路由请求）。 401 Unauthorized 表示需要客户端验证。与 403 不同的是，对于 401，客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。在测试的时候，我们可以使用 http://username:password@domain.com/ 来提交验证信息。 403 Forbidden 表示服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。 404 Not Found 就是请求失败。需要注意的是，当服务器不想揭示为什么请求被拒绝、或者没有其他适合的响应可用的情况下，也可能返回 404。 405 Method Not Allowed 对于一个只支持 POST 方法的 URI，如果使用 GET PUT 等方法访问它，就可以返回一个 405。 5xx 服务器错误 500 Internal Server Error：我也不知道出了什么错，是服务器错误的通用错误消息 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。如 Nginx 将 example.com 反向代理到了 localhost:8080，而 8080 端口并没有软件运行，此时访问 example.com 就会收到 502。 504 Gateway Timeout：作为网关或者代理工作的服务器，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器（如 V2Ray）在DNS查询超时时会返回 400 或者 500 错误。 如何选择最合适的状态码这是一个非常宏大的问题，只能说具体情形具体分析。 一个方法是参考现有的代码或后端框架等等，如 Django REST Framework 提供的通用模板中，对象创建成功用 201 Created；登录成功返回 200 OK 以及登录信息；删除成功返回 204 No Content。 还有一个方法就是在 Stack Overflow 上搜索你的行为 + REST API 或 http status code，会出现大量的结果供参考，如 logout http status code 会搜到关于注销应当返回什么，返回的状态码是否有意义这类问题。 REST API了解了 HTTP Status Code 后，另一个问题就是 REST API 了。","tags":[{"name":"后端","slug":"后端","permalink":"https://blog.lyh543.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"RESTful","slug":"RESTful","permalink":"https://blog.lyh543.cn/tags/RESTful/"}]},{"title":"drf-yasg —— Django REST Framework 文档生成","date":"2021-01-24T10:20:23.000Z","path":"python/drf-yasg/","text":"前两篇：Django 学习笔记 | Dango REST Framework 学习笔记 文档对于后端开发是相当重要，即使是一个人写前后端，如果不写文档，可能前天写的接口今天又不知道了。而且，测试部分是基于文档进行编写的，上过软件工程课程的同学应该都有了解。足以看出文档对后端开发的重要性。 对于 Django REST Framework，也有文档生成的工具。django-rest-swagger 就是一款，但是它已经不支持 Django 3.0 了。Django 3.12 可以改用 drf-yasg: Django REST Framwork Yet Another Swagger Generator。 GitHub | Read the Docs | 我使用 drf-ysag 编写的开源项目 drf-yasg 安装及全局配置安装以及这个官方文档非常详细的描述了，我就不多说了。 配置好并运行 Django 项目以后，就可以使用浏览器访问 /swagger/ 和 /redoc/ （链接取决于你的 urls 的配置）看到两种风格的文档了。我个人比较喜欢 Swagger 的，所以下面均用 Swagger 文档的界面作截图。 Swagger 另外，我个人更喜欢在 Parameters 和 Response 的地方默认展示 Example Value 而不是 Model，所以各位可以在 &lt;project_name&gt;/settings.py 中添加下面几行： 123SWAGGER_SETTINGS = &#123; 'DEFAULT_MODEL_RENDERING': 'example'&#125; 默认展示 Example Value drf-yasg 使用方法但是 drf-yasg 的使用方法并不详细。。。。 于是继续 Google 看到了另外一篇文章：自定義 drf-yasg 的 Swagger 文檔— 以 GET、POST、檔案上傳為例，简单了解了一下。 之后再去怼文档，了解了更多的方法。 为 View 的文档添加摘要和说明Swagger 的方法是使用 drf_yasg.utils.swagger_auto_schema 作为装饰器修饰每个视图。 可以装饰 Django 风格的 View： 12345678910111213141516from drf_yasg.utils import swagger_auto_schema@swagger_auto_schema( method='POST', operation_summary='注册新用户', operation_description='成功返回 201\\n' '失败（参数错误或不符合要求）返回 400',)@api_view(['POST'])def signup(request: WSGIRequest) -&gt; Response: register_serializer = UserRegisterSerializer(data=request.data) if register_serializer.is_valid(): u = register_serializer.save() user_serializer = UserSerializer(u) return Response(user_serializer.data, status=status.HTTP_201_CREATED) return Response(register_serializer.errors, status=status.HTTP_400_BAD_REQUEST) 对 View 进行装饰 也可以对 APIView 的 post get 等函数进行装饰： 1234567891011121314151617181920212223242526272829class ActivityCheckInView(APIView): @swagger_auto_schema( operation_summary='用户签到', operation_description='可能会有以下情况：\\n' '1. 签到成功，用户经验+10，每位管理员经验+50，返回 200\\n' '2. 活动不存在，返回 404\\n' '3. POST 数据不包含签到码，返回 400\\n' '4. 演讲者关闭了签到，返回 403\\n' '5. 签到码错误，返回 403\\n' '注：要求登录，否则返回 403', request_body=Schema_object(Schema_check_in_code), responses=&#123;201: None, 403: Schema_object(Schema_detail)&#125; ) def post(self, request: WSGIRequest, id: int) -&gt; Response: if not Activity.objects.filter(id=id): return Response(&#123;\"detail\": \"活动不存在\"&#125;, status=status.HTTP_404_NOT_FOUND) activity = Activity.objects.get(id=id) if \"check_in_code\" not in request.POST: return Response(&#123;\"detail\": \"POST 数据不包含签到码\"&#125;, status=status.HTTP_400_BAD_REQUEST) if activity.datetime.date() != datetime.now().date(): return Response(&#123;\"detail\": \"非当日活动\"&#125;, status=status.HTTP_403_FORBIDDEN) if not activity.check_in_open: return Response(&#123;\"detail\": \"演讲者已关闭签到\"&#125;, status=status.HTTP_403_FORBIDDEN) if request.POST[\"check_in_code\"] != activity.check_in_code: return Response(&#123;\"detail\": \"签到码错误\"&#125;, status=status.HTTP_403_FORBIDDEN) activity.attender.add(request.user) return Response(status=status.HTTP_200_OK) 对 APIView 的函数进行装饰 还可以对 GeneticAPIView 进行装饰： 1234567891011121314151617181920212223242526272829from django.utils.decorators import method_decorator@method_decorator(name=\"get\", decorator=swagger_auto_schema( operation_summary='获取沙龙信息', operation_description='获取沙龙信息\\n' '注：需要登录',))@method_decorator(name=\"put\", decorator=swagger_auto_schema( operation_summary='更新沙龙信息', operation_description='应答和 PATCH 方法相同，但 PUT 要求在请求中提交所有信息，不推荐使用',))@method_decorator(name=\"patch\", decorator=swagger_auto_schema( operation_summary='更新沙龙部分信息', operation_description='更新沙龙信息，成功返回 200\\n' '如沙龙不存在，返回 404\\n' '如更新值不合法，返回 400\\n' '注：更新参与者名单请使用 `/users/check_in/` 或 `/users/check_in_admin/` 接口\\n' '注：需要是沙龙演讲者或管理员，否则返回 403\\n' '注：PATCH 方法可以只提交更新的值，也可以提交所有值',))@method_decorator(name=\"delete\", decorator=swagger_auto_schema( operation_summary='删除沙龙', operation_description='删除沙龙，成功返回 204\\n' '注：需要是沙龙演讲者或管理员，否则返回 403',))class ActivityDetailView(RetrieveUpdateDestroyAPIView): permission_classes = (IsAuthenticated, IsPresenterOrAdminOrReadOnly, ) queryset = Activity.objects.all() serializer_class = ActivitySerializer 对 GeneticAPIView 进行装饰 ActivitySerializer 的定义可见 GitHub。 可能有的读者应该已经注意到了，对于 GeneticAPIView，Swagger 能够自动捕获其 Serializer 以及 ModelSerializer 并作为参数！除此之外，它还可以正确识别各 Serializer 类中的read_only_fields，并在请求的 Parameters 中去掉！真是太香了！ 使用 Serializer 为 View 的文档添加 parameter 和 response当然，对于 APIView 和 Django View，也是可以在 swagger_auto_schema 手动设置参数、返回值的。而如果对 GeneticAPIView 设置后，就会覆盖原来的设置。 在后文，我们就不讨论修饰哪一种 View，只讨论 swagger_auto_schema 这个装饰器了。 而后面的大部分讨论，都会围绕这个这个函数的文档。 对于 POST、PATCH 的放在 request_body 里的数据格式，可以放在 request_body 的参数部分，这个参数可以接收 rest_framework.Serializer 双厨狂喜，或是 openapi.Schema。 swagger_auto_schema 的 request_body response 的参数也是类似，只是变成了一个 dict，因为每种 response body 应当对应一个 HTTP 状态码。 swagger_auto_schema 的 respoonses 对于 rest_framework.Serializer 和 openapi.Schema 的用法，先从熟悉的 rest_framework.Serializer 说起。刚才在 GeneticAPIView 中，相信各位应该已经猜到了，它会默认将 GeneticAPIView 中的 serializer_class 作为 request_body 和 response。当然，我们也可以手动设置。 12345678910111213141516@swagger_auto_schema( method='POST', operation_summary='注册新用户', operation_description='成功返回 201\\n' '失败（参数错误或不符合要求）返回 400', request_body=UserRegisterSerializer, responses=&#123;201: UserSerializer()&#125;)@api_view(['POST'])def signup(request: WSGIRequest) -&gt; Response: register_serializer = UserRegisterSerializer(data=request.data) if register_serializer.is_valid(): u = register_serializer.save() user_serializer = UserSerializer(u) return Response(user_serializer.data, status=status.HTTP_201_CREATED) return Response(register_serializer.errors, status=status.HTTP_400_BAD_REQUEST) 手动设置 request_body 和 responses 两个 Serializer 的定义可见 GitHub。 绕开 IDE 对 {200: None} 的错误检测文档中提到，如果 responses 参数中没有 2xx 类的，会自动添加一个 200（对于 GET PUT PATCH），或是 201 （对于 POST）或 204（对于 DELETE）。要想屏蔽这个 2xx，只需要添加 {200: None}。 这个 None 有用，但是并不能通过 Pycharm 的类型检测（强迫症震怒）： Pycharm 的类型检测 作为强迫症，可以定义一个 Schema_none = None，然后： 绕开 Pycharm 的类型检测 使用 Schema 为 View 的文档添加 parameter 和 response如果没有使用 Serializers 而是手动处理的，也可以手动编写 Schema。 123456789101112@swagger_auto_schema( method='POST', operation_summary='登录', operation_description='成功返回 200' '失败（账户或密码错误）返回 401\\n' '注：一个已登录的用户 A 尝试 login 账户 B 失败后，仍具有账户 A 的凭证。', request_body=openapi.Schema(type=openapi.TYPE_OBJECT, properties=&#123; \"email\": openapi.Schema(type=openapi.TYPE_STRING, format=openapi.FORMAT_EMAIL, description='邮箱'), \"password\": openapi.Schema(type=openapi.TYPE_STRING, description='密码') &#125;), responses=&#123;200: Schema_None&#125;) 手动编写的 Schema openapi.Schema 的 type 和 format 就不用多说了，IDE 输入 openapi.TYPE_ 和 openapi.FORMAT_ 就能提示，也可以去看看文档。 emmm 文档变好看了，但是感觉代码变得又长又丑了 因此，我创建了一个 swagger.py 专门存放这些 Schema，核心代码里面直接调用就行了。 1234567891011121314151617# swagger.py# 定义了 Array 和 Object 的简写def Schema_array(schema: openapi.Schema) -&gt; openapi.Schema: # 这是将一个 element 转为 Array[element] 的函数 return openapi.Schema(type=openapi.TYPE_ARRAY, items=schema)def Schema_object(*props: dict) -&gt; openapi.Schema: result_properties = &#123;&#125; for prop in props: result_properties = &#123;**prop, **result_properties&#125; # 将两个 Dict 合为一个 Dict return openapi.Schema(type=openapi.TYPE_OBJECT, properties=result_properties)Schema_None = NoneSchema_email = &#123;\"email\": openapi.Schema(type=openapi.TYPE_STRING, format=openapi.FORMAT_EMAIL, description='邮箱')&#125;Schema_password = &#123;\"password\": openapi.Schema(type=openapi.TYPE_STRING, description='密码')&#125; 核心代码： 123456789@swagger_auto_schema( method='POST', operation_summary='登录', operation_description='成功返回 200\\n' '失败（账户或密码错误）返回 401\\n' '注：一个已登录的用户 A 尝试 login 账户 B 失败后，仍具有账户 A 的凭证。', request_body=Schema_object(Schema_email, Schema_password), responses=&#123;200: Schema_None&#125;) 效果图和上面相同。简洁多了。 另一个用到 Array 的例子： 12345Schema_title = &#123;\"title\": openapi.Schema(type=openapi.TYPE_STRING, description='沙龙标题')&#125;Schema_datetime = &#123; \"datetime\": openapi.Schema(type=openapi.TYPE_STRING, format=openapi.FORMAT_DATETIME, description=\"日期时间\")&#125;Schema_location = &#123;\"location\": openapi.Schema(type=openapi.TYPE_STRING, description='地点')&#125;Schema_presenter_ids = &#123;\"presenter\": Schema_array(Schema_object(Schema_id))&#125; 123456789@method_decorator(name='post', decorator=swagger_auto_schema( operation_summary='创建沙龙', operation_description='成功返回 201，参数错误返回 400', request_body=Schema_object(Schema_title, Schema_datetime, Schema_location, Schema_presenter_ids), responses=&#123;201: ActivitySerializer()&#125;)) Parameters 中 使用 Array 的效果 有了 Array 和 Object，就可以构造所有 JSON 语法了。","tags":[{"name":"后端","slug":"后端","permalink":"https://blog.lyh543.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"RESTful","slug":"RESTful","permalink":"https://blog.lyh543.cn/tags/RESTful/"},{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://blog.lyh543.cn/tags/Django/"}]},{"title":"Django REST Framework 学习笔记","date":"2021-01-24T10:20:22.000Z","path":"python/django-rest-framework/","text":"Django REST Framework 是什么如果你打算使用 Django 搭建一个 RESTful API 后端，你完全有必要学习 Django REST Framework。 Django REST Framework 提供了 Serializers、APIView、GeneticAPIView、ViewSets、权限管理、搜索、分页等功能。这些功能、特性可以全部加入我们的 RESTful 后端，也可以选一部分加入。 如果你和我一样，第一次接触后端，尚不了解 RESTful 后端的组成、功能，可能也会对上面的这些概念懵圈。 用通俗的话来说，RESTful 后端开发过程中，包含了相当多的重复元素，比如： 将数据模型（Django 中特指我们编写的 models.Model 类）变为 json 字符串发送给前端，这个变的过程称为序列化； RESTful API 应该对 GET /activities/ 这类请求提供获取活动列表的功能，对 POST /activities/ 提供创建活动的功能； 对于获取活动列表的功能，还应当具有搜索和分页的功能； RESTful API 应该对 GET /activities/1/ 这类请求提供获取 id 为 1 的活动信息的功能，对 PUT /activities/1/ 和 PATCH /activities/1/ 提供修改 id 为 1 的活动信息的功能，对 DELETE /activities/1/ 提供删除 id 为 1 的活动的功能 当然，还需要判定用户是否有权限获取、修改 上述步骤，使用纯 Django 也可以完成。而 Django REST Framework 所完成的，就是将具体的、重复的、步骤抽象化、简短化：将 json 到数据模型抽象化为序列器 Serializer 类，借助 Serializer 类编写 序列化 的过程可以最短缩减到三行；将提供了通用 RESTful 功能（如提供列表、创建对象、修改、删除）的一些 Django 视图 View 抽象化为 GeneticAPIView，读者在后面可以看到，对不同的 HTTP 方法提供不同功能的代码借助 GeneticAPIView 可以最短缩减到三行，搜索分页加起来也可以不超过十行；甚至的甚至，相同操作的不同 Views（如，需要对 /activities/ 和 /users/ 提供相同的列表、创建、获取、修改、删除方法）甚至可以用一个 ViewSet 进行描述。 当然，这种方法适合描述 RESTful API 中大部分通用功能，如果涉及到更细化的操作，如 signup 和 login，就没法用到 ViewSets 这类操作了。而在过于抽象的代码上，如果需求发生了少许更改，也可能导致较大的代码改动，如对于 /activities/ 和 /users/，原本二者提供的功能相同，使用一个 ViewSet 就可以描述，突然要求对 /users/ 中的注册过程添加一个验证码，都会导致这部分的代码重写。 综上所属，抽象化有其优点也有其缺点，在实际编码过程中，并不一定使用到 ViewSets，我的项目中最抽象也只用到了 GeneticAPIView。 Django 入门Django 入门 Django REST Framework 教程中也包含了必要的 Django 知识，不过我仍然建议简单看一下 Django 入门教程；以及，很多时候也会去查 Django 的文档。 Django REST Framework 官方教程汉化版教程链接 例：在序列器中定义可修改的外键 id1234class Activity(models.Model): # 为了防止循环引用，这里使用字符串表示 ActivityPhoto 类 banner = models.ForeignKey('activities_photos.ActivityPhoto', null=True, default=None, on_delete=models.SET_NULL, verbose_name=\"首页图\", related_name=\"banner_of\") Django REST Framework 处理外键 id 有点复杂。因为它的 update 默认是修改 id 值：如果你想修改 Acitivity 的 banner.id 为 4，DRF 的默认操作是把这个 Acitivity 外键现在指向的 banner 的 id 改为 4，而不是把 Acitivity 的外键重新指向 id 为 4 的 banner。 但是，请注意到，万能的 Django 为这个 Activity 提供了一个 banner_id 属性。在读取的时候，这个东西和 banner.id 的值是一样的，但在写入的时候： 修改 banner.id 的操作是将外键现在指向的 banner 的 id 改为 4，且修改为 None 时会报错：不存在 ActivityPhoto 修改 banner_id 的操作是将外键重新指向 id 为 4 的 banner，且修改为 None 表示设置这个外键为 null 于是，Serializer 里直接写 banner_id 就行了。 12345678910111213class ActivitySerializer(serializers.ModelSerializer): class Meta: model = Activity fields = (\"id\", \"banner_id\") read_only_fields = (\"id\") # 默认的 banner_id 是 allow_null=False, read_only=True，所以需要显式定义 banner_id = serializers.CharField(allow_null=True, read_only=False) # 默认的也不带 validator，如果不写 validator 导致数据库插入失败，就等着服务器抛 500 吧 def validate_banner_id(self, banner_id: str): if banner_id is None or ActivityPhoto.objects.filter(id=banner_id): return banner_id raise serializers.ValidationError(\"id 对应的图片不存在\") Django 永远滴神！ 例：自定义 APIExceptionDjango 中的 raise Http404 用着很爽，可以在任何函数打断当前 view 的执行，直接返回一个 404 的 HttpResponse。但是不能自己定义别的返回值，诸如 104、500、503 等等。 一种思路是手写一个装饰器，在原本的 view 外包装一个 try ... catch 代码块，再自己定义各种 Exception 就可以实现了。 不过，Django REST Framework 在自己的 View 中提供了这个功能，我们只需要继承 rest_framework.exceptions.APIException 就可以了。 123456class OnedriveUnavailableException(APIException): status_code = 503 default_detail = 'Onedrive 服务未登录。'# raise OnedriveUnavailableException 即可返回 503，&#123;\"detail\": \"Onedrive 服务未登录。\"&#125; 太香了！ 例：自定义对象级权限文档 需求是这样的，我们需要仿照 IsAdminOrReadOnly，编写一个 IsPresenterOrAdminOrReadOnly。 1234567class IsPresenterOrAdminOrReadOnly(BasePermission): def has_object_permission(self, request, view, activity: Activity): return bool( request.method in SAFE_METHODS or request.user and (activity.presenter.filter(id=request.user.id) or request.user.is_staff or request.user.is_superuser) ) 123456class ActivityAttenderUpdateView(GenericAPIView): permission_classes = (IsPresenterOrAdminOrReadOnly,) def patch(self, request: WSGIRequest, id: int) -&gt; Response: activity = get_object_or_404(Activity, id=id) self.check_object_permissions(request, activity) 如果你正在编写自己的视图并希望强制执行对象级权限检测，或者你想在通用视图中重写 get_object 方法，那么你需要在检索对象的时候显式调用视图上的 .check_object_permissions(request, obj) 方法。 例：完成序列化后再修改字段DRF 的 GeneticAPIView 写起来真的很爽，把 Models 和 Serializer 写好以后，GeneticAPIView 只需要几行就能写完，完成搜索、分页、序列化、返回 Response。但是，不可避免的是，某些时候想要传回更多的字段，或者由于权限问题隐藏某些字段。这个时候，我们就需要自己改写一部分 GeneticAPIView。 在 view 中的 serializer_data 中添加字段需求是这样的：原本的 login 函数完成了接收 username 和 password 并验证，正确后将该用户的信息用 UserSerializer 序列化后返回： 123456789101112def login(request: WSGIRequest) -&gt; Response: err_response = Response(status=status.HTTP_401_UNAUTHORIZED) if 'username' not in request.data or 'password' not in request.data: return err_response username = request.data['username'] password = request.data['password'] user = authenticate(request, username=username, password=password) if user is None: return err_response django_login(request, user) serializer = UserSerializer(user) return Response(serializer.data, status=status.HTTP_200_OK) 由于某些原因，我需要把 csrftoken 加入到返回的 JSON 中。csrftoken 的获取方法是 csrf.get_token(request)。如何将 csrftoken 加入序列化字段呢？ 最容易想到，但最麻烦且最不美观的方法是修改 UserSerializer。有没有其他方法呢？ 在最后一行打断点然后调试，执行到这里时看一眼 serializer.data 的类型，是 OrderedDict。OrderedDict 就很好办了，在 Response 之前修改一下，添加一个字段就可以了。 12345678910111213def login(request: WSGIRequest) -&gt; Response: err_response = Response(status=status.HTTP_401_UNAUTHORIZED) if 'username' not in request.data or 'password' not in request.data: return err_response username = request.data['username'] password = request.data['password'] user = authenticate(request, username=username, password=password) if user is None: return err_response serializer = UserSerializer(user) serializer_data = serializer.data serializer_data['csrftoken'] = csrf.get_token(request) return Response(serializer_data, status=status.HTTP_200_OK) 在 GeneticAPIView 的 serializer_data 中修改字段这个看起来就要麻烦一点了，毕竟本身 GeneticAPIView 部分是一个函数都没有写。 123456class UserListView(ListAPIView): queryset = User.objects.all().order_by(\"-userprofile__experience\") filter_backends = (filters.SearchFilter,) search_fields = ('username', 'first_name', 'last_name', 'userprofile__student_id') pagination_class = Pagination serializer_class = UserSerializer 这里的需求是：为了保护用户隐私，对于非管理员用户，不让其获取用户的 username 和 student_id，将返回的 username 改为 ***、student_id 改为前四位（代表入学年份）。 这里就有两种思路了：修改每一个 View 的处理过程（不仅仅是这个 View 需要保护隐私，其他 View 也应当保护隐私）；或者直接修改 Serializer 的序列化过程。 思路 1：修改 View 的过程我们可以考虑类似于上面添加 csrftoken 字段的思路。读 ListAPIView 的源码后，可以知道，get 方法调用了 list 方法，而 list 中做了查询、分页、序列化、包装成分页形式再返回的操作。 12345678910111213141516class ListAPIView(mixins.ListModelMixin, GenericAPIView): def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs)class ListModelMixin: def list(self, request, *args, **kwargs): queryset = self.filter_queryset(self.get_queryset()) page = self.paginate_queryset(queryset) if page is not None: serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.data) serializer = self.get_serializer(queryset, many=True) return Response(serializer.data) 我们只需要把官方的 list 方法复制下来，然后改写一下，在序列化以后判断是否是管理员，对于非管理员，替换每个 username 和 student_id 就可以了。 注意到官方给的 list 用 if 判断了是否用到分页功能，针对不同情况作了处理。我们已经用到了分页，所以可以把 if 删掉。 12345678910111213141516171819class UserListView(ListAPIView): queryset = User.objects.all().order_by(\"-userprofile__experience\") filter_backends = (filters.SearchFilter,) search_fields = ('username', 'first_name', 'last_name', 'userprofile__student_id') pagination_class = Pagination serializer_class = UserSerializer # 复制官方的 list，然后根据自己的需求进行改写 def list(self, request: WSGIRequest, *args, **kwargs) -&gt; Response: queryset = self.filter_queryset(self.get_queryset()) page = self.paginate_queryset(queryset) serializer = self.get_serializer(page, many=True) serializer_data = serializer.data # 对于非管理员，需要替换学号为学号前四位 if not (request.user.is_staff or request.user.is_staff): for item in serializer_data: item['username'] = '***' item['student_id'] = item['student_id'][0:4] return self.get_paginated_response(serializer_data) 这种方法的缺点就是需要对每一个 View 进行修改，而且在 List 的结果中，非管理员也不能获得自己的详细信息了。 思路 2：修改 Serializer上面的方法需要对每个 View 进行修改，并且新增的 View 如果忘记修改了，还会导致数据泄露。有没有从 Model 或 Serializer 下手的方法呢？ 这种方案要解决两个问题，一是序列化的过程中并没有 request，没有 request 我们就没法判断当前用户是否是管理员，所以需要通过什么方法传进去；二是需要自定义序列化的过程。 对于第一个问题，DRF 文档 中提到，可以在序列化时提供 context。 123serializer = AccountSerializer(account, context=&#123;'request': request&#125;)serializer.data# &#123;'id': 6, 'owner': 'denvercoder9', 'created': datetime.datetime(2013, 2, 12, 09, 44, 56, 678870), 'details': 'http://example.com/accounts/6/details'&#125; 在 context 中提供 user 信息，我们就可以判断用户的身份了。更好的是，GeneticAPIView 在序列化时，提供了默认的 context： 1234567891011121314151617181920212223class GenericAPIView(views.APIView): \"\"\" Base class for all other generic views. \"\"\" def get_serializer(self, *args, **kwargs): \"\"\" Return the serializer instance that should be used for validating and deserializing input, and for serializing output. \"\"\" serializer_class = self.get_serializer_class() kwargs['context'] = self.get_serializer_context() return serializer_class(*args, **kwargs) def get_serializer_context(self): \"\"\" Extra context provided to the serializer class. \"\"\" return &#123; 'request': self.request, 'format': self.format_kwarg, 'view': self &#125; 这下我们直接在 Serializer 里用就行了，GeneticAPIView 一行都不用修改。 对于第二个问题，查询资料发现，DRF 序列化的函数为 to_representation，其定义如下： 1234567891011121314151617181920212223242526class Serializer(BaseSerializer, metaclass=SerializerMetaclass): def to_representation(self, instance): \"\"\" Object instance -&gt; Dict of primitive datatypes. \"\"\" ret = OrderedDict() fields = self._readable_fields for field in fields: try: attribute = field.get_attribute(instance) except SkipField: continue # We skip `to_representation` for `None` values so that fields do # not have to explicitly deal with that case. # # For related fields with `use_pk_only_optimization` we need to # resolve the pk value. check_for_none = attribute.pk if isinstance(attribute, PKOnlyObject) else attribute if check_for_none is None: ret[field.field_name] = None else: ret[field.field_name] = field.to_representation(attribute) return ret 我们只需要重写它即可，把上面的代码复制下来，然后在 return 之前判断用户身份，替换 ret 的 student_id 和 username 字段。 不对，连复制都不需要，我们只需要调用父类的 to_representation()，然后加两行就可以了！ 1234567891011def to_representation(self, instance): ret = super().to_representation(instance) # 隐藏 username 和 student_id request = self.context.get('request') if request is None: # django shell 时会出现 request is None return ret if not (request.user.is_staff or request.user.is_superuser or request.user.id == ret['id']): ret['username'] = '***' ret['student_id'] = ret['student_id'][0:4] return ret serializers.ListField 和 models.ManyToManyField 的梦幻联动对于外键这类东西，Serializer 虽然不能自动处理，但是也提供了接口，只要加一点代码就可以完成灵活的写入。 背景场景是这样的：主讲人 是关于 Activity 和 User 的一个多对多的关系。在 Model 中是这样定义的： 123class Activity(models.Model): presenter = models.ManyToManyField(User, verbose_name=\"主讲人\", related_name=\"present_activity\") 对于获取 Actiivty 信息的 REST API，常见的一种写法是返回该 Activity 的所有主讲人的 id 组成的数组。 在 DRF 中可以使用 ListField 来实现。 12345class ActivitySerializer(serializers.ModelSerializer): class Meta: model = Activity presenter = serializers.ListField(child=serializers.IntegerField(), read_only=False) 但是 ListField 并不能直接将 ManyToManyField 的内容转化为 ListField。转化部分需要我们自己写。 怎么写呢？改 to_representation 吗？我尝试了一下这个，最终放弃了，因为一调用 super().to_representation 就会尝试把 presenter 序列化。 Python 可以定义一个类的方法为属性，如果定义了 setter，还可以把外界对这个属性的修改，反作用到原来的属性： 12345678910111213class Activity(models.Model): presenter = models.ManyToManyField(User, verbose_name=\"主讲人\", related_name=\"present_activity\") @property def presenter_id(self) -&gt; List[int]: queryset = self.presenter.all().values('id') return list(map(lambda u: u['id'], queryset)) @presenter_id.setter def presenter_id(self, value: List[int]): self.presenter.clear() self.presenter.add(*value) 然后我们指定一下 ListField 的 source 就可以了： 12345class ActivitySerializer(serializers.ModelSerializer): class Meta: model = Activity presenter = serializers.ListField(child=serializers.IntegerField(), source=\"presenter_id\", read_only=False) 就这么简单。 对了，后面发现，create 的时候还是会报错，因为 DRF 会在创建 Activity 时尝试设定 presenter 值，而此时 Activity 还没有写入数据库、没有主键，于是也没法创建多对多的记录。 解决方法是重载 create 方法，在 Activity 创建之后再写 presenter： 1234567891011class ActivitySerializer(serializers.ModelSerializer): class Meta: model = Activity presenter = serializers.ListField(child=serializers.IntegerField(), source=\"presenter_id\", read_only=False) def create(self, validated_data): presenter = validated_data.pop('presenter', []) activity = super().create(validated_data) activity.presenter_id = presenter return activity REST API 标准开发 REST 的工具有了，那标准呢？这是一个非常重要的问题。就像学了 C 语言后能写出很多的程序，但是常用的代码风格、代码库依旧要参考其他的标准。 我为此新开了一篇博文：RESTful API 标准。 DRF 项目部署可以参考 https://github.com/uestc-msc/uestcmsc_webapp_backend/blob/lyh543/docs/deploy/deploy.md Swagger 文档生成可以看 drf-yasg。","tags":[{"name":"后端","slug":"后端","permalink":"https://blog.lyh543.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"RESTful","slug":"RESTful","permalink":"https://blog.lyh543.cn/tags/RESTful/"},{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://blog.lyh543.cn/tags/Django/"}]},{"title":"Linux 连接 Docker MySQL 报错：error:\"Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)\"","date":"2021-01-04T02:36:54.000Z","path":"sql/error-cant-connect-to-local-mysql-server-through-socket/","text":"我在 Windows 的 Docker 上安装了 MySQL 8，随后在 WSL 中用命令行连接数据库失败： 123$ mysql -u root -h localhost -pEnter password:ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2) Windows 下的 PyCharm 是能正常连接 MySQL 的，所以肯定不是服务端的问题；我 Google 了也没有找到原因，所以猜测是 WSL 的锅。 但是最近在 GitHub Actions 上复现了这个问题。我在调用 GitHub Actions 为一个 Django Web 应用编写集成测试时在，这个问题再次发生了。 在搜索其他 Django + GitHub Actions + MySQL 相关网页并尝试后，我发现了问题所在：将 MYSQL_HOST 从 localhost 改为 127.0.0.1 即可！ 123456789101112131415$ mysql -u root -h 127.0.0.1 -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 17Server version: 8.0.22 MySQL Community Server - GPLCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 我猜测原因是：使用 localhost 时，mysql 客户端并不是访问 localhost:3306，而是直接访问 /var/run/mysqld/mysqld.sock。如果是在本地部署 MySQL，这样当然没有问题；但是如果使用 Docker 部署 MySQL，/var/run/mysqld/mysqld.sock 根本不存在，必须通过 127.0.0.1:3306 进行访问。 而 PyCharm 使用 jdbc 就不会受到影响。 后来我在 Stack Overflow 的十几个回答中找到一个相关的回答，但也没有提到 Docker，只有回答的回复中才提到了 Docker。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"SQL","slug":"SQL","permalink":"https://blog.lyh543.cn/tags/SQL/"}]},{"title":"Django 3.1 学习笔记","date":"2020-12-27T10:20:23.000Z","path":"python/django/","text":"Django 后端学习路线推荐从上往下看。 官方快速安装指南（3.1 版本），安装的教程 官方中文教程（3.1 版本），开发的教程 MDN 上的 Django 教程，和上面的教程有重叠，推荐只看会话和用户认证部分 Django REST Framework，这是一个基于 Django 的 RESTful 后端框架，为常见 RESTful 操作提供了模板，大大降低 REST API 开发量 Django 官方教程 关键步骤本小节记录了 官方中文教程（3.1 版本） 中的关键步骤。 1. 创建项目、项目和一个视图 安装：pip install Django 验证安装：python -m django --version 创建并初始化项目文件夹：django-admin startproject &lt;projectname&gt; 即时预览：在 &lt;projectname&gt; 目录下 python manage.py runserver [port] 创建应用：python manage.py startapp &lt;appname&gt; 编写视图： 12345# polls/views.pyfrom django.http import HttpResponsedef index(request): return HttpResponse(\"Hello, world. You're at the polls index.\") 在应用中添加写好的视图： 1234567# polls/urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] 在站点中添加应用的视图： 12345678# mysite/urls.pyfrom django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls),] 2. 数据库使用、管理员2.1 配置数据库 安装 mysqlclient：pip install mysqlclient 修改项目配置文件： 123456789101112# mysite/settings.pyDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django_learn', 'USER': 'root', 'PASSWORD': 'yourpassword', 'HOST': '127.0.0.1', 'PORT': '3306', &#125;&#125; 2.2 创建模型并迁移至数据库一个 Django 模型对于一个 SQL 数据表。 创建模型： 1234567891011121314151617# polls/models.pyfrom django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') def __str__(self): return self.question_textclass Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) def __str__(self): return self.choice_text 激活模型： 1234# mysite/settings.pyINSTALLED_APPS = [ 'polls.apps.PollsConfig' # 添加这一项] 将模型更改写入数据库： 根据类的更改，生成一个 迁移（一个存储在 &lt;app_lable&gt;/migrations 下的 py 文件，存储了变化）：python manage.py makemigrations [app_label]（文档） 将一个 迁移 应用到数据库，并迁移数据：python manage.py migrate [app_label] [migration_name]（文档） 查看一个 迁移 将对数据库造成的影响：python manage.py sqlmigrate &lt;app_label&gt; &lt;migration_name&gt;（文档） 一般来说，类变更以后，需要：python manage.py makemigrations &amp;&amp; python manage.py migrate 第一次部署的时候，需要 python manage.py makemigrations &lt;app1&gt; &lt;app2&gt; &lt;...appn&gt; &amp;&amp; python manage.py migrate 对了，migrations 文件夹应当加入 .gitignore，否则不同开发者的 migrations 就要冲突啦。 2.3 数据库 API 进入 Python 命令行：python manage.py shell 使用前先引入类：from polls.models import Choice, Question 对于一个数据表： 一个表的所有元素：Question.objects.all() 以成员筛选记录：Question.objects.filter(id=1) 以 pub_date 成员的 year 成员筛选（成员方法同理）：pub_date.year：Question.objects.filter(pub_date__year) 对于一个记录： 构造一个新记录：q = Question(question_text=&quot;What&#39;s new?&quot;, pub_date=timezone.now()) 将记录插入表：q.save() 查询、修改记录的属性（同理可调用其方法）：q.question_text 删除一个记录：q.delete() 对于一个外键（Choice 存在外键，为 Question）： 查询一个 Choice 对应的 Question：c.qeustion 查询一个 Question 对应的 Choice：q.choice_set.all() 为 Question 创建一个 Choice：q.choice_set.create(choice_text=&#39;Not much&#39;, votes=0) 2.4 管理员相关 创建管理员：python manage.py createsuperuser 管理员登录界面：http://127.0.0.1:8000/admin/ 在管理员页面中添加 Question 模型： 123456# polls/admin.pyfrom django.contrib import adminfrom .models import Questionadmin.site.register(Question) 3. 视图和 urls3.1 添加更多视图，并用参数匹配 url1234# /polls/views.pydef detail(request, question_id: int): return HttpResponse(\"You're looking at question %s.\" % question_id) # 这里可以做更多的事情，比如调用其他 Python 包 1234# /polls/url.pyurlpatterns = [ path('&lt;int:question_id&gt;/', views.detail, name='detail'),] 访问 /polls/34 会返回 You&#39;re looking at question 34. 3.2 使用 HTML 模板编写一个 HTML 模板： 12345678910&lt;!-- /polls/templates/polls/index.html --&gt;&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=\"/polls/&#123;&#123; question.id &#125;&#125;/\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 再在视图中：加载模板、用数据渲染、然后转为 HTTP Response，三步使用 django.shortcuts.render() 完成 123456from django.shortcuts import renderdef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 3.3 抛出 404 错误码12345678from django.http import Http404def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404(\"Question does not exist\") return render(request, 'polls/detail.html', &#123;'question': question&#125;) 也可以使用 django.shortcuts.get_object_or_404。该函数在 object 不存在会 raise Http404()： 12345from django.shortcuts import get_object_or_404, renderdef detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;) 也有 get_list_or_404() 函数，工作原理和 get_object_or_404() 一样，除了 get() 函数被换成了 filter() 函数。如果列表为空的话会抛出 Http404 异常。 3.4 使用 name 替代 URL 中的硬编码、为 URL 名称添加命名空间(app_name)https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial03/#removing-hardcoded-urls-in-templates https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial03/#namespacing-url-names 4. 编写一个简单的表单因为我想用 Django 做纯 REST 后端，所以这部分略。 https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial04/ 5. 测试https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial05/ 关于测试还是值得单独拿一个章节出来的：测试 6. 插入静态文件https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial06/ 7. 修改 Admin 页面https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial07/ 如果想要修改某元素对应外键的信息（而不是修改其外键），可以参考 django.contrib.admin.StackedInline 如果想要汉化 Admin 页面，可以参考：https://blog.csdn.net/aaazz47/article/details/78666099 Django 用户认证Django 用户认证（后端篇） MDN 教程：https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Django/Authentication文档：https://docs.djangoproject.com/zh-hans/3.1/topics/auth/default/ 创建用户：user = User.objects.create_user(&#39;john&#39;, &#39;lennon@thebeatles.com&#39;, &#39;johnpassword&#39;) 创建超级用户：在命令行中 python manage.py createsuperuser 登录： 12345678910111213from django.contrib.auth import authenticate, logindef my_view(request): username = request.POST['username'] password = request.POST['password'] user = authenticate(request, username=username, password=password) if user is not None: login(request, user) # Redirect to a success page. ... else: # Return an 'invalid login' error message. ... 判断用户身份：可以通过 request.user.is_authenticated==False 表示为匿名者；否则 request.user 会被设置为 User 实例。 更改密码： 12345from django.contrib.auth.models import Useru = User.objects.get(username='john')u.set_password('new password')u.save() login_required 装饰器： 1234from django.contrib.auth.decorators import login_required@login_requireddef my_view(request): 登出：django.contrib.auth.logout(request) Django 用户认证（前端篇）Django 的用户认证是用 Session 实现的，和其他的 Session 应该是类似的。但对于零基础前后端开发的我，不清楚这之中究竟发生了什么。于是我简单测试了一下。 在登录成功后，应答的 headers 中就会出现 Set-Cookies 字段： 1234567891011121314$ http POST http://127.0.0.1:8000/api/accounts/login/ &lt;&lt;&lt; '&#123;\"username\":\"lyh543@outlook.com\", \"password\":\"xxxxxxxx\"&#125;'HTTP/1.1 200 OKAllow: OPTIONS, POSTConnection: closeContent-Length: 493Content-Type: application/jsonDate: Tue, 09 Feb 2021 05:34:41 GMTReferrer-Policy: same-originServer: WSGIServer/0.2 CPython/3.9.1Set-Cookie: csrftoken=sJQyvoxpJ7nIwFpbgXSKKiBIoo7GxogKKTmsFwJshfyFMBIEyPlhQrvl8OK6FlQR; expires=Tue, 08 Feb 2022 05:34:40 GMT; Max-Age=31449600; Path=/; SameSite=LaxSet-Cookie: sessionid=kmst16goqdwof54ycuynbz7wzk1scboc; expires=Tue, 23 Feb 2021 05:34:40 GMT; HttpOnly; Max-Age=1209600; Path=/; SameSite=LaxVary: Accept, Cookie, OriginX-Content-Type-Options: nosniffX-Frame-Options: DENY 前一个 csrftoken 是防止跨站请求的，如果项目是前后端分离的话，就需要进行配置（关于 CSRF，可以看 和 CSRF 与 CORS 斗智斗勇）；后一个 sessionid 就是登录成功后的 sessionid 了。如果我们在下次请求中的 headers 中加入了这个 sessionid，服务器就能识别到我们。对于 Django 来说，就是 request.user 为登录的这个用户。 对于浏览器、requests.sessions.Session 等，会自动设置 Cookie。下面是利用 requests.sessions.Session 完成登录、查询管理员字段的过程： 123456789101112131415161718192021222324In [2]: import requestsIn [3]: s = requests.Session()In [20]: r1 = s.post(\"http://localhost:8000/api/accounts/login/\", data=&#123;\"username\":\"lyh543@outlook.com\", \"password\":\"xxxxxxxx\"&#125;)In [21]: r1Out[21]: &lt;Response [200]&gt;In [22]: dict(s.cookies)Out[22]:&#123;'csrftoken': 's1aepuw0A08k9PsFtTWn6CbCkLU24MU6tTuk3DieW4uj1b6PAXwSjrfHqfCvufz3', 'sessionid': 'f9ofrqwar9rs0phbg4p89647pwryowrs'&#125;In [23]: r1.request.headersOut[23]: &#123;'User-Agent': 'python-requests/2.18.4', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '47', 'Content-Type': 'application/x-www-form-urlencoded'&#125;In [25]: r1.headersOut[25]: &#123;'Date': 'Tue, 09 Feb 2021 03:48:32 GMT', 'Server': 'WSGIServer/0.2 CPython/3.9.1', 'Content-Type': 'application/json', 'Vary': 'Accept, Cookie, Origin', 'Allow': 'OPTIONS, POST', 'X-Frame-Options': 'DENY', 'Content-Length': '493', 'X-Content-Type-Options': 'nosniff', 'Referrer-Policy': 'same-origin', 'Set-Cookie': 'csrftoken=s1aepuw0A08k9PsFtTWn6CbCkLU24MU6tTuk3DieW4uj1b6PAXwSjrfHqfCvufz3; expires=Tue, 08 Feb 2022 03:48:32 GMT; Max-Age=31449600; Path=/; SameSite=Lax, sessionid=f9ofrqwar9rs0phbg4p89647pwryowrs; expires=Tue, 23 Feb 2021 03:48:32 GMT; HttpOnly; Max-Age=1209600; Path=/; SameSite=Lax', 'Connection': 'close'&#125;In [26]: r1 = s.get(\"http://localhost:8000/api/activities/1/admin/\")In [27]: r1Out[27]: &lt;Response [200]&gt; 而对于非登录操作、或登录失败，应答中的字段就不会有 Set-Cookies 字段，requests.sessions.Session 也不会设置 Cookies： 1234567891011121314In [2]: import requestsIn [3]: s = requests.Session()In [7]: r1 = s.get(\"http://localhost:8000/api/activities/1/admin/\")In [8]: r1Out[8]: &lt;Response [403]&gt;In [9]: s.cookiesOut[9]: &lt;RequestsCookieJar[]&gt;In [10]: list(s.cookies)Out[10]: [] Django Session 的过期时间也是可以通过修改 SESSION_COOKIE_AGE 来修改的。 使用 JWT 进行身份验证Django 自带的 Session 对于很多项目已经够用了。如果想要更高级一点的安全验证，如 Json Web Token，可以尝试 Simple JWT 配合 Django REST Framework 食用。文档给的示例代码很详细，有需要也可以仿照源码编写自己的 API。 Django 定时任务可参考 Django-crontab。 Django REST Framework这部分就另开一篇博文来写了。 Django 项目部署 (WSGI)Django 部署可以采用 WSGI，也可以使用 ASGI。WSGI 是为同步 Web Server 编写的，而 ASGI 是为异步 Web Server 编写的。虽然可以混用，但是同步函数和异步函数可以混用，但是会有约 1ms 的用于线程切换的性能损失。 。如果你主要使用的是异步函数，你可以快进到下一章，进行 ASGI 的部署。看完以后，再回来看看如何 处理静态文件。 Gunicorn诚然，python manage.py runserver 8000 然后将 8000 端口交给 Nginx / Apache / Caddy 反向代理到 80(http) / 443(https)，是最简单且最直接的方法。但是，其替代方案有多线程、占用内存小等优势。 Django 的管理命令 startproject 生成了一个最小化的默认 WSGI 配置，你可以按照自己项目的需要去调整这个配置，任何兼容 WSGI 的应用程序服务器都可以直接使用。 而其中一个 WSGI 应用程序服务器的方案，就是使用 Gunicorn。由于细节比较多，各位先不要急着实践，建议先通读这部分，再决定是否采用这种方式还是直接 startproject。 安装 Gunicorn： 1python -m pip install gunicorn 在项目文件夹下运行： 1gunicorn -b \"127.0.0.1:8000\" &lt;projectname&gt;.wsgi 其中 &lt;projectname&gt;.wsgi 也是 Python 的模块的表示方法，其表示 ./&lt;projectname&gt;/wsgi.py 这个模块。 可以将执行这条命令的过程写为 Systemd 服务，并实现 2 进程、每进程 3 线程，以及自动重启等： 1234567891011121314151617181920# djangoproject.service[Unit]Description=Django ProjectAfter=network.targetStartLimitIntervalSec=0[Service]Type=simpleRestart=alwaysRestartSec=1User=rootWorkingDirectory=/path/to/&lt;projectname&gt;/ExecStart=/usr/local/bin/gunicorn -b \"127.0.0.1:8000\" \\ --workers=2 \\ --threads=3 \\ --access-logfile - \\ &lt;projectname&gt;.wsgi[Install]WantedBy=multi-user.target 命令的 --access-logfile - 表示将 log 输出在控制台，在 Systemd 中即表示可以通过 systemctl status djangoproject 查询日志。 然后就是将这项服务复制到 /etc/systemd/system/，然后 enable 和 start 了： 1234sudo cp ./djangoproject.service /etc/systemd/system/sudo systemctl enable djangoproject # 激活sudo systemctl start djangoproject # 启动sudo systemctl status djangoproject # 查询状态 处理静态文件但是！这并没有完成部署。访问 localhost:8000 时，可以看到 Django 有正常响应，但是所有静态文件全部失效，Swagger 文档生成也失效了。 为了解决这个问题，需要配置静态文件。 在 &lt;projectname&gt;/settings.py 中配置以下几个参数 1234567import osSTATIC_ROOT = os.path.join(BASE_DIR, '.static')STATIC_URL = '/api/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static')] 三个参数的意义如下： BASE_DIR/static 是开发中静态文件所在文件夹 BASE_DIR/.static 是项目生成后静态文件所在文件夹，应当加入 .gitignore /api/static/ 是在网页中访问静态文件的路径 整个过程是这样的： 开发者将所需的静态文件放入 BASE_DIR/static 开发者运行 python3 manage.py collectstatic，Django 将开发者提供的 BASE_DIR/static 文件，和 Swagger 等 APP 提供的静态文件，一并复制进 BASE_DIR/.static 用户在浏览器中访问 /api/static/ 路径，表示用户想访问的文件夹是 BASE_DIR/.static 所以还需要进行以下两步： 运行 python3 manage.py collectstatic 通过 Nginx / Apache / Caddy 等将静态文件提供给用户 Gunicorn 提供了一个 Nginx.conf 配置模板，我也提供一份 Caddy 的配置模板： 1234567891011121314151617example.com &#123; handle /api/static/* &#123; uri strip_prefix /api/static root * /etc/uestcmsc_webapp/backend/.static file_server &#125; handle /api/* &#123; reverse_proxy localhost:8000 &#125; handle &#123; root * /etc/uestcmsc_webapp/frontend try_files &#123;path&#125; /index.html file_server &#125;&#125; 需要注意的是，这种配置的前提是所有 REST API 放在了 /api/ 下，这种方法使用的 &lt;projectname&gt;/urls.py 如下： 1234567891011api_urlpatterns = [ url(r'^docs(?P&lt;format&gt;\\.json|\\.yaml)$', schema_view.without_ui(cache_timeout=0), name='schema-json'), url(r'^docs/$', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'), url(r'^redoc/$', schema_view.with_ui('redoc', cache_timeout=0), name='schema-redoc'), path('admin/', admin.site.urls), # ...]urlpatterns = [ url('api/', include(api_urlpatterns))] Gunicorn 日志 ip 总是显示 127.0.0.1出现这个问题，我第一反应是 Caddy 反代的锅，第二反应是 Django 的锅，最后查了一下才发现是 Gunicorn 的锅。 Gunicorn doesn’t log real ip from nginx - Stack Overflow 回答也说的很清楚，只需要按照格式修改好后追加到 --access-logformat 参数即可。 我把时间、两个 -和 127.0.0.1 去掉以后的配置如下： 123456ExecStart=/usr/local/bin/gunicorn -b \"127.0.0.1:8000\" \\ --workers=2 \\ --threads=3 \\ --access-logfile - \\ --access-logformat \"%(&#123;X-Real-IP&#125;i)s \\\"%(r)s\\\" %(s)s %(b)s \\\"%(f)s\\\" \\\"%(a)s\\\"\" \\ &lt;projectname&gt;.wsgi Django 项目部署 (ASGI)Django 主推的 ASGI 部署方式，应该是它自己维护的 Daphne。 安装 Daphne 1python -m pip install daphne 在项目文件夹下运行： 1daphne &lt;projectname&gt;.asgi:application 1ExecStart=/usr/local/bin/daphne -p 8000 &lt;projectname&gt;.asgi:application 目前 Daphne 还不支持多进程，如需多进程，请使用 uvicorn。 项目开源地址上面提到的项目开源在 GitHub。","tags":[{"name":"后端","slug":"后端","permalink":"https://blog.lyh543.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://blog.lyh543.cn/tags/Django/"}]},{"title":"Go 开发的 tips","date":"2020-12-22T03:49:06.000Z","path":"go/go-tips/","text":"cheatsheet 流程控制： for 循环：for i := 0; i &lt; 10; i++ { for range 循环：for i, v := range pow {，可用 _ 代替 i 或 v while 循环：for i &lt; 10 { 紧凑的 if：if v := math.Pow(x, n); v &lt; lim { 结构体： 访问结构体成员或结指针指向的结构体成员：p.X 结构体赋值：v1 = Vertex{1, 2} 或 v2 = Vertex{X: 1/}// Y:0 隐式赋予 切片： 声明切片：[]bool{true, true, false} 或 a := make([]bool, 0, 3) 向切片增加元素：append(a, true, false) 映射： 初始化一个 string 到 int 的空映射：m := make(map[string]int) 删除映射的元素：delete(m, key) 检测某个键是否存在：elem, ok = m[key] 函数和方法： 定义函数：func split(sum int) (x, y int) { 定义结构体的方法：func (v Vertex) Abs() float64 { 入门教程A Tour of Go Go 的变量声明方式第一眼看到，觉得很怪异。不过看了这篇 关于 Go 语法声明的文章，觉得挺有意思。 Go 的声明语句是为了和自然语言（英语）保持一致： 123x int // x is intp *int // p is pointer of inta [3]int // a is array[3] of int 这主要针对的是 C 的指针，特别是加入了函数指针，一切都复杂起来： 1int (*(*fp)(int (*)(int, int), int))(int, int) 这段代码定义了一个函数指针 fp，其接收两个参数，第一个是一个函数指针（类型是 int (*)(int, int)，接收两个 int 并返回 int），第二个参数是 int。fp 返回一个函数指针，类型是最外层的 int (*(...))(int, int)，表示接收两个 int 并返回 int）。 如果用 Go 改写，将会变成： 1f := func(func (int, int) int, int) func(int, int) int 按照从左往右以 函数接收 xx 参数，返回 xx 的形式解读，可以知道：f 是一个函数，其接收两个参数，第一个参数是一个函数（func (int, int) int，接收。两个 int 并返回 int），第二个参数是一个 int。返回类型是一个函数 func(int, int) int，表示接收两个 int 并返回一个 int。 这里仅对文章核心作出解释，英文原文有更循序渐进的解释。 Go 语言代码风格go fmt &lt;filename&gt;.go 永远滴神！ 虽然 go fmt 的风格是用 tab，还是八个空格的 tab，但至少有一个官方排版方案，所以比 C++、Java、Python 各种民间规范更能让人接受。 Go 的指针指针和引用的功能是类似的，所以很多语言语言只实现了指针（如 C、Go），或只实现了引用（如 Java、Python）。如果二者都实现了，可能开发者也偏向于使用单一的一种（如 C++ STL中基本都是使用指针）。 Go 只实现了指针。但是不同的是，它的指针结构体有点意思：(*p).X 可以简写为 p.X！ 这种写法，使得结构体指针访问成员可以写成 p.X，这种写法反而更像是引用。所以，Go 虽然使用的是指针，但其语法也借鉴了引用的优点。 Go 接口 interface没学过 Java 的我看 Go 的官方教程的接口部分看得我一脸懵，于是找了其他的教程，看到菜鸟教程的示例不错。 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\")type Phone interface &#123; call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(\"I am Nokia, I can call you!\")&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123; fmt.Println(\"I am iPhone, I can call you!\")&#125;func main() &#123; var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; C++ 没有接口的概念，Java 有，可参考 Java 接口。 如果用 C++ 的方式理解，interface 可以裂解为一个“父类”，它声明了很多“虚函数”，由“子类”靠重载进行实现嘛！所以也就出现 interface “接口类型可以被赋值”这种听起来匪夷所思的事情，其实也就是把子类值赋给了父类变量，之后便可以调用父类的成员函数了。 这也是 Go 为了弥补没有类而产生的语法吧。 顺便一提，main 函数不使用 interface 写法也是可以的： 1234567func main() &#123; phone1 := new(NokiaPhone) phone1.call() phone2 := new(IPhone) phone2.call()&#125; 空接口 empty interface接口还不止于此：一个不包含任何方法的接口被称为空接口 empty interface。 空接口可保存任何类型的值（因为每个类型都至少实现了零个方法）。 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。 类型断言和类型选择 type assertion and switch所以又接着产生了类型断言 type assertion 和类型选择 type switch。 类型断言用于断言这个 interface 里到底是什么东西。其语法及对应输出如下： 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"func main() &#123; var i interface&#123;&#125; = \"hello\" s := i.(string) fmt.Println(s) // hello s, ok := i.(string) fmt.Println(s, ok) // hello true f, ok := i.(float64) fmt.Println(f, ok) // 0 false f = i.(float64) fmt.Println(f) /* panic: interface conversion: interface &#123;&#125; is string, not float64 goroutine 1 [running]: main.main() /tmp/sandbox906950040/prog.go:17 +0x1fe */&#125; 类型选择就是综合了类型断言和 switch： 12345678switch v := i.(type) &#123;case int: // v 的类型为 intcase float64: // v 的类型为 float64default: // 没有匹配，v 与 i 的类型相同&#125; 常用接口 Stringerfmt 包中定义的 Stringer 是最普遍的接口之一。 type Stringer interface { String() string}Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。 类似于 Java 的 toString()，定义了这个函数以后就可以调用 fmt 输出了。 Go 并发Go 多线程Go 开多线程也太香了吧，直接 go &lt;function&gt; 就可以了。 Go 线程同步：信道Go 的线程同步使用的是信道 channel，类似于《操作系统——精髓与设计原理》里进程同步的 消息传递 方法。 无缓冲区信道默认的信道是无缓冲区的，这种情况下采用的是“阻塞发送、阻塞接收”的方式：发送方和接收方先准备好的一方会被阻塞，直至另一方也准备好了。 创建一个无缓冲区的 int 信道可以使用 c := make(chan int)。 1234567891011121314151617181920212223// 将求数组和问题分配到两个进程完成（分别计算前 3 个和、后 3 个和）package mainimport \"fmt\"func sum(a []int, c chan int) &#123; s := 0 for _, v := range a &#123; s += v &#125; c &lt;- s // 将和送入 c&#125;func main() &#123; a := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(a[:len(a)/2], c) go sum(a[len(a)/2:], c) x, y := &lt;-c, &lt;-c // 从 c 中接收 fmt.Println(x, y, x+y)&#125; c 无缓冲区，因此在主线程执行 x, y := &lt;-c, &lt;-c 之前就准备好的 c&lt;-s 的 sum 会被阻塞。 对于无缓冲区的信道，这么写会报死锁： 12345678910111213141516171819package mainimport \"fmt\"func main() &#123; ch := make(chan int) ch &lt;- 1 fmt.Println(&lt;-ch)&#125;/*fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:main.main() /tmp/sandbox780334017/prog.go:7 +0x59Program exited.*/ 有缓冲区信道下面这种使用缓冲区信道，则是：当缓冲区满时阻塞发送方、当缓冲区空时阻塞接收方。又像是生产者、消费者问题模型了。 缓冲区大小为 n 的 int 信道定义方法为 ch := make(chan int, n)。顺便一提，无缓冲区的代码也可以用 ch := make(chan int, 0) 定义。 1234567891011package mainimport \"fmt\"func main() &#123; ch := make(chan int, 2) ch &lt;- 1 ch &lt;- 2 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125; 有意思的是，如果加两行，也会报死锁： 1234567891011121314151617181920212223package mainimport \"fmt\"func main() &#123; ch := make(chan int, 2) ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125;/*fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:main.main() /tmp/sandbox780334017/prog.go:7 +0x59Program exited.*/ 源源不断从信道接收值发送者可通过 close(c) 关闭一个信道，表示没有需要发送的值了。 接收者可以使用 v, ok := &lt;-ch 判断信道是否被关闭：若没有值可以接收且信道已被关闭，那么执行后 ok 会被设置为 false。 循环 for i := range c 会不断从信道接收值，直到它被关闭。 注意： 信道关闭后，之前传进缓冲区的值仍可被接收； 信道关闭并没有值可以接收后，再次接收会接收到零值（如果信道没有关闭，该线程会被阻塞）； 只有发送者才能关闭信道，而接收者不能。因为向一个已经关闭的信道发送数据会引发程序恐慌 (panic)。 关闭信道不是必需操作。只有在需要终止一个 range 循环等情况下需要关闭。 1234567891011121314151617181920212223// 万能的斐波那契数列package mainimport ( \"fmt\")func fibonacci(n int, c chan int) &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x+y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c &#123; fmt.Println(i) &#125;&#125; select 选择最先就绪的执行select 会阻塞当前线程，直至某个分支可以继续执行，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。 也可以添加 default，如果当前没有分支可以执行，就不会阻塞当前线程而是执行 default 语句。 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"time\")func main() &#123; tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for &#123; select &#123; case &lt;-tick: fmt.Println(\"tick.\") case &lt;-boom: fmt.Println(\"BOOM!\") return default: fmt.Println(\" .\") time.Sleep(50 * time.Millisecond) &#125; &#125;&#125; 输出： 123456789101112131415 . .tick. . .tick. . .tick. . .tick. . .BOOM! 互斥锁互斥方案就类似于《操作系统——精髓与设计原理》里进程同步的信号量了。 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( \"fmt\" \"sync\" \"time\")// SafeCounter 的并发使用是安全的。type SafeCounter struct &#123; v map[string]int mux sync.Mutex&#125;// Inc 增加给定 key 的计数器的值。func (c *SafeCounter) Inc(key string) &#123; c.mux.Lock() // Lock 之后同一时刻只有一个 goroutine 能访问 c.v c.v[key]++ c.mux.Unlock()&#125;// Value 返回给定 key 的计数器的当前值。func (c *SafeCounter) Value(key string) int &#123; c.mux.Lock() // Lock 之后同一时刻只有一个 goroutine 能访问 c.v defer c.mux.Unlock() return c.v[key]&#125;func main() &#123; c := SafeCounter&#123;v: make(map[string]int)&#125; for i := 0; i &lt; 1000; i++ &#123; go c.Inc(\"somekey\") &#125; time.Sleep(time.Second) fmt.Println(c.Value(\"somekey\"))&#125;","tags":[{"name":"tips","slug":"tips","permalink":"https://blog.lyh543.cn/tags/tips/"},{"name":"Go","slug":"Go","permalink":"https://blog.lyh543.cn/tags/Go/"}]},{"title":"WSL(Ubuntu)、Git 的配置及简单使用","date":"2020-11-18T08:33:02.000Z","path":"linux/introduction-to-wsl-ubuntu-and-git/","text":"这篇博文本来是想在俱乐部博客写的，不过最近俱乐部博客正计划用 WordPress 重构，链接可能会失效，于是就放到个人博客了。 本文将简要介绍 Windows Subsystem for Linux、Ubuntu、Git 的配置及简单使用。 为什么要学习 GitGit 是什么？为什么要学习 Git？ Git —— 维基百科 什么叫 分布式 版本控制 软件？ 什么是版本控制？假设你正在写一个非常重要的程序，为了保险，你可能会对每天下班时的版本进行存档、备份；同时，由于你可能在一个基础版本 A 上尝试添加新功能，写到一半（称作版本 B）失败了，需要回到 A；但是过了几天你又发现 B 版本的代码有可以借鉴的部分，所以需要结合最新的版本和 B 的代码。如果不借助软件来进行管理，可能后果就是你创建了一堆 程序-1.0 程序-2.0 程序-20201119 程序-新功能（失败了呜呜呜） 程序-定稿（修改版）-真定稿 文件夹。 更混乱的是，软件开发通常不是一个人，要是几个人的一堆版本混在一起，要进行管理就更混乱了。 于是，我们需要版本控制软件 Version Control Software 来做这件事情。 Git 版本控制基本概念：提交和分支Git 做的事情，就是在项目文件夹中创建一个 .git 文件夹，保存你的每一次提交 commit（git 的版本管理以提交为单位）。 对于单人的项目，你随时可以进行一次提交 git commit，保存这个版本的代码，也可以回到之前的任意一次提交时的版本。这些都是以提交为基础，可见提交真的是 Git 最重要的概念。 对于多人项目，Git 引入了分支 branch 的概念。 分支和提交（时间线为从左到右） 在 Git 图上，提交是每一个点（这个点保存了你提交时的代码版本），分支就是由点（提交）串起来的线。 上图的 Git 仓库中存在四个分支，正式版 master、开发版 dev、每个人的工作分支 michael bob。 master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？Michael 和 Bob 都在自己的分支上干活，每个人都有自己的分支。每个人的开发分支都是从 dev 分裂出来的；开发得差不多后，时不时地往 dev 分支上合并 merge 自己的代码。等到一个稳定的版本要发布时（如 v1.0.0），就把 dev 的代码合并到 master。 即使是单人的项目也可以弄一堆分支出来，用于开发新功能什么的。当然，单人的项目一般不会有这么多分支，就是一条直线。比如，我的博客的分支图（由 VS Code 的 Git Graph 插件生成）如下： 我的博客的分支图 Git 分布式Git 为什么是分布式的呢？ Git 每次是把远端（GitHub 或其他同类网站）的整个库克隆下来 git clone，提交是在本地创建一个新的点（提交），而上传到远端需要使用 git push 进行推送。所以，Git 中本地和云端的内容是基本相同的，Git 库内容不仅存于云端，还分布在每个开发者的电脑上。 Git 远端的默认名为 origin，所以你可能会看到 origin/master，这指的是这个仓库在 GitHub（或同类网站）上的 master 分支。 我们平时最好在提交之后，及时 push 至 GitHub 上，这也是起了将代码备份到云端的效果（顺便一提，数据无价，备份很重要！！！！这学期我们班已经有三个人电脑挂了，要是没有备份，实验报告和论文就没了）。 为什么要学习 WSLGit 软件本身是跨平台的，为什么不直接在 Windows 上使用 Git，而是在 WSL 上使用 Git 呢？ 我在 WSL 下使用 Git，最大的原因是 Linux 命令行的自动补全： 在 bash 或 zsh 等 shell 中输入 git （git 后有空格）然后按两次 Tab，它会提示接下来可能的命令；输入 git a 然后按两次 Tab，它会提示 a 开头的可能命令；如果输入 git ad （此时 shell 已经能确定是 git add 了）然后按一次 Tab，就会自动补全为 git add 。 bash 自动补全 可以说，自动补全可以大幅降低萌新对命令行的学习成本，而这是 Windows 的 shell —— cmd 和 powershell 都不具备的（这两个只能补全文件名，不能补全命令）。所以，使用 CLI 工具时，我更提倡使用 WSL 作为基础。 当然，为了某些能集成 Windows 下 Git 的应用（如 VS Code、各大 IDE、Tortoise Git 这个第三方 Git GUI），我也在 Windows 下安装了 Git，不过，用 Git 命令行时，我也一直使用的是 WSL 下的 Git。 当然，如果你觉得安装一个 WSL 占空间、太麻烦、不必要，也可以跳过 WSL，体验 Windows 上的 Git。 安利工具 Visual Studio Code 和 Windows TerminalWindows Terminal 是微软（抬头看看俱乐部名）官方推出的终端应用程序（terminal，可以简单地理解是 cmd powershell bash 等 shell 的外壳），美观好看，且启动速度快。 前为 Windows Terminal，后为 Powershell 在这里安利 Windows Terminal 是因为后面将介绍的 WSL 和 Git 都是 CLI（命令行）的形式，因此一款高颜值的终端应用程序是很有必要的~ 一些 Windows Terminal 使用小技巧 为安装了 Windows Terminal 的同学提供一个小练习：输入 cmd 可以启动命令提示符，那么输入什么（不超过三个字母）能启动 Windows Terminal 呢？你可以尝试自行百度 / Google，或自行寻找答案。 Visual Studio Code 是微软（再次抬头看看俱乐部名）官方推出的一款很强大的文本编辑器（注意，不是 IDE），可以替代 Notepad++ 等同类软件，具有开源、集成 terminal、插件众多、UI 好看、开箱即用同时自定义程度高、能同步设置等优点。（最近写微信小程序，发现它的开发软件也是基于 VS Code 魔改的） 我就正在 Visual Studio Code 中编写这篇博客。 套娃警告 在这里安利 Visual Studio Code，是因为它装上插件以后，能和 WSL 无缝衔接，作为 WSL 的文本编辑器，不会使用 vim、nano 等命令行文本编辑器的同学就可以使用 VS Code 作为 WSL 的文本编辑器啦~ 在 wsl 中输入 code 即可启动 VS Code 编辑文本文件 一些 Visual Studio Code 使用小技巧 Windows Subsystem for Linux 下载和安装微软提供了官方中文教程，我就不再赘述了。 对于 WSL1 和 WSL2 的选择，官方也提供了对比文，由于我更常在 WSL 中使用 Git 和 Hexo 对 C 盘的文件进行操作，对“跨 OS 文件系统的性能”需求大，因此选择了 WSL1。 Linux 开发版的选择上，本文将以 Ubuntu 20.04 LTS 作示范。 由于下载安装比较费时间，请各位同学在沙龙开始之前完成 WSL 的安装。之后的部分将在沙龙上讲述，并且会在沙龙后进行更新~ 开始菜单的 Ubuntu 下载完成后，点击开始菜单的 Ubuntu 即可开始安装。 安装过程 如果没有出现上面这个界面，而是显示 0x80004003 或类似错误提示，请读者以 WSL + 错误码作关键字进行搜索，或对照上文中提到的 WSL 官方中文教程。 然后就是初始化账号和密码，这和其他系统安装均类似。注意输入密码时，用户的输入并不会回显在屏幕上，这是为了安全考虑，还请读者不要见怪。 输入账号、密码、确认密码均正确后，即可进入系统，如下。 进入系统 12To run a command as administrator (user \"root\"), use \"sudo &lt;command&gt;\".See \"man sudo_root\" for details. 上面这行字表示，如果需要以管理员身份运行某些命令（如安装软件），需要在命令前加 sudo。这句的效果类似于 Windows 的用户账户控制，授予管理员权限才可以安装程序。 Windows 用户账户控制 如果配置的过程中关闭了初始化用户名和密码的窗口，会导致初始化用户失败，WSL 将以 root 身份（而不是定义的用户）运行。此时可以执行以下命令，卸载 WSL，然后点击开始菜单的 Ubuntu 重新安装。 1wsl --unregister Ubuntu-20.04 其中 Ubuntu-20.04 根据发行版不同而不同，可在 cmd 下使用 wsl -l 命令查询。 Ubuntu 安装软件在 Windows 上，安装软件的方式一般是找到官网的下载页面，下载 exe 或 msi，然后运行。 也有如 360 软件管家这类软件管理工具。 在 Ubuntu 上，使用的是官方的软件管理程序 apt。 apt 下载安装软件的命令为 sudo apt install。下文将演示使用 apt 安装 screenfetch。 在 sudo apt update 之前 sudo apt install screenfetch 和 360 软件管家不同的是，apt 并不会自动在线获取软件的最新信息，而是将这些信息缓存在本地。我们刚完成系统安装，信息都还没有缓存，所以需要手动 sudo apt update。 sudo apt update 接下来就是 sudo apt install screenfetch 了。 sudo apt install screenfetch 安装前提示，需要下载 833 KB 文件，安装后占用 3040 KB 空间。输入 y 继续下一步。然后就是一行行提示划过。到最后如果没有出现报错，即是安装完成。 安装完成 输入 screenfetch 并回车，测试是否成功安装。 screenfetch 请读者自行尝试： 没有 sudo 时执行 apt update 和 apt install screenfetch 会发生什么。 本教程使用的是 Ubuntu 的官方源，可能会出现访问不畅、网速跑不满带宽等情况。于是出现了开源网站镜像站，我们也可以从镜像站获取相同的软件。著名的镜像站有清华、中科大、阿里云。我校也有镜像站，但暂只向校内用户提供访问。请读者尝试自行搜索并更换镜像站。 配置 Git 个人信息和 SSH 秘钥WSL Ubuntu 提供了 Git，因此不需要安装。 首先完成用户身份配置。请将下文的 lyh543 和 lyh543@outlook.com 替换为自己的用户名和邮箱。虽然这步设置并不影响访问权限等，但推荐设置，这样提交中会包含你的用户名和邮箱。 12git config --global user.name lyh543git config --global user.email lyh543@outlook.com 配置好后，使用 git config -l 可查看是否配置成功。 git config -l SSH 协议是 HTTPS 以外，访问 GitHub 的另一协议。 SSH 协议使用公钥、私钥认证，而不是使用密码认证。也就是说，使用 SSH 协议可以省去每次输密码的过程。 大概分为两步： 本地生成密钥对； 设置 GitHub 上的公钥； 生成密钥对使用命令 ssh-keygen。 ssh-keygen 生成过程的文件夹选择、密码均可以直接按回车，默认即可。 公钥 public key 存储在 /home/msc/.ssh/id_rsa.pub，私钥 private key 在 /home/msc/.ssh/id_rsa。 然后使用 cat ~/.ssh/id_rsa.pub 查看你的公钥： cat ~/.ssh/id_rsa.pub 接下来就是将公钥存到 GitHub： 登陆你的 github 帐户。然后 Account Settings -&gt; 左栏点击 SSH Keys -&gt; 点击 Add SSH key 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title 域随意。 点击 Add key。 使用 ssh -T git@github.com 测试一下连接。 123456$ ssh -T git@github.comThe authenticity of host 'github.com (192.30.255.113)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added 'github.com,192.30.255.113' (RSA) to the list of known hosts.Hi lyh543! You've successfully authenticated, but GitHub does not provide shell access. 前三行是因为你的电脑尚未和 GitHub 建立安全连接，需要进行确认以防止中间人攻击。在安全的网络下（比如宿舍等）一般不会出错，而且这些信息都可以在对应公司的官网上查到，如GitHub 的 SSH 密钥指纹。 看到最后一句就是 OK 了。 接下来我们将完成： 把别人的仓库复制一份给自己，这个过程称为 fork 在自己的仓库中提交代码并推送至 GitHub 将自己仓库中的修改发给原仓库，并请求合并，这个过程称为 pull request fork 仓库并 clone 到本地我们想要为别人的仓库贡献代码，但我们并没有别人仓库的写权限。于是，我们可以把别人的代码复制 fork 一份给自己，在自己的仓库修改后，发给别人审核，仓库所有者同意即可合并代码。 Git 本身是没有 fork 的，因此需要在 GitHub 官网上进行 fork。 跳转到别人的仓库，点击 fork 即可。 fork 稍等片刻以后，就可以在自己的账户下看到 fork 的仓库： fork 的仓库 找到 Clone 的链接。我们想要使用 SSH 协议，因此需要复制带 SSH 的链接。 然后在 Ubuntu 中输入 git clone &lt;link&gt;： git clone git@github.com:lyh543/2020-members.git 如果是在 Windows 路径下进行的 clone，可以从 Windows 文件资源管理器看到本地有了 2020-members 文件夹。 提交自己的代码、推送至 GitHub在文件夹中加入自己的代码，然后在 Git 仓库目录下（如果在上面的路径，还需要 cd 2020-members 更改当前文件夹到 2020-members），然后依次执行 123git add --allgit commit -m \"修改了 XX 文件，添加了 YY 文件\"git push 其中 修改了 XX 文件，添加了 YY 文件 将会被记录到这次提交中，可使用 git log 看到。推送后，也可以在 GitHub 的仓库页面看到。 add commit push 这三条命令在 Git 初期学习中，已经足够使用（我接触 Git 的三年内都只用到这三条命令 hhhh）。 至于分支管理等，可以需要的时候、有兴趣的时候再系统性地学。推荐廖雪峰的 Git 教程。 提交 Pull Request将本地的修改推送到自己的远端仓库后，还需要到 GitHub 官网进行 Pull Request。Pull Request 这个命名其实很奇怪，个人更喜欢 GitLab 的叫法 Merge Request，表示请求别人合并你的代码。只是大家 提交 Pull Request 发 PR 叫惯了，就这么叫吧。 在 fork 的仓库的 Pull Request 选项卡下即可新建 Pull Request。 Pull Request 选项卡 在下面的界面选择对应的 head repo 和 branch 为自己的仓库和分支，base repo 和 branch 为目标的仓库和分支。 新建 Pull Request 然后点击 Create Pull Request，输入 title 和 comment（这是方便仓库所有者理解你为什么要发这个 PR，你更新了什么等）即可。 然后就是等仓库所有者读了你的代码以后，如果觉得可以，就会合并进他的仓库了。","tags":[{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"https://blog.lyh543.cn/tags/Visual-Studio-Code/"},{"name":"Git","slug":"Git","permalink":"https://blog.lyh543.cn/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"ssh","slug":"ssh","permalink":"https://blog.lyh543.cn/tags/ssh/"},{"name":"Windows Terminal","slug":"Windows-Terminal","permalink":"https://blog.lyh543.cn/tags/Windows-Terminal/"}]},{"title":"正则表达式（转载）","date":"2020-11-15T06:51:00.000Z","path":"computer-science/regular-expression/","text":"前言先说点别的。一般来说，听到一个计算机科学的名词的中文，可能猜不到这是什么，但是听到英文就很好理解了。 正则表达式（regular expression）这个概念，是少数的，我听了英文以后还猜不知道是什么的概念之一。 正则表达式，又称规则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本。 linux 中支持用正则表达式检索文本的有 sed 和 grep，Python 中有 re 模块，JavaScript 中有 RegExp 对象和 String.match() 等方法。 教程：正则表达式30分钟入门教程 转载：正则表达式30分钟入门教程wegester, 在线正则表达式测试器(JavaScript) 正则表达式手册 转载：正则表达式手册 下面是表中常用的表达式： 匹配位置这类字符匹配位置，不匹配字符。 ^ $：匹配开始和结束 \\b：匹配单词边界 \\B：匹配非单词边界（大写为取反，爱了爱了） 匹配多个字符 {n}：匹配确定的 n 次 {n,}：至少匹配 n 次 {n,m}：匹配至少 n 次，至多 m 次 *：等价于 {0,} +：等价于 {1,} ?：等价于 {0,1} 上述表达式均为贪婪模式（匹配最多的字符）；在表达式后增加 ? （如 {n,m}?）为非贪婪模式（匹配最少的字符）。 匹配字符 .：匹配除 \\n 的单个字符 x|y：匹配 x 或 y 单个字符 [xyz]（字符集合）：匹配所包含的任意一个字符，等价于 x|y|z [xyz]（负值字符集合）：匹配未包含的任意字符 [a-z]（字符范围）：匹配指定范围内的任意字符 [^a-z]（负值字符范围）：匹配任何不在指定范围内的任意字符 匹配字符（转义） \\cx：匹配由 x 指明的控制字符。例如，\\cM 匹配一个Control-M或回车符。x的值必须为[A-Za-z]之一 \\d：匹配一个数字字符。等价于[0-9] \\D：匹配一个非数字字符。等价于[^0-9] \\f \\n \\r \\t \\v：匹配一个换页符、换行符、回车符、制表符、垂直制表符 \\s：匹配任何空白字符，等价于 [ \\f\\n\\r\\t\\v]（注意有一个空格） \\S：匹配上一行以外的字符。等价于 [^ \\f\\n\\r\\t\\v] \\w：匹配包括下划线的任何单词字符。等价于 [A-Za-z0-9_] \\W：匹配上一行以外的字符 \\num：匹配 num，其中num是一个正整数。对所获取的匹配的引用。例如，(.)\\1 匹配两个连续的相同字符。 彩蛋：匹配网址的正则表达式1( regexpTaobao = regexp.MustCompile(`￥([\\w\\s]+)￥`) regexpURL = regexp.MustCompile(`(?:http|https|www)(?:[\\s\\.:\\/\\/]&#123;1,&#125;)([\\w%+:\\s\\/\\.?=]&#123;1,&#125;)`) regexpWhitelist = regexp.MustCompile(`((acg|im9|bili|gov).*(com|html|cn|tv)|(av\\d&#123;8,&#125;|AV\\d&#123;8,&#125;))`) regexpQQ = regexp.MustCompile(`(?:[加qQ企鹅号码\\s]&#123;2,&#125;|[群号]&#123;1,&#125;)(?:[\\x&#123;4e00&#125;-\\x&#123;9eff&#125;]*)(?:[:，：]?)([\\d\\s]&#123;6,&#125;)`) regexpWechat = regexp.MustCompile(`(?:[加+微＋+➕薇？vV威卫星♥❤姓xX信]&#123;2,&#125;|weixin|weix)(?:[，❤️.\\s]?)(?:[\\x&#123;4e00&#125;-\\x&#123;9eff&#125;]?)(?:[:，：]?)([\\w\\s]&#123;6,&#125;)`) )","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"面经集合 - 2020","date":"2020-10-29T16:00:00.000Z","path":"carrers/interview-experience/2020/","text":"推荐搭配 面试相关知识 食用。 2020冬 字节跳动北京 电商后端 日常实习职位链接 第一面面试官因为开会迟到了十分钟（没敢问是不是因为 ByteDance 会议太多了 hhhh），然后他电脑不正常，再重启直接黑屏了（太惨了）。HR 跟我打电话约下次再面，半个小时以后又说电脑修好了可以面了 hhh 这就是我的人生第一面吗 自我介绍 常规题。一定提前写稿子/写提纲。 介绍项目和一个最难的部分 了解到我学过计网、数据库、操作系统以后，就考了这三科的知识（看来实习面试还是挺有弹性的） 操作系统中，用户态和内核态的区别、这样有什么好处 操作系统中，线程和进程的区别 话说这一问还可以多答一点，比如：进程会创建进程控制块 (PCB)，而线程是线程控制块 (TCB)。由于线程没有父子进程、资源控制等结构，所以 TCB 比 PCB 简单得多，这也导致线程的创建比进程的创建快得多，大概有一个数量级的区别。这也是平时开发中，为了利用 CPU 多线程，我们常使用多线程开发，而不是多进程开发的原因。 计算机网络部分：用户从输入 url 到获取到信息过程中发生了什么（越详细越好）a. DNS 解析的过程：计算机先检查 DNS 缓存，如果没有缓存则向 DNS 服务器查询域名对应的 IP，查询的过程分为迭代和递归两种方式；面试官接着问了 DNS 基于什么协议，答案是 UDP，服务器一般使用 53 端口b. 获取到 IP 以后向路由器发包、路由器根据路由表和选路算法进行转发的过程；面试官又问了有那些选路算法（分为域内和域间路由算法，域内有链路状态 LS 和距离向量 DV，域间有 OSPF 和 RIP）；以及路由表的最长前缀匹配原则；c. 再往上就是 TCP 和 UDP 协议了；经典一问：TCP 和 UDP 的区别（TCP 面向连接、拥塞控制、流量控制），顺便还简单问了一下拥塞控制；d. 然后就是 tls 协议；e. 再往上就是最后的 HTTP 协议了。 对 HTTP 状态码的了解 我答了 200、301、302（追问了一下 301 和 302 的区别，以及 301 的实现 我答的是浏览器的实现，复盘的时候觉得他可能是问的 Nginx 的实现？不太明白）、400、403、404、500（追问了一下 502 和 504，但是不大了解，复盘的时候才知道 502 就是 Bad Gateway，504 就是本地代理挂了然而 V2Ray 就是返回 500） 复盘的时候就系统的了解了一下，写了一篇博客 数据库部分，先问了复合索引的知识：若有索引 a, b, c，查询 WHERE a &gt; x AND b = y 能否命中 答案是不能，因为 a, b, c 的含义是先按 a 排序，a 相同的再按 b 排序，这只能命中 a = x AND b &gt; y 的情况。 MySQL 数据库中的事务隔离性如何保证 哇这部分没咋学，考前三天学了，现在早忘了（） 事务需要提交也忘得差不多了，脏读、不可重复读、幻读、丢失更新只记得个名字了。 解决办法也是只记得二段锁的名字，还有一个严格二段锁和强二段锁的名字了。不过由于时间关系，面试官就没有深入追问了。 在一个圆里随机取n个点，它们在同一个半圆的概率是多少？ 想到了第一个点定下来以后，之后的所有点选到同一边的概率是 $\\frac{1}{2^{n-1}}$，但是一看 $n=2$ 时就不对，就凉了。 复盘的时候一看知乎，原来每个点都可以成为第一个点，再乘一个 $n$ 就可以了，答案是 $\\frac{n}{2^{n-1}}$。 缺失的第一个正数：给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。要求时间复杂度 $O(n)$，空间复杂度 $O(1)$。 这题一看就是套路题，我印象中好像做过，但是忘了 GG。 最后还是想起来了（又或者是我自己想出来的呢哈哈哈），不过写了个错误的置换算法，应该 while 的地方我写的是 if。不过样例过了，而面试官似乎也没看出来有问题。 你对我有没有什么想问的 问了问他们部门是干什么的，没想到面试官就开始跟我侃侃而谈，了解到了抖音原来在为直播带货打造电商平台，不然就只能引流到淘宝京东了。也是，我投简历的时候也觉得很奇怪，为什么字节跳动要搞电商，还以为有新的 pdd 呢。 顺便问了一下为什么只要求 PHP、Go、Java、Python、C/C++ 等任意一门编程语言，难道部门里这些语言都会用吗。面试官说，组里一般是用 Go 开发，但是允许进了以后现学，所以不要求有 Go 基础。 总结第一次面试，没想到都是问的一些多多少少有学过或了解过的专业知识，所以也没有那种问一些完全没听说过的东西。 总的看来，对于本科实习生/应届生应聘后端岗，除了数据结构和算法以外，计网、数据库、操作系统很重要，还得好好复习。（计组、汇编什么的偏硬件了，就不用了 2333） 这次的面试一面就没过，看来还是太菜了（也可能是概率题、编程题都没做对叭）。有时间最好把计网、数据库、操作系统补一下。 2020冬 腾讯深圳 后台开发 日常实习职位链接 第一面 自我介绍 给定数组，除了一个数出现一次外，所有数都出现两次，并且所有出现两次的数都挨着（不过面试官并没有明说题面，只是给了一堆数）。请找出找出那个出现一次的数。 我以为是 落单的数 I，兴奋到没有观察到“所有出现两次的数都挨着”，即答异或，$O(n)$ 空间复杂度。 面试官问我时间复杂度能不能再低一点，我直接懵掉。面试官就让我直接看下一题了。 然后面试结束以后五分钟就想到了 GG 可参考落单的数 IV -LintCode，不过这题似乎 LintCode 删掉了，LeetCode 也正好没有这题。可能是版权问题？ 最大子矩阵。这题目很眼熟，但是我复杂度一直算不对，面试官一直在纠正我（太菜了 面试官先让我说暴力的时间复杂度，我即答“枚举左上角和右下角，共$O(n^4)$”。面试官反问那计算矩阵值呢？我忘算了，应该是$O(n^6)$。 然后说优化，我想到了二维前缀和。前缀和的过程是 $O(n^2)$，所以我又即答时间复杂度 $O(n^2)$。后来面试官问算完前缀和然后呢，我一想还是得枚举左上角和右下角，是 $O(n^4)$ 的。啊这 面试官让我写一下由二维前缀和求矩阵的表达式，大概就是 ans[x1][y1][x2][y2] = cumsum[x2][y2] + cumsum[x1][y1] - cumsum[x1][y2] - cumsum[x2][y1]。这个没问题。 然后面试官说能不能再优化时间复杂度。我想了一下，应该是类似于最大子序列和的思想，把枚举遍历变成最大子序列和的 dp 方法。在一个方向上用这个思想优化应该挺容易，在另一个方向上还能优化吗？我边说边想，面试官说不用了，优化到 $O(n^3)$ 已经可以了。 感情我之前答错时间复杂度成 n 方的时候，他以为我发现了一个什么 nb 的算法啊，怪不得还让我详细讲讲 [LeetCode] 505. The Maze II 迷宫之二；现在 LeetCode 上已经要收费了，看看别人的博客凑合吧。就是非常基础的 BFS/DFS。面试官让我实现了一下。虽然没有一遍过样例，但还是靠 cout 调试法调试过了。 C++ 特性 shared_ptr 不了解（我 C++ 学完类以后就一直在用 MATLAB 和 Python 了） C++ 特性 vector 前面那个我就没听清，这个我也没听清是什么，干脆直接回答不知道得了，后来复盘的时候突然发现原来他写了。。。而且我还真会。。。 线程和进程的区别 经 典 复 现（见 2020冬 字节跳动 电商后端 一面） 然后就是问了一下之前的项目经历，有的会问的比较细节，比如五子棋 AI 的决策树一共写了几层。看来有时间还得得复盘项目。 总的来说， 得找时间复盘一下之前写的项目了 C++ 特性也得学，之前学完 C++ 课以后，就滚去搞算法和数模了，都没有深入 C++ 了（诶我不是面的后端吗 为什么要问这么多 C++ 特性） 第二面 自我介绍 vector 变长数组的实现？ 大概就是涉及到动态扩容到一个新的区域，然后将原来的东西拷贝过去。然后接着问，能不能自己设计一个不需要反复拷贝的变长数组。emmm 我答了一个类似于二级页表的结构，不过第二层是元素的数组而不是指针的数组。 没有写代码，但是面试官问能不能释放空间呢？我说不大能删。不过复盘的时候突然想到，可以完全使用页表那样的指针实现。需要释放空间就可以释放掉了。 148. 排序链表。 对链表进行排序，其实就是归并排序嘛。之前大概知道是用归并，不过没有写，之前也没有写过。 实现上，要从链表结点的结构定义开始写，所以写了一会。索性花了整整 45 分钟，借助 cout 调试法（牛客的网页 IDE 不允许断点调试），最后写出来了。第一次就写出来了，还是蛮有成就感的。 50. Pow(x, n)。其中保证 $n$ 是整数。注意，如果出现溢出，就输出最接近的一个 double 值。 原题我做的很顺，但是判定溢出以及最接近值我真不会。于是问能不能搜，说可以。于是在 power 函数中 return ans; 改为了： 1return isinf(ans) ? (std::numeric_limits&lt;double&gt;::max()) : ans; 不过由于时间关系就没有写 min 的情况了。 另外就是，我本来是用一层递归搞定了负次幂的情况，但是他说最好不要递归。未免太严格了吧。 最后就是 testcases 的问题，让我自己写一堆 testcases，自动判断正确与否。虽然当时想的是简单测一下就交，没想到这里。确实，学到了学到了。 谈谈你对自己优点、缺点的看法。 啊这，套路题了。但是我没准备，只随便答了一点。下次一定准备。 你有没有什么想问的 这次下来全是算法题，没有考计算机专业的其他东西。不过 testcases 确实受益匪浅。下次一定用。 总结最后还是通过面试啦~有点开心，毕竟是第一次通过面试。不过因为是在深圳（我投递的时候专门写了工作在成都并且不接受调配，没想到还是分配到深圳了），最近新冠疫情，不敢乱窜，于是就算啦。 这次面试的经验，一是和字节不同，腾讯更多考的是算法，所以刷 LeetCode 还是很有用的。二是 C++ 语法糖尽量还是要会（可我上完 C++ 课以后，主要就是用 MATLAB 和 Python 了，C++ 应该不是必须的吧）不过要是需要的话，还是可以去把 C++ Primer Plus 重新看一遍的。 2020冬 腾讯成都 WXG 后台开发 日常实习接上文，正好前几天参加腾讯成都 Openday 加了腾讯成都 HR 的微信，就问了一下能不能转岗或者重新面试。HR 告诉我还有一点 HC，于是就重新面试啦~ 第一面这次问的东西有点多，可能没记全 自我介绍 下为 C++ 的方面：描述一下 static 用过哪些 STL 库 C++ 其实最近都没咋用了，数模那段时间用 MATLAB、微信小程序用 JavaScript。 我就答了几个 ACM 常用的模板：vector、map、set、unordered_map(unordered_set)、list、sort。看来有时间一定把 C++ Primer Plus 刷一遍。 map 和 unordered_map 的区别。前者是红黑树实现，后者是 HashMap，二者在时间复杂度上有差异。 map 和 multimap 的区别。前者每个 key 只能在 map 中出现一次，后者可以出现多次。所以前者可以使用 m[key] 的形式访问 value，后者只能 m.find(key) 访问任意一个 iterator，或使用 m.equal_range(key) 返回该值的范围（左闭右开）。 C++11 C++14 的特性了解过哪些。 啊这 不用 C++ 真不了解。我就答了一个 lambda 表达式，面试官追问了一下 lambda 捕获的含义。 数据库方面：用过哪些数据库 操作系统的方面：描述一下进程间消息传递 虽然在 OS 课上学了消息传递，但我们的消息传递是为互斥服务的，也没有作为重点讲，所以当时没意识到他问的消息传递就是我学的为互斥服务的那个。 Linux 系统的方面：用过哪些命令 这个问没答好，一是没准备，二是紧张所以只说了基础的几个。其实应该让他举一个场景，让我我写相关命令。 计网方面：描述一下从浏览器输入网址后回车，到接收到服务器响应之间的过程（经典复现，见 2020 冬字节跳动） TCP 和 UDP 有什么区别 描述一下自己写的某个项目 编程题：进制转换 将一个长度最多 30 位数字的十进制非负整数转换为二进制数并输出。 第一反应就是反复进行高精度除法，但是高精度做的话时间复杂度是 $O(n^2)$，感觉会有 $O(n)$ 的算法，想了半天没想出来，跟面试官说了，最后面试官也没让我写。最后复盘发现就是原题！噔噔咚 面试官没让我写这个正确的算法，可能他也没听说过高精度除法，也不知道题解的正确复杂度相比之下，腾讯深圳的面试官还会让我算复杂度，还告诉我没有更简单的复杂度了hhhh 编程题：打印N个数组整体最大的Top K 给定 N 个有序数组，要求从大到小打印这 N 个数组整体最大的前 K 个数，要求时间复杂度是 $O(k \\log k)O(klogk)$，空间复杂度为 $O(k \\log k)O(klogk)$ 第一反应也是堆排序，类似于归并链表，对每个数组最大的元素维护堆，pop 出最大的数后，将来源数组的接下来的数加入堆。 问题就在于，原题中没保证 $N \\leq K$。当 $N&gt;K$ 时，该算法的时间复杂度变为 $O(N\\log N)$，和题目不符。面试的时候，写完了以后纠结了好一会，但是感觉题目不会这么难，于是就直接跟面试官说写完了。后来去牛客网交，过了。 只能说，牛客 OJ 这次给我的体验就是，题目质量有点不行。 总结计网数据库 OS 都考的话，基本又是啥都能答一点，但是又答不对。算法题也有一个题没写，感觉很像是字节跳动的一面。感觉会凉。 最后果然是凉了，只能说太菜了。也是，因为不是必须实习，加上寒假还有学习计划、下学期还有课，所以没有太准备面试。 正式秋招的时候一定认真复习计网、数据库、操作系统，有时间的话还可以看看 C++11、C++14 的特性。","tags":[{"name":"打工人","slug":"打工人","permalink":"https://blog.lyh543.cn/tags/%E6%89%93%E5%B7%A5%E4%BA%BA/"},{"name":"面经集合","slug":"面经集合","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E7%BB%8F%E9%9B%86%E5%90%88/"}]},{"title":"Python 爬虫 —— Selenium","date":"2020-10-27T14:19:33.000Z","path":"python/selenium/","text":"文档Selenium Webdriver 简易教程 - wizardforcel Selenium with Python中文翻译文档 前言某些网站的反爬虫机制通过按钮、跳转等功能，能够防止最简单的 requests 爬虫。 Selenium WebDriver 是一个测试框架，提供了 Java、Python 等语言的 API，可以用一种更底层、更灵活的方式来操作浏览器，模拟人在浏览器上的操作。可用于 Web 应用的测试，当然也可以用于自动化批量操作（管理员批量部署、爬虫）等等。 同时，需要下载 ChromeDriver 或使用 FireFox 浏览器。 使用我编写的一个爬虫项目代码中出现的用法已经足狗应用于很多情形了。 初始化12from selenium import webdriverdriver = webdriver.Chrome() 我将下载的 ChromeDriver 放在 main.py 同目录下（似乎也可以放在 PATH 下），执行命令后出现了一个 Chrome 测试窗口。 Chrome 测试窗口 调用这里是我在项目中使用的爬虫代码。 123456789101112131415161718192021222324252627282930313233343536373839url = \"https://240334.yichafen.com/public/queryscore/sqcode/OsTcknwmMjkzfGZlYWYyOTQ1YjA5YmM1ZTQxOGQzMmY1NTdiYzNlYjI2fDI0MDMzNAO0O0OO0O0O.html\"def get_score(name: str, student_id: str) -&gt; str: driver.implicitly_wait(1) # 等待一秒 driver.get(url) # GET 指令 driver.refresh() # 刷新 # 根据 XPath 寻找元素，XPath 可在 Chrome 检查元素中，对元素右键 - 复制 - 复制 XPath 得到 student_id_element = driver.find_element_by_xpath(\"//input[@name='s_xuehao']\") student_id_element.clear() # 清空输入框 student_id_element.send_keys(student_id) # 填入学号 name_element = driver.find_element_by_xpath(\"//input[@name='s_xingming']\") name_element.clear() name_element.send_keys(name) # 填入姓名 # 找到按钮 button = driver.find_element_by_xpath(\"//*[@id='yiDunSubmitBtn']\") button.click() # 单击按钮 driver.implicitly_wait(0.5) # 等待 0.5s try: assert(driver.find_element_by_xpath(\"//*[@id='result_content']/div[2]/table/tbody/tr[2]/td[1]\").get_attribute(\"innerHTML\") == student_id) assert(driver.find_element_by_xpath(\"//*[@id='result_content']/div[2]/table/tbody/tr[2]/td[2]\").get_attribute(\"innerHTML\") == name) except: raise ValueError(\"%s %s 信息不对应\" %(name, student_id)) # 找到需要的文本对应的 XPath，获取其文本 return driver.find_element_by_xpath(\"//*[@id='result_content']/div[2]/table/tbody/tr[2]/td[3]\").get_attribute(\"innerHTML\")if __name__ == '__main__': driver = webdriver.Chrome() with open('input.csv') as input: for line in input: name, student_id = line.strip().split(',') score = get_score(name, student_id) print(\"%s,%s,%s\" % (name, student_id, score)) with open('output.csv', 'w') as output: output.write(\"%s,%s,%s\\n\" % (name, student_id, score)) 更多文档可见 Selenium with Python中文翻译文档。","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://blog.lyh543.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"LeetCode 合集","date":"2020-10-27T11:12:57.000Z","path":"cpp/leetcode/leetcode-problems/","text":"记录一些有意思的题。 经典算法二分搜索34. 在排序数组中查找元素的第一个和最后一个位置二分搜索的加强版 4. 寻找两个正序数组的中位数算是非常经典又非常复杂的一道题了。我的算法和官方题解稍有不同，可以康康（我的题解）： 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: //尝试在 nums1 中找中位数，seq 从 0 开始 int findNum(const vector&lt;int&gt;&amp; nums1, const vector&lt;int&gt;&amp; nums2, int seq) &#123; int left = 0, right = nums1.size() - 1; while (left &lt;= right) &#123; // assert left &lt;= ans &lt;= right int mid = (left + right) / 2; int mid_2 = seq - mid; // 如果 mid 是中位数，mid_2 应当大于等于 mid，mid_2-1 应当小于等于 mid if (mid_2 &lt; 0 || (mid_2 &lt; (int)nums2.size() &amp;&amp; nums2[mid_2] &lt; nums1[mid])) &#123; right = mid - 1; &#125; else if (mid_2 - 1 &gt;= (int)nums2.size() || (mid_2 - 1 &gt;= 0 &amp;&amp; nums2[mid_2 - 1] &gt; nums1[mid])) &#123; left = mid + 1; &#125; else return nums1[mid]; &#125; return findNum(nums2, nums1, seq); // 反向在 2 数组中找 &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int n1 = nums1.size(), n2 = nums2.size(); if ((n1 + n2) % 2 == 1) return findNum(nums1, nums2, (n1 + n2) / 2); else return (findNum(nums1, nums2, (n1 + n2) / 2) + findNum(nums1, nums2, (n1 + n2) / 2 - 1)) / 2.0; &#125;&#125;; 线性数据结构时间线、区间调度问题这类问题一般是给定很多时间区间（区间的起始时间、终止时间），讨论一定的问题。 这类问题一般可以用贪心/动态规划解，贪心之前需要进行排序。 1024. 视频拼接求覆盖完整个范围所需子区间的最小值。 结论：按结束时间降序排序，然后从前往后遍历（遍历的时候需要同时考虑其结束时间是否超过了当前开始时间、其开始时间是否比下一次的开始时间更远）。 56. 合并区间结论：按开始时间升序排序，能够合并的区间一定连续。 还有一种巧妙的做法，注意到线段重合等价于 a[1] &gt;= b[0] || b[1] &gt;= a[0]，于是我们重载 set 的比较类： 123456struct Cmp &#123; bool operator() (const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) const &#123; return a[1] &lt; b[0]; &#125;&#125;; 用这个比较类定义的 set 中，如果两个线段重合，这两个线段在 set 中是被认为相等的！ 1234567891011121314151617181920212223242526struct Cmp &#123; bool operator() (const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) const &#123; return a[1] &lt; b[0]; &#125;&#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; set&lt;vector&lt;int&gt;, Cmp&gt; s; for (auto interval : intervals) &#123; auto iter = s.find(interval); while (iter != s.end()) &#123; interval[0] = min(interval[0], (*iter)[0]); interval[1] = max(interval[1], (*iter)[1]); s.erase(iter); iter = s.find(interval); &#125; s.insert(interval); &#125; return vector&lt;vector&lt;int&gt;&gt;(s.begin(), s.end()); &#125;&#125;; 并查集 并查集：721. 账户合并 带权并查集：399. 除法求值 树树的遍历（非递归）先序遍历1234567891011121314151617// 先序遍历 144vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; stack&lt;TreeNode*&gt; s; s.push(root); while(!s.empty()) &#123; TreeNode * cur = s.top(); s.pop(); if (cur == nullptr) continue; ans.push_back(cur-&gt;val); s.push(cur-&gt;right); // 先将右节点入栈，再将左节点入栈，妙啊 s.push(cur-&gt;left); &#125; return ans;&#125; 中序遍历123456789101112131415161718192021222324// 中序遍历 94vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; stack&lt;TreeNode*&gt; s; //牢记“左链入栈”：每遍历到一个点 p，就 push(p); p = p-&gt;left; TreeNode* p = root; while(p != nullptr) &#123; s.push(p); p = p-&gt;left; &#125; while(!s.empty()) &#123; p = s.top(); s.pop(); ans.push_back(p-&gt;val); p = p-&gt;right; while(p != nullptr) // 继续“左链入栈” &#123; s.push(p); p = p-&gt;left; &#125; &#125; return ans;&#125; 后序遍历123456789101112131415161718192021// 后序遍历 145// （调换左右结点遍历顺序后）进行前序遍历，得到的结果反向输出即可vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; list&lt;int&gt; ans_reverse; vector&lt;int&gt; ans; stack&lt;TreeNode*&gt; s; s.push(root); while(!s.empty()) &#123; TreeNode * p = s.top(); s.pop(); if (p == nullptr) continue; ans_reverse.push_front(p-&gt;val); // 从头插入结点 p s.push(p-&gt;left); // 由于是反向输出，所以左右节点入栈的顺序也与先序遍历相反 s.push(p-&gt;right); &#125; for (int i: ans_reverse) ans.push_back(i); return ans;&#125; 统一写法还有一种写法，统一了三种遍历，只需改变入栈的顺序。 链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/comments/495211 动态规划动态规划的题，emmm 做多了就明白套路了，做少了的话，还是多看答案，然后自己写吧。注意勤复习。 877. 石子游戏两人博弈取石子，dp[i][j] 指取完 i 到 j（闭区间）的石子后，先手比后手高的分数。dp 转移方程中由于有先后手的交换，会有 dp[][] = piles[] - dp[][] 的出现。 1000. 合并石头的最低成本NOI 1995 石子合并，非常经典的区间 dp。dp[i][j] 表示将 i 到 j（闭区间）的石子合并为一堆所需的最小总代价，而 for 中还需要一维表示在哪里合并。 312. 戳气球类似于合并石子的区间 dp，但注意由于这道题的 dp 转移方程中包含两端的气球值，所以 dp 转移方程有些不同，但同样是需要三个 for 的。 1234567891011121314int maxCoins(vector&lt;int&gt;&amp; nums) &#123; const int n = nums.size(); nums.insert(nums.begin(), 1); nums.push_back(1); vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0)); //dp[i, j] 表示戳爆 [i, j] 间的所有气球的最高总得分 for (int len = 0; len &lt; n; len++) for (int start = 1, end = start + len; end &lt;= n; start++, end++) for (int i = start; i &lt;= end; i++) // 此次戳爆第 i 个气球 dp[start][end] = max( dp[start][end], dp[start][i - 1] + dp[i + 1][end] + nums[start - 1] * nums[i] * nums[end + 1] ); return dp[1][n];&#125; 41. 接雨水一道印象很深的题，因为题面非常直观。 84. 柱状图中最大的矩形题面很像接雨水。 另外 85. 最大矩形 也用到了这个题的算法。 数学题线性筛204. 计数质数 每个合数 t 只会在 j=t最大的质因数, i=t/j 时被筛掉。 123456789101112131415161718192021class Solution &#123;public: int countPrimes(int n) &#123; vector&lt;bool&gt; is_prime(n, 1); vector&lt;int&gt; primes; for (int i = 2; i &lt; n; i++) &#123; if (is_prime[i]) primes.push_back(i); for (int j : primes) &#123; if (i*j &gt;= n) break; is_prime[i*j] = 0; if (i % j == 0) break; &#125; &#125; return primes.size(); &#125;&#125;; 不过面试一般不会要求这么高吧，会基础的埃氏筛应该就可以了；而且 巧妙的算法41. 缺失的第一个正数置换法 实现上需要注意细节，如需要使用 while 反复交换（我第一次使用的是 if）；交换的终止条件是 arr[n] != arr[arr[n]-1] 而不是 n != arr[n]-1（后者会被 [1, 1] 这种数组卡掉）。 8. 字符串转换整数 (atoi)这个题虽然可以写一堆 if，但是官方题解的有限自动机让我眼前一亮。有空一定实现一次。 巧妙的 C++ 语法std::stoiC 提供 int atoi(const char *)，而对于 string 类型，想要使用 aoti 只能使用 const char * string::c_str() 方法。不过，也可以使用 int std::stoi(const string &amp;)： 12string str = \"-233\";atoi(str.c_str()) == stoi(str); // true string::substr1string substr (size_t pos = 0, size_t len = npos) const; 总是要忘记它的定义。string::npos 的值为从 pos 到字符串最后的长度。 集合的交集349. 两个数组的交集 Python 版本就非常简洁： 12def intersection(nums1, nums2): return list(set(nums1) &amp; set(nums2)) 没想到 C++ 也自带集合求交，见set-集合运算。 巧妙的数据结构单调栈简单、好用的数据结构。 数据结构上，递减栈为从栈底往栈顶依次递减的栈（栈里可存元素，也可以存数组下标）。算法上，一个数入栈前，将小于等于它的数全部出栈。 对于某些要计算“某数后面第一个比他大/小的数”的题目，有奇效，如 739. 每日温度。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; stack&lt;int&gt; s; // 递减栈 vector&lt;int&gt; ans(T.size()); for (int i = T.size() - 1; i &gt;= 0; i--) &#123; while(!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) &#123; s.pop(); &#125; ans[i] = s.empty() ? 0 : s.top() - i; s.push(i); &#125; return ans; &#125;&#125;; 单调队列和单调栈相对应的就是单调队列了。 数据结构上，递减队列为从队首往队尾依次递减的双向队列（队列里存数组下标），其本质是类似于单调栈，但是由于题目常常加了一个长度限制，所以也需要让元素从前面出队。 算法上，一个数 i 入队列前， （如果有，）将超出边界的队首元素出队 pop_front()； 将小于等于 i 的队尾元素全部出队 pop_back()。 计算滑动窗口（一个固定大小的区间）的最值有奇效，如 239. 滑动窗口最大值。 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; q; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); i++) &#123; if (!q.empty() &amp;&amp; q.front() &lt;= i - k) q.pop_front(); // 因窗口大小而出队 while (!q.empty() &amp;&amp; nums[q.back()] &lt;= nums[i]) q.pop_back(); // 因小于当前值而出队 q.push_back(i); if (i &gt;= k - 1) ans.push_back(nums[q.front()]); &#125; return ans; &#125;&#125;; 双堆：数据流中位数对于求数据流/滑动窗口的题目，可以维护 大顶堆放小一半的数 + 小顶堆放大一半的数（保证两堆大小相等或大顶堆比小顶堆大 1），两堆的顶就是中位数。 数据流的中位数 滑动窗口中位数 对于滑动窗口，由于有删除的需求，可以使用 multiset 替代堆。 在维护左右大小的时候，如果分情况讨论会非常复杂，不如 push/remove 的时候先保证两堆大小相等或大顶堆比小顶堆大 1，然后再检查是否符合大顶小于小顶，不符合就交换。这样思路更清晰，代价时间复杂度的常数变大了。 12345678910111213141516171819202122232425262728293031323334353637// 数据流的中位数，使用双堆实现class MedianFinder &#123;public: priority_queue&lt;int&gt; big_heap; // 存小的数，保证大小等于 small_heap，或比 small_heap 多一 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; small_heap; // 存大的数 void swap_top() &#123; int b = big_heap.top(); big_heap.pop(); int s = small_heap.top(); small_heap.pop(); big_heap.push(s); small_heap.push(b); &#125; void addNum(int num) &#123; // 保证两堆大小相等或大顶堆比小顶堆大 1 if (big_heap.size() == small_heap.size()) big_heap.push(num); else small_heap.push(num); assert(big_heap.size() == small_heap.size() || big_heap.size() == small_heap.size() + 1); // 检查是否符合大顶小于小顶，不符合就交换。 if (small_heap.size() &gt; 0 &amp;&amp; big_heap.top() &gt; small_heap.top()) swap_top(); assert(small_heap.empty() || big_heap.top() &lt;= small_heap.top()); &#125; double findMedian() &#123; if (big_heap.size() == small_heap.size()) return ((double)big_heap.top() + (double)small_heap.top()) / 2; else return big_heap.top(); &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 滑动窗口中位数，使用双 multiset 实现class MedianFinder &#123;public: multiset&lt;int, greater&lt;int&gt;&gt; big_heap; // 存小的数，保证大小等于 small_heap，或比 small_heap 多一 multiset&lt;int&gt; small_heap; // 存大的数 // 检查是否符合大顶小于小顶，不符合就交换。 void make_balance() &#123; if (small_heap.size() &gt; 0 &amp;&amp; *big_heap.begin() &gt; *small_heap.begin()) &#123; big_heap.insert(big_heap.end(), *small_heap.begin()); small_heap.insert(small_heap.end(), *big_heap.begin()); big_heap.erase(big_heap.begin()); small_heap.erase(small_heap.begin()); &#125; assert(small_heap.empty() || *big_heap.begin() &lt;= *small_heap.begin()); &#125; void insert(int num) &#123; // 保证两堆大小相等或大顶堆比小顶堆大 1 if (big_heap.size() == small_heap.size()) big_heap.insert(num); else small_heap.insert(num); assert(big_heap.size() == small_heap.size() || big_heap.size() == small_heap.size() + 1); make_balance(); &#125; void remove(int num) &#123; // 保证两堆大小相等或大顶堆比小顶堆大 1 if (num &gt; *big_heap.begin()) &#123; assert(small_heap.find(num) != small_heap.end()); small_heap.erase(small_heap.find(num)); if (big_heap.size() - 2 == small_heap.size()) &#123; small_heap.insert(small_heap.end(), *big_heap.begin()); big_heap.erase(big_heap.begin()); &#125; &#125; else &#123; assert(big_heap.find(num) != big_heap.end()); big_heap.erase(big_heap.find(num)); if (big_heap.size() + 1 == small_heap.size()) &#123; big_heap.insert(big_heap.end(), *small_heap.begin()); small_heap.erase(small_heap.begin()); &#125; &#125; assert(big_heap.size() == small_heap.size() || big_heap.size() == small_heap.size() + 1); make_balance(); &#125; double findMedian() &#123; if (big_heap.size() == small_heap.size()) return ((double)*big_heap.begin() + (double)*small_heap.begin()) / 2; else return *big_heap.begin(); &#125;&#125;;class Solution &#123;public: vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; MedianFinder mf; vector&lt;double&gt; ans; for (int i = 0; i &lt; k; i++) mf.insert(nums[i]); ans.push_back(mf.findMedian()); for (int window = 0; window + k &lt; nums.size(); window++) &#123; mf.remove(nums[window]); mf.insert(nums[window+k]); ans.push_back(mf.findMedian()); &#125; return ans; &#125;&#125;;","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.lyh543.cn/tags/LeetCode/"}]},{"title":"NumPy","date":"2020-10-13T06:36:42.000Z","path":"python/numpy/","text":"NumPy for MATLAB users作为 MATLAB 用户，本想写一篇对比 NumPy 和 MATLAB 语法的博客。但是一想，网上应该有不少类似文章。一搜，居然 NumPy 官方也提供了文章。 NumPy for MATLAB users Table of Rough MATLAB-NumPy Equivalents 文章里面提到： MATLAB 矩阵用 1 作为起始下标，而 Numpy 则类似于 Python，使用 0 作为起始下标 MATLAB 中的切片操作是对复制的数组进行操作，而 NumPy 的切片是原矩阵的引用。 如需进行复制，请使用 B = A.copy() 如下 Python 代码，B 作为 A 的切片，修改 B 会使得 A 变化： 1234567891011121314In [2]: A = np.array([[1,2,3]])In [3]: AOut[3]: array([[1, 2, 3]])In [7]: B = A[0,:-1]In [8]: BOut[8]: array([1, 2])In [10]: B[0] = 2In [12]: AOut[12]: array([[2, 2, 3]])","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"NumPy","slug":"NumPy","permalink":"https://blog.lyh543.cn/tags/NumPy/"}]},{"title":"用 GitHub Actions 自动化发布 Hexo 网站到 GitHub Pages（转载）","date":"2020-09-28T13:03:29.000Z","path":"blog/use-github-actions-to-deploy-hexo/","text":"转载自：用GitHub Actions 自动化发布Hexo网站到GitHub Pages - 掘金 之前我已经习惯了自己在本地部署 Hexo 并 push，也写过一个一键 push 到博客部署仓库和博客仓库的 shell 脚本，如下： 123456789101112131415161718#!/bin/bashechoecho pushing to lyh543/lyh543.github.io.backupechogit add --allgit commit -m \"update on $(date +%c)\"git push origin# 当存在任意参数，如调用时使用 `./hexop 1` 时，则不会 push 到博客部署仓库if [ -z $1 ]; then echo echo pushing to lyh543/lyh543.github.io echo hexo d -gfi 一直这么用着，也没有觉得比 GitHub Actions 麻烦很多，直到当我有同时在笔记本和台式上写博客的需求。deploy 到 GitHub 过程中，如果此次部署的电脑和上次不同，会导致博客部署仓库的 Git 提交记录冲突，必须使用 forced update，导致每次都需要把所有文件重新传一份。 于是开始学习了 GitHub Actions。发现还不错。而且网上也有现有的部署 Hexo 的中文教程可用。下面转载这篇文章，并加入自己的理解。 准备 Hexo 网站在本地建立一个 Hexo 站点，可以参考官方快速开始文档。 建立两个 GitHub 仓库，分别叫 blog（私有的，名字可自取）和 your_github_username.github.io（公有的）。前者用来存储博客源文件，后者用于存储博客部署文件。这里我选择 lyh543.github.io.backup 存储博客源文件，lyh543.github.io 存放博客部署文件。 两个仓库最终的效果 然后将本地的博客源文件推送到 lyh543.github.io.backup 仓库。 准备 SSH 秘钥为了方便运行 GitHub Actions 时登录 GitHub 账号，我们使用 SSH 方式登录。 在本地使用 ssh-keygen 生成一组公私秘钥对： 1ssh-keygen -t rsa -b 4096 -f ~/.ssh/github-actions-deploy 生成了公钥 ~/.ssh/github-actions-deploy.pub 和私钥 ~/.ssh/github-actions-deploy。 在 GitHub 的 Settings-&gt;SSH and GPG keys 添加刚刚生成的公钥，名称随意。 在 lyh543.github.io 仓库的 Settings-&gt;Secrets 里添加刚刚生成的私钥，名称为 ACTION_DEPLOY_KEY。 如果在 Hexo deploy 过程中还需要 sftp 部署到服务器，则还需要在服务器添加私钥：在本地执行 ssh-copy-id -i ~/.ssh/github-actions-deploy.pub root@you-server-ip.com。 设置 Hexo 的部署配置在 _config.yml 添加部署配置： 1234567891011121314151617# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: github: git@github.com:lyh543/lyh543.github.io.git branch: master# 如果有 sftp 部署到服务器的需求，则可将下面的部分取消注释# - type: sftp# host: your-server-ip.com# user: root# # pass: &lt;password&gt;# remotePath: /var/www/html/blog# port: 22# privateKey: /home/runner/.ssh/id_rsa # runner 是 GitHub Actions 的 username（这里不能使用 ~ 代替 /home/runner）# # passphrase: [passphrase]# # agent: [path/to/agent/socket] 配置 GitHub Actions在 lyh543.github.io.backup 仓库的 Actions 选项卡下点击新建 workflow，编写如下配置。 123456789101112131415161718192021222324252627282930313233343536373839name: Deploy Blogon: [push] # 当有新push时运行jobs: build: # 一项叫做build的任务 runs-on: ubuntu-latest # 在最新版的Ubuntu系统下运行 steps: - name: Checkout # 将仓库内master分支的内容下载到工作目录 uses: actions/checkout@v1 # 脚本来自 https://github.com/actions/checkout - name: Use Node.js 10.x # 配置Node环境 uses: actions/setup-node@v1 # 配置脚本来自 https://github.com/actions/setup-node with: node-version: \"10.x\" - name: Setup Hexo env env: ACTION_DEPLOY_KEY: $&#123;&#123; secrets.ACTION_DEPLOY_KEY &#125;&#125; run: | # set up private key for deploy mkdir -p ~/.ssh/ echo \"$ACTION_DEPLOY_KEY\" | tr -d '\\r' &gt; ~/.ssh/id_rsa # 配置秘钥 chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts # ssh-keyscan your-server-ip.com &gt;&gt; ~/.ssh/known_hosts # 如果需要 sftp，则还需要注释掉一行 # set git infomation git config --global user.name 'lyh543' # 换成你自己的邮箱和名字 git config --global user.email 'lxl361429916@live.com' # install dependencies npm i -g hexo-cli # 安装hexo npm i - name: Deploy run: | # publish hexo generate &amp;&amp; hexo deploy # 执行部署程序 新建 Workflow 直接将配置复制覆盖左边的编辑框的内容即可。名称可自取。然后在本地 git pull。 之后就可以在 GitHub Actions 看到这次部署了。 GitHub Actions","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.lyh543.cn/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog.lyh543.cn/tags/GitHub/"},{"name":"转载","slug":"转载","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"Excel 将数字转为文本","date":"2020-09-28T03:31:11.000Z","path":"microsoft/excel/convert-number-to-text/","text":"Excel 中一个很麻烦的事情就是将数字转为文本。 如果能够在存数据之前，将单元格格式设置为文本，就很方便。 但是，如果已经存了数据，将单元格格式再设置为文本，原来的数据也不会改变其形式（如下图），除非点击每一个框进行/重新计算。 文本形式的数据仍然是科学计数法 因此很是麻烦。 参考EXCEL如何把数值批量转换成文本？ - 简书，个人使用第一种方法成功。 使用分列功能在Excel中，分列功能不仅仅可以根据需求把单列数据分成多列，还可以修改数据格式。 步骤： 选中数据 单击【数据】-【下一步】-【下一步】-【文本 确定后，就可以发现数据格式变为文本了 小技巧：默认情况下，数字靠右边是数值；数字靠左边是文本 使用分列功能将数字转为文本 我转换后的效果： 转换后的效果","tags":[{"name":"Excel","slug":"Excel","permalink":"https://blog.lyh543.cn/tags/Excel/"}]},{"title":"数模国赛答辩相关","date":"2020-09-27T08:21:43.000Z","path":"mcm/cumcm-oral-defenses/","text":"前天晚上突然通知我们去参加数模国赛的答辩，有点受宠若惊，因为和队友三个人都是第一次参赛，大家也都很菜，觉得拿一个省一就已经可以了。参加答辩，意味着我们保国二冲国一了。大家都是第一次参加国赛答辩，在这两天了解到了不少，也把经验分享给各位。 本篇讲的是 2020 年国赛四川赛区的答辩经验，对于今后和其他赛区的答辩，仅供参考。 答辩注意事项 答辩的目的是在于证明文章是你写的，而不是要进行评级国一还是国二！这一点非常重要。也就是说， 你只需要证明论文是你写的就行，不需要证明论文、模型的正确性；当老师问你这个模型有问题，而模型确实有问题，大大方方承认就行了，顺便可以解释一下自己是怎么想的。 也不需要准备太充分，因为这并不会决定你是国一还是国二，你和其他参赛者不是竞争关系，只需要通过就可以了，没有内卷。 不要暴露自己的学校！！！不管是台上还是台下。答辩台上绝对不要暴露自己的学校，如果暴露了，不怀好意的老师可能就会针对你，问很难的问题。在台下，也不要向其他同学透露自己的学校（我当时就说我是北大的hhhh），也最好不要向带队老师等本校老师打招呼。 自我介绍：“我们是 Cxxx 队，我是 xxx，我是 yyy，我是 zzz”。队号一定要说，人名也可以说。 三个人会一同站在一个小教室的讲台上，老师们在台下。可以一个人讲，也可以大家都讲。要自信。 不需要做 PPT，答辩的时候队伍的论文会被提前拷贝到讲台的电脑上，三个同学都可以操作电脑。几位老师手里也有一份论文，在答辩前老师是阅读过你们的论文的。 答辩过程中，自己主要讲论文主要思想、方法、结果。 答辩过程，自己讲 + 老师提问一共约 10-15 分钟。也有会一直问问题甚至超时，导致后面的队的答辩都延时了（我们组本来是 10:40 答辩，最后拖到了 11:00）；也可能问几分钟就好了。 老师如果认可你的方法/结果，提问就少；不认可，提问就多。 如果老师不说话，就一直讲；如果老师提问打断，就回答老师问题。 所以最好还是提前准备好 10-15 分钟的答辩思路。 实际上，在我们小组答辩时，刚说完开场白，老师就直接让我们翻到论文 13 页，提问模型二以及求解模型的代码。问完了这个模型（大概过了 7 分钟），就结束了23333 如果老师指定 xxx 人讲，也可以说“这部分具体的细节我不是很了解，可以让 yyy 来答”。只要别三个人都不会就行。 最后再次重复强调，答辩的老师只辨真伪，不辨等级。对于尖锐的问题，不要和老师吵起来。老师说是错的，如果真的错了，就承认自己写错了。反正是我自己算的/我自己写的就行。 其他注意事项 答辩可能在其他学校 检查身份证、学生证（二者缺一不可） 注意有没有签到，有的是进考场的时候签到，有的是在答辩之前签到 着装不作特别要求，整齐即可 回答模板这里提供一个模板： 谢谢老师提的问题。下面请允许我对这个问题作出解释。xxxx（如果真的是有问题）当时时间紧促，这里确实有一点小问题。下来我们会进行改进。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://blog.lyh543.cn/tags/%E6%9D%82%E8%B0%88/"},{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"FFmpeg （萌新向）","date":"2020-09-26T09:56:33.000Z","path":"others/ffmpeg/","text":"急速裁剪视频（不重新编码）开始接触 ffmpeg 就是在裁剪视频长度的时候。Premier、格式工厂、Windows 照片自带的裁剪等软件都需要对视频进行重新编码。而 ffmpeg 则可以通过设置参数 -c copy，在创建视频的时候不重新编码，这样的好处是裁剪的过程基本就是文件复制的过程，CPU 不再成为性能瓶颈，SSD 上速度是真滴快。 1ffmpeg -i input.mp4 -ss 00:01:00 -t 01:00:00 -c copy output.mp4 -i 参数指定输入文件，-ss 指定开始裁剪的时间，-t 指定裁剪总长度，-c 指定编码格式。 改变码率和分辨率 限制码率：使用参数 -b 2M 将视频平均码率限制在 2Mbps。 修改视频分辨率：使用参数 -vf scale=640:480，或省略一个参数 -vf scale=-1:480，程序将自动按比例缩放。 1ffmpeg -i input.mp4 -b 2M -vf scale=-1:720 output.mp4 需要注意的是，过低的码率会导致画质变低，甚至出现花屏。 使用 CUDA 加速重新编码软件查看可使用的硬件加速： 12345678&gt; ffmpeg -hwaccels:: 略过一堆输出Hardware acceleration methods:cudadxva2qsvd3d11vavulkan 这里由于使用的是 N 卡，于是确定使用 cuda。 确定编码格式和对应的编码器，带了 nv 的基本就是 NVIDIA 的编码/解码器： 12345678&gt; ffmpeg -codecs | find \"nv\":: 略过一堆输出 D.V.L. dsicinvideo Delphine Software International CIN video DEV.LS h264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (decoders: h264 h264_qsv h264_cuvid ) (encoders: libx264 libx264rgb h264_amf h264_nvenc h264_qsv nvenc nvenc_h264 ) DEV.L. hevc H.265 / HEVC (High Efficiency Video Coding) (decoders: hevc hevc_qsv hevc_cuvid ) (encoders: libx265 nvenc_hevc hevc_amf hevc_nvenc hevc_qsv ) D.V.L. idcin id Quake II CIN video (decoders: idcinvideo ) D.VIL. wnv1 Winnov WNV1 D.AIL. twinvq VQF TwinVQ 我们使用 H.265(HEVC) 格式编码，用 CUDA 加速编码过程。于是选择使用 hevc_nvenc 作为编码器。 最后写命令： 1ffmpeg -hwaccel cuda -i input.mp4 -c:v hevc_nvenc output.mp4 其中 -c 参数放在 -i 后，表示修改编码格式（在 -i 前则是解码格式）；-c:v 是修改视频编码格式。 如果提示 Nvidia 驱动版本太低，需要更新驱动。 下载 m3u8m3u8 是一种流媒体格式，常用于在线观看、直播等。如腾讯课堂的回看就是以这个格式提供的。 网上有不少 m3u8 下载器，我一直使用的是 nilaoda/M3U8-Downloader。我也知道它用到了 ffmpeg，不过一直以为它只是做了视频合并。 今天使用某 APP 时，刚开始没有找到现成的将加密 m3u8 转为 mp4 的轮子，于是自己想按照博客 手写一个 shell 脚本实现。但看到最后，没想到 ffmpeg 还能一行（从网络或从本地）下载 m3u8 并转为单文件！nb！ 下面给出三个版本的用法（一般采用第一个就行，最快）： 12345678# 不重新编码ffmpeg -allowed_extensions ALL -i \"URL\" -c:v copy output.mp4# 使用默认编码进行编码（应该是 h264 吧）ffmpeg -allowed_extensions ALL -i \"URL\" output.mp4# 使用 CUDA 编码为 h265ffmpeg -allowed_extensions ALL -hwaccel cuda -i \"URL\" -c:v hevc_nvenc output.mp4 -allowed_extensions ALL：m3u8 可能涉及到加密，需要读取 .key 秘钥文件；而 ffmpeg 默认不让读取媒体格式以外的格式，所以需要加这个参数允许读取所有格式； &quot;URL&quot;：替换为本地路径或 HTTP URL 均可。也可以用 wget 或 curl 将 URL 中的 m3u8 源文件下载下来，再运行 ffmpeg； output.mp4：输出文件，没什么好说的。","tags":[]},{"title":"远程过程调用（Remote Procedure Call）","date":"2020-09-17T13:38:24.000Z","path":"computer-science/remote-procedure-call/","text":"推荐阅读：https://zhuanlan.zhihu.com/p/36427583 远程过程调用 Remote Procedure Call 这个词的每一部分都有其含义，拆开理解： 调用：调用某些函数、功能、API 等 过程：面向过程，而不是 RESTful 的面向资源。 远程：调用的部分不来自一个程序、同一块内存，而是调用其他程序（如通过网络端口调用本地数据库、远程数据库甚至分布式数据库）","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"RESTful API 标准","date":"2020-09-15T13:33:43.000Z","path":"back-end/restful-api-standard/","text":"文章部分内容转自：https://www.colabug.com/2017/0627/228298/ REST 是一种软件架构风格，如果你们的接口是 REST 接口，那么就可被认为你们的的接口是 RESTful 的，英文名词和形容词的区别。 REST 接口是围绕“资源”展开的，利用 HTTP 的协议。其实 REST 本也可以和 HTTP 无关，但是现在大家普遍的使用 REST 都是依托于HTTP协议。 URL 语法RFC 3986定义了通用的URI语法： 1URI = scheme “://” authority “/” path [ “?” query ][ “#” fragment ] scheme: 指底层用的协议，如 http、https、ftp host: 服务器的 IP 地址或者域名 port: 端口，http 中默认 80 path: 访问资源的路径，就是咱们各种 web 框架中定义的 route 路由 query: 为发送给服务器的参数 fragment: 锚点，定位到页面的资源，锚点为资源id RESTful API 设计资源路径对于资源的定义，即 URL 的定义，是最重要的；想要设计出优雅的、易读的 REST 接口，其实还是很不容易的。 URL 中不能有动词在 RESTful 架构中，每个网址代表的是一种资源，所以网址中不能有动词，只能有名词，动词由 HTTP 的 get、post、put、delete 四种方法来表示。 URL 结尾不应该包含斜杠 /这是作为 URL 路径中处理中最重要的规则之一，正斜杠 / 不会增加语义值，且可能导致混淆。REST API 不允许一个尾部的斜杠，不应该将它们包含在提供给客户端的链接的结尾处。 许多Web组件和框架将平等对待以下两个URI： 12http://api.canvas.com/shapes/http://api.canvas.com/shapes 但是，实际上URI中的每个字符都会计入资源的唯一身份的识别中。 两个不同的 URI 映射到两个不同的资源。如果 URI 不同，那么资源也是如此，反之亦然。因此，REST API 必须生成和传递精确的 URI，不能容忍任何的客户端尝试不精确的资源定位。 有些 API 碰到这种情况，可能设计为让客户端重定向到相应没有尾斜杠的 URI（也有可能会返回301 – 用来资源重定向）。 正斜杠分隔符 / 必须用来指示层级关系url 的路径中的正斜杠 / 字符用于指示资源之间的层次关系。 例如： 12345http://api.user.com/schools/grades/classes/boys– 学校中所有的男生http://api.college.com/students/3248234/courses– 检索id为3248234的学生学习的所有课程的清单。 应该使用连字符 - 来提高 URL 的可读性，而不是使用下划线 _为了使 URL 容易让人们理解，请使用连字符 _ 字符来提高长路径中名称的可读性。 一些文本查看器为了区分强调 URI，常常会在 URI 下加上下划线。这样下划线 _ 字符可能被文本查看器中默认的下划线部分地遮蔽或完全隐藏。 为避免这种混淆，请使用连字符 - 而不是下划线 URL路径中首选小写字母RFC 3986 将 URI 定义为区分大小写，但 scheme 和 host components 除外。 URL路径名词均为复数为了保证 url 格式的一致性，建议使用复数形式。 RESTful API对资源的操作对于 REST api 资源的操作，由 HTTP 动词表示 CURD 操作 GET：获取资源 POST：新建资源 PUT：在服务器更新资源（向客户端提供改变后的所有资源） PATCH：在服务器更新资源（向客户端提供改变的属性，一般不用，用 PUT） DELETE：删除资源 资源过滤在获取资源的时候，有可能需要获取某些“过滤”后的资源，例如指定前10行数据 1http://api.user.com/schools/grades/classes/boys?page=1&amp;page-size=10 返回状态码推荐标准HTTP状态码有很多服务器将返回状态码一直设为 200，然后在返回 body 里面自定义一些状态码来表示服务器返回结果的状态码。由于 REST api 是直接使用的 HTTP 协议，所以它的状态码也要尽量使用 HTTP 协议的状态码。 200 OK 服务器返回用户请求的数据，该操作是幂等的 201 CREATED 新建或者修改数据成功 204 NOT CONTENT 删除数据成功 400 BAD REQUEST 用户发出的请求有问题，该操作是幂等的 401 Unauthoried 表示用户没有认证，无法进行操作 403 Forbidden 用户访问是被禁止的 422 Unprocesable Entity 当创建一个对象时，发生一个验证错误 500 INTERNAL SERVER ERROR 服务器内部错误，用户将无法判断发出的请求是否成功 503 Service Unavailable 服务不可用状态，多半是因为服务器问题，例如CPU占用率大，等等 更多的可以参考维基百科，或者这篇博客。 具体情形具体分析REST API 是一个非常宏大的问题，只能说具体情形具体分析。 一个方法是参考现有的代码或后端框架等等，如 Django REST Framework 提供的教程就是一个带有简单权限管理的 Snippet。 还有一个方法就是在 Stack Overflow 上搜索你的行为 + REST API 或 http status code，会出现大量的结果供参考，如 logout http status code 会搜到关于注销应当返回什么，返回的状态码是否有意义这类问题。 登录和登出 登录和登出应该使用不同的路径，如 /login 和 /logout。Stack Overflow 登录和登出都应该使用 POST 方法，这是为了防浏览器预加载，以及防止搜索引擎的爬虫。Stack Overflow 登出操作完成后应当返回一个 HTTP 204 No Content 报文，虽然这对大部分前端都没什么用，但是说不定真的有人需要用接收报文作时间戳什么的。Stack Overflow 重置密码Stack Overflow 中给出了相当多的方案：","tags":[{"name":"后端","slug":"后端","permalink":"https://blog.lyh543.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"RESTful","slug":"RESTful","permalink":"https://blog.lyh543.cn/tags/RESTful/"}]},{"title":"汇编语言与微机接口技术 课程笔记","date":"2020-09-08T06:52:38.000Z","path":"computer-science/assembly-language-and-interface-technology-of-microcomputer-classnote/","text":"授课老师：廖建明老师 教材：《微机原理与接口技术》(第4版). 吴宁,乔亚男主编. 清华大学出版社 参考教材:《汇编语言程序设计》. 廖建明主编.清华大学出版社 第一章 微型计算机基础概论计算机的工作原理计算机中的指令执行过程：取指令 -&gt; 指令译码 -&gt; 读取操作数 -&gt; 执行命令 -&gt; 存放结果 计算机基本组成结构 指令的顺序工作方式和并行流水线工作方式 冯 • 诺依曼计算机的工作原理： 存储程序工作方式 运算器为核心 特点： 存储程序，共享数据，顺序执行； 属于顺序处理机，适于确定的算法和数值处理。 不足： 与存储器间有大量数据交互，对总线要求很高； 执行顺序由程序决定，对大型复杂任务较难处理； 以运算器为核心，处理效率较低；由PC控制执行顺序，难以进行真正的并行处理。 非冯 • 诺依曼计算机：并行性 微机系统组成 微处理器：运算器单元+控制器单元+寄存器单元+内部总线，具有CPU全部功能的大规模集成电路芯片。 微型机：微处理器+内存+I/O接口+系统总线+电源+输入/输出设备+外存设备 微机系统：微型机+系统软件+应用软件 第二章 微处理器8086/8088 特点、工作模式特点：并行流水线、内存空间分段管理、多处理器系统 工作模式：最小（单处理器，不必接总线控制器）/最大（多处理器，需总线控制器） 最小模式下的总线连接示意图 最大模式下的总线连接示意图 工作模式选择：$MN/\\overline{MX}$引脚 $MN/\\overline{MX}=0$：最大模式 $MN/\\overline{MX}=1$：最小模式 8086/8088 引线及功能地址线和数据线 $AD0-AD7$：低 8 位地址和低 8 位数据信号（分时复用）。传送地址时单向，传送数据时双 $A8-A15$：8位地址信号 $A16-A19/S3-S6$：高4位地址信号，与状态信号分时复用 $\\overline{WR}$：写信号 $\\overline{RD}$：读信号 $IO/\\overline{M}$：访问内存/访问接口 $\\overline{DEN}$：低电平有效时，数据总线上数据有效，允许进行读/写操作 $DT/\\overline{R}$(Data Transmit/ Receive)：为“1”时 CPU 向存储器或 I/O 传送，否则为反向 $ALE$：地址锁存信号，当其为高时表示地址线上地址有效。一般用它将地址锁存到一个锁存器中 $RESET$：复位信号。当其为高时将完成CPU内部复位。复位后CPU内部寄存器的值如下表 复位后 CPU 的内部寄存器状态 例题 $READY$：外部同步控制输入信号，高电平有效（8088 与内存/外设之间在一个总线周期内的时钟配合信号） 中断请求和响应信号 $INTR$：可屏蔽中断请求输入端 $NMI$： 非屏蔽中断请求输入端 $\\overline{INTA}$：中断响应输出端 总线保持信号 $HOLD$：总线保持请求信号输入端。当 CPU 以外的其他设备要求占用总线时，通过该引脚向 CPU 发出请求（外设 -&gt; CPU） $HLDA$：总线保持响应信号输出端。CPU 对 HOLD 信号的响应信号（CPU -&gt; 外设） 8088 和 8086 CPU 引线的差异 数据总线宽度不同 8088的外部总线宽度是8位，8086为16位。 访问存储器和I/O控制的信号含义不同 8088——$IO/\\overline{M}=0$ 表示访问内存； 8086——$\\overline{IO}/M=1$ 表示访问内存。 8088/8086 内部结构 执行单元 EU 总线接口单元 BIU 8086CPU结构 执行单元 EU 组成： ALU 8 个通用寄存器 1 个标志寄存器 EU 部分的控制电路 功能： 指令译码 指令执行 暂存中间运算结果 保存运算结果特征 总线接口单元 BIU 组成： 地址加法器 4 个段寄存器 指令指针 IP 总线控制逻辑 功能： 从内存中取指令到指令队列（指令队列是并行流水线工作的基础） 负责与内存或 I/O 接口之间的数据传送 在执行转移程序时，BIU 清除指令队列，从指定的新地址取指令，并立即传给执行单元执行 8088/8086 内部寄存器 16 位寄存器 8个通用寄存器 4个段寄存器 2个控制寄存器 通用寄存器 数据寄存器：AX、BX、CX、DX AX 分为 AH:AL，以此类推 AX: Add BX: Base 基址寄存器 CX: Count 计数 DX: Data 在间接寻址的 I/O 指令中存放 I/O 端口地址 在 32 位乘除法运算时，存高 16 位数 地址指针寄存器：SP、BP SP: Stack Pointer 栈顶的偏移地址 BP: Base Pointer 基址指针寄存器，访问内存时存放内存单元的偏移地址 BX BP 作为通用寄存器，二者均可用于存放数据 作为基址寄存器，用 BX 表示所寻找的数据在数据段；用 BP 则表示数据在堆栈段 变址寄存器 Index Register：SI、DI 存放数据在内存中的地址 SI (Source Index)：源 DI (Destination Index)：目标 控制寄存器 IP (Instruction Pointer)：指令指针寄存器，其内容为下一条要执行指令的偏移地址 FLAGS：CF、SF、AF、PF、OF、ZF、IF、TF、DF CF (Carry Flag)：进位标志位 SF (Signal Flag)：符号标志位 AF (Auxility Flag)：辅助 CF。若 Bit3 向 Bit4 有进位(借位)，AF=1 Bit 号从 0 开始，用中文描述就是第四位向第五位有进位。 在 16 位加法中，AF 仍然是 Bit3 向 Bit4 进位的结果。详见 assembly - how to set auxiliary flag for 16bits binary addition - Stack Overflow PF (Parity Flag)：奇偶标志位，运算结果的低 8 位中 1 的个数为偶数时 PF=1 OF (Overflow Flag)：溢出标志位 ZF (Zero Flag)：零标志位 TF (Trap Flag)：陷阱标志位，TF=1 使 CPU 处于单步执行指令 IF (Interrupt Flag)：允许中断标志位 DF (Direction Flag)：方向标志位。在数据串操作时确定操作的方向。 例题 段寄存器 作用：用于存放相应逻辑段的段基地址 8086/8088 内存中逻辑段的类型：代码段、数据段、附加段、堆栈段 8086/8088 内存中逻辑段的数量 最多为 64K 个 程序中同时可以使用4个段，分别由CS、DS、ES和SS四个段寄存器指示。 CS (Code Segment)：代码段寄存器，存放代码段的段基地址。 DS (Data Segment)：数据段寄存器，存放数据段的段基地址。 ES (Extended Segment)：附加段寄存器，存放数据段的段基地址。 SS (Stack Segment)：堆栈段寄存器，存放堆栈段的段基地址。 段寄存器 8088/8086 存储器组织内存地址分为物理地址、逻辑地址。 物理地址：8086/8088 CPU有 20 根地址线，它可以产生 20 位的地址码，寻址范围为 $2^20$，即 1 兆字节空间。 字单元：任何两个相邻字节单元构成，16 bits 子单元地址：字节较小地址 存放规则：小端 例题 32-bit 逻辑地址 = 16-bit 段基地址 :（拼接） 16-bit 段内地址 20-bit 物理地址：16-bit 段基地址 *16+ 16-bit 偏移地址 段首的偏移地址 = 0000H 例题 8086/8088 的存储器段结构的特点 段大小 &lt;= 64KB 段首地址为一个小节的首地址 小节：每 16 Bytes 为一小节 小节的首地址最低位为 0000 逻辑段在物理上可能是：可邻接的、间隔的、部分重叠的或完全重叠的 在任一时刻，一个程序只能访问4个当前段中的内容 例题 逻辑地址、物理地址转换物理地址 = 段基地址 &lt;&lt; 4 + 偏移地址 例题 堆栈堆栈： 特定的存储区，访问该存储区一般需要按照专门的规则进行操作 主要用于暂存数据以及在过程调用或处理中断时保存断点信息 一般分为专用堆栈存储器和软件堆栈 专用堆栈存储器：按堆栈的工作方式专门设计的存储器 软件堆栈：由程序设计人员用软件在内存中划出的一块存储区作为堆栈来使用。8086/8088采用这种方式。堆栈组成： 栈底：固定，是堆栈存储区最大地址单元 栈顶：浮动，是最后存入信息的存储单元 栈顶指针 SP：指示栈顶单元 数据在堆栈中以字（16 bits）为单位小端存放 初始化时，SP = 栈底 + 2 = 堆栈长度 堆栈长度 &lt;= 64KB SP 始终表示堆栈段基址与栈顶之间的距离 程序设置多个堆栈段 堆栈 例题 8088 系统总线总线 Bus：是一组导线和相关的控制、驱动电路的集合，它是计算机系统各部件之间传输地址、数据和控制信息的通道。 分类： 地址总线 AB 数据总线 DB 控制总线 CB 最小模式下的系统总线 最小模式下不需要 8288 总线控制器，而最大模式下需要。 8282：锁存器，连接地址线（因为要和数据线复用，所以要配合 ALE 将地址存进锁存器） 8284：时钟发生器 8286：双向总线驱动器，连接（内外部的）数据总线 最大模式下的系统总线 8288：总线控制器，支持 CPU *****总线时序、总线周期 时序：CPU各引脚信号在时间上的关系 总线周期：CPU 完成一次访问内存(或I/O接口)操作所需要的时间 一个总线周期至少包括 4 个时钟周期 8088最小模式下的读周期 T1上 输出地址 T1下 锁地址 T2 输出状态，设置 $\\overline{RD}$、$\\overline{DEN}$ T3 输入数据 T4 复位，关状态输出 但这个状态在最小模式中没有用，在最大模式中才会用到（ 8088最小模式下的写周期 写的区别除了 $\\overline{WR}$、$DT/\\overline{R}$、外，还有 AD 线在地址输出结束后必须立即进行数据输出。 IA-32 微处理器和工作方式Intel公司将 80286 之后的 80X86 32 位微处理器称为 IA(Intel Architecture)-32 结构（现在是 AMD64） IA-32 微处理器历史应该不是重点，所以就比较略了。 80286 实地址模式、虚地址保护模式 CPU 被分为： 总线部件 BU 地址部件 AU 执行部件 EU 指令部件 IU 80386 实地址模式、保护模式和虚拟 8086 模式 CPU 被分为： 总线接口单元 BIU 指令预取单元 IPU 指令译码单元 IDU 执行单元 EU 分段单元 SU 分页单元 PU 分页存储 80486 突发传送方式（成块数据传送） Pentium 与80X86系列微处理器兼容 RISC型超标量结构（处理器包含多个指令单元和指令流水线） 高性能浮点运算器 双重分离式高速缓存（分离指令缓存和数据缓存） 64位数据总线 分支指令预测 常用指令固化与微代码改进（把常用的指令改用硬件实现，而不使用微程序方式） 系统管理方式程序 SMM（电源管理、为操作系统和正在运行的程序提供安全性） IA-32 主要寄存器通用寄存器：8 个 32 位通用寄存器 通用寄存器 指令指针和标志寄存器： 指令指针和标志寄存器 段寄存器和系统地址寄存器： 段寄存器和系统地址寄存器 控制寄存器： 控制寄存器 IA-32 处理器工作方式实模式 兼容 8086 32条地址线中只有低20条地址线起作用，可寻址1MB的物理地址空间 无多任务处理 保护模式 32条地址可寻址4GB的物理存储器空间 支持虚拟存储器功能。每个任务运行可以有16K个段，每个段最大为4GB，一个任务最大可使用64TB虚拟地址空间 程序运行分为4个特权等级，操作系统核心运行在最高特权级0，用户程序运行在最低特权级3 虚拟 8086 模式 在虚拟8086方式下，IA-32微处理器总体上是工作在保护虚地址方式，支持多用户多任务操作系统。其中，有的任务可以工作在虚拟8086方式，运行DOS应用程序。 保护模式下的存储器访问 ] 本章小结 本章小结 8088 相关知识： 地址线、数据线、控制线若干 16 位寄存器（各个的中文？） 8个通用寄存器：AX、BX、CX、DX、SP、BP、SI、DI 4个段寄存器：CS、DS、ES、SS 2个控制寄存器：IP、FLAGS (CF、SF、AF、PF、OF、ZF、IF、TF、DF) 存储器 32-bit 逻辑地址 = 16-bit 段基地址 拼接 16-bit 段内地址 20-bit 物理地址：16-bit 段基地址 *16+ 16-bit 偏移地址 堆栈：栈底固定，为地址最大值；以字为单位 第三章 指令系统概述（略）寻址方式这里讲的是 8086 的寻址方式，《计算机组成原理》讲的是 MIPS 的，因此会有区别。 除了立即寻址、寄存器寻址、隐含寻址，其余寻址方式都是得到 偏移地址 以后 +16*段地址 得出，并且这些方式都会加 [ ]。 立即寻址 立即寻址 寄存器寻址 寄存器寻址 直接寻址偏移地址 = 立即数 直接寻址 直接寻址下，存储器操作数的长度由指令中另一个操作数的长度决定。如 MOV [1234H], CX MOV CL, [1234H] 直接寻址方式下，操作数的段地址默认为数据段 但允许段重设，即由指令定义段，说明数据存放在其他逻辑段中 MOV AX, ES:[1200H] 指令将 ES:[1200H] 的数存入 AX 这种情况称为段超越，所加的段寄存器叫段前缀 寄存器间接寻址偏移地址 = 寄存器值 寄存器间接寻址 “偏移地址”只能来自于间址寄存器(BX, BP, SI, DI) 间址寄存器必须为 16-bit registers “段地址”取决于基址寄存器 BX, SI, DI -&gt; DS BP -&gt; SS 但允许段超越 记忆上，就记 BP base pointer 作用类似于 SP stack pointer，都是用来指栈的某个位置。其余都是指 DS。 寄存器相对寻址偏移地址 = 寄存器值 + 立即数 寄存器值同样来自于 BX、BP、SI 或 DI 基址-变址寻址偏移地址 = 基址寄存器值 + 变址寄存器值 “段地址”取决于基址寄存器 BX -&gt; DS BP -&gt; SS（在计算题中，不要无脑使用 DS 作段地址！！！BP 需要使用 SS） 常用于一维数组 例 基址-变址-相对寻址偏移地址 = 基址寄存器值 + 变址寄存器值 + 立即数 段地址同上 常用于二维数组 例 五种寻址方式的总结 五种寻址方式的总结 除立即寻址、寄存器寻址、隐含寻址外，其余都是计算得到偏移地址，然后在 BIU 中的地址加法器运算（+16*基地址）得到物理地址。 隐含寻址指令中隐含了一个或两个操作数的地址，即操作数在默认的地址中。 12MUL BL; AX = AL * BL 数据传送指令通用数据传送注意：该类指令的执行对标志位不产生影响 一般数据传送指令 MOV12MOV dest, src; 读取 src 并保存到 dest 注意事项： 各 FLAGS 一般不作为操作数在指令中出现 两操作数长度必须相同 OFFSET、SEG 等运算符得到的值可视为立即数 某些方向是不能传输数据的，具体看图 MOV指令的传送方向示意图 可以用两条记忆： 立即数和 CS 不能做 dest（显然） 立即数和段寄存器如果想传送到别的段寄存器，必须经过通用寄存器中转。 顺便一提，立即数可以不经过寄存器、直接传入存储器。但由于立即数的长度不定，可能需要显式指明存储器的长度，如 MOV BYTE PTR[BX], 233H。参见 PTR 运算符。 例题：判断下列指令的正确性： 12345678MOV AL, BX ; 错误，长度不一致MOV AX, [SI]05H ; 对MOV [BX][BP], AX ; 错误，同时使用两个基址寄存器MOV DS, 1000H ; 错误，常数不能直接送段寄存器MOV DX, 09H ; 对，立即数位数不够，会自动补齐MOV [1200H], [SI] ; 错误，dst 和 src 不能同时为存储器MOV AX, CS ; 对MOV DS, CS ; 错误，段寄存器之间不能传送 例：将符号“*”的ASCII码2AH送入内存数据段中以变址指针DI所指的单元再偏移100个字节单元中： 12MOV AL, '*'MOV 100[DI], AL 堆栈操作指令 PUSH POP1234PUSH OPRD; 压栈POP OPRD; 出栈 注意事项： 堆栈操作以字为单位，故操作数必为 16 位 操作数不能是立即数 操作数可以来自寄存器或存储器 若为存储器操作数，需要声明为字存储单元 不能 POP 到 CS，这是上面的知识 PUSH 顺序是从高地址向低地址，看下图 压栈过程 出栈过程 交换指令 XCHG123; XCHG REG/MEM, REG/MEMXCHG AX, BXXCHG [2000], CL 注意事项： 两操作数至少有一个是寄存器操作数 不允许使用段寄存器 字位扩展指令 CBW CWD 将带符号数的符号位 (0/1) 扩展 Convert 到高位； 零操作数指令，采用隐含寻址，隐含的操作数为 AX 或者 “AX与DX” 1234CBW; 将 AL 的符号位扩展到 AH (Convert Byte to Word); 若 AL 最高位=1，则执行后 AH = FFH; 若 AL 最高位=0，则执行后 AH = 00H 1234CWD; 将 AX 符号位扩展到 DX (Convert Word to Doubleword); 若 AX 最高位=1，则执行后 DX = FFFFH; 若 AX 最高位=0，则执行后 DX = 0000H 判断以下指令执行结果： 1234567891011MOV AL, 44HCBW; AX = 0044HMOV AX, 0AFDEHCWD; DX = 0000HMOV AL，86HCBW; AX = FF86H 输入输出指令 IN OUT 专门面向I/O端口操作的指令 输入指令：IN acc, PORT 输出指令：OUT PORT, acc PORT 为端口地址，acc 为累加寄存器 AL 或 AX 可以认为指令的第一个参数是目的地址 dest，这和 MOV 保持一致。 PORT 的寻址方式： 直接寻址 端口地址为 8 位时，指令中直接给出 8 位端口地址 可寻址 256 个端口 间接寻址 端口地址为 16 位时，指令中的端口地址必须由 DX 指定 可寻址 64K 个端口 例： 123456IN AX, 80HMOV DX, 2400HIN AL, DXOUT 35H, AX 地址传送指令 LEA LDS LES取偏移地址指令 LEALEA (Load Effective Address)：将一个存储单元的 16 位偏移地址取出送 16 位通用寄存器（常为间址寄存器）。 1LEA REG, MEM 类似于 MOV，但 MOV 取的是存储器值，而 LEA 取的是存储器的偏移地址。 MOV 和 LEA 对比 123456789101112MOV SI, DATA1; 这里的 DATA1 是变量; SI = DATA1 中的内容LEA SI, DATA1; SI = DATA1 的偏移地址MOV BX, [BX]; BX = BX 作为偏移地址对应的值LEA BX, [BX]; BX 不变 变量的知识见变量。 看起来 LEA 有点蠢，但其是有存在意义的：当寻址方式比较复杂（如基址-变址-相对寻址），LEA 能一行获取其地址，但 MOV 指令则不行，因为 MOVWhat’s the purpose of the LEA instruction? - Stack Overflow。 一道简单的例题：将数据段中首地址为 MEM1 的 50 字节的数据传送到同一逻辑段首地址为 MEM2 的区域存放。 流程图 代码如下： 12345678910 LEA SI, MEM1 LEA DI, MEM2 MOV CL, 50NEXT: MOV AL, [SI] MOV [DI], AL INC SI INC DI DEC CL JNZ NEXT HLT ; halt，暂停执行 眼睛：我没学会脑子：我也没学会 看不懂就下来再看看。 LEA 不访问存储器，而下面的 LDS、LES 要访问存储器。 装入地址指针指令 LDS LES12LDS DEST, SRCLES DEST, SRC 作用：把 SRC 存储单元开始的 4 个字节单元的内容送入 DEST 通用寄存器和段寄存器 DS（LDS指令）或 ES（LES指令） 低 16 位送 DEST，一般是送 SI 或 DI 高 15 位送 DS/ES 例题 执行后，SI=0020H，DS=5030H。 标志位操作指令LAHF SAHF LAHF (Load Flags to AH)：将 FLAGS 的低 8 位装入 AH LAHF SAHF (Save Flags to AH)：执行与LAHF相反的操作 PUSHF POPF PUSHF：将 FLAGS 压栈 POPF：将栈顶弹出给 FLAGS 算术运算类指令标志位影响这类指令的执行大多对状态标志位会产生影响。 参考：http://www5.zzu.edu.cn/qwfw/info/1044/2483.htm教材上并没有写 AND 指令会改变 SF 等，然后练习题考了hhhhh，真离谱 影响标志位 影响六个 (CF, SF, AF, ZF, PF, OF) 影响五个 (不影响 CF) 影响五个 (不影响 AF) 影响两个 (CF, OF) 影响一个 (CF) 不影响 指令 ADD/ADC/SUB/SBB/NEG/CMP, CMPS/SCAS INC/DEC AND/OR/XOR/TEST, SAL/SAR/SHL/SHR MUL/IMUL ROL/ROR/RCL/RCR DIV/IDIV NOT, MOV, IN/OUT 加法加法指令对操作数的要求与 MOV 指令基本相同： 源操作数可以是通用寄存器、存储单元或立即数 目的操作数只能是通用寄存器或存储单元，不能是立即数 二者不能同时来自存储器。 带符号加法 ADD12ADD OPRD1, OPRD2; OPRD1 = OPRD1 + OPRD2 目的地址依旧是第一个，类似于 MOV。 ADD 指令的执行对全部 6 个状态标志位都产生影响 例： 123MOV AL, 78HADD AL, 99H; 试写出指令执行后的结果 结果及标志位 带进位加法 ADCADC (ADd with Carry) 可用于实现多字节数（大数）相加。 12ADC OPRD1, OPRD2; OPRD1 = CF + OPRD1 + OPRD2 例：求两个大数的和，两个数的长度为 20 字节，首地址为 M1 和 M2。 1234567891011 LEA SI, M1 LEA DI, M2 MOV CX, 20 CLC ; 使 CF = 0NEXT: MOV AL, [SI] ADC [DI], AL INC SI ; SI、DI 自增 INC DI DEC CX ; CX 自减 JNZ NEXT ; Jump if（当运算结果） Not Zero HLT 自增 INC12INC OPRD; OPRD = OPRD + 1 OPRD 可以来自存储器，不能来自段寄存器或立即数 INC 指令执行不影响 CF 标志，只影响其他五个 为什么 INC（以及 DEC）不影响 CF 标志呢？据 Stack Overflow，这并不是为了节省成本，而是为了循环的 i++ 等不会影响到 CF 标志位。上段 ADC 处举的例子就很好的说明了这一点：如果 INC 改变了 CF，程序必须在每次完成 ADC 后存储 CF 的状态，否则就会被 INC 覆盖，代码会麻烦得多。 减法带符号减法 SUB12SUB OPRD1, OPRD2; OPRD1 = OPRD1 - OPRD2 SUB 指令的执行对全部 6 个状态标志位都产生影响（同 ADD） 带借位减法 SBB类似于 ADC： 12SBB OPRD1, OPRD2; OPRD1 = OPRD1 - OPRD2 - CF SBB (SuBtraction with Borrow)：指令格式、对操作数的要求、对标志位的影响与 SUB 指令完全一样 自减 DEC类似于 INC： 12DEC OPRD; OPRD = OPRD-1 OPRD 不能是段寄存器或立即数 DEC 不影响 CF 例 1：实现一个计数循环程序，下面的代码正确吗？ 123456 MOV AL, 10HLOP: DEC AL JNC LOP ; Jump if Not CF; 错误！ DEC 不影响 CF; 程序会执行一次后停止（如果原来 CF = 1）; 或死循环 （如果原来 CF = 0） 例 2 是一个两层的嵌套循环： 1234567 MOV BL, 2NEXT1: MOV CX, 0FFFFHNEXT2: DEC CX JNZ NEXT2 DEC BL JNZ NEXT1 HLT 求补 NEG NEG 将影响六个标志位 当且仅当操作数为 0 时，CF = 0，结果不变（仍为 0） 当且仅当字节操作数为 -128 (80H) 或字操作数为 -32768 (8000H) 时，OF = 1，结果不变（仍为 -128 或 -32768） 比较 CMP只影响六个标志位，不会存储结果。常接 JNZ JNC 等语句实现条件跳转。 两个数大小比较： CMP AX, BX 无符号数 有符号数 AX=BX ZF=0 ZF=0 AX&gt;BX CF=0, ZF=0 OF=SF, ZF=0 AX&lt;BX CF=1, ZF=0 OF!=SF, ZF=0 可相关判断指令 JA JAE JB JBE JG JGE JL JLE 例题：在 20 个无符号数中找出最大的数，并将其存放在 MAX 单元中。 123456789101112 LEA BX, MAX LEA SI, BUF MOV CL, 20 MOV AL, [SI] ; AL 保存目前的最大值NEXT: INC SI CMP Al, [SI] JNC GOON ; CF=0 转移 MOV AL, [SI] ; 将更大的 [SI] 放进 ALGOON: DEC CL JNZ NEXT MOV [BX], AL HLT 乘法 运算结果长度是乘数的两倍，即 8位-&gt;16位，16位-&gt;32位 一个乘数和计算结果使用隐含寻址，隐含的是存放被乘数的累加寄存器 AL 或 AX，及存放结果的 AX 或 DX 乘法只影响 OF、CF；若运算结果的高半部分是无效数值，则 OF=CF=0，否则 OF=CF=1 考虑 8 位乘 8 位，结果仍可以用 8 位存储的情况，此时 OF=CF=0 对于无符号乘法，当且仅当高半部分为全 0， OF=CF=1 对于有符号乘法，当且仅当高半部分为低半部分的符号扩展，OF=CF=1 若有符号乘法结果为 00000000 11111111，高半部分不是符号扩展，CF=OF=0。若在后续步骤只看后半部分，会导致原来的正值被（错误地）识别为负值 无符号乘法 MUL123MUL OPRD; 字节运算：AX = AL * OPRD; 字运算： DX:AX = AX * OPRD OPRD 不能是立即数 若结果高半部（AH 或 DX）是全 0（不是有效数值），则 CF=OF=0，否则 CF=OF=1 带符号乘法 IMULIMUL (sIgned MULtiply) 除了操作数是带符号外，其余与 MUL 指令相同。 1IMUL OPRD 若结果高半部（AH 或 DX）是低半部的符号扩展（不是有效数值），则 CF=OF=0，否则 CF=OF=1 除法12345; 无符号除法 DIV OPRD; 有符号除法IDIV OPRD 指令要求被除数是除数的双倍字长 若 OPRD 是 8 bits 执行：AX/OPRD AL = 商 AH = 余数 若 OPRD 是 16 bits 执行：DX:AX/OPRD AX = 商 DX = 余数 简而言之，就是高位存余数，低位存商。记忆的方法，可以想：平时更常用除法而不是求模，低位存储的结果就可以直接进行下一步运算。 除法指令常和 CBW 或 CWD 配合使用。 BCD 码调整指令 六条指令 DAA Decimal Adjust after Addition，Decimal 即每四位表示一个 BCD 码，又称压缩型、组合型 AAA ASCII Adjust after Addition，ASCII 即每八位表示一个 BCD 码，又称非压缩型、非组合型 剩下的就自己看 PPT 吧。 AAA DAA AAS DAS AAM AAD 逻辑运算和移位指令逻辑运算 逻辑运算指令对操作数的要求大多与MOV指令相同 NOT 运算指令要求操作数不能是立即数 除 NOT 运算指令外，其余指令的执行都只会影响 OF 和 CF（使 OF=CF=0）。NOT 指令不不影响标志位 与 AND语法上类似于 ADD。 12AND OPRD1, OPRD2; 两操作数按位相“与”，结果送目标地址 OPRD1 例： 12345678; 实现两操作数按位相与的运算AND BL, [SI]; 使目标操作数的某些位不变，某些位清零AND AL, 0FH; 在操作数不变的 情况下使 CF 和 OF 清零AND AX, AX 例 2：从地址为 3F8H 端口中读入一个字节数，如果该数 bit1 位为 1，则将 DATA 为首地址的一个字输出到 38FH 端口，否则就不能进行数据传送。 12345678 LEA SI, DATA MOV DX, 3F8HWAIT: IN AL, DX AND AL, 02H JZ WAIT ; ZF=1转移 MOV DX, 38FH MOV AX, [SI] OUT DX, AX 或 OR12OR OPRD1, OPRD2; 两操作数按位相“或”，结果送目标地址 OPRD1 例题： 123456; 实现两操作数 相“或”的运算OR AX, [DI]; 使某些位不变，某些位置“1”OR CL, 0FH; 在不改变操作数的情况下使 OF=CF=0OR AX, AX 非 NOT12NOT OPRD; 操作数按位取反再送回原地址 操作数不能是立即数 对标志位无影响 例： 1NOT BYTE PTR[BX] 这里的 BYTE PTR 是强制转换，见PTR 运算符。 异或 XOR12XOR OPRD1, OPRD2; 两操作数按位相“异或”，结果送目标地址 OPRD1 例： 12XOR BL, 80H ; 将 BL 的最高位变反XOR AX, AX ; 将 AX 清零 注意，XOR AX, AX 的效果等价于 MOV AX, 0，但： 前者会使 OF=CF=0 前者的字节码更短 前者在旧的架构上速度会更快（新架构就没必要了） 参见 xor ax, ax when loading segment register - Stack Overflow 测试（与） TEST123TEST OPRD1, OPRD2; 执行“与”运算，运算的结果影响标志位，但不送回目标地址; 常用于测试某些位的状态 例题：从地址为 3F8H 的端口中读入一个字节数，当该数的 bit1， bit3， bit5 位同时为 1 时，则从 38FH 端口将 DATA 为首地址的一个字输出，否则就从端口重新输入。 12345678 LEA SI, DATA MOV DX, 3F8HWAIT: IN AL, DX ; ... ; ... MOV DX, 38FH MOV AX, [SI] OUT DX, AX ; ... 部分的代码可以有三个版本： 使用三次 TEST： 123456TEST AL, 02HJZ WAIT ; ZF=1转移TEST AL, 08HJZ WAITTEST AL, 20HJZ WAIT 使用 AND 后 CMP： 123AND AL, 2AHCMP AL, 2AHJNZ WAIT 使用 AND 后 XOR： 123AND AL, 2AHXOR AL, 2AHJNZ WAIT 移位指令算术左移 SAL 逻辑左移 SHL1234567; 算术左移 (Shift Arithmetic Left) 指令，视为有符号数SAL OPRD, 1SAL OPRD, CL; 逻辑左移指令，视为无符号数SHL OPRD, 1SHL OPRD, CL CL 是 CX 寄存器的低 8 位。 SAL 和 SHL 二者实际上就是一条指令，都是最低位补 0，最高位移到 CF。 算术右移 SAR 逻辑右移 SHR1234567; 算术右移指令，视为有符号数SAR OPRD, 1SAR OPRD, CL; 逻辑右移指令，视为无符号数 SHR OPRD, 1SHR OPRD, CL SAR 和 SHR 移出的数送 CF，移入 0 （算术右移）或符号位（逻辑右移）。 不带 CF 的循环移位 ROL RORRO 取自 Rotate。 二者都是在原数上循环移位，同时移出的数送 CF。见下。 带 CF 的循环移位 RCL RCR二者都是 CF 作为移入的数，移出的数再送 CF。 循环移位 循环移位可用于： 用于对某些位状态的测试 高位部分和低位部分的交换 与非循环移位指令一起组成32位或更长字长数的移位 例：对从存储单元 M 开始的三字数据执行左移一位。 123SAL M, 1RCL M+2, 1RCL M+4, 1 示例 例 2：将 1000H 开始存放的 4 个压缩 BCD 码转换为 ASCII 码存放到 3000H 开始的单元中去。 123456789101112131415161718192021 MOV SI, 1000H MOV DI, 3000H MOV CX, 4Next: MOV AL, [SI] MOV BL, AL ; 由于每个字节有 2 个 BCD 码，需处理两次，故备份一个在 BL AND AL, 0FH OR AL, 30H ; 处理 AL 的后四位 MOV [DI], AL INC DI ; 目的地地址 ++ MOV AL, BL PUSH CX ; 对 CX （用于计数剩余字节）备份 MOV CL, 4 ; 此处的 CL 为右移次数 SHR AL, CL ; 处理 AL 的前四位 OR AL, 30H MOV [DI], AL INC DI ; 目的地地址 ++ INC SI ; 源地址 ++ POP CX DEC CX JNZ Next HLT 串操作指令 针对数据块或字符串的操作 实现存储器到存储器的数据传送（前面的所有命令都不能） 串操作指令及其功能：（&lt;=&gt;表示比较，&lt;- 表示数据存储） 串传送 MOVS：存储器 -&gt; 存储器 串比较 CMPS：存储器 &lt;=&gt; 存储器 串扫描 SCAS：存储器 &lt;=&gt; AL/AX 串装入 LODS：存储器 -&gt; AL/AX 串送存 STOS：存储器 &lt;- AL/AX 特点 源串地址由 DS:[SI] 提供，目的串由 ES:[DI] 提供 源串允许段（DS）重设，目的串不允许段（ES）重设。 每次： 只处理串中的一个单元(字或字节) 这些指令执行结束后，都会按 DF 决定的方向自动修改 SI 和/或 DI，使其指向下一个单元（按指令可分别处理字单元和字节单元） 地址修改方向由 DF 标志位决定： DF = 0 =&gt; 增地址方向 DF = 1 =&gt; 减地址方向 指令前面可加上自动重复前缀，实现自动重复执行串操作，重复执行次数由 CX 指定 重复前缀重复前缀：重复执行给定指令，每执行一次后，自动使 CX-1=&gt;CX，直至 CX=0 或其他条件 无条件重复 REP =&gt; 若 CX≠0 则重复 条件重复 REPE 相等重复 =&gt; 若 CX≠0 且 ZF=0 则重复 REPZ 为零重复（上一指令的别名） REPNE 不相等重复 =&gt; 若 CX≠0 且 ZF≠0 则重复 REPNZ 不为零重复（上一指令的别名）注意：重复前缀本身不改变标志位 串操作指令流程 串操作指令流程(以传送操作为例) 左边部分是串操作的初始化，右边的虚线框部分由串操作指令完成。 串传送指令 MOVS123MOVS OPRD1(ES:DI), OPRD2(DS:SI)MOVSBMOVSW 第一种格式中，OPRD1 为目标串地址，OPRD2 为源串地址（类似于 MOV）。两串的段地址允许使用默认值（ES、DS），源串也允许段重设 二、三种格式下隐含了操作数地址（目标串 ES:DI、源串 DS:SI） MOVSB 一次完成一个 Byte 的传送，MOVSW 一次完成一个 Word 的传送 执行结束后，按 DF 决定的方向自动修改 SI 和 DI，使其指向下一个单元 例题：用串传送指令实现200个字节数据的传送： 123456LEA SI, MEM1LEA DI, MEM2MOV CX, 200CLD ; Clear Direction Flag: DF = 0REP MOVSBHLT 串比较指令 CMPS123CMPS OPRD1(DS:SI), OPRD2(ES:DI)CMPSBCMPSW 和 MOVS 相同的是，后两个命令默认目标串 ES:DI、源串 DS:SI 和 MOVS 不同的是，OPRD1 为源串，OPRD2 为目标串（这和 SUB、CMP 相同） 和 CMP 相同的是，执行 OPRD1-OPRD2，不改变操作数， 只改变标志位 串比较指令常与条件重复前缀连用 指令的执行不改变操作数，仅影响标志位 执行结束后，按 DF 决定的方向自动修改 SI 和 DI，使其指向下一个单元 例：比较两组（200个字节）对应数据，找出第一个不同数据放入AL，其地址放入BX 12345678910 LEA SI, MEM1 LEA DI, MEM2 MOV CX, 200 CLD REPE CMPSB ; 指令执行结束，可能是找到不同，也可能是完全相同 JZ STOP DEC SI ; 注意！ MOV AL，[SI] MOV BX，SISTOP: HLT 上述第 7 行的 DEC SI 说明：当前 REPE CMPSB 条件不满足时，也会执行 SI++ DI++ CX--，然后停止执行指令。 串扫描指令 SCAS123SCAS OPRD(ES:DI)SCASBSCASW 执行 AX （或 AL） - OPRD，结果不保存，只影响标志寄存器 常用于在指定存储区域中寻找关键字 OPRD 为目标串，默认为 ES:SI 执行结束后，按 DF 决定的方向自动修改 DI，使其指向下一个单元 串装入指令 LODS123LODS OPRD(DS:SI)LODSB ; 存入 ALLODSW ; 存入 AX 用于将内存某个区域的数据串依次装入累加寄存器 AX/AL，以便进行处理 不影响标志位 LODS 指令加重复前缀无意义（等价于 LOAD 最后一个有效值） 执行结束后，按 DF 决定的方向自动修改 SI，使其指向下一个单元（这即是和 MOV AL, [SI] 的最大区别） 串存储指令 STOS123STOS OPRD(ES:DI)STOSB ; 将 AL 存入内存STOSW ; 将 AX 存入内存 配合重复前缀，常用于将内存某个区域置同样的值。 串操作指令注意事项注意事项： 需要定义附加段 目标操作数必须在附加段 需要设置数据的操作方向 确定 DF 的状态 源串和目标串指针分别为 SI 和 DI 串长度值必须由 CX 给出 注意重复前缀的使用方法 传送类指令前加无条件重复前缀 串比较类指令前加条件重复前缀，但前缀不影响 ZF 状态 程序控制指令程序的执行方向 程序控制类指令的本质：控制程序的执行顺序 决定程序执行方向的因素：CS，IP 下条指令地址：CS:[IP] 修改 CS，程序转向另一个代码段执行 修改 IP，程序转向本代码段内另一处执行 转移指令 JMP 转移指令修改 CS 和 IP 的值，实现程序转移 分为无条件转移指令和有条件转移指令 无条件转移指令1JMP OPRD 段内转移 段内转移：目标地址为 16 位，赋值给 IP 段内直接转移：OPRD/Label 为立即数，**IP &lt;= IP + Label**（Label 被汇编为 8/16 位位移量） 段内间接转移：OPRD 为寄存器或存储器，**IP &lt;= OPRD** 例题： 12345678JMP Next ; Next 为标号; 执行后 IP 到 Next 所在指令的地址JMP BX ; BX = 1200H; 执行后 IP = 1200HJMP [BX] ; [BX] = 4312H; 执行后 IP = 4312H。 关于 Label 的详细介绍可见标号。 段间转移 JMP FAR 段间转移：目标地址为 32 位，赋值给 CS:IP 段内直接转移：OPRD/Label 为立即数，CS:IP = Label（Label 被汇编为 32 位地址） 段间间接寻址：转移的目标地址由指令中的 32 位存储器单元给出 例： 123456JMP FAR Label ; 段内直接转移; CS:IP = LabelJMP DWORD PTR[BX] ; 段内间接寻址; IP = [BX]; CS = [BX+1] 例 2： 123456MOV SI，1122HMOV WORD PTR[SI]，0120HADD SI，2MOV WORD PTR[SI]，0122HJMP DWORD PTR[SI-2]; CS = 0122H, IP = 0120H 注意第二行，将立即数存入 [SI] 指明的内存时，必须使用 BYTE/WORD PTR 显式指明立即数的长度是 8 位还是 16 位，因为立即数和 [SI] 的长度都是不一定的。寄存器值存入内存则不需要，因为寄存器隐式地给出了长度。参见 PTR 运算符。 条件转移指令 在满足一定条件下，程序转移到目标地址继续执行 条件转移指令均为直接寻址的段内短转移，即转移的位移量为 8 位补码表示，范围为：**-128~+127**IP=IP+位移量 常见条件指令的应用： 指令 条件 应用 JC/JNC 判断CF的状态 常用于比大小 JZ/JNZ 判断ZF的状态 常用于循环体的结束判断 JO/JNO 判断OF的状态 常用于有符号数溢出的判断 JS/JNS 判断SF的状态 JP/JNP 判断PF的状态 用于判断运算结果低8位中1的个数是否为偶数 没有类似指令判断 AF 或 DF 的状态，只有上面五个 JA/JAE/JB/JBE 判断CF或CF+ZF的状态 常用于无符号数的大小比较 JG/JGE/JL/JLE 判断SF、OF和ZF的状态 常用于带符号数的大小比较 有关 JA JG 等的含义和用法请读者自行百度 / Google。 例题：统计内存数据段中以 TABLE 为首地址的 100 个 8 位有符号数中正数、负数和零的个数。 例题程序 循环控制指令 循环范围：以当前 IP 为中心的 -128～+127 范围内循环 循环次数：由 CX 寄存器指定 循环指令：LOOP LOOPZ LOOPNZ 无条件循环指令 LOOP1LOOP LABEL 操作： CX-1 =&gt; CX CX ≠ 0 则转 LABEL，否则执行下条指令 也就是说，当 CX = 1 时执行 LOOP 则不会跳转，而是顺序执行。 有条件循环指令 LOOPZ LOOPNZ（略）LOOPZ 和 LOOPNZ 过程调用指令 CALL 用于调用一个子过程 子过程由程序员预先设计并装入内存 子过程执行结束后要返回原调用处 重要概念：入口地址、断点，如图 入口地址和断点 调用指令的执行过程： 保护断点：将断点（调用指令的下一条指令的地址）压栈 获取子过程的入口地址（子过程第一条指令的地址） 执行子过程，含相应参数的保存及恢复 恢复断点，返回原程序（将断点地址由堆栈弹出） 分为： 段内直接调用 段内间接调用 段间直接调用 段间间接调用 段内调用 CALL NEAR由于被调用程序与调用程序在同一代码段，调用前只需保护断点的偏移地址。 1CALL (NEAR) PROC 执行过程： 断点压栈 PROC =&gt; IP 例： 1234CALL TIMER ; 直接调用CALL WORD PTR[SI] ; 间接调用，指明长度为 16 位，是段内调用; 执行后 IP = [SI], CS 不变 段间调用 CALL FAR由于子过程与原调用程序不在同一代码段，调用前需保护断点的段基地址和偏移地址。 先将 CS 压栈，再压入 IP。 格式： 1CALL FAR PROC 例： 12345CALL FAR TIMERCALL DWORD PTR[SI] ; 指明长度为 32 位，是段间调用; 执行后 IP = [SI]; CS = [SI+2] 返回指令 RET1RET 从堆栈中弹出断点地址，返回原程序 一般位于子程序的最后 在格式上不区分段内或段间 中断控制指令中断和过程调用的区别 中断是随机事件或异常事件引起，调用则是事先已在程序中安排好 响应中断请求不仅要保护断点地址，还要保护 FLAGS 内容 调用指令在指令中直接给出子程序入口地址 中断指令只给出中断向量码，入口地址则在中断向量码指向的中断向量表（内存单元）中 中断指令 INT中断指令，又称作软中断指令 123INT n; n*4 为中断服务程序入口的偏移地址（段地址 = DS）; 8086 的中断向量表存放在内存最低的 1K 单元 中断指令的执行过程 将 FLAGS 压入堆栈 将 INT 指令的下一条指令的 CS、IP 压栈 由 n*4 得到存放中断向量的地址 将中断向量（中断服务程序入口地址）送 CS 和 IP 寄存器 CS = DS:[n*4] IP = DS:[n*4+2] 转入中断服务程序 下图中，左图为中断后的堆栈段，右图为数据段和代码段。 中断指令的执行过程 例： [0084H] = 1123H, [0086H] = 2000H。执行 INT 21H 后， IP = [21H*4] = 1123H CS = [21H*4+2] = 2000H 下一条指令在 21123H 溢出中断指令 INTOINTO 指令通常安排在有符号数加减运算指令之后判断是否发生溢出 1INTO 指令执行时检查 OF 标志： 若 OF=1，则启动一个类型为4的中断过程,即相当于执行指令: INT 4 若 OF=0，不做任何操作执行下一条指令 中断返回指令 IRET1IRET 中断服务程序的最后一条指令，执行： 恢复断点 恢复标志寄存器内容 处理器控制指令主要分为： 对标志位的操作 对标志位操作都是无操作数指令 可操作的标志位有 CF、IF和DF 与外部设备的同步 常见指令 作用 CLC (clear CF) 清除进位标志 STC (set CF) 置1进位标志 CMC (complement CF) 进位标志取反 CLD 清除方向标志 STD 置1方向标志 CLI 清除中断标志 STI 置1中断标志 第四章 汇编语言程序设计汇编语言语句种类及其格式汇编语言语句分为指令语句和伪指令语句。 指令语句每一条指令语句在汇编时都要产生一个可供CPU执行的机器目标代码，它又叫可执行语句。 指令语句的一般格式 指令助记符和操作数两个字段就是上一章——指令系统介绍的指令 标号是可选字段，后面必须跟 : 主要用于控制程序执行顺序 注释字段为可选项，以分号 ; 开始 它不会产生机器目标代码，不影响程序的功能 注释可以加在指令的后面，也可以是整个语句行 12LABEL1: ADD AX, BX ;功能为AX&lt;=(AX)+(BX); 后面的程序段将完成一次对存储器的访问 伪指令语句 伪指令语句又叫命令语句，是指示性语句 伪指令本身不产生自己的机器目标代码，它指示汇编程序对其后面的指令语句和伪指令语句如何处理 伪指令语句的一般格式 标识符指令语句中的标号和伪指令语句中的符号名统称为标识符，它由若干个字符构成。 标识符构成规则： 字符的个数为 1-31 个 可以使用字母、数字、@ 、 _或 ? 不能以数字开头 不能使用系统专用的保留字 保留字 CPU 中各寄存器名（如 AX、CS 等） 指令助记符（如MOV、ADD） 伪指令符（如SEGMENT、DB） 表达式中的运算符（如GE、EQ） 属性操作符（如PTR、OFFSET等） 汇编语言数据 数据：指令和伪指令语句中的操作数 常用的数据形式有：常数、变量和标号 一个数据由数值和属性（比如是字节数据还是字数据）两部分构成 常数常数：经过汇编后其值已完全确定，并且在程序运行过程中不会改变。 常数的表示 二进制数：以字母 B 结尾，如 01001001B 八进制数：以字母 O 或 Q 结尾，如631Q 254O 十进制数：以字母 D 结尾，或者没有结尾字母。如 2007D、2007 十六进制数：以字母 H 结尾，如 3FEH 如果常数的第一个数符为字母，为了与标识符区别，必须在其前面冠以数字 0，如0F000H 为 16 位常数 实数：如 2.134E+10。汇编源程序时会把实数转换为 4 字节、8 字节或 10 字节的二进制数形式存放。 字符串常数：用引号（单引号或双引号）括起来的一个或多个字符，其值为这些字符的ASCII码 如 &#39;ABC&#39; 存储为 41H 42H 43H 其中 41H 在低地址，43H 在高地址，类似于 C 语言的 char * 常数的作用 作指令语句的源操作数 在指令语句中作位移量 在数据定义伪指令中使用 123456789101112; 1. 作指令语句的源操作数MOV AX, 0B2F0HADD AH, 64H; 2. 在指令语句中作位移量MOV BX, 32H [SI]MOV 0ABH [BX], CXADC DX, 1234H[BP][DI]; 3. 在数据定义伪指令中使用DB 10HDW 3210H 变量变量：用来表示存放数据的存储单元，这些数据在程序运行期间可以被改变。 程序中以变量名的形式来访问变量。变量名就是存放数据的存储单元地址。 变量的定义定义变量：给变量在内存中分配一定的存储单元。也就是给这个存储单元赋与一个符号名，即变量名，同时还要将这些存储单元预置初置。 定义变量使用数据定义伪指令 DB、DW、DD、DQ 和 DT 等。 格式： 123456VAR_DATA SEGMENTDATA1 DB 12H; 变量名 + 数据定义伪指令 + 初值DATA2 DB 20H, 30HDATA3 DW 5678HVAR_DATA ENDS 变量的属性 段属性（逻辑段）：上例 DATA1 DATA2 DATA3 均在 VAR_DATA 逻辑段 偏移量属性（偏移地址）：上例 DATA1 DATA2 DATA3 的偏移量分别为 0, 1, 3 类型属性，如下： 类型 中文 变量长度 DB Define Byte 1 字节 DW Define Word 2 字节 DD Define Doubleword 4 字节 DQ Define Quadword 8 字节 DT Define Tenbytes 10 字节 变量的预置 数值表达式 ? 表达式：表示预置任意内容（未赋初值） 字符串表达式 DUP 表达式 数值表达式1234; 1. 数值表达式DATA1 DB 32, 30H; DATA1 的内容为 32（20H）; DATA1+1 单元内容为30H ? 表达式123DA-BYTE DB ?, ?, ?; 表示让汇编程序分配三个字节存储单元; 这些存储单元的内容的值为任意（未赋初值） 字符串表达式 字符串长度不超过 255 个字符 使用 DB 伪指令，会对每个字符分配一个字节单元，从左到右将各字符的 ASCII 码以地址递增的顺序依次存放 使用 DW 伪指令，可以给两个字符组成的字符串分配两个字节存储单元 但需要注意的是，两个字符的存放顺序是前一个字符放在高地址，后一字符放低地址单元 使用 DD 伪指令，只能给两个字符组成的字符串分配 4 个字节单元 两个字符存放在较低地址的两个字节单元中，存放顺序与 DW 伪指令相同 而较高地址的两个字节单元存放 0 DW 和 DD 伪指令不能用两个以上字符构成的字符串赋初值 123456789; 3. 字符串表达式STRING1 DB 'ABCDEF'; 低地址到高地址依次为 'A' 'B' 'C' 'D' 'E' 'F'STRING2 DW 'AB', 'CD', 'EF'; 低地址到高地址依次为 'B' 'A' 'D' 'C' 'F' 'E'STRING3 DD, 'AB', 'CD'; 低地址到高地址依次为 'B' 'A' 0 0 'D' 'C' 0 0 DUP 表达式DUP 称为重复数据操作符。其格式为：变量名 数据定义伪指令 重复次数 DUP(重复内容)。 如： 12345DATA_A DB 10H DUP(?); 分配 16 个字节单元，不赋初值DATA_B DB 20H DUP('AB'); 分配 20H * 2 = 64 个字节单元，其内容为 'ABABAB'... **嵌套的 DUP**： 12DATA_C DB 10H DUP(4 DUP(2), 7); 重复 10H 个数字序列（2、2、2、2、7），共占用 10H*5 = 50H 字节 DUP 和 DW 组合时，每个 重复内容 占用两字节，例如： 1DATA DW 5, 2 DUP(1, 2 DUP(1)) DW 所指向的内存单元（每字节）为 5 0 1 0 1 0 1 0 1 0 1 0 1 0，共占用 14 字节。 地址表达式该地址表达式为一变量名（或标号名），那么： 用伪指令 DW 定义则是用它的偏移量来初始化变量 用伪指令 DD 定义则是用它的段基值和偏移量来初始化变量，且段基值存放在高字单元，偏移量存放在低字单元 123456789101112; 设以下变量的段基址为 0915H，NUM 的偏移地址为 0004HNUM DB 75HARRAY DW 20H DUP(0)ADR1 DW NUM ; DW 时取 NUM 的偏移地址; ADR1 = 0004HADR2 DD NUM ; DD 时取 NUM 的偏移地址（存入低字）和段基址（存入）; ADR2 = 0915 0004HADR3 DW ARRAY[2]; ADR3 = 0007H 注意：变量不能出现在 DB 语句的右边，因为变量的偏移地址为 16 位，与 DB 定义的变量长度不匹配。 语句运行后的内存 注意，ARRAY[2] 这样的形式，等价于 OFFSET(ARRAY)+2。和 C 语言不同的是，[2] 不会根据是 DB 还是 DW 而使用不同的偏移量，而是一律偏移 2！可详见算术运算符。 以上表达式组成的序列如下： 12NUM DB 2 DUP(1), 2 DUP(2, 'B'), '123', 1, 2, 3; NUM 从低地址到高地址分别为 1 1 2 'B' 2 'B' '1' '2' '3' 1 2 3 变量的使用在指令语句中，直接引用变量名就是对其存储单元的内容进行存取。 12345678DA1 DB 0FEHDA2 DW 52ACHDA3 DW 0MOV AL, DA1 ; 等价于 MOV AL, 0FEHMOV BX, DA2 ; 等价于 MOV BX, 52ACHMOV DA3, BX ; 将 DA3 变量赋值 52ACH，注意二者大小需要对应; 变量是可以被重复赋值的 伪指令语句中，DATA2 DB DATA1 为取 DATA1 地址 指令语句中，MOV AL, DATA1 为取 DATA1 存储的值 符号和变量对比 符号 变量 可变与否 类似于常量，不可变 可变 定义 EQU 或 = DB DW 等 地址空间 无 有段基址、偏移地址 标号 标号 label 加在一条指令的前面，它就是该指令在内存的存放地址的符号表示，也就是指令地址的别名 标号主要用在程序中需要改变程序的执行顺序时，用来标记转移的目的地 下面代码的 LAB 和 NEXT 即为标号 1234567 MOV CX, 100LAB: MOV AX, BX ; ... LOOP LAB JNE NEXT ;不为零转移 ; ...NEXT: ; ... 标号的三个属性 段属性 SEG 它表示该标号所代表的地址在哪个逻辑段中，即段基值。 偏移量属性 OFFSET 它表示该标号所代表的地址在段内与段起点间的字节数，即地址的偏移量。 距离属性（也叫类型属性） 它表示该标号可以被段内还是段间的指令调用。 NEAR（近）：用作段内转移，即只能是与该标号所指指令同在一个逻辑段的其它指令才能使用它 FAR（远）：可以被非本段的转移和调用指令使用 标号的距离属性可以有两种方法来指定： (1) 隐含方式 1SUB1: MOV AX, 30H SUB1 默认为 NEAR。 (2) 用 LABEL 伪指令给标号指定距离属性 1标号名 LABEL NEAR/FAR 该语句要与指令语句连用，如下： 12SUB1_FAR LABEL FARSUB1: MOV AX, 30H 上文中，SUB1_FAR 与 SUB1 两个标号具有相同的逻辑地址。但 SUB1 只能被本段调用，SUB1_FAR 可以被其它段的指令调用。 LABEL 定义变量属性LABEL 伪指令还可以用于定义变量的属性，即改变一个变量的属性，如把字变量的高低字节作为字节变量来处理。 12DATA_BYTE LABEL BYTEDATA_WORD DW 20H DUP(?) DATA_BYTE 与 DATA_WORD 具有相同的段基址和偏移量 DATA_BYTE 可以被用来存取一个字节数据，而 DATA_WORD 则不能 符号定义语句符号定义语句将常数或表达式等形式用某个指定的符号来表示。在 8086/8088 汇编语言中有两种符号定义语句，分别为等值语句 EQU 和等号语句 =。 等值语句 EQU 格式：符号名 EQU 表达式 功能：用符号名来表示 EQU 右边的表达式。后面的程序中一旦出现该符号名，汇编程序将把它替换成该表达式。 类似于 C 的 #define 表达式： 常数或数值表达式 12COUNT EQU 5NUM EQU COUNT+5 地址表达式 1ADR1 EQU DS:[BP+14] 变量名、寄存器名或指令助记符 12CREG EQU CX ; 在后面的程序使用CREG就是使用CXCBD EQU DAA ; DAA为十进制调整指令 注意，同一符号不能用 EQU 重复定义。 等号语句 =格式：符号名=表达式 等号语句与等值语句具有类似的作用，二者的区别是： 等号语句可以对一个符号进行多次定义 等号语句不能为助记符定义别名（诸如 CBD=DAA 是错误的） 等值语句与等号语句都不会为符号分配存储单元。所定义的符号没有段、偏离量和类型等属性。 表达式与运算符表达式是指令或伪指令语句操作数的常见形式。它由常数、变量、标号等通过操作运算符连接而成。 任何表达式的值在程序被汇编的过程中进行计算确定，而不是到程序运行时才计算。 8086/8088宏汇编语言中的操作运算符非常丰富，可以分为以下五类。 算术运算符 逻辑运算符 关系运算符 数值返回运算符 属性修改运算符 算术运算符包含 +、-、*、 / 、MOD、SHL、SHR、[ ]。 运算符 + 和 - 也可作单目运算符，表示数的正负 使用 +、-、* 和 / 运算符时，参加运算的数和运算结果都是整数 / 运算为取商的整数部分，而 MOD 运算取除法运算的余数 123456NUM=15*8 ; NUM = 120NUM=NUM/7 ; NUM = 17NUM=NUM MOD 3 ; NUM = 2NUM=NUM+5 ; NUM = 7NUM=-NUM-3 ; NUM = -10NUM=-NUM-NUM ; NUM = 20 SHR 和 SHL 为逻辑移位运算符 SHR 为右移，左边移出来的空位用 0 补入。SHL 为左移，右边移出来的空位用 0 补入。 移位运算符（如上）与移位指令区别： 移位运算符的操作对象只能是某一具体的数（常数），在汇编（编译）时完成移位操作 而移位指令是对一个寄存器或存储单元内容，在程序运行时执行移位操作 12345NUM=11011011BMOV AX, NUM SHL 1 ; AX=1 1011 0110BMOV BX, NUM SHR 2 ; BX= 11 0110BADD DX, NUM SHR 6 ; DX = 11B 下标运算符 [ ] 具有相加的作用 MOV AX，DA_WORD[20H] 等价于 MOV AX，DA_WORD+20H。 不过，需要注意的是汇编的 [ ] 和 C 语言不同： C 语言中，如果变量 DA_WORD 为 2 字节，DA_WORD[20H] 为 DA_WORD 偏移 20H*2 字节后的内容；而汇编中只是普通的加法，DA_WORD[20H] 为 DA_WORD 偏移 20H 字节后的内容。 以下语句均等价： 12345MOV AX, ARRAY[BX][SI] ; 基址变址寻址MOV AX, ARRAY[BX+SI]MOV AX, [ARRAY+BX][SI]MOV AX, [ARRAY+SI][BX]MOV AX, [ARRAY+BX+SI] 以下为错误语句： 123MOV AX，ARRAY+BX+SIMOV AX，ARRAY+BX[SI]MOV AX，ARRAY+DA_WORD 逻辑运算符逻辑运算符有NOT、AND、OR和XOR等四个，它们执行的都是按位逻辑运算。 12345MOV AX，NOT 0F0H ; 0FF0FHMOV AL, NOT 0F0H ; 0FHMOV BL, 55H AND 0F0H ; 50HMOV BH, 55H OR 0F0H ; 0F5HMOV CL, 55H XOR 0F0H ; 0A5H 关系运算符 关系运算符包括：EQ（等于）、NE（不等于）、LT（小于，less than）、 LE（小于等于）、GT（大于）、 GE（大于等于） 关系运算符用来比较两个表达式的大小。比较的两个表达式必须同为常数或同一逻辑段中的变量 若是常量的比较，则按无符号数进行比较；若是变量的比较，则比较它们的偏移量的大小。 关系运算的结果只能是真（全 1）或假（全 0） 1234MOV AX，0FH EQ 1111B ; AX = 0FFFFMOV BX, 0FH NE 1111B ; BX = 0VAR DW NUM LT 0ABH ; 若符号常量 NUM 值小于 0ABH，则 DW=0FFFFH；否则为 0 数值返回运算符该类运算符有 5 个，它们可以将变量或标号的某些特征值或存储单元地址的一部分提取出来。 SEG 运算符取变量或标号所在段的段基址。 1234567; 设 DATA 逻辑段段基址为 1FFEHDATA SEGMENTK1 DW 1，2K2 DW 3，4; ...MOV AX, SEG K1MOV BX, SEG K2 两条 MOV 指令将被汇编为： 12MOV AX, 1FFEHMOV BX, 1FFEH OFFSET 运算符该运算符的作用是取变量或标号在段内的偏移地址。 123456789DATA SEGMENTVAR1 DB 20H DUP(0)VAR2 DW 5A49HADDR DW VAR2 ; ADDR=20H; ...MOV BX，VAR2 ; BX=5A49HMOV SI, OFFSET VAR2 ; SI=20HMOV DI, ADDR ; DI=20HMOV BP，OFFSET ADDR ; BP=22H 获取变量的偏移量还可以用指令 LEA。 需要注意的是： 12345MOV SI, OFFSET DATA[BX]; 错误，个人猜测是因为 OFFSET 只能取最简单的 *变量* 的偏移地址LEA SI, DATA[BX]; 正确 另外，OFFSET 和 SEG 的返回值可认为是立即数，不能直接 MOV 进 DS、ES（见MOV 指令）。解决办法是经过 AX 中转。 TYPE 运算符作用：取变量或标号的类型属性，并用数字形式表示。对变量来说就是取它的字节长度。 类型 返回值 BYTE 1 WORD 2 DWORD 4 QWORD 8 TBYTE 10 NEAR 标号 -1 FAR 标号 -2 1234567V1 DB 'ABCDE'V2 DW 1234H, 5678HV3 DD V2; ...MOV AL, TYPE V1 ; AL = 1MOV CL, TYPE V2 ; CL = 2MOV CH, TYPE V3 ; CH = 4 LENGTH 运算符 该运算符用于取变量的长度 如果变量是用重复数据操作符 DUP 说明的,则 LENGTH 运算取最外层 DUP的重复值。 如果没有用 DUP 说明，则 LENGTH 运算返回值总是 1。 123456789K1 DB 10H DUP(0)K2 DB 10H，20H，30H，40HK3 DW 20H DUP (0，1，2 DUP(0))K4 DB 'ABCDEFGH'; ...MOV AL, LENGTH K1 ; (AL)=10HMOV BL, LENGTH K2 ; (BL)=1MOV CX, LENGTH K3 ; (CX)=20HMOV DX, LENGTH K4 ; (DX)=1 从上例可以看出，LENGTH 并不能求得字符串变量的长度，还是需要$ 符号 SIZE 运算符 该运算符只能用于变量 SIZE = LENGTH * TYPE 1234MOV AL，SIZE K1 ; (AL)=10HMOV BL，SIZE K2 ; (BL)=1MOV CL，SIZE K3 ; (CL)=20H*2=40HMOV DL，SIZE K4 ; (DL)=1 属性修改运算符这一类运算符用来对变量、标号或存储器操作数的类型属性进行修改或指定。 PTR 运算符 格式：类型 PTR 地址表达式 作用: 将地址表达式所指定的标号、变量或用其它形式表示的存储器地址的类型属性临时修改为“类型”所指的值 类型：BYTE、WORD、DWORD、NEAR 或 FAR 这种修改是临时的，只在含有该运算符的语句内有效，类似于 C 语言 (char)i 强制转换。 12345678910DA_BYTE DB 20H DUP(0)DA_WORD DW 30H DUP(0); ...MOV AX, WORD PTR DA_BYTE[10]ADD BYTE PTR DA_WORD[20], BLINC BYTE PTR [BX]SUB WORD PTR [SI], 100JMP FAR PTR SUB1 ; 指明SUB1不是本段中的地址MOV WORD PTR[SI]，0120H 注意最后一行，将立即数存入 [SI] 指明的内存时，必须使用 BYTE/WORD PTR 显式指明立即数的长度是 8 位还是 16 位，因为立即数和 [SI] 的长度都是不一定的。寄存器值存入内存则不需要，因为寄存器隐式地给出了长度。 HIGH/LOW 运算符格式：HIGH 表达式 LOW 表达式 用来将表达式的值分离出高字节和低字节。 如果表达式为一个常量，则将其分离成高 8 位和低 8 位 如果表达式是一个地址（段基值或偏移量）时，则分离出它的高字节和低字节 HIGH/LOW 运算符不能分离寄存器、存储器单元或变量中的内容。 分离变量的段基址、偏移量时，需要配合 SEG 和 OFFSET。这是符合“变量在伪指令中是偏移地址，在指令中是存储器中内容”的。 12345678910111213; 设 DATA 段的段基址为 0926HDATA SEGMENTCONST EQU 0ABCDHDA1 DB 10H DUP(0)DA2 DW 20H DUP(0)DATA ENDS; ...MOV AH, HIGH CONST ; AH = 0ABHMOV AL, LOW CONST ; AL = 0CDHMOV BH, HIGH (OFFSET DA1) ; BH = 00HMOV BL, LOW (OFFSET DA2) ; BL = 10HMOV CH, HIGH (SEG DA1) ; CH = 09HMOV CL, LOW (SEG DA2) ; CL = 26H 运算符的优先级 优先级别 运算符 （最高）1 LENGTH, SIZE, ( ) 2 PTR, OFFSET, SEG, TYPE, THIS 3 HIGH, LOW 4 *, /, MOD, SHR, SHL 5 +, `- 6 EQ, NE, LT, LE, GT, GE 7 NOT 8 AND （最低）9 OR, XOR 相同优先级别的操作，从左到右进行。 程序的段结构8086/8088 将内存按逻辑段进行管理，不同的逻辑段可以用来存放不同目的的内容。 在程序中使用四个段寄存器CS,DS,ES和SS来访问它们。 在源程序中，使用伪指令来定义和使用这些逻辑段。 段定义伪指令 SEGMENT伪指令 SEGMENT 和 ENDS 用于定义一个逻辑段，分别表示定义的开始与结束。 1234段名 SEGMENT [定位类型] [组合类型] ['类别名']; ...; ...段名 ENDS 段名段名：由用户定义。 定义类型定位类型：段的起始数据边界，即第一个可存放数据的位置（不是段基地址）。 定位类型 含义 段的起始边界 PAGE 该段从一个页面的边界开始 xxxx xxxx xxxx 0000 0000 PARA（默认） 该段从一个小节的边界开始 xxxx xxxx xxxx xxxx 0000 DWORD 该段从一个双字的边界开始 xxxx xxxx xxxx xxxx xx00 WORD 该段从一个偶数字节地址开始 xxxx xxxx xxxx xxxx xxx0 BYTE 该段起始数据单元地址可以是任一地址值 xxxx xxxx xxxx xxxx xxxx 定位类型为 PAGE 和 PARA 时，段的起始边界直接选用段基址，即它们是重合的。定位类型为 DWORD、WORD 和 BYTE 时，段的起始边界与段基址可能不同。 组合类型组合类型说明符用来指定段与段之间的连接关系和定位。 默认：未指定组合类型，表示本段与其它段无连接关系 在装入内存时，本段有自己的物理段，因此有自己的段基址 PUBLIC：将该逻辑段接在前一逻辑段后面，形成新逻辑段 在满足定位类型的前提下，将与该段同名的段邻接在一起，形成一个新的逻辑段，共用一个段基址。段内的所有偏移量调整为相对于新逻辑段的段基址 COMMON：产生一个覆盖段 在多个模块连接时，把该段与其它也用 COMMON 说明的同名段诉汇编程序，在处理置成相同的段基址，这样可达到共享同一存储区。共享存储区的长度由同名段中最大的段确定 STACK：将该段作为栈使用 把所有同名段连接成一个连续段，且系统自动对 SS 段寄存器初始化为该连续段的段基址，并初始化堆栈指针 SP 用户程序中应至少有一个段用 STACK 说明，否则需要用户程序自己初始化 SS 和 SP。 AT 表达式：手动指定段基址 表示本段可定位在表达式所指示的小节边界上 表达式的值就是段基值 MEMORY：本段在存储器中应定位在所有其它段之后的最高地址上 如果有多个用 MEMORY 说明的段，则只处理第一个用 MEMORY 说明的段，其余的被视为 COMMON 类别名类别名为某一个段或几个相同类型段设定类型名称。 系统在进行连接处理时，把类别名相同的段存放在相邻的存储区，但段的划分与使用仍按原来的设定。 类别名必须用单引号引起来。所用字符串可任意选定，但它不能使用程序中的标号、变量名或其它定义的符号。 示例123456789101112131415161718192021STACK1 SEGMENT PARA STACK 'STACK0';......STACK1 ENDSDATA1 SEGMENT PARA 'DATA';......DATA1 ENDSSTACK2 SEGMENT PARA 'STACK0';......STACK2 ENDSCODE SEGMENT PARA MEMORY ASSUME CS:CODE,DS:DATA1,SS:STACK1MAIN:;......CODE ENDSDATA2 SEGMENT BYTE 'DATA';......DATA2 ENDS END MAIN 该程序经LINK程序连接处理后装入内存的示意图 在段定义中选用了 PARA 说明，则该段起始单元与前面已分配存储单元之间可能存在一些未使用的空白 CODE 段的组合类型为 MEMORY，因此被装入在其它段之后（最高地址） 段寻址伪指令 ASSUMEASSUME的作用是告诉汇编程序，在处理源程序时，定义的段与哪个段寄存器关联。 ASSUME并不设置各个段寄存器的具体内容，段寄存器的值是在程序运行时设定的。所以，一般需要同时使用： 1234ASSUME DS:段名MOV AX, 段名MOV DS, AX 一般格式：ASSUME 段寄存器名: 段名, 段寄存器名:段名...... 段寄存器名：CS, DS, ES 或 SS 段名：用 SEGMENT/ENDS 定义。 12345678910111213141516171819DATA1 SEGMENTVAR1 DB 12HDATA1 ENDSDATA2 SEGMENTVAR2 DB 34HDATA2 ENDSCODE SEGMENTVAR3 DB 56H ASSUME CS:CODE, DS:DATA1, ES:DATA2START: ; ..... INC VAR1 INC VAR2 INC VAR3 ; ......CODE ENDS END START 例如上面程序中的 3 条 INC 指令： 第 1 条 INC 指令要访问的变量 VAR1 在逻辑段 DATA1 中，由于一般操作数寻址隐含使用的是 DS，而 DATA1 又正是与 DS 对应，所以指令 INC VAR1 就可以直接汇编成目标代码 FE 06 0000 第 2 条 INC 指令要访问的变量 VAR2 在逻辑段 DATA2 中，而 DATA2 是与 ES 对应的，要正确执行这条指令必须使用段前缀（即用 ES 替代 DS），因此汇编程序在汇编这条指令时就自动产生一个段前缀标记代码 26，所以指令 INC VAR2 在这个程序中汇编的目标代码为 26 FE 06 0000 与第 2条 INC 指令类似，第 3 条 INC 指令要访问的变量 VAR3 在逻辑段 CODE 中，指令汇编时自动产生一个段前缀标记代码 2E 表示用 CS 替代 DS，所以指令 INC VAR3 汇编的目标代码为 2E FE 06 0000 可以使用关键字 NOTHING 将前面的设置删除。 12ASSUME ES:NOTHING ; 删除前面对 ES 与某个定义段的关联ASSUME NOTHING ; 删除全部 4 个段寄存器的设置 但是 ASSUME 的存在意义依然有点奇怪：DS 被改为段基址以后，想知道 DS 和谁被关联了，读一下 DS 不就行了吗，为什么还要 ASSUME 呢？ 搜索了一下，大概明白了： ASSUME 是给汇编程序看的，而 MOV AX, DATA MOV DS, AX 是给 CPU 看的。 汇编的时候，代码还没在 CPU 里跑，自然是没法读取 DS 的，所以要通过 ASSUME 语句设定。 段寄存器的装入从上面可以看出，要让一个段寄存器真正地指向某个逻辑段，一般需要两个步骤： 将段基值装入到该段寄存器 将段和段基址建立关联（常用 ASSUME 语句实现） DS 和 ES 的装入下面是一个错误示范： 12345678910111213141516DATA1 SEGMENTDBYTE1 DB 12HDATA1 ENDSDATA2 SEGMENTDBYTE2 DB 14H DUP(?)DATA2 ENDSCODE SEGMENT ASSUME CS:CODE, DS:DATA1START: MOV AX,DATA1 MOV DS,AX MOV AX,DATA2 MOV ES,AX MOV AL,DBYTE1 ; 正确 MOV DBYTE2[2],AL ; 错误，因为 ASSUME 指令中未指定 ES 与 DATA2 关联CODE ENDS 使用逻辑段前需要进行两个步骤： 使用 ASSUME ES: DATA2 建立 ES 和 DATA2 的联系 使用 MOV AX,DATA2 MOV ES,AX 将 DATA2 段基址装入 ES 如果已经将段基址装入了 ES，也可以临时指明段前缀： 1MOV ES:DBYTE2[2], AL SS 的装入在段的组合类型中提到，若将一个段声明为 STACK，系统会自动初始化 SS 和 SP 寄存器为对应的值。 因此，SS 的装入有两种方法： 手动使用 MOV 装入 SS 和 SP，然后 ASSUME SS:段名 123456789DATA_STACK SEGMENT DB 40H DUP(?) TOP LABEL WORDDATA_STACK ENDSCODE SEGMENT MOV AX,DATA_STACK MOV SS,AX MOV SP,OFFSET TOP 上述例子中，SS=DATA_STACK，SP=TOP=40H 定义段时使用 STACK 作为组合类型（系统自动装入 SS 和 SP），然后 ASSUME SS:段名 123456STACK1 SEGMENT PARA STACK DB 40H DUP(?)STACK1 ENDSCODE SEGMENT ASSUME CS:CODE, SS:STACK1 上述例子中，SS=STACK1，SP=40H CSCPU在执行指令之前根据CS和IP的内容来从内存中取指令,即必须在程序执行之前装入CS和IP的值。因此,CS和IP的初始值就不能用可执行语句来装入。 装入CS和IP一般有下面两种情况。 程序加载到主存时，由系统软件给CS和IP赋予初始值 结束伪指令格式：END 起始地址 起始地址: 是一个标号或表达式，它必须是程序中第一条指令语句前所加的标号，如前文的 END MAIN 汇编源程序必须以END伪指令结束 END伪指令指示源程序结束并指定程序运行时的第一条指令的地址（起始地址） 起始地址段基址和偏移量被分别装入CS和IP中 123456CODE SEGMENT ASSUME CS:CODE,......START:; ...CODE ENDS END START 程序运行期间，当执行某些指令时，CPU自动修改CS和IP，使它们指向新的代码段。 执行段间过程调用CALL和段间返回指令RET； 执行段间无条件转移指令JMP; 响应中断及中断返回指令； 执行硬件复位操作。 总结 修改 DS、ES： MOV + ASSUME MOV + 临时指明段基址 ES:段名 修改 SS： 声明段为 STACK + ASSUME MOV + ASSUME 过程定义伪指令 PROC 在程序设计过程中，常常将具有一定功能的程序段设计成一个子程序。在MASM宏汇编语言中，用过程 (PROCEDURE) 来构造子程序。 123过程名 PROC [NEAR/FAR] RET过程名 ENDP 过程名如同标号，具有段、偏移量和距离三个属性 距离属性使用NEAR和FAR来指定，默认为NEAR 每一个过程中必须包含有返回指令RET，它控制CPU从过程中返回到调用该过程的主程序。 当前位置计数器 $ 与定位伪指令 ORG汇编程序在汇编源程序时，每遇到一个逻辑段，就要为其设置一个位置计数器，用来记录该逻辑段中定义的每一个数据或每一条指令在逻辑段中的相对位置。 可以使用 $ 获取位置计数器的值。$ 也被称为当前位置计数器。$ 在使用上完全类似变量的使用。 可以使用 ORG 改变位置计数器的值。 1234567891011121314151617DATA1 SEGMENT ORG 30H ; 跳到 30H，即保留段的前 30H 字节 DB1 DB 12H,34H ; DB1 偏移量为 30H ORG $+20H ; $ = 32H，跳到 52H，即保留段的 32H~51H 字节 STRING DB 'ABCDEFGHI' ; STRING 偏移量为 52H COUNT EQU $-STRING ; COUNT = 9，即 STRING 的长度 DB2 DW $ ; DB2 = $ = 自己的偏移量 DB3 DB $+20H ; 错误，访问到了段外的内容DATA1 ENDSCODE SEGMENT ASSUME CS:CODE, ...... ORG 12HSTART: MOV AX,DATA MOV DS,AXCODE ENDS END START DOS 功能调用 DOS操作系统为程序设计人员提供了可以直接调用的功能子程序 调用这些子程序可以实现从键盘输入数据，将数据送显示器显示，打印机打印，以及磁盘操作等功能 调用DOS功能需要用软中断指令 INT 21H，并在执行该指令之前，将调用的功能号送入寄存器 AH 中，有关的参量送指定的寄存器。 三步骤： 送入口参量到指定的寄存器 送功能号到 AH 执行 INT 21H 带显示的键盘输入（1号功能） 该功能子程序将等待键盘输入，直到按下一个键 将字符的ASCII码送入AL寄存器，并在屏幕上显示该字符 如果是Ctrl-C组合键，则停止程序运行 该功能调用无入口参量 12MOV AH，01HINT 21H 不带显示的键盘输入（8号功能） 该功能调用与1号功能的作用相似，区别是8号功能将不显示输入的字符 12MOV AH，8INT 21H 不带显示的键盘字符输入（7号功能）该功能与8号功能相似，但对Ctrl-C组合键和TAB制表键无反应。 12MOV AH，7INT 21H 字符串输入（0AH号功能） 该功能调用可实现从键盘输入字符串，其长度 &lt;= 255个字符 调用前，应在内存中建立输入缓冲区 缓冲区第一个字节是可输入的最大字符数+1 第二个字节是系统在调用该功能时，自动填入的实际输入的字符个数 从第三个字节开始存放输入字符的ASCII码（见后面例子） 当用户输入回车键时，结束输入，并将回车键的ASCII码 0DH 作为最后一个字符送入缓冲区。但它不计入实际输入字符个数 入口参量：DS 和 DX 寄存器分别装入输入缓冲区的段基值和偏移量 123456789CHAR_BUF DB 31H ;缓冲区的最大长度 DB 0 ;存实际输入字符数 DB 31H DUP(0);输入缓冲区 ; ......MOV DX,SEG CHAR_BUF ;如果DS已经指向CHAR_BUF所在MOV DS,DX ;数据段，则可以省去这两条指令MOV DX,OFFSET CHAR_BUFMOV AH,0AHINT 21H 字符显示（2号功能）该功能实现在屏幕上显示单个字符。 入口参量：DL 装入要显示字符的ASCII码。 123MOV DL, 'A'MOV AH，2INT 21H 字符打印（5号功能）该功能将字符送入打印机接口，实现单个字符的打印操作。 入口参量：DL 装入打印字符的ASCII码 123MOV DL，'A'MOV AH，5INT 21H 字符串显示（9号功能）该功能实现将一个字符串显示到屏幕上。 入口参数： 将待显示的字符串存放在一个数据缓冲区，字符串以符号“$”作为结束标志。 将字符串的首址的段基值和偏移量分别送入 DS 和 DX 中 12345CHAR DB 'This is a test.', 0AH, 0DH, '$'; ......MOV DX, OFFSET CHARMOV AH, 9INT 21H 直接输入输出（6号功能）该功能可以实现键盘输入，也可以实现屏幕显示操作。两种操作通过 DL 的内容确定。 (DL)=00~0FEH 时，输出 DL 对应的字符。 123MOV DL，24H ; $的ASCII码为24HMOV AH，06 INT 21H ; 输出 $ (DL)=FFH 时 ，从键盘输入字符 该功能不等待键盘输入，而是从键盘缓冲区中读取。读取的字符ASCII码送入AL中，如果缓冲区为空，则标志位ZF=1。 1234WAIT: MOV DL，0FFH MOV AH，6 INT 21H JZ WAIT 读出系统日期（2AH号功能）读出的日期信息放入指定的寄存器中： CX：年（1980—2099） DH：月（1—12） DL：日（1—31） AL：星期（0—星期日，1—星期一……） 123456789YEAR DW ?MONTH DB ?DAY DB ?； ......MOV AH,2AHINT 21HMOV YEAR,CXMOV MONTH,DHMOV DAY,DL 设置系统日期（2BH号功能）该功能用来改变计算机CMOS中的系统日期。入口参数： CX&lt;=年号（1980—2099） DH&lt;= 月号（1—12） DL&lt;= 日（1—31） 返回参数在AL中，成功设置，则返回 (AL)=0，否则 (AL)=0FFH 1234567MOV CX,2000MOV DH,11MOV DL,2MOV AH,2BHINT 21HCMP AL,0JNE ERROR ;转出错处理 读出系统时间（2CH号功能）执行该功能将获得系统的当前时间。返回的时间参数存放在指定的寄存器中： CH：小时（0—23） CL：分（0—59） DH：秒（0—59） DL：百分秒（0—99） 设置系统时间（2DH号功能）调用该功能，将设定系统时间。其入口参量为： CH：小时（0—23） CL：分（0—59） DH：秒（0—59） DL：百分秒（0—99） 该功能执行后返回时，如果调用成功，则（AL）=0。否则（AL）=0FFH 程序返回操作系统的方法在DOS操作系统下运行在早期的计算机中使用DOS操作系统，系统运行为单一进程，为了让系统运行完用户的程序后，能够正确地返回到操作系统，需要在程序中加上一些必要的语句。 一般有以下两种方法： 使用DOS系统功能调用实现返回 使用程序段前缀PSP实现返回 使用DOS系统功能调用实现返回执行DOS功能调用4CH，控制用户程序结束，并返回DOS操作系统。 在程序结束时，使用两条指令： 12MOV AH，4CHINT 21H 程序结构如下： 123456789101112131415161718DATA SEGMENT ; ……DATA ENDS ;定义数据段STACK1 SEGMENT PARA STACK DW 20H DUP (0)STACK1 ENDS ;定义堆栈段CODE SEGMENT ASSUME CS:CODE,DS:DATA,SS:STACK1START: ;指令开始地址 MOV AX,DATA MOV DS,AX ;初始化DS ; …… MOV AH, 4CH INT 21H ;返回DOS操作系统CODE ENDS END START ;汇编结束标志 使用程序段前缀PSP实现返回 DOS系统将一个.EXE文件（可执行文件）装入内存时，在该文件的前面生成一个程序段前缀PSP Program Segment Prefix。 PSP的长度为100H字节 系统将DS和ES都指向PSP的开始 CS指向该程序的代码段，即第一条可执行指令 PSP的开始是一条中断指令 INT 20H，执行该指令将终止用户程序，返回DOS系统。 内存结构 为了使程序执行完后，正确返回DOS，需要做以下三个操作： 将用户程序编制成一个过程,类型为 FAR 将PSP的起始逻辑地址压栈,即将 INT 20H 指令的地址压栈 在用户程序结尾处,使用一条 RET 指令。执行该指令将使保存在堆栈中的PSP的起始地址弹出到CS和IP中 123456789101112131415161718192021DATA SEGMENT ;……DATA ENDS ;定义数据段STACK1 SEGMENT PARA STACK DW 20H DUP (0)STACK1 ENDS ;定义堆栈段CODE SEGMENT ASSUME CS:CODE,DS:DATA,SS:STACK1MAIN PROC FAR ;设置为FAR过程 PUSH DS ;为返回操作系统执行INT 20H 指令做准备 MOV AX,0 PUSH AX ;立即数不能够作为操作数 MOV AX,DATA MOV DS,AX ;初始化DS ; ...... RET ;返回操作系统MAIN ENDPCODE ENDS END MAIN ;汇编结束标志 在Windows操作系统下运行Windows系统下系统的运行为多进程方式，进程间切换由系统自动完成，即当用户的程序结束后使用 HLT 就自动返回操作系统。 1234567891011121314151617DATA SEGMENT ; ......DATA ENDS ;定义数据段STACK1 SEGMENT PARA STACK DW 20H DUP (0)STACK1 ENDS ;定义堆栈段CODE SEGMENT ASSUME CS:CODE,DS:DATA,SS:STACK1START: ;指令开始地址 MOV AX,DATA MOV DS,AX ;初始化DS等 ; ...... HLT ;结束程序CODE ENDS END START ;汇编结束标志 汇编语言程序应用实例顺序程序设计实例例 1：利用学号查学生的数学成绩表 12345678910111213141516171819202122232425262728TITLE TABLE LOOKUPDATA SEGMENT TABLE DB 81, 78, 90, 64, 85, 76, 93, 82, 57, 80 DB 73, 62, 87, 77, 74, 86, 95, 91, 82, 71 NUM DB 8 MATH DB ?DATA ENDSSTACK1 SEGMENT PARA STACK DW 20H DUP(0)STACK1 ENDSCOSEG SEGMENT ASSUME CS:COSEG, DS:DATA, SS:STACK1START: MOV AX, DATA MOV DS, AX ;装入DS MOV BX, OFFSET TABLE ;BX指向表首址 XOR AH, AH ;(AH)=0 MOV AL, NUM DEC AL ;实际学号是从1开始的 ADD BX, AX ;BX加上学号指向要查的成绩 MOV AL,[BX] ;查到成绩送AL MOV MATH, AL ;存结果 MOV AH, 4CH ;返回DOS INT 21HCOSEG ENDS END START 分支程序实例用比较/测试指令+条件转移指令实现分支 CMP DEST，SRC：做减法 TEST DEST，SRC：做与运算 例 2：数据段的ARY数组中存放有10个无符号数，试找出其中最大者送入MAX单元。 123456789101112131415161718192021222324252627DATA SEGMENT ARY DB 17，5，40，0，67，12，34，78，32，10 MAX DB ?DATA ENDSSTACK1 SEGMENT PARA STACK DW 20H DUP(0)STACK1 ENDSCODE SEGMENT ASSUME DS:DATA CS:CODE SS:STACK1START: MOV AX, DATA MOV DS, AX ;SI指向ARY的第一个元素 LEA SI, ARY MOV CX, 9 ;CX作次数计数器，遍历后九个元素 MOV AL, [SI] ;取第一个元素到ALLOP: INC SI ;SI指向后一个元素 CMP AL, [SI] ;比较两个数 JAE BIGGER ;前元素≥后元素转移 MOV AL, [SI] ;取较大数到ALBIGGER: DEC CX ;减1计数 JNZ LOP ;未比较完转回去，否则顺序执行 MOV MAX, AL ;存最大数 MOV AH, 4CH INT 21HCODE ENDS END BEGIN 例 3：编写一程序，实现将存储器中的源数据块传送到目的数据块。 需要注意的是，在存储器中两个数据块的存放有下列情况：两个数据块分离和有部分重叠。 我们采用：当源块首地址 &lt; 目的块首地址时，从数据块末地址开始传送。反之，则从首地址开始传送。 123456789101112131415161718192021222324252627282930313233343536373839404142TITLE DATA BLOCK MOVEDATA SEGMENT ORG $+20H STRG DB 'ABCDEFGHIJ' ; 数据块 LENG EQU $-STRG ;数据块字节长度 BLOCK1 DW STRG ;源块首址 BLOCK2 DW STRG-5 ;目的块首址DATA ENDSSTACK1 SEGMENT STACK DW 20H DUP(0)STACK1 ENDSCOSE SEGMENT ASSUME CS:COSE, DS:DATA, SS:STACK1BEGIN: MOV AX, DATA MOV DS, AX MOV CX, LENG ;设置计数器初值 MOV SI, BLOCK1 ;SI指向源块首址 MOV DI, BLOCK2 ;DI指向目的块首址 CMP SI,DI ;源块首址&gt;目的块首址吗？ JA TOP ;大于则转到TOP处，否则顺序执行 ADD SI,LENG-1 ;SI指向源块末址 ADD DI,LENG-1 ;DI指向目的块末址BOTTOM: MOV AL，[SI] ;从末址开始传送 MOV [DI], AL DEC SI DEC DI DEC CX JNE BOTTOM JMP END1TOP: MOV AL,[SI] ;从首址开始传送 MOV [DI],AL INC SI INC DI DEC CX JNE TOPEND1: MOV AH, 4CH INT 21HCOSE ENDS END BEGIN 用跳转表形成多路分支当程序的分支数量较多时，采用跳转表的方法可以使程序长度变短。跳转表有两种构成方法： 跳转表用入口地址构成 跳转表用无条件转移指令构成 跳转表用入口地址构成这种方法将所有入口地址存在一个变量数组中（称为跳转表），跳转前取出对应地址然后直接跳。 例 4：设某程序有10路分支，试根据变量N的值（1~10），将程序转移到其中的一路分支去。 123456789101112131415161718192021222324252627282930313233TITLE JUMP TABLE OF ADDRESSDATA SEGMENT ATABLE DW BRAN1, BRAN2, BRAN3, ..., BRAN10 N DB 3DATA ENDSSTACK1 SEGMENT PARA STACK DW 20H DUP (0)STACK1 ENDSCODE SEGMENT ASSUME CS:CODE, DS:DATA, SS:STACK1START: MOV AX, DATA MOV DS, AX XOR AH, AH MOV AL, N DEC AL SHL AL,1 MOV BX,OFFSET ATABLE ;BX指向表首址 ADD BX,AX ;BX指向查表地址 MOV CX,[BX] ;将N对应的分支入口地址送到CX中 JMP CX ;转移到N对应的分支入口地址BRAN1: ; ... JMP END1BRAN2: ; ... JMP END1BRAN3: ; ... JMP END1 BRAN10: ; ...END1: MOV AH,4CH INT 21HCODE ENDS END START 跳转表用无条件转移指令构成跳转表的每一个项目就是一条无条件转移指令。这时跳转表是代码段中的一段程序。利用 每一条 JMP 指令都是3字节编码，可以在跳转表前计算出目标 JMP 指令的地址，然后跳转。 例 4 的另一种写法。 1234567891011121314151617181920212223242526272829303132333435363738394041TITLE JUMP TABLE OF INSTRUCTIONDATA SEGMENT N DB 3DATA ENDSSTACK1 SEGMENT PARA STACK DW 20H DUP(0)STACK1 ENDSCODE SEGMENT ASSUME CS:CODE, DS:DATA, SS:STACK1START: MOV AX,DATA MOV DS,AX MOV BH,0 MOV BL,N DEC BL ;四条指令实现(N-1)*3 MOV AL, BL ;每一条指令都是3字节编码 SHL BL, 1 ADD BL, AL ADD BX, OFFSET ITABLE ;BX指向查表地址 JMP BX ;转移到N对应的JMP指令ITABLE: JMP BRAN1 ;JMP指令构成的跳转表 JMP BRAN2 ;每一条指令都是3字节的编码 JMP BRAN3 ; ... ; ... JMP BRAN10BRAN1: ; ... JMP END1BRAN2: ; ... JMP END1; ...; ...BRAN10: ; ...END1: MOV AH,4CH INT 21HCODE ENDS END START 循环程序实例计数控制循环——循环次数已知使用 CX 计数即可。 例 5：设有两个数组X和Y，它们都有8个元素，其元素按下标从小到大的顺序存放在数据段中。试编写程序完成下列计算： 123Z1=X1+Y1 Z2=X2-Y2 Z3=X3+Y3 Z4=X4-Y4 Z5=X5-Y5 Z6=X6+Y6Z7=X7+Y7 Z8=X8-Y8 由于循环体中有“+”和“-”两种可能的运算，通过设置标志0(+)和1(-)来判断，低位表示低下标的运算。八个运算表达式由8位逻辑尺：10011010B来识别。 1234567891011121314151617181920212223242526272829303132DATA SEGMENT X DB 0A2H,7CH,34H,9FH,0F4H,10H,39H,5BH Y DB 14H,05BH,28H,7AH,0EH,13H,46H,2CH LEN EQU $ -Y Z DB LEN DUP(?) LOGR DB 10011010B ;设置标志0(+)和1(-)来判断，低位表示低下标的运算DATA ENDSSTACK0 SEGMENT PARA STACK DW 20H DUP(0)STACK0 ENDSCOSEG SEGMENT ASSUME CS:COSEG, DS:DATA, SS:STACK0BEGIN: MOV AX, DATA MOV DS, AX MOV CX, LEN ;初始化计数器 MOV SI, 0 ;初始化指针 MOV BL, LOGR ;初始化逻辑尺LOP: MOV AL, X[SI] SHR BL, 1 ;标志位送CF JC SUB1 ;为1，转做减法 ADD AL, Y[SI] ;为0，做加法 JMP RESSUB1: SUB AL, Y[SI]RES: MOV Z[SI], AL ; 存结果 INC SI ; 修改指针 LOOP LOP MOV AH, 4CH INT 21HCOSEG ENDS END BEGIN 条件控制循环——循环次数未知根据条件控制使用 JZ JL JG 等语句进行跳转实现循环。 例 6 编写一程序，将字单元 VARW 中含1的个数(含1的个数是指用二进制表示时,有多少个1)统计出来，存入CONT单元中。 1234567891011121314151617181920212223242526DATA SEGMENT VARW DW 1101010010001000B CONT DB ?DATA ENDSSTACK1 SEGMENT PARA STACK DW 20H DUP(0)STACK1 ENDSCODE SEGMENT ASSUME CS:CODE, DS:DATA, SS:STACK1BEGIN: MOV AX, DATA MOV DS, AX MOV CL, 0 ;初始值为0,统计1的个数 MOV AX, VARWLOP: EST AX, 0FFFFH ;测试（AX）是否为0 JZ END0 ;为0，循环结束 JNS SHIFT ;判最高位，为0则转SHIFT INC CL ;最高位为1，计数SHIFT: SHL AX, 1 JMP LOPEND0: MOV CONT, CL ;存结果 MOV AH, 4CH INT 21HCODE ENDS END BEGIN IA-32 微处理器的指令与汇编语言结构简介寻址方式相对 8086 来说，IA-32 扩充了寄存器结构，采用了多种存储器管理方式 ，因此其寻址方式有了较大的增强。 允许使用 32 位的通用寄存器作寄存器间接寻址。例如：MOV DX, [EBX] 所有的32位通用寄存器均可作为基址寄存器使用；除 ESP 外的32位通用寄存器都能作为变址寄存器使用。 例如： 123MOV EDX, [EDX+16]MOV AX, ADDR[EBP]MOV EBX, [ESI][EAX] 32 位的变址寄存器可以乘上一个比例常数2、4和8，从而形成比例变址寻址方式、基址-比例变址寻址方式和基址-比例变址-位移寻址方式。 寻址方式 上述三种情况可用如图公式表示。 例如： 123MOV EBX, ADDR[ESI*2] ; 比例变址寻址方式MOV EAX, [EDI*4][EDX] ; 基址比例变址寻址方式MOV EBX, [EDI*8][EBP+10] ; 基址比例变址位移寻址方式 扩展的指令IA-32微处理器对8086/8088的指令进行了扩展或新增了指令。所有指令的操作数可以是8位、16位或32位。 下面列举其中部分新增的指令。 数据传送指令符号扩展：MOVSX MOVZX格式：MOVSX DEST, SRC MOVZX DEST, SRC 两种用法： 8 位寄存器/存储器 -&gt; 16/32 位寄存器 16 位寄存器/存储器 -&gt; 32 位寄存器 MOVSX是带符号数扩展指令（符号填充），MOVZX是无符号数扩展指令（零填充） 例如： 12MOVSX ECX, AX ; 将字扩充到双字MOVZX BX, AL ; 将字节扩充到字 取偏移量 LFS LGS LSS类似于 LDS、LES（DEFG 还行） LFS 指令将 32 位的偏移量送目的寄存器，16 位的段选择子送 FS。 其他两条指令类似，只是段寄存器变为GS和SS。 算术运算指令新增了两种乘法指令，格式： 12345IMUL DEST, SRC ; 将(SRC)与(DEST)相乘，将结果放在 DEST 中IMUL DEST, SRC1, SRC2; 将(SRC1)与(SRC2)相乘，将结果放在 DEST 中 新增了两条扩展指令。 12345678CWDE; Convert Word to Doubleword; 将AX的符号位扩展到EAX的高16位; 加一个 E 与 CWD （扩展位放在 DX）以示区别CDQ; Convert Dooubleword to Quadword; 将EAX的符号位扩展到EDX的所有32位 逻辑运算与移位指令 对于移位指令，当移位次数大于 1 时，允许使用立即数作为操作数。 例如，SAL AX, 2 新增了 SHLD 与 SHRD 指令 12345SHLD DEST, SRC, OPTR; 对 DEST 左移 OPTR 位，移出的位依次进入 CF 标志位，DEST 空出的位由 SRC 的高位顺序移入。移位结束后SRC保持不变SHRD DEST, SRC, OPTR; 对 DEST 右移 OPTR 位，移出的位依次进入 CF 标志位，DEST 空出的位由 SRC 的低位顺序移入。移位结束后，SRC保持不变 8086 的 RCL RCR只能移一次，空出的位由 CF 补。 堆栈操作指令 PUSH允许立即数入栈 12PUSH 0ABCDH ;将16位立即数入栈PUSH 0ABCD0000H ;将32位立即数入栈 新增两条PUSH指令 PUSHA 指令将8个16位通用寄存器AX、BX、CX、DX、SP、BP、SI与DI一次性入栈。 PUSHD 指令将8个32位通用寄存器EAX、EBX、ECX、EDX、ESP、EBP、ESI与EDI一次性入栈。 似乎是为了函数调用时保存所有寄存器值？ 新增两条POP指令 与上面对应地： POPA指令从栈顶弹出8个字数据分别送入AX、BX、CX、DX、SP、BP、SI与DI。 POPD指令从栈顶弹出8个双字数据分别送入EAX、EBX、ECX、EDX、ESP、EBP、ESI与EDI。 IA-32 汇编语言程序框架概述IA-32汇编语言程序设计的方法同前面介绍的16位指令程序设计基本相同。但在结构上有三点主要差异。 在开始处增加了方式选择； 在段定义中增加了使用类型可选项； 可以同时使用6个段。 方式选择方式选择伪指令用来确定微处理器工作模式和当前指令集。 .8086 -选择8086/8088指令集。这是汇编程序默认的方式。.286 -选择80286实地址方式指令集.286P -选择80286保护方式.386 -选择80386非保护方式指令集。.386P -选择80386保护方式 确定段的使用类型属性IA-32的段定义格式：段名 SEGMENT [定位类型] [组合类型] [类别名] [使用类型]，较8086多了一个使用类型。 使用类型: 有USE16和USE32两种取值，用来定义段寻址方式 USE16：8086/8088实地址方式，段基值16位，偏移量16位，最大段长64KB。该值为缺省值 USE32：对应保护方式，段基值(段选择子)16位，偏移量32位，最大段长4GB。 例题例: 统计一个字数组中非负数的个数，结果保存在RESULT单元中。 123456789101112131415161718192021222324.386DATA SEGMENT PARA USE16ARRAY DW 234, -87, 65, 0, 23, -54, 23,44,-54, 0CNT EQU $-ARRAYRESULT DW ?DATA ENDSSTACK1 SEGMENT PARA STACK USE16 DW 100 DUP(?)STACK1 ENDSCODE SEGMENT PARA USE16 ASSUME CS:CODE, DS:DATA, SS:STACK1 BEGIN: MOV AX, DATA MOV DS, AX LEA SI, ARRAY MOV CX, CNT/2ACS: LODSW BT AX, 15 ;386新增指令,将AX的第15位送CF JC NEXT INC RESULTNEXT: LOOP ACS MOV AH, 4CH INT 21HCODE ENDS END BEGIN bt是位操作指令： 指令的格式：BT/BTC/BTR/BTS Reg/Mem,Reg/Imm ;80386+位检测指令是把第一个操作数中某一位的值传送给标志位CF，具体的哪一位由指令的第二操作数来确定。根据指令中对具体位的处理不同，又分一下几种指令：BT：把指定的位传送给CF；BTC：把指定的位传送给CF后，还使该位变反；BTR：把指定的位传送给CF后，还使该位变为0；BTS：把指定的位传送给CF后，还使该位变为1；例如：假设(AX)=1234H，分别执行下面指令。BT AX, 2 ;指令执行后，CF=1，(AX)=1234hBTC AX, 6 ;指令执行后，CF=0，(AX)=1274hBTR AX, 10 ;指令执行后，CF=0，(AX)=1234hBTS AX, 14 ;指令执行后，CF=0，(AX)=5234h 下面再看一个不像前面学的汇编语言的汇编语言程序： 123456789101112131415161718.386.model flat, stdcall;Include文件定义include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;数据段. DataCaption db ‘A MessageBox !’,0Text db ‘Hello, World !’, 0;代码段.codestart： invoke MessageBox，NULL,offset Text, offset Caption,MB_OK invoke ExitProcess, NULLend start 程序执行结果 第六章 输入输出及中断技术输入输出系统概念输入输出系统：计算机系统中除 CPU 和内存储器之外的部分 I/O系统分为： 输入输出设备 输入输出接口 输入输出软件 特点： 复杂性：输入输出设备、处理器、操作系统的复杂性 异步性：工作速度和时序不一致 实时性：控制的时效性。I/O系统保证处理器对不同设备的请求提供及时服务 与设备无关性：接口的标准化，由操作系统屏蔽了设备的差异。 I/O 接口系统及接口有关I/O系统的概念、特点，以及I/O接口的功能等，请参阅教材描述，自行学习。 总体上，I/O接口应具备以下功能： 数据的缓冲与暂存 信号电平与类型的转换 增加信号的驱动能力 对外设进行监测、控制与管理，中断处理 I/O 端口 端口：接口中的寄存器 端口的主要作用：信息的缓存 端口类型： 数据端口：缓存输入和输出的数据 状态端口：缓存需要输入的外设工作状态 控制端口：缓存由系统输出的各种控制信息 I/O端口 I/O系统中的接口和端口的地址： 每个接口为一个芯片，每个芯片有一个基地址。 端口地址=芯片地址（高位地址）+片内地址 I/O 端口的编址方式编址方式： 与内存统一编址 独立编址 I/O 端口与内存统一编址 指令及控制信号统一 内存地址资源减少 I/O端口与内存统一编址 I/O 端口独立编址 内存地址资源充分利用 能够应用于端口的指令较少 I/O端口独立编址 8088/8086 的 I/O 端口编址 采用I/O端口独立编址方式(但地址线与存储器共用) 地址线上的地址信号用$IO/\\overline{M}M$（$\\overline{IO}/M$）来区分 I/O操作只使用20根地址线中的16根：A15~A0 可寻址的I/O端口数为64K(65536)个 I/O地址范围为0~`FFFFH` I/O 地址译码 I/O地址译码 全地址译码与部分地址译码一个接口电路中可以有一个或多个端口。 全地址译码： 全部16位I/O地址信号参与译码 当接口中只有一个端口时， 16位地址线应全部参与译码，译码输出直接选择该端口中； 当接口中有多个端口时，则16位地址线的高位参与译码（决定接口的基地址），低位直接输入到接口芯片，用于寻址接口中要访问的端口。 部分地址译码： 仅用部分地址（比如16位中低10位）信号参与译码 含多个端口的接口，最低的几位直接连到接口芯片 I/O系统中，因地址资源丰富，多采用部分地址译码。 看不出来有什么区别。 I/O地址译码例题例：某外设接口有 4 个端口，地址为 2F0H——2F3H，由 A15～A2 译码得到，而 A1、A0 用来区分接口中的 4 个端口。试画出该接口与系统的连接图。 题目分析： 寻址端口的地址信号最多为 16bit，题中仅用 12bit 就能表示其地址——故采用部分地址译码 该接口电路中含有4个端口，片内端口寻址需 2 位地址信号，其余 10 位为接口芯片地址，即片选地址信号。 地址范围： xxxx 0010111100 00 (2F0H) …… xxxx 0010111100 11 (2F3H) x 表示任意状态，图中无需接入；后两位表示片内地址 译码电路图 最上面表示 $\\overline{IOR}$ 和 $\\overline{IOW}$ 至少有一个是 0（有效）时芯片有效，若都是 1 则芯片无效。 接口的基本构成 接口的基本构成 AB (Address Bus) DB (Data Bus) CB (Control Bus) 数据输入/输出寄存器：暂存输入/输出的数据 命令寄存器：存放控制命令（设定接口功能、工作参数和工作方式） 状态寄存器：保存外设当前状态，以供CPU读取 接口的类型及特点 按传输信息的方向分类： 输入接口 输出接口 按传输信息的类型分类： 数字接口 模拟接口 按传输信息的方式分类： 并行接口 串行接口 接口特点： 输入接口： 要求对数据具有控制能力（允许数据送到数据线） 常用三态门实现 输出接口： 要求对数据具有锁存能力（接收后保持数据不变） 常用锁存器实现 简单接口电路三态门接口及 74LS244三态：高电平、低电平、高阻态 三态门接口 74LS244： 含8个三态门的集成电路芯片 在外设具有数据保持能力时用来输入接口数据 74LS244 例题：编程判断图中的开关状态，若全闭合则转NEXT1，否则转NEXT2。 例题图 注意到开关 K0~K7 的另一侧接了地。如果开关闭合，输入 I0~I7 应该为 0。反之为 1。 由图可知对应的地址为： 1000 0111 1111 11xx 即 83FCH~83FFH。 可以任选其中一个地址如 83FCH 作为该接口地址，编程如下： 12345MOV DX, 83FCHIN AL, DXAND AL, 0FFH ; 闭合为 0JZ NEXT1JMP NEXT2 锁存器接口及 74LS273 74LS373 74LS374锁存器接口： 通常由 D 触发器构成 特点： 具有对数据的锁存能力 不具备对数据的输出控制能力 74LS273：8 个 D 触发器 74LS273 74LS373和74LS374： 三态输出的8 D触发器，并具有对数据的控制能力。 既可以做输入接口，也可以做输出接口。 74LS374 不懂 例题：输出接口地址是多少？ 例题图 不懂+1 I/O接口综合应用例题（重要！） 根据 4 个开关的状态控制 7 段数码管的显示（输入：4位开关 输出：显示符号与输出数据对应表中的 7 位） 当4个开关的状态分别为0000~`1111`时，在7段数码管上对应显示’0’～’F’ 设显示接口的地址为 F0H，开关接口地址为 F1H 数码管结构图 显示符号与输出数据对应表 解：下面是总线连接图。 四个开关 K0~K3 连接 74LS244，输入到 CPU 汇编程序将 D0~D3 转为上表中的 8 位值 8 位值通过 D0~D7 连接 74LS273，输出到数码管 译码器部分有一个 74LS138，它把 3 位信号 (A B C) 转为 Y0~Y7（此问只用到了 Y0 和 Y1）。A3~A7 接入到 74LS138 的使能端。 总线连接图 程序段： 1234567891011121314......Seg7 DB 3FH,06H, 5BH,4FH,66H,6DH, 7DH,07H,7FH,67H,77H, 7CH,39H,5EH,79H,71H...... LEA BX, Seg7 MOV AH, 0GO: IN AL, 0F1H AND AL, 0FH MOV SI, AX MOV AL, [BX+SI] OUT 0F0H, AL JMP GO 基本输入/输出方法基本输入/输出方法有： 无条件传送 查询式传送 中断方式传送 直接存储器存取(DMA) 其中前三种是程序控制方式。 无条件传送要求外设总是处于准备好状态。 优点： 软件及接口硬件简单 缺点： 只适用于简单外设，适应范围较窄 例：读取开关的状态；当开关闭合时，输出编码使发光二极管亮。 查询工作方式 仅当条件满足时才能进行数据传送； 每满足一次条件一般只进行一次数据传送。 适用场合： 外设并不总是处于“准备好”状态 对传送速率和效率要求不高 工作条件： 外设应提供设备状态信息 接口应具备状态端口 单个外设的查询工作方式流程图 上述流程图可能出现一直等待外设，导致死机的情况。 单个外设的查询工作方式流程图（改进） 例：数据输出 外设状态端口地址为03FBH，bit5 为状态标志（=1忙，=0准备好） 外设数据端口地址为03F8H，CPU 写入数据会使状态标志置1；外设把数据读走后又把它置 0。 试画出其电路图，并将 BUF 中的 100 个字节数据输出。 1234567891011 MOV CL, 100 LEA SI, BUFAGAI: MOV DX, 03FBH NEXT: IN AL, DX TEST AL, 20H JNZ NEXT MOV DX, 03F8H MOV AL, [SI] OUT DX, AL INC SI LOOP AGAI 多个外设时查询工作方式 优点：软硬件比较简单 缺点：CPU 效率低，数据传送的实时性差，速度较慢 多个外设时查询工作方式 中断控制方式 特点：外设在需要时向CPU提出请求，CPU再去为它服务。服务结束后或在外设不需要时，CPU可执行自己的程序。 优点：CPU 效率高，实时性好，速度快。 缺点：程序编制相对较复杂。 以上三种I/O方式的共性 信息的传送均需通过CPU 软件： 外设与内存之间的数据传送是通过CPU执行程序来完成的（PIO方式）； 硬件：I/O接口和存储器的读写控制信号、地址信号都是由CPU发出的。 缺点：程序的执行速度限定了传送的最大速度 DMA控制方式 外设直接与存储器进行数据交换 ，CPU不再担当数据传输的中介者； 总线由DMA控制器（DMAC）进行控制（CPU要放弃总线控制权），内存/外设的地址和读写控制信号均由DMAC提供。 DMA控制方式 DMA控制方式的工作过程： 外设向DMA控制器发出“DMA传送请求”信号 DREQ； DMA控制器收到请求后，向CPU发出“总线请求”信号HOLD； CPU在完成当前总线周期后会立即发出HLDA信号，对HOLD信号进行响应； DMA控制器收到HLDA信号后，就开始控制总线，并向外设发出DMA响应信号DACK。 DMA控制方式工作过程例：从外设向内存传送若干字节数据 DMAC向I/O接口发出读信号； 向地址总线上发出存储器的地址； 发出存储器写信号和AEN信号； 传送数据并自动修改地址和字节计数器 判断是否需要重复传送操作; 若数据传送完，DMA控制器撤销发往CPU的HOLD信号； CPU检测到HOLD失效后，则撤销HLDA信号，并在下一时钟周期重新开始控制总线。 DMA工作方式： 周期窃取：每个DMA周期只传送一个字节或一个字就立即释放总线。 数据块传送：DMAC在申请到总线后，将一块数据传送完后才释放总线，而不管中间DREQ是否有效。 周期窃取的DMA DMA控制方式的优缺点： 优点：数据传输由DMA硬件来控制，数据直接在内存和外设之间交换，可以达到很高的传输速率。 缺点：控制复杂，硬件成本相对较高。 中断技术基本概念CPU执行程序时，发生了某种随机的事件(外部或内部)，引起CPU暂时中断正在运行的程序，转去执行一段特殊的服务程序(称为中断服务程序或中断处理程序)，以处理该事件，该事件处理完后又返回被中断的程序继续执行，这一过程称为中断。 中断源：引起CPU中断的事件，发出中断请求的来源。 分类 内部中断 异常中断：异常事件引起 软件中断：中断指令引起 外部中断 可屏蔽中断：INTR 中断 非屏蔽中断：NMI 中断 引入中断的原因： 提高数据传输率； 避免了CPU不断检测外设状态的过程，提高了CPU的利用率。 实现对特殊事件的实时响应。 中断处理的一般过程 中断请求 中断源识别及中断判优 中断响应 中断处理（服务） 中断返回 中断请求 包括 NMI、INTR 中断请求信号应保持到中断被处理为止； CPU响应中断后，中断请求信号应及时撤销。 中断源识别 软件查询法：在中断处理程序中查找中断源 中断矢量法—硬件识别 由中断源提供中断类型号，CPU根据类型号确定中断源。 中断源识别及中断判优（确定先响应哪个中断请求）由硬件系统完成 中断判优当有多个中断源同时提出请求时，需要确定首先响应哪一个中断源。 优先级法则： 同时出现或等待的多个中断源，优先级最高的被响应。 低优先级的中断程序允许被高优先级的中断源所中断（可能出现中断嵌套） 也可以设置成禁止中断嵌套 软件判优：顺序查询中断请求，先查询的先服务，即先被查询的中断源优先级别高硬件判优：链式判优、并行判优（中断向量法） 菊花链逻辑电路 看不懂图。 中断响应中断响应包含以下几个操作： 向中断源发出中断响应信号 $\\overline{INTA}$ 关中断 保护硬件现场：将FLAGS压入堆栈 保护断点：将CS、IP压入堆栈 获得中断服务程序入口地址 这些步骤都是由硬件系统完成。 中断处理执行中断服务程序 中断服务程序的特点： 中断服务程序要定义为“远过程” 结束时要用 IRET 指令返回 中断服务程序完成的工作： 保护软件现场（参数） 开中断 STI–允许中断嵌套 中断处理—具体的处理 关中断 CLI 恢复软件现场 中断返回 IRET 中断返回执行 IRET 指令，包括下面的操作： 使 IP、CS 和 FLAGS 从堆栈弹出 开中断 外部可屏蔽中断处理过程 8088/8086中断系统在8086/8088所有的中断源都统一分配了不同的类型号 8088/8086中断系统 内部中断 中断类型 功能 类型0 除数为0中断例行程序 类型1 单步 类型2 非屏蔽中断，NMI 类型3 设置断点 类型4 溢出处理中断，INTO指令 类型10H 显示设备中断 类型20H 程序结束中断 类型21H DOS系统功能调用功能程序 外部中断 非屏蔽中断 NMI 引脚上出现上升沿触发 不受标志位IF的限制，即不可以屏蔽。 类型号：2 可屏蔽中断 INTR引脚输入，高电平有效 受标志位IF的限制 类型号：08H~0FH 70H~77H 中断向量表 存放各类中断的中断服务程序的入口地址； 每个入口占用4 Bytes，低字为段内偏移，高字为段基址； 表的地址位于内存的00000H～003FFH，大小为1KB，共256个入口。 中断向量表 IVT8086/8088中断向量表位于内存最低1KB 中断向量表 IVT 中断向量表的初始化 系统启动时已经把默认的中断向量写入IVT 用户需将自定义的中断服务程序入口地址放入向量表 注意点： 向量表所在的段基址=0 存放中断服务程序入口的单元的偏移地址=n*4 例：将中断类型码为48H的服务程序入口地址放入向量表 1234567891011121314TIMER PROC FAR ; ... ; ... IRETTIMER ENDP; 下面的程序用MOV指令将类型码为48H的中断服务程序TIMER的中断向量放入向量表MOV AX，0000HMOV DS，AXMOV SI，0120H ; 48H*4MOV BX，OFFSET TIMERMOV [SI]，BXMOV BX，SEG TIMER MOV [SI+2]，BX 可屏蔽中断的类型号的获取时序对可屏蔽中断的响应需要两个总线周期： 可屏蔽中断的类型号的获取时序 8088内部中断与NMI中断特点： 无 $\\overline{INTA}$ 总线周期 中断类型码固定或由指令给出 8086的中断响应和处理流程 8086的中断响应和处理流程 IA-32的中断模式 picture 29 picture 30 picture 31 picture 32 picture 33 中断控制器 8259A 介绍一. 8259A 的功能与结构8259A 的主要功能 记录 8 个中断源的中断请求。 确定是否响应中断请求，并确定优先的中断请求并响应。 CPU 响应中断时向 CPU 发送中断类型号。 8259A 的内部结构 8259A的内部结构 6-5-p4 6-5-p5 6-5-p6 三个寄存器的英文分别是 Interrupt Request Register (IRR), In-Service Register (ISR), Interrupt Mask Register (IMR)。这三个的功能一定要记住，当然要是记住了英文就很好记了。 8259A 的工作原理 当IR0～IR7中的一条或多条请求线变高时，将相应的IRR位置1。 根据中断服务寄存器（ISR）和中断屏蔽寄存器（IMR）的内容，找出未被屏蔽的最高优先权的中断请求，向CPU发中断请求信号INT。 CPU响应中断时，送回应答信号 $\\overline{INTA}$ 脉冲。 8259A接到CPU发的第一个 $\\overline{INTA}$ 脉冲时，把ISR中与最高优先级请求信号对应的位置1，并把IRR中的相应位复位。 在8259A接到第二个 $\\overline{INTA}$ 脉冲时向CPU发送中断类型码。如果是在AEOI（自动结束中断）方式，在这个脉冲结束时复位ISR的相应位。在其他方式下，要在中断服务程序结束时通过发EOI命令来复位ISR相应位。 8259A 的外部特性 8259A与CPU的接口引脚图 8259A与CPU的接口引脚(1) 8259A与CPU的接口引脚(2) 二. 8259A 的工作方式下面的部分应该只用对名字留一个印象，具体是什么功能、怎么工作，应该不重要。 1. 优先级管理方式1) 中断嵌套方式 普通全嵌套方式 这是最常用最基本的工作方式，8259A初始化后为该方式。 当一个中断正被处理时，只有比它优先级更高的中断请求才会被响应。 特殊全嵌套方式 它与普通全嵌套方式的区别是：允许同级中断进行嵌套 只允许主片8259A使用特殊全嵌套方式，以实现从片中的高低优先级之间的嵌套。 以上两种嵌套方式中各中断源的优先级顺序是固定的，加电时优先级从高到低顺序为：IR0、IR1、IR2、IR3、IR4、IR5、IR6、IR7。也可以重设和循环优先级。 2) 优先级变化方式 优先级固定方式 各中断请求的优先级固定不变，8259A加电后IR0最高，IR7最低。 优先级循环方式 优先队列是变化的，一个中断源得到中断服务后，它的优先级自动降为最低。 按照加电时的优先级顺序进行优先级循环称为优先级自动循环方式。改变初始优先级顺序后的循环，称为优先级特殊循环方式。 优先级循环方式适合于系统中各个中断源级别相当，能够得到均衡的服务。 2．中断源的屏蔽方式 常规屏蔽方式 8259A的每个中断请求输入端都可通过对应的IMR位的设置被屏蔽。IMR某位为“1”表示屏蔽对应的中断请求。 特殊屏蔽方式 使正在处理的中断所对应的IMR位置1，并使对应的ISR位清零，这样任何优先级的中断都可得到响应。 主要用在中断服务程序中需要动态地改变系统的优先级结构的情况。 例如，在执行中断服务程序的某一部分时，需要禁止比本中断优先级低的其他中断请求，而在执行另一部分时，又希望开放这些中断请求。 看不懂 3．中断结束的处理方式中断结束 (End of Interrupt, EOI) 自动中断结束方式 它是最简单的中断结束方式。 系统进入中断过程，在第二个INTA脉冲的后沿，8259A将当前处理的中断所对应的ISR位清零。 当系统正在为某外设进行中断服务，但在8259A的ISR中却没有对应位指示，故该方式只能用于非嵌套方式处理。 在初始化时由初始化命令字ICW4的AEOI位置1来设置这种方式。 正常中断结束方式 它用在两种全嵌套方式下，当CPU向8259A发出中断结束命令时，8259A将ISR中优先级最高的位复位（即当前正在进行的中断服务结束）。 这种结束方式的操作很简单，通过向8259A的偶地址端口输出一个操作命令字OCW2来发EOI命令。 特殊中断结束方式 用这种方式结束中断时，在程序中要发一条特殊中断结束命令，指出当前中断服务寄存器ISR中的哪一位将被清除。 它通过向8259A的偶地址端口输出一个操作命令字OCW2，其中的L2、L1、L0这三位指出了对ISR中的哪一位进行清除。 该方式用于中断优先级顺序会改变的特殊全嵌套方式（两种优先级循环方式），无法判断ISR的哪位是当前处理的中断。 对于多片8259A级联情况，如果不是自动中断结束方式，在中断服务程序的最后需要发两次EOI命令，分别清除从片中的ISR位和主片中的ISR位。 对于采用特殊嵌套方式的多片级联，从片中可能嵌套有多个中断源，应先向从片发EOI命令，然后读ISR，检查还有无为1的位，如无则才能向主片发EOI命令。 这说的是人话吗（逃 4．连接系统总线的方式 缓冲方式 在很多片8259A级联的大系统中，8259A需要通过总线驱动器和数据总线相连，这就是缓冲方式。 在缓冲方式下，8259A的SP/EN端和总线驱动器的允许端相连， SP/EN端输出的低电平可作为总线驱动器的控制信号。 非缓冲方式 当系统中只有单片8259A或有少量几片8259A级联时，一般将8259A直接与数据总线相连，这种方式就称为非缓冲方式。 8259A的SP/EN端作为输入端，在单片8259A系统中， SP/EN端接高电平；在多片系统，主片的SP/EN 端接高电平，从片的SP/EN端接低电平。 8259的级联结构 5．中断触发方式 电平触发方式 把中断请求输入端的高电平作为中断请求信号。这时高电平信号不能持续太久，否则一次中断请求可能会被多次响应。 边沿触发方式 8259A将中断请求输入端IRi出现的上升沿作为中断请求信号。该中断请求得到触发后可以一直保持高电平。 真心看不懂。 三. 8259A 的初始化命令字和初始化流程 ICW OCW 下面的图考试应该会给吧。应该就是依葫芦画瓢的事情了。 8259A 读写功能的实现 ICW1 ICW2 ICW2是用来设置中断类型码，编程时用ICW2设置中断类型码高5位T7～T3（即D7～D3），而D2～D0的值恒为零。 中断类型码的高5位就是ICW2的高5位，而低3位是由引起中断请求的引脚IR0～IR7决定。 例如：ICW2为20Ｈ，则8259A的IR0～IR7对应的8个中断类型码为20H、21H、22H、23H、24H、25H、26H、27H。 ICW3 ICW4 ICW4 说明 ICW4 说明（续） 8259A 的初始化流程： 8259A 的初始化流程 例题：以微型计算机中使用的单片8259A为例，试对其进行初始化设置。在微型计算机中，8259A的ICW1和ICW4的端口地址分别为20H、21H。初始化设置的程序段如下： 123456MOV AL, 13H ;设置ICW1（中断请求信号采用边沿触发方式；单片；后面要写ICW4）OUT 20H, AL MOV AL, 18H ;设置ICW2（将中断类型码高5位指定为00011）OUT 21H, ALMOV AL, 0DH ;设置ICW4（用常规全嵌套方式；不用中断自动结束方式；采用缓冲方式；工作于8088/8086系统）OUT 21H, AL 应该对照着表就能做叭。 四. 8259A 的操作命令字 对8259A用初始化命令字初始化后，就进入工作状态了，准备接受IRi输入的中断请求信号。 在8259A工作期间，可通过操作命令字（OCW）来使它按不同的方式操作。 8259A有3个操作命令字OCW1-OCW3，没有写入顺序和时间要求，可独立使用。 OCW1写入奇地址，OCW2和OCW3写入偶地址。 OCW1 8259A初始化后缺省的状态是全部屏蔽位=0(允许中断) 例：若要屏蔽IR5、IR4和IR1引脚上的中断，而让其余的中断得到允许。试确定其中断屏蔽操作命令字。 OCW1为：00110010 或 32H。 OCW2 OCW2具有发EOI命令和设置优先级循环方式的两种功能，其中101和111两种情况是结束中断后的系统方式设置。 R：优先级方式控制位。 1：循环优先级 0：为固定优先级。 SL：指示OCW2中L2～L0位是否有效。 1：有效； 0：无效。 EOI：在非自动中断结束方式下的中断结束命令位。 1：发中断结束命令，它使现行中断的ISR位复位； 0：不发出中断结束命令。 L2～L0：它有两个作用。 (1)设定优先级特殊循环方式时初始的最低优先级序号； (2)在特殊中断结束命令中指明ISR的哪位被复位。 例：若某8259A的OCW2设置为11000011B，试分析此操作命令字所确定的操作方式。 该命令字确定8259A为优先级特殊循环（参见优先级变化方式），将IR3定为最低优先级。因此，系统中优先级从高到低为IR4、IR5、IR6、IR7、IR0、IR1、IR2、IR3。 OCW3 有三个功能： 设置特殊中断屏蔽方式：D6D5=11为设置，10为清除. 查询中断请求：使P=1先写到8259A，再对该地址读入，得到中断状态字节（见下图）。 I=1,表示IR0~IR7中有中断请求，R2R1R0表示其中最高优先级的编号（IRi）； I=0，表示无中断请求产生。 读8259A的状态 写RR和RIS=10的OCW3到8259A，再读该地址，得到IRR的内容； 写RR和RIS=11的OCW3到8259A，再读该地址，得到ISR的内容； 中断状态字 如果要读IMR，只需要从奇地址端口(A0=1)读8259A即可，与OCW3无关。 五. 8259A 的应用举例两片级联，应该不会考（） 设两片8259A级联，提供15级向量中断，CAS2～CAS0作为互连线，从片8259A的INT直接连到主片8259A的IR2上。 端口地址，主片在020H～03FH范围内，实际使用020H和021H两个端口；从片在0A0H～0BFH范围，实际使用0A0H和0A1H两个端口。 主、从片的中断请求信号均采用边沿触发方式。 主片与从片采用一般全嵌套方式，优先级的排列次序为0级最高（主片的IR0），依次为1级（主片的IR1）、2级（主片的IR2，即从片的IR0 ～IR7），然后是3级～7级（主片的IR3～IR7）。 采用非缓冲方式，主片的SP/EN端接+5V，从片的SP/EN端接地。 设定主片的中断号为08H～0FH，从片的中断号为70H～77H。 两个8259A的级联图 对主片8259A的初始化： 12345678910111213141516171819INTM00 EQU 020H ;主8259A端口0INTM01 EQU 021H ;主8259A端口l…… MOV AL, 00010001B;ICWl; 边沿触发，要ICW4，级联方式 ；要ICW3OUT INTM00, ALJMP SHORT $+2 ;延迟=该指令的执行时间，$+2是下条指令MOV AL, 00001000B ;ICW2：设置主片的中断向量，起始 ;的中断向量为08HOUT INTM01, ALJMP SHORT $+2MOV AL, 00000100B ;ICW3：主片的IR2接从片8259A的INT OUT INTM01, ALJMP SHORT$+2MOV AL, 00000001B ;ICW4：非总线缓冲，常规全嵌套， ;正常结束中断方式OUT INTM01, ALJMP SHORT$+2 对从片8259A的初始化： 12345678910111213141516171819INTS00 EQU 0A0H ;从片8259A端口0INTS01 EQU 0A1H ;从片8259A端口1MOV AL, 0001000lB ;ICWl：边沿触发，要ICW4； ;级联方式，要ICW3OUT INTS00, AlJMP SHORT $+2MOV AL, 01110000B ;ICW2：设置从片的中断向量， ；起始的中断向量为70HOUT INTS01, ALJMP SHORT $+2MOV AL, 00000010B ;ICW3，设置从片的识别标志， ；即指定连接主片的IR2OUT INTS01, ALJMP SHORT $+2MOV AL, 00000001B ;ICW4：非总线缓冲，常规全嵌套， ；正常结束中断方式OUT INTS01, ALJMP SHORT $+2 123456789101112131415161718192021222324252627282930MY_INT PROC FARPUSH AXPUSH BX….STI&lt;中断服务程序主体&gt;CLI….POP BXPOP AXMOV AL, 20H ; 用OCW2写EOI 命令 ， 00100000BOUT A0H, AL ;向从片发EOI命令MOV AL, 20HOUT 20H, AL ; 向主片发EOI命令IRET MY_INT ENDPCLI PUSH DSXOR AX, AXMOV DS, AXMOV BX, n ; 中断类型号MOV CL,2SHL BX, CL ;向量表偏移地址=nX4MOV AX, OFFSET MY_INTMOV [BX], AXMOV AX, SEG MY_INTMOV [BX+2], AXPOP DS;按上述方法设置用户的各个中断向量STI 第七章 常用数字接口电路7.1 并行通信与串行通信1. 并行通信 定义：能同时传送一个数据的所有位。 一个数据的位数可以是字节或字长。两个设备之间有必须有多条数据传输线，才能实现多位数据同时传输。 并行通信 并行方式主要用于近距离通信，如计算机内的总线结构 并行通信有简单接口和可编程接口 特点： 传输速度快，处理简单； 适合近距离传送； 所传送信息无固定格式要求。 2. 串行通信 定义：数据逐位顺序传送。 数据一位一位通过同一通信线进行传输。 发送设备将几位并行数据转换成串行方式，再逐位传输到接收设备。在接收端将数据从串行方式转换成并行方式。 串行通信 数据传送方式： 双工：两根数据传输线，能够同时发送和接收 半双工：单根数据传输线，不能同时发送和接收 单工：单根数据传输线只用作发送或只用作接收 通信方式： 同步通信：通信时，发送方和接收方的时钟频率和相位保持一致，收发双方采用同一个时钟信号来定时。每两个字符间的时间间隔固定。 异步通信：收发双方没有统一的时钟来定时和同步，每两个字符间的时间间隔不固定。 传输速率： 在通讯中，用波特率来描述数据的传输速率。即每秒钟传送的二进制位数，简写为bps。 7.2 可编程计数/定时器芯片 8253 定时/计数器的应用 生产线上统计产品的数目—-计数器 系统的动态存储器刷新—-定时器 系统时钟计时—-定时器 扬声器的频率源—-定时器 常用的定时方法 软件定时：优点是节省硬件；缺点是执行程序期间CPU一直被占用，降低了CPU效率 硬件定时：要用额外的硬件—计数/定时器，但可提高CPU的利用率 8253 基本功能 具有三个相互独立的16位计数器，也叫通道。 每个通道都可设定以6种工作方式之一进行计数/定时 每个计数器都可设为按二进制或BCD码计数 具有计数和定时功能，都是基于减1计数方式工作。 计数器减为0后，产生输出信号，有的方式可自动装入初值重新计数。 在减1过程中，随时都可由CPU读取计数器的当前值。 8253 结构 8253 引脚 8253 接口 8253 寄存器选择表 8253 内部结构 各计数器的内部结构 8253的控制字8253工作前需要通过控制字进行设置，每个计数器（通道）都要单独写控制字，端口地址都为同一个地址。 8253的控制字 似乎挺好理解的，比 8259 的控制字好理解多了。 虽然我还是不会背 8253的工作方式8253共有6种工作方式：方式0~方式5。 8253各工作方式的共同点： 控制字写入计数器时，所有控制逻辑立即复位，输出端OUT进入初始态； 写入计数初值后，要经过一个时钟周期后计数器才开始计数； 在时钟脉冲CLK的上升沿门控信号GATE被采样； 计数器的计数时间点是CLK的下降沿。 方式0—计数结束中断下面六个方式，主要是看图说话，图比字形象的多。 方式0—计数结束中断 写入控制字后OUT变低； 写入计数初值后的一个CLK的下降沿，计数初值被装入计数器，然后在每个CLK的下降沿做减1计数； 当计数到0时OUT输出变为高电平； GATE为高电平时，计数器工作，为低电平时停止计数；在计数过程中若重新写了新的计数初值，则按新值重新工作；每写一次计数初值只计数一个周期。 方式1—可重复触发的单稳态触发器(硬件触发) 方式1—可重复触发的单稳态触发器(硬件触发) 写入控制字后，OUT变为高电平； 写入计数初值后，当GATE从低变高后的一个CLK下降沿装入初值，OUT变为低。然后对每个CLK下降沿做减1计数，计到0时OUT变高。 若计数结束后GATE又出现上跳，则重新装入计数初值，重新开始计数。 若计数过程中GATE又出现上跳，则重新装入计数初值，重新开始计数，本次OUT周期宽度加长。 负脉冲宽度=计数初值 X CLK周期。 方式2—频率发生器(软件或硬件触发) 方式2—频率发生器(软件或硬件触发) 软件触发：保持GATE为高 写控制字后，OUT变为高电平； 写计数初值后的一个CLK的下降沿，初值被装入计数器，然后对每个CLK的下降沿减1计数； 计数期间OUT保持为高，当计数到1时OUT输出宽度为1个CLK周期的负脉冲，然后重新装入计数初值开始计数。 若计数中重写计数初值，则下次计数周期才会以新值开始计数。 硬件触发：写控制字和计数初值时GATE为低，当其变高后的下一个CLK下降沿计数器装入初值，后面每个CLK下降沿计数。 方式2为自动装入计数初值的重复计数器。 方式3—方波发生器(软件或硬件触发) 方式3—方波发生器(软件或硬件触发) 方式3与方式2相似，只是OUT输出是一个占空比为1:1的方波； 若计数初值为偶数，则OUT输出是高低电平对称的方波； 若计数初值为奇数，则OUT输出不对称，前面的高比后面的低多1个CLK周期，即近似方波。 方式3与方式2一样也可由硬件触发，即GATE从低变高后启动。 方式4—软件触发选通 方式4—软件触发选通 写入控制字输出变高，写入计数值后的一个CLK下降沿装入初值，然后对每个CLK下降沿计数； 计数到0时输出1个CLK周期宽度的负脉冲； 若计数中重写计数初值，则下一个CLK下降沿被装入，然后按此初值计数； 若计数中GATE变低将停止计数，当其变高时继续计数； 计数初值一次写入只计数一个周期，类似软件触发的方式2的一个周期，但负脉冲的出现会延后一个周期。 方式5—硬件触发选通 方式5—硬件触发选通 写入控制字后，OUT变高； 写入计数值后，当GATE出现上升沿后的一个CLK下降沿装入初值，然后对每个CLK下降沿计数，计数到0时OUT输出一个CLK周期的负脉冲。 在计数中若GATE变低后再变高，将重新启动一次计数周期。 在计数中若写入新计数值，本次计数周期不受影响。 一次GATE触发只计数一个周期，即类似硬件触发的方式2的一个周期，但负脉冲的出现会延后一个周期。 方式比较 方式 0 与方式 4 的比较（软件控制） 方式 1 与方式 5 的比较（硬件触发） 方式 2 与方式 3 的比较（连续波形输出） 方式 4 与方式 5 的比较（非连续的单脉冲输出） 总结 8253的六种工作方式中有软件启动和硬件启动： 软件启动：写入控制字及初值后的第一个CLK下降沿装入初值，下一个CLK下降沿开始减1计数。有方式0，2，3，4。 硬件启动：写入控制字及初值后的一个GATE信号上升沿后的第一个CLK下降沿装入初值，下一个CLK下降沿开始计数。有方式1，2，3和5。 其中方式2和方式3既可软件启动，也可硬件启动。 8253工作方式分为连续波形和非连续波形输出： 连续波形输出：一次启动后，计数到0时则自动装入初值循环工作。有方式2，3 非连续波形输出：一次启动后，计数到0后则结束。有方式0，1，4，5 方式0—计数结束中断 方式1—可重复触发的单稳态触发器(硬件触发) 方式2—频率发生器(软件或硬件触发) 方式3—方波发生器(软件或硬件触发) 方式4—软件触发选通 方式5—硬件触发选通 8253 的初始化编程下面这段话很重要！ 初始化编程的顺序为： 对某一指定计数器，先写入控制字，再写入计数初始值。 计数初值写入的格式和顺序必须按控制字D5和D4规定的格式写入。 注意：所有通道的控制字都写入同一个控制端口，而计数初值则要写入指定计数器对应的端口。 可以结合下面的例子食用： 例 1 例 2 例 3 例 4-1 例 4-2 例 4-3 例 4-4 更复杂的例子就不一贴出了。 考试重点编一个小的接口应用程序 8253 8255 8259（内容有点多，但考试不会考太难）考工作方式、工作模式，不会设计 8253 定时计数器8255 应用题 给一组数，找非零数的个数，15 分，框架 12 分 不考的内容（已经老师确认）1.第五章存储器系统2.第六章82373.第七章8251 错题三四章 对段寄存器CS的装入方式有( 234 ).(1)使用MOV指令(2) 使用段间转移指令(3)使用段间子程序调用指令(4)使用END伪指令 RCR 填空题1． 设 (BX)=0C49CH, (CX)=0F002H 123ROL BX, CLXOR BH, CHRCR BX, CL 上述指令序列执行后，(BX)=() ,CF=() 一定看清 0F 开头的，第一位是 0 还是 F！上面两个都应该是字母开头。 答案是 (BX)=0B89C ,CF=1 编程题试编制一完整源程序，将一个字符串（只包含有字母和数字符）中的小写字母转换为大写，数字符转换成其对应的二进制值。各字符转换后的内容仍然存放在原来的单元中。已知A的ASCII码为41H，a的ASCII码为61H。字符串的定义如下： 123DATA SEGMENT STRING DB 'BTe3F5…….'DATA ENDS 123456789101112131415161718192021222324252627282930DATA SEGMENT STRING DB 'BTe3F5…….' LEN EQU $-STRINGDATA ENDSSTACK1 SEGMENG STACK DW 20H DUP(?)STACK1 ENDSCODE SEGMENT ASSUME CS:CODE, SS:STACK1, DS:DATASTART: MOV AX, DATA MOV DS, AX MOV CX, LEN LEA SI, STRINGLOP: MOV AL, [SI] CMP AL, 'a' JGE LITTLE1 CMP AL, '9' JLE NUMBER1 JMP NEXT2LITTLE1:SUB AL, 'a'-'A' JMP NEXT1NUMBER1:SUB AL, '0'NEXT1: MOV [SI], ALNEXT:2 INC SI LOOP LOP HLTCODE ENDS END START 六七八章 接口部分 8086/8088复位后，初始化执行的物理地址是 0FFFF0H 当中断处理程序准备执行第一条指令时，IF=0, TF=0 8259A中，特殊全嵌套优先级方式一般用于 多片8259A中的主片中 DAC0803工作在 两级缓存 方式下时，可在转换输出模拟信号的同时可接收下一个数字信号 IRET指令会向8259A发送EOI信息，以结束当前的中断 × 8086/8088中地址引脚与其它信号复用，所以地址信息需要锁存 √ 8255A中的端口C置1/0方式使得端口C适合配合端口A、B做控制位使用。√ 是否响应软件指令INT引发的中断受IF位的影响。× CPU和外设之间的数据传送方式有 无条件传送、查询方式、中断方式、DMA方式 硬件中断分为 可屏蔽中断、非屏蔽中断 8259A工作的优先级方式有全嵌套、特殊嵌套、优先级自动循环、优先级特殊循环 后记最后考试考了很多的原题。选填题全是前四章的内容，简单题是前四章和后三章各一半，最后解答题一个是前四章的，三个是接口部分，其中两个是老师发的练习题的原题/简化。 隔壁网安就乱划重点 + 没有原题。表扬一下汇编。","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"汇编","slug":"汇编","permalink":"https://blog.lyh543.cn/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"计算机网络安全 课程笔记","date":"2020-09-08T02:20:09.000Z","path":"computer-science/computer-network-security-classnote/","text":"第一章 信息安全概述什么是信息 什么是信息安全 信息是对事物不确定性的度量，并进而采用信息量来描述信息。 信息安全是保证信息的基本属性所需的全面的管理 规程和控制。 信息安全的基本属性 完整性 可用性 机密性 可靠性 不可抵赖性 信息安全服务 认证 访问控制 数据保密 数据完整性 非否认 安全机制加密 数字签名 访问控制 数据完整性 认证交换机制 业务填充机制（发送额外数据掩盖正常通信） 路由控制 公正（可信第三方） 安全服务与安全机制的关系安全服务是由安全机制来实现的；一种安全机制可以实现一种或者多种安全服务；一种安全服务可以由一种或者多种安全机制来实现。 安全威胁与攻击 被动攻击（未经许可泄露信息但不修改，不容易被检测） 主动攻击（数据篡改、虚假流的产生，如重放攻击、DoS） 物理访问攻击 内部人员攻击 软硬件配装攻击 第二章 网络接口层协议的安全威胁OSI 参考模型OSI 参考模型的七层，即是将 TCP/IP 中的应用层细分为（自底向上）会话层、表示层、应用层。 OSI 参考模型 网络接口层的安全威胁攻击原理：窃听。 原因：集线器、交换机物理功能（集线器重新生成该信号，并广播给所有接口；如果帧的目的 MAC 地址是 FF-FF-FF-FF-FF-FF 或在交换机表中查不到对应的表项，则广播该帧） ARP 协议的安全威胁攻击原理：如果我们冒充网关主机 C，不停的向以太网发送自己的 ARP 广播包，告知自己的 IP-MAC ，此时其它主机就会被欺骗，更新我们 C 的 IP-MAC 为网关主机的 IP-MAC ，那么其它主机的数据包就会发送到 C 主机上，因为没有发给真正的网关，就会造成其它主机的网络中断 原因：ARP 协议信任以太网所有的节点，效率高但是不安全。这份协议没有其它字协议来保证以太网内部信息传输的安全，它不会检查自己是否接受或发送过请求包，只要它就收到的 ARP 广播包，他就会把对应的 IP-MAC 更新到自己的缓存表。 IP 协议的安全威胁拒绝服务攻击避免被追踪而受到惩罚，构造针对同一目的 IP 地址的 IP 分组，而源 IP 地址为随机的 IP地址 原因：IP 协议并不能对 IP 数据报中的源 IP 的真实性进行验证，导致任意节点可以构造 IP 数据报，其源 IP 并非该节点的真实 IP。该假冒 IP 分组仍能顺利达到目的结点，即 IP 假冒攻击。 对链路层和 IP 层攻击的本质是什么没有验证发送者的身份。 TCP 协议的安全威胁TCP 原理略。 SYN Flooding原因：当客户端请求服务器时，客户端发起一个TCP SYN包，服务器端接收到该请求后，如果能够响应该请求，即回复一个TCP ACK SYN包，同时分配相应的资源记录客户请求信息，然后等待客户端的ACK包，以便完成“三次握手”过程。 攻击方式：客户端可以不理会服务器端的 TCP ACK SYN 包，而是继续发送假冒的 TCP SYN 包，在没有超时之前服务器端都会分配资源保持客户端请求的状态信息。 ACK Flooding原因：在TCP连接建立之后，所有的数据传输TCP报文都是带有ACK标志位的，主机在接收到一个带有ACK标志位的数据包时，需要检查该数据包所标识的连接四元组是否存在，如果存在则检查该数据包所标识的状态是否合法，然后再向应用层传递该数据包。 攻击方式：攻击者一定要用大流量ACK小包冲击才会对服务器造成影响。随机源IP的ACK小包应该会被服务器很快丢弃，因为在服务器的TCP堆栈中没有这些ACK包的状态信息。 序列号预测攻击原因：TCP 端口号和序列号是接收方判断数据包是否为所需数据包的主要依据。 攻击方式：如果这两个因素都能被攻击者确定，那么攻击者可以构造一个TCP包发送出去并被接收方接受。如果所构造的TCP包里包含的内容或者所设置的标志位并非发送方的后续行为，则形成攻击。 LAND 攻击攻击方式：构造特殊 TCP SYN 包，该包的目的地址和源地址均为目的主机，结果被攻击主机又发回ACK消息并创建一个空连接，每一个这样的连接都将保持到超时为止，从而导致目的主机连续地自我响应。 原因：操作系统的设计缺陷，现已基本消除。 UDP 协议的安全威胁UDP 假冒攻击者假冒客户端向客户端发出请求。 UDP 劫持攻击者假冒服务器向客户端发出 UDP 应答。 DNS 协议安全威胁根源为：DNS 是建立在 UDP 上的服务，且没有进一步的验证端主机身份的步骤，也是无连接、不可靠的。 DDoS分布式拒绝服务攻击 (DDoS) 是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施拒绝服务攻击。 缓存投毒攻击者仿冒权威名字服务器向缓存 DNS 服务器发送伪造应答包，力争抢先完成应答以污染 DNS 缓存。 域名劫持在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。 HTTP 协议安全威胁钓鱼攻击就是钓鱼网站等。 原因： HTTP 协议并没有考虑用户认证（用户并不能确定远端服务器的真实身份）。 跨站脚本攻击跨站脚本 (Cross-site scripting, XSS)：攻击者将恶意的客户端脚本注入正常的网页中，利用此漏洞进行 Cookie 窃取、会话劫持、钓鱼等攻击。 原因：网页开发时留下的漏洞。 电子邮件安全威胁 传输安全（原因：明文传输） 存储安全 发送者身份确认 接受者已收到确认 邮箱炸弹攻击（发送无意义邮件耗尽空间） 第三章网络隔离 同轴电缆（物理层，无隔离） 集线器（物理层，无隔离） 交换机（链路层） 虚拟子网（基于交换机实现 VLAN 划分，可基于端口、MAC、网络层、IP 组划分） 路由器（网络层） 作为唯一安全组件时：路由器相对交换机，集线器，能提供更高层次的安全功能 作为安全组件的一部分时：路由器常用作屏蔽设备，执行包过滤功能，而防火墙对能够通过路由器的数据包进行检查（路由器是第一道关口，防火墙是第二道） 防火墙技术用一个或一组网络设备（计算机系统或路由器等），在两个或多个网络间加强访问控制，以保护一个网络不受来自另一个网络攻击的安全技术。 需掌握基本原理。 分组过滤防火墙 分组：IP 包分组 网络层 分组过滤防火墙根据包头信息进行处理 应用代理防火墙 应用层 又称代理网关、代理服务器 用户需将代理设置为应用代理防火墙 用户感觉是自己 - HTTP 服务器 的连接，实际是 自己 - 代理服务器 和 代理服务器 - HTTP 服务器 状态监测防火墙 传输层 上二者技术的折中 建立状态表（记录已连接的数据报信息）、规则集 状态监测防火墙 流程图 防火墙的典型体系结构包过滤路由器模型是有一个带有路由功能的防火墙或者起防火墙作用的路由器，也被称为筛选路由器。通常作为边界路由器部署在用户网络的边界。通常采用分组过滤技术。 优点：价格。 缺点：内部网络的IP地址并没有被隐藏起来，并且不具备监测、跟踪和记录的功能。 picture 3 单宿主堡垒主机模型堡垒主机，是指应用代理防火墙，它连接着一个不安全的网络和一个安全的网络。 单宿主堡垒机模型是指只有一个网络接口的堡垒主机。由包过滤路由器和堡垒主机组成。安全等级比包过滤防火墙系统高，实现了网络层安全（包过滤）和应用层安全（代理服务）。 说人话，堡垒主机用一根网线连接了外网和内网（外网和内网其实是物理连通的）。 picture 4 双宿主堡垒主机模型双宿主堡垒主机有两块网卡：一块连接内部网络，一块连接包过滤路由器。在应用层提供代理服务，可以构造更加安全的防火墙系统。主机在两个端口之间直接转发信息的功能被关掉了，在物理结构上强行使所有传送内部网络的信息经过堡垒主机。 说人话，堡垒主机一根网线连外网，一根网线连内网（外网和内网没有直接物理连通）。内网上外网必须经过堡垒主机。 子网屏蔽防火墙模型用两个内网和一个堡垒主机。 picture 5 内部路由器的主要功能是保护内部网络免受来自外部网络与参数网络的侵扰。 堡垒主机的主要功能是为内外部服务请求进行代理。 两个路由器之间的区域叫 DMZ 网络。 防火墙在网络边界安全中的作用 通过过滤不安全的服务而降低风险，提高内部网络安全性 保护网络免受基于路由的攻击 强化网络安全策略 对网络存取和访问进行监控审计 利用防火墙对内部网络的划分，实现内部网重点或敏感网段的隔离 网络地址转换的基本概念、分类将每个局域网节点的地址转换成一个 IP 地址，反之亦然。 静态 NAT 动态 NAT（动态分配 IP） 网络地址端口转换 (NAPT)，最常用 网络地址转换与网络安全： 如果改变源地址的话，数字签名不再有效 给网络取证带来了巨大的困难 依赖于IP和端口的防火墙过滤规则需要改变 物理隔离的基本概念、网闸物理隔离：指处于不同安全域的网络之间不能以直接或间接的方式相连接。 分为单向隔离、协议隔离、网闸。 网闸 (gap)：位于两个不同安全域之间，通过协议转换的手段，以信息摆渡的方式实现数据交换，且只有被系统明确要求传输的信息可以通过。（最常用） 第四章前三章也就图一乐，后面才是重点.jpg 网络安全模型PDR 模型 **保护 (Protection)**：在入侵前预防 **检测 (Detection)**：在入侵时检测 **响应 (Response)**：检测到入侵时响应 保护分为物理实体保护技术、信息处理保护技术；检测分为入侵检测技术、漏洞检测技术、网络扫描技术；响应需要把系统调整到安全状态，以及杜绝危害的进一步扩大 PPDR 模型在 PDR 的基础上增加了**安全策略 (Policy)**。 安全策略是 PPDR 模型的核心，所有的保护、检测、响应都依据安全策略而实施。 PDRR 模型在 PDR 的基础上增加了**恢复 (Recover)**：检测入侵失败或响应失败后，会进行恢复。 另外 PDRR 中的“响应”由 Responce 换成了 Reaction。 PDRR 模型还引入了时间的概念： $Pt$: 保护时间，即入侵开始到成功入侵的时间; $Dt$: 检测时间; $Rt$: 响应时间; $Et$: 系统暴露时间. PDRR 模型用两个公式表示安全的要求： $Pt &gt; Dt + Rt$，即系统的保护时间应大于系统的检测时间和响应时间之和 $Et = Dt + Rt, if Pt = 0$，即如果保护时间为 0，那么检测时间与响应时间的和就是安全目标系统的暴露时间 PDRR 应当： 提高系统的防护时间 $Pt$ 降低检测时间 $Dt$ 和响应时间 $Rt$ 在系统遭到破坏后，应尽快恢复，以减少系统暴露时间 $Et$ APPDRR 模型APPDRR 在综合了 PPDR 和 PDRR 的基础上，又添加了风险评估 (Assessment)，所以留个单词分别是： 由风险评估 (Assessment) 安全策略 (Policy) 保护 (Protection) 检测 (Detection) 响应 (Reaction) 恢复 (Restoration) 响应和恢复的英文都变了，但是中文还是那个意思 PADIMEE 模型这个变动就大了： Policy (安全策略） Assessment (安全评估) Design (设计/方案) Implementation (实现) Management/Monitor (管理/监控) Emergency Response (紧急响应) Education (安全教育) PPT 戛然而止，所以应该不是重点。 网络安全预警主要功能： 实时网络数据流跟踪 网络攻击模式识别 网络安全违规活动捕获 对将要发生的或已发生的网络攻击进行预警 对攻击的下一步动作进行合理的推测 网络安全预警系统结构 通用网络安全预警系统功能模块结构： 通用网络安全预警系统功能模块结构 常见网络安全预警模型： 基于入侵事件的预警模型 基于攻击过程的预警模型 基于流量监控的预警模型 戛然而止。 常见加密算法 对称加密算法：DES（数据加密标准）、AES（高级数据加密标准）等 非对称加密算法：RSA（三个人的名字）、ECC（椭圆曲线加密）等 流密码（上面四个算法都需要将数据段分块）：RC4（其实也属于对称加密算法） VPN基本概念依靠 ISP (Internet 服务提供商) 和其它 NSP(网络服务提供商) 在公用网络中建立专用的数据通信网络的技术。 原理/关键技术 隧道技术：实质上是一种封装，即将一种协议 (如协议 X) 封装在另一种协议 (如协议 Y) 中传输，从而实现协议 X 对公共网络的透明性。 加密技术：对信息进行重新编码。 密钥管理技术：确保在公用数据网上安全地传递密钥而不被窃取。密钥的分发有两种方法：一种是通过手工配置；另一种采用密钥交换协议动态分发。 用户认证技术：在正式的隧道连接开始之前确认用户身份，实施资源访问控制或用户授权。有两种基本模式：有第三方参与的仲裁模式和没有第三方参与的基于共享秘密的认证模式。 分类 picture 2 优点用到的协议 第二层转发协议 L2F 点到点隧道协议 PPTP：是对点到点协议 PPP 的扩展，使用一种增强的 GRE 封装机制使 PPP 数据包按隧道方式穿越 IP 网络，并对传送的 PPP 数据流进行流量控制和拥塞控制。 第二层隧道协议 L2TP：国际标准隧道协议，综合了 PPTP 协议以及 L2F 协议的优点，它将链路层协议封装起来进行传输。优点在于提供了差错和流量控制。 通用路由封装协议 GRE：规定了怎样用一种网络层协议去封装另一种网络层协议的方法，GRE 的隧道由其两端的源 IP 地址和目的地址来定义。 IP 安全协议 IPSec：是一组开放协议的总称，它给出了应用于 IP 层上网络数据安全的一整套体系结构。 IPSec 协议组成？？？ 内网监管技术基本概念针对局域网内的用户终端和网络设备进行监视和控制，规范内部网络用户的行为、防止敏感信息的泄漏的技术。 入侵检测的分类、技术 根据入侵检测的数据源： 基于主机的入侵检测 基于网络的入侵检测 混合型入侵检测 根据检测方法： 异常检测，即对已知攻击进行分析，建立入侵模式库，并比对捕获的流量 误用检测，即对正常系统行为建立模型，并比对观察到的目标活动 按时间： 实时入侵检测 定时入侵检测 按系统体系结构： 集中式 IDS 分布式 IDS 入侵检测框架 技术： 用于误用入侵检测的技术，见上 用于异常入侵检测的技术，见上 入侵防御系统分类、组成入侵防御系统：一种主动积极的网络防护系统，当发现攻击企图后，会将攻击包丢掉或采取阻断措施，实现对系统的实时防护，是一种积极的、主动的入侵防范和阻止系统。 分类： 基于主机的入侵防御系统 基于网络的入侵防御系统 应用入侵防御系统 组成： 嗅探器 监测分析组件 策略执行组件 日志系统 管理控制台 漏洞的分类按漏洞的成因： 设计漏洞 实现漏洞 配置漏洞 按攻击危险程度： 高级危险漏洞 中级危险漏洞 低级危险漏洞 按攻击结果： 攻击入侵型漏洞 攻击死机型漏洞 信息泄露型漏洞 漏洞检测方法分类按测试程序或测试者的角色： 主动检测法 被动检测法 按测试程序或测试者测试的途径： 主动测试 网络测试 分布式测试 漏洞检测方法 安全扫描（模拟攻击） 源代码扫描 反汇编扫描 环境错误注入 网络扫描技术 完全 TCP 连接 TCP SYN 扫描 秘密扫描技术 间接扫描技术 分片、诱导扫描 UDP 扫描 识别扫描 代理扫描 安全响应阶段、分类 前期：确认时间、初步分析 中期：护理时间 后期：进一步提供安全性、分析总结、 分类： 被动响应：被入侵时仅向用户报告 主动响应：被入侵时自动采取措施 蜜罐、蜜网蜜罐：一种安全资源，其价值在于被扫描、攻击和攻陷。 蜜罐系统：一个包含漏洞且运行于互联网上的计算机系统，它通过模拟一个或多个易受攻击的系统，给攻击者提供一个包含漏洞并容易被攻破的攻击目标，吸引攻击者对其发起攻击，同时完整地且不被察觉地将他们的活动记录下来。 蜜网：蜜网技术建立了一个攻击诱捕的网络体系架构，该体系结构可以包含一个或多个蜜罐，并提供多种工具以方便对攻击信息的采集和分析，同时保证蜜网网络的高度可控性。 蜜罐分类按照其部署目的： 产品型蜜罐：的在于为一个组织的网络提供安全保护。 研究型蜜罐：对黑客攻击进行追踪和分析，了解到黑客所使用的攻击工具及攻击方法 按照其交互度的等级： 低交互蜜罐：一般仅仅模拟操作系统和网络服务。 中交互蜜罐：对真正的操作系统的各种行为的模拟。 高交互蜜罐：完全向攻击者提供真实的操作系统和网络服务。 蜜罐功能 攻击诱骗：吸引黑客的注意并诱使其发起攻击，增大黑客发现并入侵蜜罐的几率。 数据捕捉：基于主机的数据收集；基于网络的数据收集； 数据控制：防止以当前攻陷系统作为跳板，进而攻击其它系统。 蜜网拓扑结构 蜜网技术应用 捕获僵尸网 捕获网络钓鱼 抗蠕虫病毒 蜜网技术发展趋势 picture 2 第五章 协议安全技术前四章也就图一乐，后面才是重点.jpg 什么是协议、什么是安全协议协议：两个或两个以上的参与者所采取的一系列步骤以完成某项特点的任务。 安全协议 (Cryptographic Protocol)：在消息处理过程中采用了若干密码算法的协议 安全协议按协议目的分类 密钥交换协议 认证协议 认证和密钥交换协议 电子商务协议 双向认证并交换两个秘密值——NSPK 协议NS 这个人有点 nb，发明了一个公钥协议 Public Key Protocol 和一个对称密钥协议 Symmetric Key Protocol。前者简称为 NSPK 协议，后者称为 NSSK 协议。 Needham-Schreoder 公钥认证协议 (NSPK 协议) 协议主体就是协议的参与者（或用户）。其中圆括号中的数字表示消息的顺序；符号“→”表示消息的流向：“M”表示Alice向Bob发送消息M；{M}K表示用密钥k对消息M进行加密；如{Na, A}kb表示用Bob的公钥kb对消息Na和A（即消息Na和A进行简单串接后得到的消息）进行加密；A是Alice的身份，Na和Nb是新鲜的一次性随机数。所谓新鲜的一次性随机数（Nonce）或一次性随机数是指该随机数在产生时间上很新且用完后即被丢弃，不会重用。 第一步：Alice在本地生成共享秘密值之一的Na，将Na和自己的身份A串联之后，用Bob的公钥kb对整个消息进行加密，并将得到的密文发送给Bob 第二步：Bob收到用自己的公钥加密的密文之后，用自己的私钥解读该消息，得到Na和A。Bob本地生成另外一个共享秘密值Nb，将解密得到的Na与Nb串联之后，用Alice的公钥ka对所得到的消息进行加密，并将对应的密文发送给Alice 第三步：Alice收到密文之后，用自己的私钥进行解密得到Na与Nb。如果解密得到Na值与自己在第一步中所生成的Na值相同，则Alice知道通信的另外一方就是Bob（即Alice证明了Bob的身份），并得到了两个共享秘密值Na与Nb。同时Alice用Bob的公钥kb对解密得到的Nb进行加密，并将密文发送给Bob。Bob收到密文后，用自己的私钥解密得到Nb，如果该值与自己在第二步生成的值相同，则Bob就证明了通信的另外一方就是Alice(即Bob证明了Alice的身份），并得到了两个共享秘密值Na与Nb。由于只有拥有Bob的私钥才能解密消息{Na, A}kb，从而得到Na,而除了Bob之外，其他任何人均不可能拥有该私钥，因此不能知道Alice和Bob之间所交换的内容，即消息的机密性得到保证。同样，由于只有Bob才能解密得到Na ，因此第二步中的Na也只有Bob才能知道，因此Alice可以通过解密{Na, Nb}ka ，并通过比较Na值是否相同来确认Bob的身份。Bob对Alice的身份认证过程与Alice相似。 密钥交换协议、密钥传输协议：RPC 协议密钥交换协议可分为两种情况：密钥传输和密钥协商。密钥传输是单方把密钥算出来然后发给另一方用，密钥协商是双方共同协商得出，中间没有直接传输密钥。 下面几个密钥交换协议只进行了密钥交换，没有验证对方的身份。如果加入了验证身份，那就是认证与密钥交换协议了。 基于对称密码的密钥传输协议 协议5-1-2由4条消息组成，需要交换的共享密钥由Bob生成，通过协议传递给Alice。协议过程中用到了对称密码算法和认证，使用一次性随机数的目的是为了防范重放攻击。 作为密钥交换协议，其并没有对对方的身份进行认证，只知道对面是拥有 $k_{ab}$ 的人。如果攻击者拥有了 $k_{ab}$，就可以伪装成任意一方和另一方进行通讯。可见只使用一个对称密钥，安全性是不高的。 密钥交换协议、密钥协商协议：DH 协议DH 是密钥协商协议。 DH 协议 协议5-1-3由3条消息组成，其中 $x_a$ 和 $x_b$ 分别为 Alice 和 Bob 选择的随机数。在消息交换之后，Alice 计算 $k_{ab}=(g^{x_b})^{x_a} = g^{x_ax_b}$。同理，Bob计算 $k_{ab}=(g^{x_a})^{x_b} = g^{x_ax_b}$。因此实现了共享密钥（或秘密）的交换。 DH 协议不能防止重放攻击。经 DH 改进的 STS 协议 能防止重放攻击。 单向认证协议：X. 509 标准这里实现对自己的认证的思路是，使用自己的私钥加密消息。如果包经中间人修改过，那么中间人加密过的包是没法用原发送者的公钥解密的。 除此之外，消息中还加入了 Nonce、时间戳以及接接收，防止了重放攻击。（加入接收者可以防止中间人把 A 发往 B 的包反手转发给 C 这种情况） X. 509 标准中的一次传输单向认证协议 需要注意的是，双向认证协议一般不能等同于两个单向认证协议的简单叠加。似乎是需要 Bob 完成对自己认证的同时，发起对 Alice 的认证请求。 双向认证协议：X. 509 标准 X. 509 标准中的三次传输双向认证协议 协议5-1-5由3条消息组成，其中M1、 M2 、 M3和M4是可选内容。 认证与密钥交换协议：STS 协议STS 协议是 DH 协议的一个改进版本，不仅实现了双向认证，而且实现了双向密钥确认，因而属于认证与密钥交换协议。协议5-1-6由3条消息组成，其中$k_{ab}= g^{x_ax_b}$。由于采用了签名机制来保证消息的真实性，因此可以抵御许多针对 DH 协议的攻击。 STS 协议 协议中不仅用到了 DH 的方法，还加入了私钥用以认证。可以说是 DH 方法和双向认证方法的结合。 电子商务安全协议 与其它类型的安全协议相比，电子商务协议具有显著的特殊性。在电子商务安全协议中，协议主体往往是交易的双方和金融机构，因此远比一般安全协议复杂。此外，除了一般协议中要求的机密性、完整性和不可抵赖性之外，电子商务安全协议还特别强调公平性（Fairness）和匿名性（Anonymity）。前者指协议应该保证交易双方都不能通过损害对方的利益而得到不应该得到的利益，后者指交易双方的身份应该尽量不为他人所知（有时甚至要求交易双方和金融机构也不能知道交易方的信息）。安全电子交易（SET协议）是一个典型的电子商务安全协议。 安全协议按是否需要可信第三方分类仲裁协议仲裁协议需要借助于一个称之为仲裁者的可信第三方（Trusted Third Party）来完成消息交换。可信意味着仲裁者在协议过程中并无既得利益，且于协议中的其它任何主体之间无厉害关系，因此协议主体也乐于信赖该仲裁者。在仲裁者的帮助下，协议主体之间完成协议过程。 仲裁协议原理示意图 裁决协议 裁决协议原理示意图 由图5-1-3可知，裁决者Trent并不参与Alice和Bob之间的交易，仅当Bob没有收到书款提交裁决请求时，Trent才参与协议。如果交易顺利完成，Trent在协议中无需承担任何工作，其负担大为减轻。 自动执行协议 自动执行协议不需要任何第三方（如仲裁者和裁决者）的参与，在协议主体之间完成协议过程。由于自动执行协议本身就保证了协议的安全性（如机密性、公平性等），因此不需要仲裁者来协助完成协议，也不需要裁决者来解决争端，因此是比较好的一种安全协议。但是，设计一个安全的自动执行协议具有很高的难度，目前属于安全协议研究的热点问题。以上述Alice向Bob购书为例，要设计一个无仲裁者和裁决者的自动执行协议无疑是极为困难的事情。 安全协议缺陷分类（1）基本协议缺陷：协议中没有或者很少考虑对攻击者的防范而引发的协议缺陷（如TCP/IP协议的安全缺陷问题等）。（2）口令/密码设置缺陷：在设置和使用口令或密码的过程中，未考虑攻击者对其的猜测攻击等情况（如口令和密码过短，直接采用用户名来作为口令和密码等）。（3）陈旧消息缺陷：在协议设计过程中，未考虑消息的时效性（即新鲜性），从而使得攻击者可以利用协议过程中产生的过时消息来对协议进行重放攻击。（4）并行会话缺陷：协议设计对仅考虑单个协议执行的情况，对多个协议（或同一个协议的多个运行实例）并行会话缺乏考虑，使得攻击者可以相互交换适当的协议消息来获得更为重要的消息。（5）内部协议缺陷：协议参与者中至少有一方不能够完成所有必须的动作而导致缺陷。（6）密码系统缺陷：协议中使用的密码算法的安全强度问题导致协议不能完全满足所要求的机密性、完整性、认证等需要而产生的缺陷。 对 DH 协议的中间人攻击 在实际应用中，要设计一个安全的协议是极为困难的。以著名的DH 协议为例，由于存在针对该协议的“中间人攻击”，因此DH协议就不是一个绝对安全的协议。所谓中间人攻击，就是攻击者作为第三者，插入到协议主体Alice和Bob的通信过程的中间，对消息进行处理，从而破坏协议的正常执行。DH协议的中间人攻击如攻击5-2-1所示。 针对 DH 协议的中间人攻击 而作为中间人的Malice，则同时获得了Alice和Bob所拥有的两个密钥（即kam和kbm）。在随后的通信中，当Alice用kam加密消息时，Malice可以用相同的kam解密，得到消息的明文，并对该明文消息用kbm加密后转发给Bob。后者可以用自己拥有的kbm解密，因此不能感知任何错误或异常。同样，对于Bob发送给Alice的加密消息，Malice 可以采用 kbm `密钥实施欺骗功能。 重放攻击对 NSSK 的重放攻击注意，前提是 Malice 获得了 Alice 和 Bob 之前使用过的某个会话密钥 $k_{ab}$。 对 NSSK 的重放攻击 攻击者Malice通过对Alice和Bob过去某次NSSK协议的通过过程进行窃听，获得了其中的第三条消息 {kab , A } kbt.通过对该加密消息的攻击（如典型的蛮力破解），破译了该消息，从而得到了Alice和Bob使用的会话密钥 kab .当然，该破译过程可能需要较长的时间（如一年甚至更长）。一旦获得旧的会话密钥kab之后，Malice可以在今后某个时刻重新发送过去截获的旧消息 {kab , A } kbt而Bob对此并无只觉，因此它按照协议执行。随后的过程中Malice可以成功欺骗Bob，使得Bob认为和Alice发起了一次认证和密钥交换协议，并使得Alice（实质上是Malice伪装成Alice）的身份得以认证通过。但是，Alice在整个协议过程中根本未出现，所有的行为均为攻击者Malice所为。通过对攻击5-2-2的分析可知，重放攻击之所以成功，其根本原因在于消息的新鲜性无法得到保证。如当Bob收到NSSK协议中第三条消息{kab , A} kbt时，他并不能区分该消息是现在产生的，还是过去的旧消息。 分类从被重放消息的来源来看，重放攻击可分为协议轮内攻击和协议轮外攻击。协议轮是指一个协议的整个过程消息交换过程（如NSSK协议中的5条消息交换即为一个协议轮）。因此，协议轮内的重放攻击就是指重放在本协议轮被截获的消息，而协议论外攻击则是重放从其它协议轮中捕获的消息。 根据消息的去向，重放攻击可分为偏转攻击和直接攻击。偏转攻击是通过改变消息的去向而实施的攻击。直接攻击是将消息发送给任意接收方而实施的攻击。其中偏转攻击分为反射攻击和第三方攻击。前者指将消息返回给发送者，而后者指将消息发给协议合法通信双方之外的任一方。攻击5-2-2中的重放攻击属于协议轮外攻击和直接攻击。 抵抗重放攻击的三种方法及其特点 方法 特点 缺点 应用 挑战－应答机制 通过新鲜一次性随机数保证消息的新鲜性 需要生成一次性随机数的算法 用于挑战的发起者验证所收到消息的新鲜性 时戳机制 利用时戳保证消息的新鲜性 需要全局时钟同步；时间窗口大小不易控制 用于消息的接收者判断消息的新鲜性 序列号机制 利用消息序列号来保证消息的新鲜性 需要协商初始序列号，序列号不易同步 可用于发送者和接收者判断消息的新鲜性 挑战－应答机制 挑战－应答机制 在协议5-2-1中，Bob对Alice的挑战是利用对称密钥进行加密。Alice收到Bob发送的消息之后，用相同的密钥解密得到自己所期望的应答，并与自己在第一步中所发送的挑战进行比较。如果相同，则消息是新鲜的；否则消息即为陈旧消息，可能是重放攻击。 需要说明的是，协议5-2-1仅仅证明了消息的新鲜性，而其它消息的新鲜性则未提供保证。 时戳机制时戳机制是指发送者在消息中嵌入发送消息的本地时刻，而接收者在消息达到后，通过对比消息中所包含的时间信息和本地时间信息的差值，来决定该消息是否为新鲜消息。如果接收者对消息延迟达到所能容忍的时间差值为$δ$，发送消息的时刻为$Ts$，收到消息的时刻为$Tr$，如果$| Tr - Ts |&lt;= δ$，则接收者认为该消息是新鲜的，否则该消息是陈旧消息（即可能时重放攻击）。 与挑战－应答机制不同，对时戳的保护（或变化）只能由消息的发送者提供。 前文的单向认证协议即加入了时戳机制，只需要一次传输就能完成单向认证。 序列号机制在序列号机制中，协议主体之间首先协商一个一致的初始序列号。协议过程中每条协议消息均带上序列号。每发送一条消息，序列号对应加1。因此，协议实体可以通过对比消息中的序列号和自己当前所期望的序列号是否相同来判断消息的新鲜性。典型的采用序列号机制来对抗消息重返的过程如图5-2-4所示。 序列号机制 注意在实现上，双方共用一套序列号。 由于序列号需要协商并保持同步，因此在实际应用中较少采用。 Kerberos 协议内容常见的认证协议包括用户口令认证协议（PAP）、挑战－握手认证协议（CHAP）、Kerberos 认证协议和 X. 509 认证协议等。 Kerberos 原理在 Kerberos 认证协议中，存在四个角色： 客户端（C：Client）：请求服务的用户 服务器（S：Server，即提供某种服务的服务器）：向用户提供服务的一方 认证服务器（AS：Authentication Server）：负责验证用户的身份，如果通过了认证，则向用户提供访问票据准许服务器的票据许可票据（Ticket-Granting Ticket） 票据准许服务器（TGS：Ticket-Granting Server）：负责验证用户的票据许可票据，如果验证通过，则为用户提供访问服务器的服务许可票据（Service-Granting Ticket）。 因此，从认证服务器所获得的票据许可票据不能作为用户访问服务器的凭证，只能作为访问票据许可服务器的凭证，而后者所授予的服务票据才是用户访问服务器的凭证。 Kerberos中的四种角色及其相互间的密钥共享关系示意图 用户C和票据准许服务器TGS和服务器S之间并无密钥共享关系，因此它们之间的通信采用会话密钥来加密。 Kerberos 系统构架 其中， (1)(2) 每次用户登录执行一次； (3)(4) 每种服务执行一次； (5)(6) 每次服务会话执行一次。 在 Kerberos 的认证过程中也存在票据有效期问题。因此，当用户向认证服务器 AS 请求一张与票据许服务器 TGS 通信的通行证时，该通行证除了会话密钥之外，还包括用户端、服务器端、时戳以及有效期等信息。 同样，票据许可服务器颁发给用户的服务许可票据除了包含会话密钥之外，同样也包含用户、服务器、时戳和有效期等信息。一旦用户获得票据许可票据，则访问其它服务时只需要访问票据许可服务器，而无需通过认证服务器。 有意思的是，Kerberos 协议可以看做两次 NSSK 协议。第一次是用户和 TGS 经过 AS 仲裁后完成一次 NSSK 协议；第二次是用户和 S 经过 TGS 仲裁后完成一次 NSSK 协议。 Kerberos V4 缺陷 依赖性：加密系统的依赖性（DES）、对 IP 协议的依赖性和对时间依赖性。 字节顺序：没有遵循标准 票据有效期：有效期最小为5分钟，最大约为21小时, 往往不能满足要求 认证转发能力：不允许签发给一个用户的鉴别证书转发给其他工作站或其他客户使用 领域间的鉴别 加密操作缺陷：非标准形式的 DES 加密（传播密码分组链接 PCBC）方式，易受攻击 会话密钥：存在着攻击者重放会话报文进行攻击的可能 口令攻击：未对口令提供额外的保护，攻击者有机会进行口令攻击 Kerberos V5 改进 加密系统：支持使用任何加密技术。 通信协议：IP 协议外，还提供了对其他协议的支持 报文字节顺序：采用抽象语法表示（ASN.1）和基本编码规则（BER）来进行规范 票据的有效期：允许任意大小的有效期，有效期定义为一个开始时间和结束时间 鉴别转发能力：更有效的方法来解决领域间的认证问题 口令攻击：提供了一种预鉴别（preauthentication）机制，使口令攻击更加困难。 Kerberos 领域间的互通跨领域的服务访问： 一个用户可能需要访问另一个 Kerberos 领域中应用服务器； 一个应用服务器也可以向其他领域中的客户提供网络服务。 领域间互通的前提： 支持不同领域之间进行用户身份鉴别的机制； 互通领域中的 Kerberos 服务器之间必须共享一个密钥； 同时两个 Kerberos 服务器也必须进行相互注册。 远程服务访问的认证过程 远程服务访问的认证过程就是把 TGS 的一步拆为了本地 TGS 和远程 TGS 两个部分。 X. 509X.509 是密码学里公钥证书的格式标准。X.509 证书已应用在包括 TLS/SSL 在内的众多网络协议里。 X. 509 证书SSL/TLS 证书就是 X. 509 证书。 证书的颁发证书由可信证书权威机构（CA - Certficate Authority）创建。 用户或 CA 将证书存放在目录服务器中； 表示法：证书机构 Y 颁发给用户 X 的证书表示为 Y&lt;&lt;X&gt;&gt; CA&lt;&lt;A&gt;&gt; 表示 CA 颁发给用户 A 的证书。 CA 用其私有密钥对证书进行了签名。 用户可用 CA 的公开密钥验证证书的有效性； 任何拥有 CA 公开密钥的用户都可以从证书中提取被该证书认证的用户的公开密钥； 除了CA外，任何用户都无法伪造证书或篡改证书的内容； 由于证书是不可伪造的，可将证书存放数据库（即目录服务）中，而无需进行特殊的保护。 证书的获取通信双方 A 和 B 如何获得对方的证书： 小型网络中，共同信任同一个 CA。通过访问公共目录服务获取对方的证书，或直接传递。 大型网络， 多个 CA，层次化管理。CA 之间交换公开密钥（即交换证书）。 X.509认证协议中的证书的获得 证书的吊销 证书过期； 在证书过期之前申请将其作废。例如，用户密钥被泄露，CA的密钥被泄露，或者用户不再使用某一个CA颁发的证书等。 X.509认证协议中的证书的吊销 X. 509 三种认证TLS 协议、会话、连接、TLS记录层协议、握手协议第七章 计算机系统可靠性技术容错系统 自动侦测 自动切换 自动恢复 RAID RAID 0：冗余无校验的磁盘阵列 RAID 1：镜象磁盘阵列 RAID 2：并行海明纠错阵列 RAID 3：奇偶校验并行位交错阵列 RAID 4：奇偶校验扇区交错阵列 RAID 5：循环奇偶校验阵列，是目前采用最多、最流行的方式 容灾分类 本地容灾 异地数据冷备份 异地数据热备份 异地应用级容灾 容灾技术 数据容灾：数据复制技术、数据备份技术和数据管理技术 应用容灾：系统迁移技术、灾难检测技术和系统恢复技术 例题以下考题大多基于 2016 年、2017 年的考卷，和 2020 年的考题有很大出入，所以参考价值可能不是很大。请读者知悉。 单词卡 这个单词卡背下来以后，做选择填空有用：https://quizlet.com/cn/248705201/网络安全-flash-cards/下面有不少题都可以在这个单词卡中找到！宝藏网站 第二章TCP/IP 协议栈除应用层外面临的主要安全协议 物理层：窃听 链路层：窃听、假冒 网络层：假冒 传输层： UDP：假冒 TCP：SYN Flooding、ACK Flooding、序列号预测攻击、Land 攻击 TCP 协议在设计之初考虑到了安全问题错。在开发的时候只考虑了可靠性和兼容性，没有考虑到安全性。 TCP 特点 全双工通信：服务连接的两端有两条彼此独立、方向相反的通道。可以使数据在两个方向上同时进行传送操作。在发送数据的同时也能够接收数据，两者同步进行。 面向连接：所谓面向连接，是指通信的双方在开始传输数据之前，必须通过“三次握手”的方式在通信双方建立一条逻辑上的链路 可靠通信：TCP协议通过自动分片，保证分片的顺序，确认-重传等机制来实现可靠通信 面向字节流：TCP所传输的数据包是面向字节流的，即将多个消息连接成一个字符串，再依照TCP所认定的分片大小来分割传送 第四章安全机制是__的总称 保护信息 信息系统安全措施 包过滤技术基本原理及优缺点 防火墙在网络层中根据数据包的包头信息进行判断，允许该包通过或者阻断。其原理是根据数据包的源IP地址、目的IP地址、源端口号、目的端口号、包类型和数据包头中的各种标志位等因素来确定是否允许数据包通过。其核心是安全策略即过滤规则的设计。 包过滤技术的优点在于其容易实现、费用少、对性能的影响不大，对流量的管理较出色。 包过滤技术的缺点是： 过滤规则表随着应用的深化会很快变得很大而且复杂，这样不仅规则难以测试，而且规则结构出现漏洞的可能性也会增加。 包过滤技术只对数据包头进行检查，没有身份验证机制，因此不能分辨正常用户和入侵者。 包过滤技术不能进行应用层的深度检查，因此不能发现传输的恶意代码及其攻击数据包。 包过滤技术容易遭受源地址欺骗，外部攻击者可通过将攻击数据包源地址改为内部地址而穿透防火墙。 子网屏蔽防火墙模型用两个内网和一个堡垒主机。 picture 5 主要功能： 外部路由器：主要是对参数网络上的主机提供保护内部路由器：保护内部网络免受来自外部网与参数网络的侵扰参数网络： 防止从堡垒主机上偷看内部信息流堡垒主机： 为内部服务请求进行代理 常见的物理隔离部件包括 单向隔离部件 协议隔离 网闸 VPN 按应用分类 Access VPN（远程接入VPN）：客户端到网关，使用公网作为骨干网在设备之间传输VPN数据流量； Intranet VPN（内联网VPN）：网关到网关，通过公司的网络架构连接来自同公司的资源； Extranet VPN（外联网VPN）：与合作伙伴企业网构成Extranet，将一个公司与另一个公司的资源进行连接。 用户通过本地的Internet服务提供商登陆到Internet，并在现在办公室和公司内部网之间建立一条保密通道。这种访问方式是：远程访问 VPN。 网上能找到对于三种 VPN 的解释实在是太少，例题似乎都是这一题。想要了解的童鞋可以看看下图。 三种 VPN IPSec 运行模式 传输模型 隧道模式 PPDR安全模型包括4个主要部分，分别是 安全策略 保护 检测 响应 常用网络安全预警模型有： 基于入侵事件的预警模型 基于攻击过程的预警模型 基于流量监控的预警模型 入侵检测系统的主要技术指标： 主要：漏报率、误报率 其他的还包括处理性能、完备性、容错性、及时性 入侵检测根据数据来源分为： 基于主机的入侵检测 基于网络的入侵检测 混合型入侵检测 入侵检测按照检测方法分为： 异常检测 无用检测 通用入侵检测框架四个基本组件： 事件产生器 时间分析器 响应单元 时间数据库 数据传输加密应用模式有： 链路加密 节点加密 端到端加密 以下关于链路加密的说法不正确的是：A. 链路加密是在通信链路两端加上加密设备对数据进行加密B. 链路加密可以采用硬件实现C. 链路加密中每个用户可以选择自己的加密密钥D. 链路加密中所用用户使用相同的加密密钥 选 C。 端口扫描的基本原理是什么？端口扫描技术可以分成哪几类？端口扫描的原理是向目标主机的TCP/IP端口发送探测数据包，并记录目标主机的响应。通过分析响应来判断端口是打开还是关闭等状态信息。 根据所使用通信协议的不同，网络通信端口可以分为TCP端口和UDP端口两大类，因此端口扫描技术也可以相应的分为TCP端口扫描技术和UDP端口扫描技术。 第五章安全协议按是否需要可行第三方分类 仲裁协议 裁决协议 自动执行协议 Kerberos的设计目标不包括：授权包括：认证、记账、审计 数字签名机制至少包括两个过程 （用私钥）签名 （用公钥）验证 X.509证书包含的主要内容有哪些？（至少列举5条）（1）证书的版本信息 (1’)（2）证书的序列号 (1’)（3）证书所用的签名算法 (1’)（4）证书的发行机构 (1’)（5）证书的有效期 (1’)（6）证书所有人的名称 (1’)（7）证书所有人的公开密钥 (1’)（8）证书发行者对证书的签名 (1’) SSL产生会话密钥的方式随机由客户机产生并加密后通知服务器 简述SSL中会话状态和连接状态的区别和联系答：会话状态包含了标识一个会话的特征的信息和握手协议的协商结果。客户端和服务器端都需要记住已建立的所有的会话的状态。会话状态供握手协议层使用；（2分）连接状态包含了客户端和服务器端在传输数据过程中使用的加密参数。客户端和服务器端只需在一个连接存在时记住这个连接的状态。连接状态供记录协议层使用；（2分）多个连接状态可以和同一个会话状态关联，避免为每一个连接进行协商以提供新的安全参数。 简述 TLS 的概念及功能TLS全称是Transport Layer Security (传输层安全)。在客户端和服务器两实体之间建立一个安全的通道，防止敌手的侦听、篡改以及消息伪造。TLS协议基于可靠的传输协议（如TCP协议），其组成主要包括TLS记录层协议和TLS握手协议。(3分) TLS记录层协议利用密钥协商协议和对称加密机制，可以为通信双方提供一个安全通道，用于数据的安全传输。此外，TLS记录层协议还包括了消息的完整性校验功能，从而确保消息传输的完整性。TLS握手协议用于通信实体之间的相互认证和密钥协商。TLS协议位于OSI模型中的应用层和传输层之间，对于参与通信的客户端和服务器来说，TLS协议是透明的。(3分) TLS 握手协议分为 5 个阶段（1）交换安全能力（客户端向）（2）服务器密钥交换与认证（3）客户端密钥交换与认证（4）结束阶段（5）应用程序阶段 SET 的安全性体现在 认证 数据完整性 消息的私密性 SET 协议的实体由六部分组成： 持卡人 商家 发卡行 收单行 支付网关 认证中心 SET 协议使用了双重数字签名技术。请简述双重数字签名的目的和基本过程。SET 协议中，持卡人进行支付时需要对订单信息和支付信息同时进行签名，因此称为双重数字签名。 双重数字签名允许商家验证持卡人对订单信息和支付信息的签名，但只能看到订单信息，而不知道支付信息的具体内容。这样的目的是保护用户的个人信息的隐私性。 持卡人将支付信息摘要，订单信息和双重数字签名用数字信封加密后发送给商家，将订单信息摘要、支付信息和双重数字签名用数字信封加密后经商家转发给支付网关。 商家解开信封，生成订单的摘要后和账号的摘要连接起来，用持卡人证书的签名公钥即可验证签名。 六至九章容错技术分为 硬件容错技术（多硬件重复运行） 时间容错技术（重复执行指令） 信息容错技术（冗余位） 软件容错技术（多程序冲突运行） 容灾技术分为 本地容灾 异地数据冷备份 异地数据热备份 异地应用级容灾 访问控制模型分为 自主访问控制模型 强制访问控制模型 基于角色的访问控制模型","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"操作系统 课程笔记","date":"2020-09-08T02:20:09.000Z","path":"computer-science/operating-system-classnote/","text":"教材：《操作系统——精髓与设计原理 第八版》– William Stallings 一 操作系统概述操作系统的目标和功能操作系统： 控制应用程序执行的程序 应用系统和计算机硬件之间的接口 目标：方便、有效、扩展能力 功能： （作为用户/计算机接口的）OS 提供的服务： 程序开发 程序运行 I/O设备访问 文件访问控制 系统访问 错误检测和响应 记账 Accounting （作为资源管理器的）操作系统负责 资源管理，控制数据的移动、存储、管理 操作系统的历史串行处理 无 OS 控制台、输入设备（卡片机阅读器） 简单批处理系统 监控程序 对一批作业自动处理 内存中只能存放一道作业 简单批处理系统 监控程序的功能： 作业的自动续接 内存保护 定时器（防止作业独占） 特权指令（内核模式下） 中断 运行模式：用户模式、内核模式 多道批处理系统 多道批处理系统 多道批处理系统：简单批处理系统的改进 内存中同时存放多个作业 作业可并发执行 作业调度程序 硬件支持： I/O中断 DMA …… 特征：多道性、调度性、无序性、无交互能力 如下，系统可用内存250MB，三个作业可同时处理： 示例-信息 分时系统产生原因：人机交互、共享主机、方便上机 分时系统： 采用多道程序设计技术处理多个交互作业 多个用户共享处理器 多个用户通过不同终端同时访问系统 特征：多路性、独立性、及时性、交互性 比较 多道批处理系统 分时 实时系统 主要目标 充分利用处理器 减少响应时间 OS 指令源 作业提供命令（无交互） 终端键入命令（来自用户） 特征 多道性、调度性、无序性、无交互能力 多路性、独立性、及时性、交互性 可确定性、可响应性、用户控制、可靠性、故障弱化能力 第一个分时操作系统：CTSS (Compatible Time-Sharing System) CTSS 内存占用示例 实时系统系统能够及时（即时）响应外部事件的请求，在规定的时间内开始或完成对该事件的处理，并控制所有实时任务协调一致地运行。 应用领域： 航空航天 军事 工业控制 事务系统总之家用电脑不需要 特征：可确定性、可响应性、用户控制、可靠性、故障弱化能力 操作系统的主要成就这部分是一个概述，具体的定义和实现在后面都会有讲。 进程进程：一个正在处理器执行的程序 为什么会有进程 进程的组成： 可执行程序 相关数据 程序的执行上下文（execution context） 进程状态 操作系统用来管理和控制进程所需的所有数据（处理器寄存器的内容、进程优先级、是否在等待I/O事件、在内存中的位置……） 如下，正在执行的 B 进程切换到 A 时，需要保存 B 的上下文： 典型的进程实现 内存管理任务： 进程隔离 自动分配和管理 支持模块化程序设计 保护和访问控制 长期存储 文件系统：实现了长期存储文件：一个有名称的对象，访问控制和保护的基本单元 虚拟存储： 以逻辑方式访问存储器，不考虑物理内存可用的空间数量 满足多作业F同时驻留内存的要求 换入、换出机制 分页机制（进程大小不同） 每个作业部分驻留（检测到缺页时载入） 分页机制： 页：若干个固定大小的块，组成进程 虚地址（virtual address）：由页号和页内偏移量组成 虚地址和内存中实地址（real address，物理地址）之间的动态映射机制 虚存寻址 信息保护和安全OS 的 4 类典型安全问题： 可用性 保密性 数据完整性 认证 调度和资源管理调度策略需要考虑： 公平性 有差别的响应性 有效性 多道程序环境中涉及进程调度和资源分配的主要组件 现代操作系统的特征 微内核：只给内核分配基本功能（地址空间、进程间通信 IPC、基本的调度） 优点：简化实现、灵活、适合分布式 多线程 线程：可分派的工作单元。包括上下文、数据区域 进程：一个或多个线程和相关系统资源的集合 对称多处理：多处理器架构，且每个处理器地位相同 多个进程/线程可以并行 多处理器对用户透明 OS 负责调度、同步 优点：性能、可用性、渐增性、扩展性 分布式 面向对象 给小内核增加模块化扩展、定制操作系统 容错性操作系统相关技术： 进程隔离 并发控制 虚拟机 检测点和回滚机制 多处理器和多核操作系统考虑因素关键问题： 并发进程或线程 调度 同步 内存管理 可靠性、容错性 多核系统潜在的并行能力有三个层次 应用程序以多线程形式执行能力 多处理器的多线程程序执行能力 核内部硬件并行、指令集并行 OS 常用策略： 应用层并行 虚拟机 主流操作系统（略）单体内核 单体内核：在一大块代码中包含了所有的操作系统功能，作为单个进程运行，具有唯一的地址空间 所有的功能部件都可以访问内核数据结构和例程 Linux 虽然是单体内核，但是采用了模块化结构 二(1) 进程管理：进程描述与控制什么是进程进程：一段代码执行的时候就称为进程 进程 = 代码 + 相关数据 进程由以下元素表征： 进程的元素 上下文数据（狭义，图中的“上下文数据”即是狭义）：CPU寄存器 广义：图中全部数据 记账信息：统计信息（CPU 时长等） 进程控制块 Process Control Block, PCB 各操作系统不同 用于中断进程后恢复进程 进程控制块 进程特征： 动态性（存在生命周期，本质特征） 并发性（重要特征） 独立性 异步性：按各自独立的、不可预知的速度向前推进 为什么速度不可预知？——存在中断等等 进程与程序比较： 进程：正在运行的程序实例 进程 = 进程控制块 + 程序 + 相关数据 引入进程概念为并发作铺垫 程序静态，进程动态 “程序-进程”不是一对一 反例 1：一个进程可以对应多个程序（一个进程调用 DLL 等，也算是多个程序） 反例 2：一个程序可以对应多个进程 进程状态进程轨迹进程轨迹：进程执行的指令序列，用来描述单个进程的行为 处理器的行为可以用多个进程交替执行的轨迹来描述，如下图。 示例 进程的两状态模型 进程的两状态模型 简单易懂。 进程的两状态模型的排队图 进程的创建和终止进程创建的原因： 提交批处理作业后，准备处理新的批处理作业 （终端用户）交互登陆 为提供服务而由操作系统创建 由现有进程派生 相关的进程称为父进程和子进程 记忆方法：可以由操作系统、用户、父进程创建，其中操作系统可以因为新的作业或提供系统服务而创建。 进程终止： 终止的原因 进程的五状态模型将 Not Running 细分为就绪（等 CPU）和阻塞（等 I/O 之类的），得到了五状态模型： 进程的五状态模型 进程的五状态模型的排队图 排队模型如上图。除此之外，还有下列几种变形： 多阻塞队列 多就绪队列（优先级不同） 退出状态（保留记账信息等） 进程的五状态模型的排队图（多阻塞队列） 挂起挂起的进程： 原因：内存资源紧张、无就绪进程（进程全阻塞等待 I/O） 交换：把内存的一个进程的部分或全部移到磁盘中（挂起状态），然后从挂起队列取一个进程/接纳一个新进程 挂起状态：将内存中处于阻塞、就绪、甚至是执行状态的进程放到外存，不再参与 CPU 的竞争 六状态模型 为区分两种挂起，便有了七状态的挂起状态图（重点）： 七状态模型 挂机进程特征： 不能立即执行 可能在等待事件 需要被一个代理（自身、父进程或 os）挂起 需要被代理取出 进程挂起的原因： 进程挂起的原因 进程描述 进程的三种情况 操作系统的控制结构 内存表：用于跟踪内存和外存 分配给进程的内存 分配给进程的外存 内存块或外存块的保护属性，如为哪些进程所共享 管理外存所需要的信息 注：外存使用虚拟存储或交换机制 I/O 表： I/O 的状态 源/目标的内存单元 文件表： 是否存在 在外存中的位置 当前状态 其他属性 进程表： 用于管理进程 表中有内存、I/O、文件的引用 表能被 OS 访问 OS 需要知道：进程的位置、属性 位置包含：程序、数据、（调用）栈 属性即 PCB 程序、数据、栈和属性构成进程映像 PCB 中的信息： 进程标识信息 进程的唯一标识符 ID，构成索引 父进程 ID 用户 ID 处理器状态信息 被设计为程序状态字 PSW 寄存器 由寄存器内容组成 用户可见寄存器 控制、状态寄存器 栈指针 进程控制信息 调度和状态信息（进程状态、优先级、调度相关信息、等待事件的标识） 数据结构（用队列、环等链接到其他进程） 进程间通信（两个进程通信的相关信息） 进程特权 存储管理（进程虚存的段表、页表的指针） 进程所有权、使用情况（打开的文件、使用历史） 记忆上，进程控制信息的六点可以按照章节名来记：调度和状态信息（对应进程调度）、进程通信（对应进程同步）、存储管理（对应第三章）、进程使用情况（对应 I/O、文件），外加数据结构和进程特权（对应内核模式）。 进程表 = n * 进程映像的指针进程映像 = 程序 + 数据 + 栈 + 属性(PCB)PCB = 进程标识信息 (三个 ID) + 处理器状态信息 (PSW) + 进程控制信息 进程控制内核内核 kernel：操作系统的核心 操作系统中的重要系统功能 常驻内存 功能： 资源管理：进程管理、存储管理、I/O 设备管理（文件管理放在核外） 支撑功能：中断处理、时钟管理、记账功能 中断处理既是内核的基本功能，也是整个操作系统赖以活动的基础，操作系统的一切重要活动最终都依赖于中断。 执行模式大多数处理器至少支持用户模式和内核模式。 用户模式 优先权较少 运行用户程序 系统模式/内核模式/控制模式 优先权更高 运行内核 某些指令、内存只能在特权模式下运行/访问，如： 读取/修改 PSW 等控制寄存器 原始 I/O 指令 内存管理相关 记忆上，用户模式和系统模式是一一对应的。系统模式的特权可以分为三个方面：寄存器、内存、I/O。 区分用户模式和内核模式的原因：保护 OS 和重要操作系统表不受程序干扰 内核模式的实现方案： IA-64 处理器的 PSWR 中存在指示执行模式的位 当用户调用操作系统服务或中断促发系统例程时，相关位被置为内核模式 当从系统服务返回用户进程时，执行模式置为用户模式 系统调用 system call 是 OS 为用户提供的接口。 进程创建回忆进程创建的原因？ 创建进程的流程： 分配 ID 分配内存 初始化 PCB（标识信息、处理器状态信息、控制信息） 建立相关指针、引用（如将其插入就绪或就绪/挂起链表） 建立/扩充其他数据结构 进程切换下均指用户模式下的进程切换。 进程切换的时机 系统中断系统中断：普通中断和陷阱对比。 普通终端和陷阱 内存失效：缺页等 中断不一定导致进程切换（getpid() 系统调用引发中断，但没有进程切换） 模式切换模式切换：用户模式和内核模式之间的相互转换。 模式切换原因： 系统调用 中断 中断出现时，会将程序计数器置为中断处理程序的开始地址（汇编基础 hhh） 需要从用户模式切换到内核模式，以便中断处理能执行特权指令 注意： 模式切换不一定导致进程切换（getpid() 系统调用引发中断，但没有进程切换） 进程切换一定会有模式切换（进程切换一定要在内核模式下进行） 进程状态转换 模式切换不一定有进程状态转换 进程切换一定有进程状态转换（就绪、阻塞等） 进程切换步骤： 保存处理器上下文（寄存器） 更新当前进程的 PCB（状态、数据结构等变化） 将 PCB 的指针移至相应队列（就绪、阻塞、挂起等） 选择另一进程执行 切换回来的步骤： 更新该进程的 PCB 更新内存管理数据结构 恢复被选择进程的上下文 总结几个概念的关系 中断、模式切换 --不一定--&gt; 进程切换、进程状态转换（反例均为 getpid()） 进程切换 --一定--&gt; 模式切换、进程状态转换 操作系统的执行 操作系统的执行 Unix SVR4 的进程管理Unix SVR4 的进程状态图 Unix SVR4 的进程状态图 阻塞在 Unix SVR4 中被称为 Sleep。 Unix SVR4 的进程创建 内核系统调用 fork()，在内核模式下完成 在进程表中为新进程分配一个空项 为子进程分配一个唯一的 ID 复制父进程的进程映象，但共享内存除外 增加父进程所拥有的文件的计数器，反映另一个进程现在也拥有这些文件的事实 将子进程设置为就绪态 将子进程的 ID 号返回给父进程，将 0 值返回给子进程 fork() 的返回值：-1（出错）、0（无子进程）、正值（子进程的 ID） 进程创建后，可能发生： 控制权：父进程，执行点：调用 fork 的位置 控制权：子进程，执行点：调用 fork 的位置 控制权：其他进程（即使当前父子进程处于就绪态） 最终父进程和子进程均会在下一条语句上继续运行 例题 1： 123456789#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;void main(void) &#123; printf(\"Hello\"); fork(); printf(\"Bye\");&#125; 输出 HelloByeBye，但父/子进程输出 Bye 的先后顺序未知。 例题 2： 12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; int i; for (i=0;i&lt;3;i++) fork(); printf(\"hello, world\\n\"); return 0;&#125; 输出 8 个 hello, world。 例题 3： 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;void main(void)&#123; int i; static char buffer[10]; if (fork()==0) strcpy(buffer, \"Child\\n\"); else strcpy(buffer, \"Parent\\n\"); for (i=0; i &lt; 5; ++i) &#123; sleep(1); write(1, buffer, sizeof(buffer)); &#125;&#125; 该程序的运行无法保证输出顺序，输出顺序依赖于内核所用的调度算法。在 Ubuntu 20.04 LTS 测试结果如下： 12345678910111213$ gcc test.c -o test$ ./testParentChildParentChildParentChildParentChildParentChild$ 例题 4：下面代码执行后，问父子进程的 global 和 vari 变量值。 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;int global = 4;void main(void) &#123; int pid; int vari = 5; printf(\"before fork\\n\"); if ((pid = fork()) &lt; 0) &#123; printf(\"fork error\\n\"); exit(0); &#125; else if (pid == 0) &#123; global++; vari--; &#125; printf(\"global=%d,vari=%d\\n\", global, vari);&#125; 运行后，父进程的 (global, vari) = (4,5)；子进程的 (global, vari) = (4,5)。 变量名 父进程 子进程 global 4 5 vari 5 4 这个例子说明，子进程的内存是父进程 (global, vari) = (4,5) 的复制下（而不是引用），子进程进行 global++; vari--; 完全不影响父进程的变量。 线程线程与进程进程的两个属性（拥有资源、调度/执行的基本单位）是独立的，OS 应该能独立处理它们，为此引入线程。 调度并分派的单位通常称为线程（或轻量级进程 LWP） 资源所有权的单位通常称为进程 多线程 multithreading：操作系统在单个进程内支持多个并发路径的能力。 单线程：每个进程中只有一个线程在执行（在多线程出现之前，还没有线程这个概念；显然这是在多线程出现之后才给出的定义）。 多进程与多线程的例子 多线程环境中，与进程相关的资源和保护： 容纳进程映像的虚地址空间（回忆进程映像 受保护的访问： 处理器 其他进程（进程间通信时，以进程为单位） 文件 I/O 资源 一个进程中可能有多个线程，每个线程有： 执行状态（运行、就绪等） 未运行时保存的线程上下文（寄存器值） 执行栈（过程调用） 用于局部变量的静态存储空间 与进程内其他线程共享的内存和资源访问 如下图，多线程模式中，几个线程的 PCB 和内存地址空间是共享的，而每个线程有自己的 TCB、用户栈和内核栈。进程控制块 Thread Control Block 较 PCB 会简单很多，其内容如上点。 单进程和多进程模型 进程的优点： 创建线程快于创建进程（因为 TCB 简单） 终止线程快于终止进程（同上） （同一进程内）线程切换快于进程切换（上下文、数据结构少） 线程提高了不同执行程序间通信的效率（线程间通信） 调度和分派基于线程 大多数与线程相关的信息保存在线程级的数据结构中 挂起一个进程 == 挂起内部所有线程 终止一个进程 == 终止内部所有线程 线程主要状态：运行、就绪、阻塞（类似于进程三状态模型）和线程状态变化相关的基本操作：派生、阻塞、解除阻塞、结束 使用线程的远程过程调用示例 如上，即使是在单核 CPU 上运行，多线程技术在 I/O 密集型程序中能显著提高效率。 单处理器上的多线程示例 需要线程同步的原因：一个进程中的所有线程共享一个地址空间和进程所拥有的资源，一个线程对其的修改将影响其他线程。 多线程，多进程，多核相关概念多线程，多进程，多核的概念令人迷惑，不过知乎上有篇总结贴可以参考。 CPU 的线程数 == 可以同时并行的线程数量 == 操作系统看到的核数（可使用任务管理器或 htop 等） 进程是系统资源（内存、显卡、磁盘）的分配单位，线程是调度（可以理解为 CPU 资源）的分配单位 同进程下的线程共享该进程的资源，不同进程的线程如果想要共享资源，需要在 OS 层面上通信，效率低 对于计算密集型进程，进程线程数 == CPU线程数 时能充分利用 CPU 资源，进程线程数 &gt; CPU线程数 时会因为 CPU 频繁进程切换导致效率反而变低 对于 IO 密集型进程，由于进程会被频繁阻塞，进程线程数 &gt; CPU线程数 能够提高 CPU 利用率，提高效率 Python 是一个特例，由于 Global Interpreter Lock (全局解释器锁) 的存在，一个 Python 进程中只能同时有一个线程执行 线程分类 用户级线程 User-Level Thread, ULT 内核级线程 Kernel-Level Thread, KLT 用户级线程和内核级线程 用户级线程 ULTULT 下，线程由库函数实现，线程的创建、销毁全部由库函数实现。而内核不知道用户级线程的存在，依旧按照进程为单位进行调度。 ULT 下进程状态和线程状态的关系 如上图，ULT 下，会出现一些比较神奇的情况： (a) 图是正常运行的状态 线程 2 等待 I/O，导致进程 B 被阻塞，此时线程 1、2 均未被 CPU 运行，但线程 2 的数据结构中仍被标记为运行，如图 (b) I/O 事件到达，进程 B 被置为就绪，此时线程 1、2 均未被 CPU 运行，但线程 2 的数据结构中仍被标记为运行，如图 (c) 进程 B 运行过程中，线程 2 等待线程 1 的事件，此时线程 2 被置为阻塞，线程 1 被置为运行，进程 B 仍为运行 用户级线程优点： 线程切换不需要内核模式 调度策略因应用程序不同而不同 可以运行在任何操作系统上 缺点： 当用户级线程执行系统调用时，不仅阻塞当前线程，还将引起同一进程中的其他线程阻塞 采用 ULT 策略，不能利用多处理器技术（ULT 下，内核按进程分配处理器） 解决方法： 将应用程序写成多进程程序而不是多线程 Jacketing（套管）技术：将一个可能产生阻塞的系统调用转换成一个非阻塞的系统调用 一种解决线程阻塞问题的方法是，使用一种称为“套管”(jacketing) 的技术。“套管”的目标是把一个产生阻塞的系统调用转化为一个非阻塞的系统调用。例如，替代直接调用一个系统 I/O 例程，让线程调用一个应用级的 I/O 套管例程，这个套管例程中的代码用于检查并确定 I/O 设备是否忙。如果忙，该线程进入阻塞态并把控制权传送给另一个线程。这个线程重新获得控制权后，套管例程会再次检查I/O设备。 内核级线程 KLT纯 KLT 软件中，管理线程的所有工作均由内核完成。应用级没有线程管理代码，只有一个到内核线程设施的应用编程接口 API。 Windows是这种方法的一个例子。 优点： （解决了纯 ULT 的两个痛点）一个进程的多个线程可以调度到多处理器上 当一个线程阻塞时，内核可以调度同一进程内的其他线程 此外，内核本身也可以是多线程的缺点： 从一个线程切换到相同进程内的另一个线程时，需要切换到内核模式 线程和进程操作执行时间（µs） Null Fork: Fork 以后什么都不做 Signal Wait: 一个进程/线程发出信号到另一个进程/线程收到信号 KLT 下操作涉及到模式切换；进程操作涉及到共享空间等 混合方法在混合系统中， 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行 一个应用程序中的多个用户级线程会被映射到一些（小于等于用户级线程数）内核级线程上（程序员还可以调节 KLT 的数量） 优点： 同一个进程中的多个线程可利用多处理器 引起阻塞的系统调用不会阻塞整个进程 设计正确时，这种方法可结合纯 ULT 方法和纯 KLT 方法的优点，并克服它们的缺点。Solaris操作系统是使用混合方法的很好例子。 二(2) 进程管理：进程调度如果有多个进程（线程）竞争 CPU，需要选择下一个要运行的进程（线程）。OS 中完成这部分工作的程序称为调度程序 scheduler。调度程序使用的算法称为调度算法 scheduling algorithm。 调度的目的：满足系统目标（响应时间、吞吐量、处理器效率）的方式，把进程分配到一个或多个处理器上执行 调度的类型 调度类型 操作 决策内容 长程调度 创建进程 -&gt; 挂起/就绪 把进程添加到当前活跃的进程集中 中程调度 挂起 &lt;-&gt; 就绪/运行 把进程添加到（至少部分）已在内存且可被执行的进程集中 短程调度 就绪 &lt;-&gt; 运行 下次执行哪个就绪进程 下图为三种调度和状态图的关系。 调度与状态图 下图为三种调度的层次关系。 调度的层次 注意三种调度的关系不是包含，而是嵌套。 具有三种调度的调度队列模型 长程调度 决定哪个程序可以进入系统中处理 控制系统并发度 创建的进程越多，每个进程执行的时间比例越小 可能限制并发的度给当前进程集提供满意的服务 长程调度需考虑： 何时操作系统能够接纳进程 接纳哪个作业为之创建进程（先来先服务，或根据优先级、期望的执行时间、I/O 需求） 中程调度中程调度是交换功能的一部分，是否换入取决于系统并发度的需求。在不使用虚存的系统中，换入决策还需考虑换出进程的存储需求。 短程调度 又称分派程序 执行最频繁 决定下次执行哪个进程 当前进程阻塞或被抢占时，调用短程调度程序 事件：时钟中断、I/O 中断、系统调用、信号等 调度的规则相关概念 响应时间：从用户提交一个请求开始，到接收响应之间的时间间隔 响应时间 = 输入传送时间 + 处理时间 + 响应传送时间 截止时间：某任务必须开始执行/必须完成的最迟时间 吞吐量：在单位时间内，系统完成的进程数 处理器利用率：处理器处于忙状态的时间百分比 周转时间：进程从提交到完成的时间 周转时间 = 等待资源的时间 + 执行时间 等待资源的时间 = 就绪 + 阻塞 + 就绪/挂起 + 阻塞/挂起 注意“周转时间”和“响应时间”针对的主体不同，前者是进程，后者是用户 平均周转时间：多个进程周转时间的平均值 平均带权周转时间：多个进程带权周转时间的平均值 带权周转时间 $= T/S \\geq 1$，其中 $T$ 为周转时间，$S$ 为服务时间（执行时间） 若 $T/S=1$ 说明进程来了立即被调用，没有等待 调度规则总结短程调度的主要目标：以优化系统某些方面为目的，分配处理器时间 面向用户，与性能相关：周转时间、响应时间、 最后期限（截止时间） 面向用户，与性能无关：可预测性 面向系统，与性能相关：吞吐量、 处理器利用率 面向系统，与性能无关：公平性、强制优先级、平衡资源 优先级的使用下图为多优先级队列的一个例图。总是先执行优先级最高的进程（RQ0）。 优先级的使用 考虑进程优先级可能导致饥饿（低优先级进程迟迟无法运行），可以采用动态优先级方案（如根据等待时间变化优先级，等待时间过长后提高优先级）。 调度的决策模式调度的决策模式： 非抢占（非剥夺）：执行进程只有在执行完毕，或因申请 I/O 或请求某些操作系统服务而阻塞自己时，才释放处理器。OS 不会主动中断进程。 抢占（剥夺）：执行进程可能被操作系统中断，并转换为就绪态 抢占可能发生在： 新进程到达 中断发生后把一个阻塞进程置为就绪态 周期性的时钟中断 调度的选择函数： 决定下次选择哪个就绪进程执行 可基于优先级、资源需求、进程的执行特性 基于执行特性时的基本参数： w = 在系统里已经等待 waiting 的时间 e = 在系统里已经执行 execution的时间 s = 进程所需的总服务 service 时间，需要估计或由用户提供 e-s = 进程还需要执行的时间 调度算法 系统的资源分配策 -&gt; 资源分配算法 对于不同的系统目标，采用不同的调度算法 常见（短程）调度算法： 先来先服务 First Come First Served, FCFS 时间片轮转 Round Robin, RR 短进程优先 Shortest Process Next, SPN 剩余时间最短优先 Shortest Remaining Time, SRT 响应比高者优先 Highest Response Ratio Next, HRRN 反馈 Feedback …… 概述 概述 先来先服务 FCFS 算法：First-Come-First-Served, FCFS，也称为 FIFO 选择就绪队列中存在时间最长的进程运行 max[w] 即按请求 CPU 的顺序使用 CPU 示例 算法评价： 非抢占调度 有利于 CPU 繁忙型的进程（非抢占，能一直利用 CPU），而不利于 I/O 繁忙型的进程（需要反复排队 太惨了） 不适合直接用于单处理器系统,通常与其它调度算法混合使用 平均周转时间长 对长进程有利，不利于短进程 时间片轮转 RR 算法：Round Robin, RR 每个进程被分配一个时间片，周期性产生时钟中断，中断时当前进程进入就绪队列末尾，基于 FCFS 选择下一个作业运行 如果进程在时间片内阻塞或结束，则立即切换 CPU RR 算法在通用的分时系统或事务处理系统中特别有效 示例 图中 q 为时间片长度，下同。 注意，D 到达的同时 C 调度时间片结束，此时优先级： D &gt; C。 算法评价： 抢占 常用于分时系统或事务处理系统 时间片与性能、响应时间相关 时间片太短——进程切换频繁，降低 CPU 效率 时间片太长——短交互请求的响应时间变长 时间片最好略大于一次典型交互的时间 对 CPU 密集型进程有利，对 I/O 型密集型进程不利（用不完一个时间片） 针对最后一点的改进：Virtural RR 算法 增加一个辅助队列，接收 I/O 阻塞完成的进程 调度优先于就绪队列 但占用的处理器时间小于就绪队列 类似于超市的快速结账通道 VRR 算法比 RR 算法公平 短进程优先 SPN算法: Shortest Job(Process) First(Next), SJF/SPF/SPN 短进程或短作业优先调度 min[s] 前提：预知执行时间 示例 算法评价： 非抢占 长进程饥饿 有利于短进程，减小了平均周转时间 缺少剥夺机制，不适用于分时系统/事务处理环境 用户估计不准时，算法不一定能真正做到短作业优先调度 剩余时间最短优先 SRT算法: Shortest Remaining Time, SRT 选择预期剩余时间最短的进程 min[s-e] 当一个新进程加入就绪队列时，如果它比当前运行的进程具有更短的剩余时间，就抢占当前正在运行的进程 在 SPN 的基础上增加了剥夺机制，抢占型 示例 算法优点： 既不像 FCFS 偏爱长进程，也不像 RR 算法产生很多中断（因时间片而产生），减少了开销 周转时间方面，比 SPN 好：只要就绪，短作业可以立即被执行 算法缺点： 需要估计预期的服务时间 s 存在长进程饥饿现象 必须记录进程的已服务时间 响应比高者优先 SRRN算法: Highest Response Ratio Next, HRRN 当前进程执行完毕或需要阻塞时，选择就绪队列中响应比 $R_p$ 最高的进程投入执行，其中 $$R_p = \\frac{等待时间+要求服务时间}{要求服务时间} = \\frac{w+s}{s}$$ 示例 算法评价： 非抢占 动态优先权调度算法 算法说明了进程的年龄 是 FCFS 和 SJF 的结合，既照顾了短进程，又考虑了作业到达的先后次序，不会使长进程长期得不到服务 但每次调度之前，都须先做响应比的计算，会增加系统开销；且难以准确计算 反馈调度法 FeedbackSPN、SRT、SRRN 采用了“奖励短进程”的思想。虽然性能较好，但均基于进程的预期执行时间。 算法思想： 采用惩罚运行时间较久的进程的思想 关注已经执行的时间 e 抢占（但是只在时间片结束时抢占） 动态优先级 采用多级队列区别对待的方法——惩罚长进程 多个独立的、优先级不同的就绪队列，优先调度优先级高的队列 进程执行过程中会降级 算法有多个变种（根据抢占机制不同而不同） （基于时间片轮转的）反馈调度算法：Feedback, FB 设置多个就绪队列，每个队列赋予不同优先级 第一队列优先级最高，依次递减 优先级越高的队列，进程执行的时间片越小 新进程进入时，首先放入第一个队列尾 $RQ0$，按 FCFS 原则排队 如果进程在当前队列的时间片内完成则退出 一般而言，从队列 $i$ 中调度的进程允许执行 $q=2^i$ 的时间，然后才能被抢占 当且仅当进程被抢占时，会被降一级优先级 如果时间片到达而没有被抢占（无其他进程需调度），则当前进程继续运行且暂时不降级。此后，一旦新进程出现，原进程会被立即抢占（无视时间片）并降一级 到达最低优先级队列后，不再降级 仅当第一队列空闲时，才调度第二队列中的进程，依次类推 调度队列 重点掌握！！！ 示例 注意在下面的调度图中，第 6 时刻 D 到达，此时 B 在第 2 队列，但没有被立即抢占。必须等 B 的时间片用完后才会进行抢占。 评价：多级反馈队列调度算法具有较好的性能，能较好地满足各种类型用户的需要。 终端型作业：有利（常为短作业，能在第一队列内完成） 短作业：有利（能在前几个队列内完成） 长进程：将依次在第 1, 2, …, n 个队列中运行，随着优先级下降，分配的时间片长度增加，减少了抢占次数 问题：当不断有新进程到来时，长进程仍可能饥饿 实时系统与实时调度实时系统：系统能够及时（即时）响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。对于实时系统而言，系统的正确性不仅取决于计算的结果，而且还依赖于产生结果的时间。 实时系统 = 实时控制系统 + 实时信息处理系统 实时任务：具有及时性要求的、常常被重复执行的特定进程。在实时系统中习惯称为任务 截止时间 开始截止时间：任务在某时间以前必须开始执行 完成截止时间： 任务在某时间以前必须完成 实时任务分类按截止时间分： 硬实时任务（必须在截止时间前开始/完成） 软实时任务（可以稍微延迟一些） 按周期性分： 周期性实时任务（如每五秒就绪一次） 非周期性实时任务 实时操作系统特点 可确定性(determinism)：关注的是从设备中断到系统获知中断的时间 可响应性(responsiveness)：关注的是系统获知中断后，为中断提供服务的的时间 用户控制(user control)：需要用户能够区分软、硬实时任务，并控制任务优先级 可靠性(reliability)：要求高于非实时系统 失效弱化(fail-soft operation)：故障时尽可能多地保存性能和数据，尽可能减少损失 实时调度的两个维度 调度方法：下次调度哪个任务 抢占方式：调度时采用什么抢占方式（在什么时候抢占） 调度方法分类调度方法方面，大概分为四类： 静态表驱动调度法 静态优先级抢占调度法 基于动态规划的调度法 动态尽力调度法 静态表驱动调度表 用于调度周期性实时任务 按照任务信息（周期到达的时间、执行时间、完成截止时间以及任务的优先级），制订调度表，调度实时任务 例：最早截止时间优先 EDF 此类算法不灵活，任何任务的调度申请改动都会引起调度表的修改 静态优先级抢占调度法 此类算法多用于非实时多道程序系统 优先级的确定方法很多，例如在分时系统中，可以对 I/O 密集型和 CPU 密集型的进程赋予不同的优先级 实时系统中一般根据任务的时间约束赋予优先级，例如速率单调调度算法 RMS 即是根据任务周期长度为实时任务赋予静态优先级。 基于动态规划的调度法 当实时任务到达以后，系统为新到达的任务和正在执行的任务动态创建一张调度表 在当前执行进程不会错过其截止时间的条件下，如果也能使新到达任务在截止时间内完成，则立即调度执行新任务 动态尽力调度法 实现简单，广泛用于非周期性实时任务调度 当任务到达时，系统根据其属性赋予优先级，优先级高的先调度。例如最早截止时间优先 EDF 调度算法就采用了这种方法。这种算法总是尽最大努力尽早调度紧迫任务，因此称为“最大努力调度算法” 缺点在于，当任务完成，或截止时间到达时，很难知道该任务是否满足其约束时间 抢占方式分类抢占方式分为以下四类，见表： 抢占方式 抢占/非抢占 抢占时间点 响应时间 应用 图 基于时间片的轮转调度 抢占 进程时间片用完 秒级 分时系统及一般实时处理系统 基于优先级的非抢占调度 非抢占 进程阻塞或完成 数百毫秒至数秒 多道批处理系统及不太严格的实时系统 基于优先级的抢占点抢占调度 抢占 剥夺点（时间中断）到来时 几毫秒至几十毫秒 一般实时系统 立即抢占式调度 抢占 立即 微秒至毫秒级 苛刻的实时系统 实时调度方法实例近年来，人们提出了许多关于实时任务调度的合适方法，这些方法都基于每个任务的额外信息。最常见的信息包括： 就绪时间 启动的限期 starting deadline 完成的限期 completion deadline 处理的时间：任务执行到完成的时间 资源需求：任务执行过程中所需的资源集 优先级：度量任务的相对重要性 子任务结构：一个任务可分解为一个必须执行的子任务和一个可选执行子任务，前者有硬截止时间 hard deadline 实时调度需要考虑的两个问题： 下次调度哪个任务？——选择 deadline 最早的任务 使用什么抢占方式？——对于启动限期明确的任务，采用非抢占方式；对于具有完成限期的实时系统，采用抢占策略（这合理吗？） 实例：有完成限期的周期性实时任务在一个实时系统中，有两个周期性实时任务A和B A：周期：20ms，执行时间：10ms B：周期：50ms，执行时间：25ms 不同执行策略和效果 可见，在这个例子中，按“最早完成截止时间优先” Earliest Deadline First, EDF 的抢占模式能够使得所有任务都能在 deadline 之前执行完成。 实例：有开始限期的非周期性实时任务 此类任务是非周期性的，不可预测的，若采用 EDF 算法，存在危险性 若在任务就绪前，预先知道任务的开始截止时间，则可以采用允许 CPU 空闲的 EDF 调度算法 Earliest Deadline with Unforced Idle Times 优先调度截止时间最早的合格任务，并让该任务运行完毕 合格任务可以是还未就绪，但是事先知道其开始截止时间的任务 尽管 CPU 的利用率不高，但这种调度算法可以保证系统中的任务都能按要求完成 A、B、C、D、E五个非周期性进程，到达时间、执行时间和开始截止时间如下： 五个实时任务的执行信息 不同执行策略和效果 允许 CPU 空闲、优先调度 deadline 最早的（可能还未就绪的）合格任务，使得其能完成 B 任务。 实例：周期性实时任务 Rate Monotonic Scheduling, RMS 周期性任务 任务速率：任务周期（单位：秒）的倒数，以赫兹为单位 任务速率用于优先级的确定 任务周期越短，优先级越高 优先级函数是任务速度的单调递增的函数 系统按任务优先级的高低进行调度 实时系统处理能力限制假定系统中有 $m$ 个周期性的硬实时任务，任务 $i$ 的处理时间为 $C_i$，周期为 $P_i$，则在单处理机情况下，必须满足下面的限制条件： $$\\sum_{i=1}^m \\frac{C_i}{P_i} \\leq 1$$ 即系统中各个任务的处理器利用率总和不能超过 1（CPU的利用率 = 任务执行时间 / 任务周期）。 优先级反转 高优先级任务被低优先级任务阻塞，导致高优先级任务迟迟得不到调度。但其他中等优先级的任务却能抢到CPU资源。– 从现象上来看，好像是中优先级的任务比高优先级任务具有更高的优先权。——信号量优先级反转（翻转）与优先级继承– kummer话你知- 简书 可能发生于任何基于优先级的可抢占的调度方案中 已在火星探路者中发生 例子 解决方案是，使用优先级继承：优先级较低的任务继承任何与其共享同一资源的优先级较高的任务的优先级。 解决方案 二(3) 进程管理：进程同步并发的原理 日常生活现象 多道程序设计为什么需要同步？ 进程是计算机中的独立个体，且具有异步性、并发性 资源是计算机中的稀缺个体，需共享，如CPU、内存、I/O设备 进程之间可能需要协作完成任务 相关概念这些概念后面会经常用到，很重要。 原子操作：由一个或多个指令序列实现的动作或函数，对外不可见，一组指令要么都执行，要么都不执行。（数据库并发中的事务也有原子性） 临界资源：不可同时访问，必须互斥访问的资源，如打印机 临界区：访问临界资源的代码，任意时刻只能由一个进程在这段代码中运行 互斥：当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问共享资源的情形 忙等现象：当一个进程等待进入临界区时，它会继续消耗处理器的时间 活锁：两个或两个以上的进程为响应其他进程而持续改变自己状态，但是不做有用工作的情形 死锁：两个或两个以上的进程因等待其他进程做完某些事而不能继续执行的情形 竞争条件：多个进程或线程读写共享的数据时，结果取决于多个进程的指令执行顺序 饥饿：一个具备执行条件的进程，被调度程序无限期的忽视而不能调度的情形 忙等、饥饿和死锁 并发控制的产生产生原因： 单处理器的交替执行和多处理器的重叠执行 二者表达的是同样的问题——进程的相对执行速度不可预测，其取决于： 其他进程的活动 操作系统处理中断的方式 操作系统的调度策略 进程执行的相对速度不可预测，给并发带来了困难 资源共享充满了危险性 操作系统需要优化管理资源的分配 定位程序的设计错误很困难 如，两个进程共享 echo() （如下）可能会出现问题： 1234567char chin;void echo()&#123; chin = getchar() chout = chin; putchar(chout);&#125; 两端并行的 echo() 如图，设 chin、chout 均为全局变量。P1 程序输入 x，但由于 chin 被 P2 改变，P1 输出的是 y。 解决方法：控制对共享资源的访问，使得一个进程的功能和输出结果与执行速度无关。 于是，我们需要从进程的交互方式入手。不同的交互方式，并发控制问题不一样。 进程间的交互方式进程间的关系： 竞争 通过共享合作 通过通信合作 进程间的竞争资源 进程间不知道彼此的存在 进程竞争使用同一资源时，它们之间会发生冲突 这类资源如：I/O设备、存储器、处理器、时钟 进程竞争资源时，并发控制面临三个问题：互斥、死锁、饥饿 进程间通过共享合作 多个进程共享一个变量、共享文件或数据库 一个进程的结果可能取决于从另一个进程获得的信息 进程知道其他进程也可能共享同一个数据，因此必须合作 进程通过共享合作时，并发控制面临四个问题：互斥、死锁、饥饿、数据一致性（比上面多一个数据一致性） 进程间通过通信合作 进程间通过通信完成同步和协调彼此活动 一个进程的结果可能取决于从另一个进程获得的信息 通信可由各种类型的消息组成，发送或接收消息的原语由操作系统或程序设计语言提供 不涉及对共享资源的访问 进程通过通信合作时，并发控制面临两个问题：死锁、饥饿 互斥互斥的要求（访问临界区的原则） 空闲让进：如临界区空闲，则有进程申请就立即进入 忙则等待：每次只允许一个进程处于临界区（互斥） 有限等待：保证进程在有限时间内能进入临界区(不会死锁或饥饿) 让权等待：进程在临界区不能长时间阻塞等待某事件 本课程将从五个方面介绍互斥的实现，分别为软件方法、硬件方法、信号量、管程、消息传递。 互斥：软件方法 通过在进入区设置、检查一些标志来判断是否有进程在临界区 若已有进程在临界区，则在进入区通过循环检查进行等待 进程离开临界区后在退出区修改标志 初步设想——轮换使用临界区使用 turn 变量实现轮换使用临界区。 123456789101112131415161718192021222324// 共享的全局变量int turn = 0;// 进程 P0 的代码P0()&#123; do &#123; while (turn != 0); //进入区 // 进程P0的临界区代码; //临界区 turn = 1; //退出区 // 进程P0的其它代码 //剩余区 &#125; while (true);&#125;//进程 P1 的代码P1 ()&#123; do &#123; while (turn != 1); //进入区 // 进程P1的临界区代码; //临界区 turn = 0; //退出区 // 进程P1的其它代码 //剩余区 &#125; while (true);&#125; 严格轮换，实现了互斥访问 在临界区外出错/被终止也会影响其他进程的执行 忙等（一切需要 while(true) 的代码均是忙等） 违反了“空闲让进”原则 看不懂加粗词的读者请往上搜索其定义。 第一次改进——设置临界区状态标志使用 flag[2] 标记临界区的状态标志，发现对方的 flag 为 false 则进入临界区。 1234567891011121314151617181920212223242526// 共享的全局变量,标志临界区是否可用bool flag[2] = &#123;false, false&#125;; // 进程 P0 的代码P0()&#123; do &#123; while (flag[1]); //进入区 flag[0] = true; // 进程P0的临界区代码; //临界区 flag[0] = false; //退出区 // 进程P0的其它代码 //剩余区 &#125; while (true);&#125;//进程 P1 的代码P1 ()&#123; do &#123; while (flag[0]); //进入区 flag[1] = true; // 进程P1的临界区代码; //临界区 flag[1] = false; //退出区 // 进程P1的其它代码 //剩余区 &#125; while (true);&#125; 忙等 违反了“忙则等待”原则，互斥访问未实现（如果两段代码同时执行各自的 while 和各自的 flag[i]=true，二者会同时进入临界区） 第二次改进——预先表明进入临界区的态度仍然使用 flag[2] 标记临界区的状态标志，但先修改自己的 flag，再查询对方的 flag，最后进入临界区。 这个方法实现了互斥，但如果双方同时执行到 while，会死锁。当然，仍然存在忙等。 12345678910111213141516171819boolean flag[2] = &#123;false, false&#125;; //共享的全局变量// 进程P0do &#123; flag[0] = true; //进入区 while (flag[1]); //进入区 // 进程P0的临界区代码； //临界区 flag[0] = false; //退出区 //进程P0的其它代码 //剩余区&#125; while (true);// 进程P1do &#123; flag[1] = true; //进入区 while (flag[0]); //进入区 // 进程P1的临界区代码； //临界区 flag[1] = false; //退出区 //进程P1的其它代码 //剩余区&#125; while (true); 第三次改进——谦让上面的问题是因为修改了自己的 flag 然后死等对方的 flag，等不到就一直等，结果两个人互等。 这次改成，等不到就暂时释放自己的 flag，等一会后再改回来。 这个方案实现了互斥，且未死锁，但是有长时间僵持的可能性（这是因为可能相互谦让）。 123456789101112131415161718192021222324252627boolean flag[2] = &#123;false, false&#125;; //共享的全局变量//进程P0do &#123; flag[0] = true; while (flag[1]) &#123; flag[0] = false; //谦让 //随机延迟一小段时间； flag[0] = true; &#125; //进程P0的临界区代码； //临界区 flag[0] = false; //退出区 //进程P0的其它代码 //剩余区&#125; while (true);//进程P1do &#123; flag[1] = true; while (flag[0]) &#123; flag[1] = false; //谦让 //随机延迟一小段时间； flag[1] = true; &#125; //进程P1的临界区代码； //临界区 flag[1] = false; //退出区 //进程P1的其它代码 //剩余区&#125; while (true); Dekker 互斥算法—— flag 冲突时根据 turn 裁定为回避刚才相互谦让的问题，Dekker 算法使用 turn 来裁定，当双方的 flag 冲突的时候，应该谁先访问。同时，当一方访问完临界区后，需将 turn 和 flag 都让出去。 这个算法实现了互斥、无死锁，但仍然为忙等。 12345678910111213141516171819202122232425262728293031323334boolean flag[2] = &#123;false, false&#125;; //共享的全局变量int turn = 1; //共享的全局变量// 进程P0do &#123; flag[0] = true; //进入区 while (flag[1]) &#123; if (turn == 1) &#123; flag[0] = false; while (turn == 1) ; //等待 flag[0] = true; &#125; &#125; //进入区 // 进程P0的临界区代码； //临界区 turn = 1; //将 turn 让出去 flag[0] = false; //退出区 // 进程P0的其它代码 //剩余区&#125; while (true);// 进程P1do &#123; flag[1] = true; //进入区 while (flag[0]) &#123; if (turn == 0) &#123; flag[1] = false; while (turn == 0) ; //等待 flag[1] = true; &#125; &#125; //进入区 // 进程P1的临界区代码； //临界区 turn = 0; //将 turn 让出去 flag[1] = false; //退出区 // 进程P1的其它代码 //剩余区&#125; while (true); Peterson 互斥算法——先把 turn 让给对方Dekker 在 flag 冲突时才使用 turn 裁定，而 Peterson 互斥算法，就是在开始的时候直接先把 turn 让给对方，再判断对面是不是拥有 turn==i 和 flag[i] 二者。 Peterson 算法较 Dekker 算法的显著优点是算法更简洁，对应的代码行数更短。 这个算法实现了互斥、无死锁，但仍然为忙等。 123456789101112131415161718192021boolean flag[2] = &#123;false, false&#125;; //共享的全局变量int turn; //共享的全局变量//进程P0do &#123; flag[0] = true; //进入区 turn = 1; //进入区 while (flag[1] &amp;&amp; turn == 1); //进入区 // 进程P0的临界区代码； //临界区 flag[0] = false; //退出区 // 进程P0的其它代码 //剩余区&#125; while (true);//进程P0do &#123; flag[1] = true; //进入区 turn = 0; //进入区 while (flag[0] &amp;&amp; turn == 0); //进入区 // 进程P1的临界区代码； //临界区 flag[1] = false; //退出区 // 进程P1的其它代码 //剩余区&#125; while (true); 总结对于软件方法： 始终不能解决“忙等”现象 实现互斥比较困难 通常能实现两个进程的互斥，很难控制多进程互斥 算法设计需非常小心，否则可能出现死锁、互斥失败等 以上算法中，Dekker 和 Peterson 算法都较好地在软件方法上实现了两进程互斥。 互斥：硬件方法硬件方法如下： 中断禁用 机器指令 compare &amp; swap Exchange 中断禁用中断禁用（屏蔽中断）可用于单处理器系统。通过禁用中断，避免进程切换，简单粗暴地实现了互斥访问。 其缺点有： 无法响应其他外部请求，且无法切换进程，执行效率明显下降 在多处理器环境不能实现互斥（多个进程在多个处理器下并行执行） 123456while (true) &#123; disable interrupt //屏蔽中断 critical section //临界区 enable interrupt //启用中断 remainder //其余部分&#125; 专用机器指令在多处理器环境中，几个处理器共享访问公共主存。处理器表现出一种对等关系，不存在主/从关系（对称多处理器）。 处理器之间没有支持互斥的中断机制。因此，处理器的设计者提出了一些机器指令，用于保证两个动作的原子性（如在一个周期中对一个存储器单元的读和写）。 这些动作在一个指令周期中执行，不会被打断，不会受到其他指令的干扰。 compare &amp; swap 指令比较和交换指令 compare &amp; swap 用于比较一个内存单元的值和一个测试值，如果相等，则发生交换。 123456int compare_and_swap(int *word, int testval, int newval)&#123; int oldval = *word; if(oldval == testval) *word = newval; return oldval;&#125; 该指令总是返回旧内存值。因此，如果返回值与测试值相同，则表示该内存单元已被更新。 这个原子指令由两部分组成：比较内存单元值和测试值；值相同时产生交换。整个比较和交换功能按原子操作执行，即它不接受中断。 这个指令的另一个版本返回一个布尔值：交换发生时为真，否则为假。几乎所有处理器家族（x86、IA64、sparc 和 IBMz 系列等）都支持该指令的某个版本，且多数操作系统都利用该指令支持并发。 下面是操作系统使用 compare_and_swap 实现并发互斥的一个方案。 12345678910111213141516171819int bolt;void P(int i)&#123; while (true) &#123; // 一共只有一个 0，所有进程可以用手里的 1 尝试换 0 。哪个进程抢到了 0 就该谁执行 while(compare_and_swap(&amp;bolt, 0, 1) == 1); // 进入区 // 临界区代码 bolt = 0; //退出区 // 剩余区代码 &#125;&#125;void main()&#123; bolt = 0; parbegin(P(1), P(2), ..., P(n)); // 阻塞主程序，初始化并行过程 P1, P2, ..., Pn；全部终止之后，才恢复主程序的执行&#125; Exchange 指令1234567procedure exchange(var r: register; var m: memory); var temp; begin temp := m; m := r; r := temp; end 下面是操作系统使用 exchange 实现并发互斥的一个方案。 123456789101112131415161718192021int bolt;void P(int i)&#123; while (true) &#123; int keyi = 1; // 一共只有一个 0，所有进程可以用手里的 1 尝试换 0 。哪个进程抢到了 0 就该谁执行 do exchange (&amp;keyi, &amp;bolt) while (keyi == 1); // 临界区代码 bolt = 0; //退出区 // 剩余区代码 &#125;&#125;void main()&#123; bolt = 0; parbegin(P(1), P(2), ..., P(n)); // 阻塞主程序，初始化并行过程 P1, P2, ..., Pn；全部终止之后，才恢复主程序的执行&#125; 信号量信号量、管程 都是提供互斥的方案。 引言 交通信号灯：红灯停，绿灯行 信号量实现互斥与同步的基本原理： 两个或多个进程可以通过传递信号进行合作：迫使进程在某个位置暂时停止执行（阻塞），直到它收到一个可以“向前推进”的信号（被唤醒）。 实现信号灯作用的变量被称为信号量。 定义信号量 Semaphore 可视为一个值为整数的变量。具有三个操作： 一个信号量可以初始化为非负数 semWait （Wait或P）操作使信号量的值减少1，若值变为负数，则阻塞执行 semWait 操作的进程 semSignal（Signal或V）操作使信号量的值增加1，若值小于等于零，则被 semWait 阻塞的进程解除阻塞 除了这三个操作外，没有其他方法可以检查或操作信号量。 顺便，P 和 V 并称为 PV 操作。 分类信号量分为二元信号量（信号量的值只能是0或1）和计数信号量（非二元信号量/一般信号量） 二元信号量的定义及semWait和semSignal原语操作 一般信号量的定义及semWait和semSignal原语操作 上述二者都使用队列来组织等待信号量的进程。 强信号量：进程以FIFO方式从队列里移除 弱信号量：未规定阻塞进程从队列里移除的顺序 (强)信号量机制示例：设进程A、B、C依赖于进程D的结果，s初始为1，表示D的一个结果可用 (强)信号量机制示例 信号量解决互斥问题使用信号量能解决互斥问题，只需要给需要互斥的区域加一个信号量 s，访问前 P，访问后 V 即可。 信号量解决互斥问题 例：进程A、B、C访问受信号量lock保护的共享资源 进程A、B、C访问受信号量lock保护的共享资源 信号量的实现P 和 V 应作为原语实现。即，任意时刻只能有一个进程用 P 和 V 来操作控制信号量。 一种方案是用硬件或固件实现。另一种方案是采用硬件指令支持来保证进程互斥使用 P 和 V 操控信号量。 信号量的两种可能实现（左为compare&swap，右为中断禁用） 上例中，共享资源数量为 1。进一步地，可扩展为共享资源数量为多个或共享资源允许多个进程同时访问的情况： 在任何时候，信号量里 count 值可以解释如下： s.count ≥ 0 时，s.count 表示执行 P(s) 操作而不被阻塞的进程数（可看作可用资源数）。这种情形信号量可支持同步与互斥。 s.count &lt; 0时，s.count 表示阻塞在 s.queue 队列上的进程数。 四大经典同步问题 生产者/消费者 理发师 读/写者 哲学家就餐 生产者/消费者问题生产者与消费者问题： 一个或多个生产者产生数据并放入缓冲 每次只能有一个消费者从缓冲中取出数据（互斥） 任何时候只能由一个生产者或消费者访问缓冲（互斥） 需解决同步问题： 保证缓冲区满时，生产者不会往缓冲区中增加数据 保证缓冲区空时，消费者不能从缓冲区中取走数据 – Dijkstra 程序框图 生产者/消费者问题使用信号量的一个实现如下： 123456789101112131415161718192021/*program bounded_buffer*/const sizeofbuffer =…; /* 缓冲区大小 */var s : semaphore(:= 1); /* 用以互斥的信号量s，初始化为1 */ n : semaphore(:= 0); /* 表示资源的信号量n，表征数据单元数量，初始化为0 */ e : semaphore(:= sizeofbuffer); /* 表示资源的信号量e，表征空存储单元数量 */procedure producer ; procedure consumer ;begin begin repeat repeat /*produce a item*/ semWait(n); semWait(e); semWait(s); semWait(s); /*get a item*/； /*store a item*/ semSignal(s); semSignal(s); semSignal(e); semSignal(n)； /*consume a item*/ forever foreverend; end;begin /* 主程序 */ parbegin producer ; consumer ; parendend. 上段代码使用了三个信号量： s：表示生产者、消费者之间的互斥 e：表示空间资源量（放满了产品，就没有空间了） n：表示产品资源量 很有意思的是，生产者、消费者是对偶的关系。生产者需要空间，生产产品；消费者需要产品，“生产”空间。所以最简单的生产者/消费者问题中，二者的代码是很类似的。 注意： 应先申请资源信号量，再申请互斥信号量，顺序不能颠倒，否则可能导致死锁！（由于所有生产者、消费者共用一个互斥信号量，拿到了就得赶紧用，不然别人都会等你。或者说，互斥信号量应该是最后申请的信号量） 可能出现死锁 释放信号量的顺序应该是“先申请的后释放”。如果 producer 改为先释放 n 再释放 s，被阻塞在 P(n); 的消费者接收到 n 以后可能会被再次阻塞在 P(s)。 123456789101112// 错误的 producer 示例procedure producer ; procedure consumer ;begin begin repeat repeat /*produce a item*/ semWait(n); semWait(e); semWait(s); semWait(s); /*get a item*/； /*store a item*/ semSignal(s); semSignal(n); semSignal(e); semSignal(s)； /*consume a item*/ forever foreverend; end; 对于同一个信号量的 wait 与 signal 操作，既可以出现在同一个进程中，也可以出现在不同进程中（如 n 和 e）。 但是，对任何信号量的 wait 与 signal 操作必须配对。 wait与signal语句不能颠倒顺序，wait语句一定先于signal语句执行，对吗？ 不对，应为：在进入临界区前必须先执行wait操作，退出临界区后必须执行signal操作。对于同步信号量而言，既有可能先执行wait操作，也有可能先执行signal操作。 示例一 桌子上有一只盘子，最多可以放入 N (N&gt;0) 个水果； 爸爸随机向盘中放入苹果或桔子。儿子只吃盘中的桔子，女儿只吃盘中的苹果； 只有盘子中水果数目小于 N 时，爸爸才可以向盘子中放水果； 仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果； 每次只能放入或取出一个水果，且不允许多人同时使用盘子。 用信号量机制实现爸爸、儿子和女儿之间的同步与互斥活动，并说明所定义信号量的含义。要求用伪代码描述。 分析： 一个生产者和两个消费者被连接到大小为 N 的缓冲区上； 盘子是一互斥资源（不能同时访问），故设置访问盘子的互斥信号量 mutex； 爸爸、儿子因为桔子的放入与取出而同步，设置产品资源信号量orange； 爸爸、女儿因为苹果的放入与取出而同步，设置产品资源信号量apple； 爸爸、儿子、女儿因为共享盘子空间，设置空间资源信号量empty。 1234567891011121314151617181920212223242526272829303132333435363738semaphore mutex = 1; //盘子操作互斥信号量semaphore apple = 0, orange = 0; //苹果、桔子放入、取出的资源信号量semaphore empty = N; //盘子中可放入的水果数目father()&#123; while (true) &#123; result=prepare_fruit(); //准备水果，result为水果类型 P(empty); //盘子中可放入的水果数目减1 P(mutex); //互斥访问盘子 put a fruit on the plate(); //将一个水果放入盘子 V(mutex); //恢复访问盘子 if (result == apple) //准备的水果为苹果 V(apple); //允许女儿取苹果 else //准备的水果为桔子 V(orange); //允许儿子取桔子 &#125;&#125;son() &#123; while (true) &#123; P(orange); //判断是否可取桔子 P(mutex); //互斥访问盘子 get an orage from plate(); //取桔子 V(mutex); //恢复访问盘子 V(empty); //盘子中可放入的水果数目加1 &#125;&#125;daughter() &#123; while (true) &#123; P(apple); //判断是否可取苹果 P(mutex); //互斥访问盘子 get an apple from plate(); //取苹果 V(mutex); //恢复访问盘子 V(empty); //盘子中可放入的水果数目加1 &#125;&#125; P() 等价于 wait()，V() 等价于 signal()，后面就使用 P 和 V 了。 有意思的是，如果将原题的 N 改为 1，即盘子只有一个容量，就不需要 mutex 互斥信号量了，因为不会出现一边爸爸在放水果，另一边儿子/女儿在吃的情况。 下面的例二就是这种情况，可以省下一个 mutex 信号量。 示例二 桌子上有一只盘子，爸爸负责向盘中放苹果，妈妈负责向盘中放桔子； 儿子只吃盘中的桔子，女儿只吃盘中的苹果； 只有盘子为空时，爸爸或妈妈才可以向盘子中放入一个水果； 仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果。 请用信号量机制实现爸爸、妈妈、儿子和女儿之间的同步与互斥活动，并说明所定义信号量的含义。要求用伪代码描述。 分析： 两个生产者和两个消费者被连接到大小为1的缓冲区上； 盘子是一互斥访问的空间资源，故设置资源信号量plate； 爸爸、女儿因为苹果的放入与取出而同步，设置产品资源信号量apple； 妈妈、儿子因为桔子的放入与取出而同步，设置产品资源信号量orange。 这里不需要 mutex 信号量，原因在示例一中提到了。 1234567891011121314151617181920212223242526272829303132333435semaphore plate = 1; //是否允许向盘子放入水果semaphore apple = 0, orange = 0; //盘子中是否有苹果、桔子dad() &#123; while (true) &#123; prepare an apple; P(plate); //互斥向盘子放水果 put an apple on the plate; //将苹果放入盘中 V(apple); //允许取苹果 &#125;&#125;mom() &#123; while (true) &#123; prepare an orange; P(plate); //互斥向盘子放水果 put an orange on the plate; //将桔子放入盘中 V(orange); //允许取桔子 &#125;&#125;son() &#123; while (true) &#123; P(orange); //互斥取水果 get an orange from the plate; //从盘中取出桔子 V(plate); //允许向盘中放入水果 &#125;&#125;daughter() &#123; while (true) &#123; P(apple); //互斥取水果 get an apple from the plate; //从盘中取出苹果 V(plate); //允许向盘中放入水果 &#125;&#125; 示例三 桌子上有一只盘子，最多可以放入2个水果； 爸爸负责向盘中放苹果，妈妈负责向盘中放桔子，女儿负责取出并消费水果； 放入者和取出者不允许同时使用盘子（两个生产者可以同时访问盘子）； 当且仅当盘子中同时存在苹果和桔子时，女儿才从盘子中取出并消费水果。 请用信号量机制实现爸爸、妈妈和女儿之间的同步与互斥活动，并说明所定义信号量的含义。要求用伪代码描述。 分析： 由题意，盘子上最多只能出现一个苹果（要是出现两个苹果，那就没地方放桔子了）和一个桔子。因此，可以把盘子“分为”两个盘子，一个是用来放苹果的盘子，一个是用来放桔子的盘子。 这样做以后，又可以省下 mutex 信号量，其原因和示例二省下 mutex 的原因相同。 两个生产者和一个消费者被连接到大小为2的缓冲区上 盘子中是否可以放入苹果，设置空间资源信号量empty_apple； 盘子中是否可以取出苹果，设置产品资源信号量apple； 盘子中是否可以放入桔子，设置空间资源信号量empty_orange； 盘子中是否可以取出桔子，设置产品资源信号量orange。 123456789101112131415161718192021222324252627282930semaphore apple = 0, orange = 0; //盘子中是否有苹果、桔子semaphore empty_apple = 1, empty_orange = 1; //盘子是否可放入苹果、桔子dad()&#123; while (true) &#123; prepare an apple; P(empty_apple); //盘子中是否可放入苹果 put an apple on the plate; //将一个苹果放入盘子 V(apple); //允许女儿取苹果 &#125;&#125;mom()&#123; while (true) &#123; prepare an orange; P(empty_orange); //盘子中是否可放入桔子 put an orange on the plate; //将一个桔子放入盘子 V(orange); //允许女儿取桔子 &#125;&#125;daughter() &#123; while (true) &#123; P(apple); //盘子中是否有苹果 P(orange); //盘子中是否有桔子 get an apple and an orange from plate();//取水果 V(empty_apple); //盘子中可以放入苹果 V(empty_orange); //盘子中可以放入桔子 &#125;&#125; 示例四女儿负责画画，爸爸、妈妈负责欣赏。女儿在白板上画完一幅画后，请爸爸、妈妈均欣赏过一遍后，再创作新画，依次重复。请用信号量机制实现女儿、爸爸和妈妈之间的同步与互斥活动，并说明所定义信号量的含义。要求用伪代码描述。 另一种描述方法：一个生产者进程和两个消费者进程共享大小为1的缓冲，当且仅当缓冲为空时，生产者进程负责放入数据，当且仅当缓冲有数据时，消费者读数据，只有当两个消费者都读取数据后，生产者才能删除原有数据并继续生产下一个数据。 分析： 此题和示例三类似：示例三中，两个生产者的产品被一个消费者同时消费后才能继续生产；此题中，一个生产者的产品同时被两个消费者消费后才能继续生产。 解决的方案也类似，将这幅画“分为”给爸爸看的话和给妈妈看的画，分别设置空间资源量和产品资源信号量。 爸爸是否欣赏过，设置空间资源信号量empty_dad； 爸爸是否可以欣赏，设置产品资源信号量full_dad； 妈妈是否欣赏过，设置空间资源信号量empty_mom； 妈妈是否可以欣赏，设置产品资源信号量full_mom。 123456789101112131415161718192021222324252627282930semaphore empty_dad = 1, empty_mom = 1; //爸爸、妈妈是否已看过女画的新画semaphore full_dad = 0, full_mom = 0; //是否存在可供爸爸、妈妈看的新画daughter()&#123; while (true) &#123; P(empty_dad); //爸爸是否看过 P(empty_mom); //妈妈是否看过 draw a new picture on the whiteboard; //画一幅新画 V(full_dad); //爸爸可以看了 V(full_mom); //妈妈可以看了 &#125;&#125;dad() &#123; while (true) &#123; P(full_dad); //白板上是否存在没有看过的画 enjoy the picture on the whiteboard; //看画 V(empty_dad); //爸爸已看过新画 &#125;&#125;mom() &#123; while (true) &#123; P(full_mom); //白板上是否存在没有看过的画 enjoy the picture on the whiteboard; //看画 V(empty_mom); //妈妈已看过新画 &#125;&#125; 读者/写者问题问题描述： 多个进程访问一个共享数据区（可为文件、内存空间、寄存器）。其中若干读进程只能读数据，若干写进程只能写数据。 为数据库、文件、内存区及一组寄存器等的数据访问问题建立了一个通用模型。示例——联网售票系统、12306在该系统中，数据的查询和更新非常频繁，不可避免会出现多个进程试图查询或修改（读/写）其中某一条数据的情形。 问题的三种角色： 读进程 写进程 共享数据 问题的三个条件： 同时读 同时写 互斥读写 读者/写者问题和生产者/消费者问题的区别： 读/写者的数据可多次读，生产/消费者的数据消费完后就没有了 读者彼此不互斥，消费者彼此互斥 读者优先思想： 一旦有读者正在读数据，则允许随后的读者进入读数据 只有当全部读者退出，才允许写者进入写数据 导致写者饥饿 变量设置: wsem：互斥信号量，用于Writers间互斥、Writers和Readers互斥 readcount：统计正在同时读数据的Readers个数 x：对变量readcount互斥算术操作 12345678910111213141516171819202122int readcount=0；semaphore x = 1, wsem=1;void reader() &#123; while (1) &#123; P(x); readcount++; if (readcount==1) P(wsem); // 思考：这句 if 能不能放到下一行的 V(x) 之后？ V(x); READ; P(x); readcount--; if (readcount==0) V(wsem); V(x); &#125;&#125;void writer() &#123; while (1) &#123; P(wsem); WRITE; V(wsem); &#125;&#125; 算法核心：wsem 就像是一道防线，每次只会放一个人进去。所有的 Writers 会受其控制；但对于 Readers，仅当里面没有 Readers 的时候才会受其控制。 思考：不可以。对 readcount 的读写操作都需要拿到互斥量。反例就是，如果进程 A 写完 readcount 以后释放 x，准备读 readcount 时被 OS 中断，OS 转而调度 B 进程修改了 readcount，之后 A 进程读到的值就不是原先 A 写的值。 考虑如下进程序列(设序列中从右到左为进程先后到达顺序)，哪种情况下可能存在写者饥饿 R R R W W W R W R R W R R W R W W R W R R W 第五个存在写者饥饿，因为由于 W 前正在读操作，W 后的 R 可以插队到 W 之前。 公平优先这个就比之前的复杂了。 这个算法的核心思想是：连续的 Reader 可以同时读，但是 Reader 不允许插队到 Writer 之前（读者优先就是读者插队导致了写着饥饿）。 变量设置： wrsem：互斥信号量，确定Writer 、Reader请求顺序 wsem：互斥信号量，用于Writers间互斥，Reader互斥Writers readcount：统计同时读数据的Readers个数 x：对变量readcount互斥算术操作 123456789101112131415161718192021222324252627int readcount=0, semaphore x=l, wrsem=1, wsem=l;void reader() &#123; while (true) &#123; P(wrsem); P(x); readercount++; if (readercount == 1) P(wsem); V(x); V(wrsem); // 思考 1：这句能放在第五行 P(wrsem) 之后吗？ READ; P(x); readercount--; if (readercount == 0) V(wsem); V(x); &#125;&#125;void writer() &#123; while (true) &#123; P(wrsem); P(wsem); WRITE; V(wsem); V(wrsem); // 思考 2：这句不能放在 WRITE 之前吗？ &#125;&#125; 第一道防线：wrsem，W、R均要排队，保证公平 第二道防线：wsem（拦所有 W 和第一个 R） 系统保证，一、二道防线之间最多只有一个人 当某 R 进入第一道防线后，若第二道防线内没人或只有 R，则可以进入，否则需 P(wsem) 当某 W 进入第一道防线后，仅若第二道防线内没人，才可以进入，否则需 P(wsem) 当某 R 进入第二道防线后，会把第一道防线打开 当某 W 进入第二道防线后，不会打开第一道防线；只有当 W 走的时候才会打开两道防线 思考 1：不可以。否则如果这个 R 后面是一个 W，W 可能（由于系统调度的原因）抢先完成 P(wrsem) P(wsem) 并开始写，之后 R 开始执行 if (readercount == 1) P(wsem);，最后就是结果这个 W 比 R 先做任务。 思考 2：从原理上说是可以的。原算法中，某 W 进入第二道防线后，不会打开第一道防线；修改以后，W 进入第二道防线以后就会打开第一道防线。但考虑到接下来进入第一道防线的 W/R 仍然需要等待第二道防线，和修改之前没有区别，修改后还会导致这个 W/R 被二次阻塞，所以从效率上说，不推荐修改。 考虑从右到左先后到达顺序的进程序列：R, R, W, R, R…… 写者优先这个似乎比上面那个还复杂。 这个算法的思想是，当 Writers 正在写时，其他 W 可以插队到 R 之前排队。 变量设置： wsem：互斥信号量，用于Writers间互斥，Reader互斥Writers readcount：统计同时读数据的Readers个数 x：对变量readcount互斥算术操作 rsem：互斥信号量，当至少有一个写者申请写数据时互斥新的读者进入读数据。 第一个写者受rsem影响，一旦有第一个写者，后续写者不受rsem其影响。但是读者需要在rsem上排队。 writecount：用于控制rsem信号量 y：对变量writecount互斥算术操作 12345678910111213141516171819202122232425262728293031323334int readcount = 0, writecount = 0;semaphore x=1, y=1, wsem=1, rsem=1;void reader( ) &#123; while (1) &#123; P(rsem); P(x); readcount++; if (readcount==1) P(wsem); V(x); V(rsem)； READ; P(x); readcount--; if (readcount==0) V(wsem); V(x); &#125; &#125;void writer( ) &#123; while (1) &#123; P(y); writecount++; if (writecount==1) P(rsem); V(y); P(wsem); WRITE; V(wsem); P(y); writecount--; if (writecount==0) V(rsem); V(y); &#125;&#125; 第一道防线：rsem，拦所有 R 和第一个 W 第二道防线：wsem，拦所有 W 和第一个 R 当某 W 进入第一道防线，后面的 W 均可进入第一防线，所有 R 均被拦住 当某 R 进入第一道防线，如果是进入的第一个 R 则需要拿到 wsem 不让后面的 W 写；随后放开第一道防线 rsem，让后面的 W/R 进入 如果进入的是 R，则可以进入第二道防线，一起读，顺便释放 rsem 再放一个人进来； 如果进入的是 W，则之后的 W 均不需要等待第一道防线；对于第二道防线，需要等待最后一个 R wsem 才能进入。 设每个序列最右为队首： R R W R R R W W R R W W R R R R 对于第四个，即使是写者优先，W 仍然需要等待四个 R 读完才能写。 写者优先改进于是，又提出了写者优先改进，其在写者优先的基础上只加了第六行 P(z); 和第十三行 V(z);。 123456789101112131415161718192021222324252627282930313233343536int readcount = 0, writecount = 0;semaphore x=1, y=1, wsem=1, rsem=1;void reader( ) &#123; while (1) &#123; P(z); P(rsem); P(x); readcount++; if (readcount==1) P(wsem); V(x); V(rsem)； V(z); READ; P(x); readcount--; if (readcount==0) V(wsem); V(x); &#125; &#125;void writer( ) &#123; while (1) &#123; P(y); writecount++; if (writecount==1) P(rsem); V(y); P(wsem); WRITE; V(wsem); P(y); writecount--; if (writecount==0) V(rsem); V(y); &#125;&#125; z 只对 reader 起作用，使得只能有一个 R 在 rsem 上排队（而这个 R 手上拿了 z），其余 R 均需在 z 上排队；这样，在 rsem 上排队的 W 前面最多只会出现一个 R，而避免了在 rsem 上形成长队列（指 R 的长队列）。 示例一有一座东西方向的独木桥，每次只能有一人通过，且不允许行人在桥上停留。东、西两端各有若干行人在等待过桥。请用P、V操作来实现东西两端行人过桥问题。 这个例子只允许一个人在桥上，即所有人都是写者。就是一个最基础的人人之间均互斥。 12345678910111213141516171819semaphore s = 1; //互斥信号量void east_west( )&#123; while (true) &#123; P(s); //互斥其他人过桥 //行人从东向西过桥 V(s); //允许其他人过桥 &#125;&#125;void west_east( )&#123; while (true) &#123; P(s); //互斥其他人过桥 //行人从西向东过桥 V(s); //允许其他人过桥 &#125;&#125; 示例二有一座东西方向的独木桥，同一方向的行人可连续过桥。当某一方向有行人过桥时，另一方向行人必须等待。桥上没有行人过桥时，任何一端的行人均可上桥。请用 PV 操作来实现东西两端人过桥问题。 同方向行人可连续过桥，可以把这群人看做读者。那么，哪个方向是读者呢？谁先上谁就是读者，妙啊！ x：互斥信号量，用于读者互斥写者 countA、countB：统计读者数目（同时在桥上的行人数目） mutexA、mutexB：对变量countA、countB互斥算术操作 123456789101112131415161718192021222324252627282930int countA=0, countB=0；semaphore x=1, mutexA=1, mutexB=1;void east_west() &#123; while (1) &#123; P(mutexA); countA++; if (countA==1) P(x); V(mutexA); walk across the bridge from east to west; P(mutexA); countA--; if (countA==0) V(x); V(mutexA); &#125;&#125;void west_east() &#123; while (1) &#123; P(mutexB); countB++; if (countB==1) P(x); V(mutexB); walk across the bridge from west to east; P(mutexB); countB--; if (countB==0) V(x); V(mutexB); &#125;&#125; 只有当一个人是这个方向上第一个上桥的人，他才需要等待 x，就能保证第一个上桥的那个方向的其他人也能上桥，而反方向的人就得等这些人走完桥。 示例三有一座东西方向的独木桥，同一方向的行人可连续过桥。当某一方向有行人过桥时，另一方向行人必须等待。桥上没有行人过桥时，任何一端的行人均可上桥。出于安全考虑，独木桥的最大承重为4人，即同时位于桥上的行人数目不能超过4。请用 PV 操作来实现东西两端人过桥问题。 这个简单，在示例四中加一个初始化为 4 的信号量 count 就行。 12345678910111213141516171819202122232425262728293031323334int countA=0, countB=0；semaphore x=1, mutexA=1, mutexB=1, count=4;void east_west() &#123; while (1) &#123; P(mutexA); countA++; if (countA==1) P(x); V(mutexA); P(count); walk across the bridge from east to west; V(count); P(mutexA); countA--; if (countA==0) V(x); V(mutexA); &#125;&#125;void west_east() &#123; while (1) &#123; P(mutexB); countB++; if (countB==1) P(x); V(mutexB); P(count); walk across the bridge from west to east; V(count); P(mutexB); countB--; if (countB==0) V(x); V(mutexB); &#125;&#125; 理发师问题理发店有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客，则理发师睡觉。当一个顾客到来时，他必须叫醒理发师，如果理发师正在理发时又有顾客到来，则如果有空椅子可坐，他就坐下来等。如果没有空椅子，他就离开。 理发师和顾客工作流程 就是注意各种状态的信号量，按照流程图话就完事了。 1234567891011121314151617181920212223242526272829303132333435363738394041int n_customer= 0; //店里的顾客,含正在理发的人数semaphore mutex = 1; //waiting的互斥信号量semaphore bchair = 1; //理发椅的个数semaphore wchair = 5; //空椅子的个数semaphore ready = 0; //是否有顾客准备好semaphore finish = 0; //理发师是否完成理发main() &#123; cobegin baber(); customer(); coend &#125;void baber() //理发师进程&#123; while (true) &#123; P(ready); //有顾客准备好了 // 理发 V(finish); //允许其他顾客理发 &#125;&#125;void customer()&#123; P(mutex); //互斥waiting变量的操作 if (n_customer &lt; 6) //店里顾客数没达上限 &#123; n_customer++; //店里顾客数增1 V(mutex); //允许waiting变量的操作 P(wchair); //找一个空椅子坐下 P(bchair); //再找理发椅坐下 V(wchair); //释放一个空椅子 V(ready); //该顾客准备好了 P(finish); //等待理发师完成理发 V(bchair); //离开理发椅 P(mutex); //互斥waiting变量的操作 n_customer--; //等待顾客数减1 V(mutex); //允许waiting变量的操作 &#125; else &#123; // 离开 V(mutex); &#125;&#125; 理发师睡觉问题的类似问题： 某银行提供一个服务窗口和10个供顾客等待的座位。顾客到达银行时，若有空座位，则到取号机上领取一个号，等待叫号。取号机每次仅允许一位顾客使用。当营业员空闲时，通过叫号选取一位顾客，并为其服务。顾客和营业员的活动过程描述如下： 1234cobegin&#123; process 顾客i&#123;从取号机上获取一个号码; 等待叫号; 获取服务; &#125; process 营业员&#123;while (true)&#123;叫号; 为顾客服务; &#125;&#125;&#125; 请添加必要的信号量和 PV 操作，实现上述过程中的互斥与同步。要求写出完成的过程，说明信号量的含义并赋初值。 123456789101112131415161718192021222324semaphore mutex = 1; //互斥使用取号机的信号量semaphore empty = 10; //空座位的数量信号量semaphore full = 0; //已占座位的数量信号量semaphore service = 0; //等待叫号信号量process 顾客i&#123; P(empty); P(mutex); //从取号机获得一个号； V(mutex); V(full); P(service); //等待叫号&#125;process 营业员&#123; while (true) &#123; P(full); V(empty); V(service); //叫号 //为顾客服务; &#125;&#125; 都比较简单，较之前的生产者/消费者和读者/写者问题简单了很多。 管程信号量、管程 都是提供互斥的方案。 管程的引入信号量可以高效的实现进程间互斥与同步，但是信号量的 PV 操作可能分散在整个程序中，使用难度高。 管程 monitor 是一个程序设计语言结构，采用了集中式的进程同步方法，提供了与信号量同样的功能，但更易于控制。 很多程序设计语言都支持管程，如 Pascal、Java 等。 管程的概念一个管程定义了一个共享数据结构和能为并发进程所执行（在该数据结构上）的一组操作/过程，这组操作能同步进程、改变管程中的数据。 共享数据结构是对系统中共享资源的抽象。对该共享数据结构的操作则定义为一组过程，通过调用这些过程实现对共享资源的申请、释放和其它操作 管程 = 局部数据 + 过程 + 初始化序列 管程的特点 局部数据变量只能被管程的过程访问，任何外部过程都不能访问 一个进程通过调用管程的一个过程进入管程 在任何时候，只能有一个进程在管程中执行（互斥），调用管程的任何其它进程都被阻塞，以等待管程可用。 若由于某种原因，一个正在管程中执行的进程必须阻塞，该如何处理？——释放管程，供其它进程使用 如果管程内的数据结构代表了共享资源,则通过管程提供了对资源的互斥访问机制。 用管程实现进程同步管程通过使用条件变量提供对进程同步的支持。条件变量包含在管程中，只能在管程中访问。 操作条件变量的两个函数： cwait(c)：调用进程的执行在条件 c 上阻塞，管程可供其它进程使用。 csignal(c)：恢复在条件 c 上阻塞的一个进程，若不存在阻塞进程，则什么都不做。 这里的 cwait 和 csignal 作用于条件变量,与作用于信号量的 wait 和 signal 不同。 所以条件变量是什么呢？继续往后看。 管程的结构 管程的结构 生产者/消费者问题的管程解决方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* program producerconsumer */monitor boundedbuffer;char buffer [N]; /* space for N items */int nextin, nextout; /* buffer pointers */int count; /* number of items in buffer */cond notfull, notempty; /* condition variables for synchronization */void append (char X)&#123; if (count == N) cwait(notfull); /* buffer is full; avoid overflow */ buffer[nextin] = x; nextin = (nextin + 1) % N; count++; /* one more item in buffer */ csignal(notempty); /* resume any waiting consumer */&#125;void take (char x)&#123; if (count == 0) cwait(notempty); /* buffer is empty; avoid underflow */ x = buffer[nextout]; nextout = (nextout + 1) % N; count--; /* one fewer item in buffer */ csignal(notfull); /* resume any waiting producer */&#125;/* monitor body */&#123; nextin = 0; nextout = 0; count = 0; /* buffer initially empty */&#125;void producer()&#123; char x; while (true) &#123; produce(x); append(x); &#125;&#125;void consumer&#123; char x; while (true) &#123; take(x); consume(x); &#125;&#125;void main&#123; parbegin (producer, consumer);&#125; 看完以后还没有弄懂 hhhh 所以就照搬教材上的话了： 生产者可以通过管程中的过程 append 向缓冲区中增加字符，它不能直接访问 buffer。该过程首先检查条件 notfull，以确定缓冲区是否还有可用空间。如果没有，执行管程的进程在这个条件上被阻塞。其他的某个进程(生产者或消费者)现在可以进入管程。此后，当缓冲区不再满时，被阻塞进程可以从队列中移出，重新激活并恢复处理。向缓冲区中放置一个字符后，该进程发送 notempty 条件信号。对消费者函数也可以进行类似的描述。这个例子表明，与信号量相比较，管程担负的责任不同。对于管程，它构造了自己的互斥机制：生产者和消费者不可能同时访问缓冲区；但是，程序员必须把适当的cwait和csignal原语放在管程中，以防止进程向一个满缓冲区中存放数据项，或从一个空缓冲区中取数据项。而在使用信号量的情况下，执行互斥和同步都是程序员负责。注意在图5.16中，进程执行csignal函数后立即退出管程，若在过程最后未发生csignal，建议发送该信号的进程被阻塞，从而使管程可用，并放入队列中直到管程空闲。此时，一种可能是把阻塞进程放到入口队列中，这样它就必须与其他还未进入管程的进程竞争。但是，由于在 csignal 函数上阻塞的进程已在管程中执行了部分任务，因此使它们优先于新进入的进程是很有意义的，这可通过建立一条独立的紧急队列来实现，如图5.15 所示。并发 Pascal 是使用管程的一种语言，它要求 csignal 只能作为管程过程中执行的最后一个操作出现。若没有进程在条件 x 上等待，csignal(x)的执行将不会产生任何效果。 而对于信号量，在管程的同步函数中可能会产生错误。例如，若省略 boundedbuffer 管程中的任何一个 csignal 函数，则进入相应条件队列的进程将被永久阻塞。管程优于信号量之处在于，所有的同步机制都被限制在管程内部，因此不但易于验证同步的正确性，而且易于检测出错误。此外，若一个管程被正确地编写，则所有进程对受保护资源的访问都是正确的；而对于信号量，只有当所有访问资源的进程都被正确地编写时，资源访问才是正确的。 消息传递进程交互时，需要满足两个基本要求： 同步：为实现互斥，进程间需要同步 通信：为实现合作，进程间需要交换信息 消息传递提供了上述两方面的功能，并可工作在分布式系统、共享内存的多处理器和单处理器系统中。 消息传递的通信原语消息传递有两条通信原语： Send(destination,message)：进程以消息的形式给指定的进程（目标）发送信息 Receive(source,message)：进程通过接收原语receive接收消息，接收原语中指明源进程和消息 消息格式 消息格式 有点像计算机网络中的报文。 消息传递问题中的同步只有发送进程发送消息，接收进程才能收到消息。 发生进程调用发送原语时，有两种可能：发送进程发送消息后，要么阻塞直到这个消息被目标进程收到；要么不阻塞。 当一个进程调用接收原语时，也两种可能：若已经有消息到达，则接收者接收消息并继续执行；若没有消息到达，接收者要么阻塞等待，要么放弃接收，继续执行。 基于发送者/接收者的两种策略的组合，就产生了消息传递的三种同步方式，如下。 消息传递的三种同步方式阻塞发送，阻塞接收： 发送者和接受者都阻塞，直到完成消息投递 有时被称为会合 rendezvous 考虑了进程间的紧密同步 不阻塞发送，阻塞接收： 发送者不阻塞，但是接收者阻塞直到请求的消息到达 最有效的一种组合 允许发送者可以尽快的向目的发送一条或多条消息 例如，如一个服务进程给其他进程提供服务或资源 不阻塞发送，不阻塞接收： 不要求任何一方等待 通信原语确定来源、目标的方式直接寻址 Send 原语包含目标进程的标识号 Receive 原语有两种处理方式：显式的指明源进程，对于处理并发进程的合作有效；或不可能指定源进程，如打印机服务进程，采用隐式寻址，接收到消息时将源地址保存下来。 间接寻址 消息被发送到一个共享的数据结构，该结构由暂存消息的队列（被称为信箱）构成 发送进程往信箱发送消息，接收进程从信箱取走消息 这种方法提供了对消息使用的灵活性。 间接寻址发送者和接收者之间的关系 使用消息传递实现互斥 多个并发执行的发送进程和接收进程共享一个邮箱 box，且 box 的初始状态为仅包含一条“空消息”（进入临界区的令牌）； 采用“不阻塞发送，阻塞接收”方式传递消息； 若邮箱中存在一条消息，则允许一个进程进入临界区。 若邮箱为空，则表明有一个进程位于临界区，其它试图进入临界区的进程必须阻塞。 只要保证邮箱中最多只有一条消息，就能保证只允许一个进程进入临界区，从而实现进程互斥使用临界资源。 有点像信号量的 PV 操作。 或者说，消息传递可以实现信号量。 1234567891011121314151617181920/* program mutualexclusion */const int n = /* 进程数 */;void main()&#123; create_mailbox(box); /* 创建邮箱 */ send(box, null); /* 初始化，向邮箱发送一条空消息 */ parbegin(P(1), P(2), …, P(n));&#125;void P(int i)&#123; message msg; while (true) &#123; receive(box, msg); /* 从邮箱接收一条消息 */ &lt;临界区&gt;; send(box, msg); /* 将消息发回到邮箱 */ &lt;其余部分&gt; &#125;&#125; 使用消息传递实现生产者/消费者问题既然消息传递可以实现信号量，那么就可以按照信号量的方式实现生产者/消费者问题。 使用两个邮箱 mayconsume 和 mayproduce，大小均为 capacity。 Mayproduce Mayconsume 该邮箱起初填满空消息（即允许生产的令牌） 生产者产生的数据作为消息发送到该信箱（即允许消费的令牌） 只要该邮箱有消息，生产者就可生产 只要该邮箱有数据消息，消费者就可消费 每次生产前取一条空消息，之后生产数据，并将数据作为消息发至mayconsume邮箱 每次消费前，取一条消息，消费后，向mayproduce发送一条空消息 消费者的每次消费使得该邮箱中的空消息数增加 生产者的每次生产使得该邮箱的消息数增加 类似于空间资源信号量 类似于产品资源信号量 123456789101112131415161718192021222324252627const int capacity = /* 缓冲区容量 */;void main() &#123; create_mailbox(mayproduce); create_mailbox(mayconsume); for (int i = 1; i &lt;= capacity; i++) send(mayproduce, null); //初始化信箱 parbegin(producer, consumer);&#125;void producer() &#123; message pmsg; while (true) &#123; receive(mayproduce, pmsg); pmsg = produce(); send(mayconsume, pmsg); &#125;&#125;void consumer &#123; message cmsg; while (true) &#123; receive(mayconsume, cmsg); consume(cmsg); send(mayproduce, null); &#125;&#125; 和前面的代码一对比才发现，这里并没有实现互斥信号量 n。emmm 可能是在 produce() 函数里手动或自动实现了互斥吧，或者这里并不要求生产者彼此互斥。 二(4) 进程管理：进程死锁 生活中的死锁现象 死锁的原理下面两个进程并行可能导致死锁： 12345678void _P() void _Q()&#123; &#123; P(A); P(B); P(B); P(A); //... //... V(B); V(A); V(A); V(B);&#125; &#125; 下图为描述该过程的示意图： 死锁的定义死锁定义：一组相互竞争系统资源或进行通信的进程间的永久阻塞。 当一组进程中的每个进程都在等待某事件，而只有同组进程中阻塞的其他进程能够促发该事件时，死锁发生 死锁是永久性的，且无有效的解决方案 资源的分类 一次仅供一个进程安全使用且不因使用而耗尽的资源，如处理器、I/O通道、内存和外存、设备，以及诸如文件、数据库和信号量之类的数据结构之类的 可消耗资源是指可被创建（生产）和销毁（消耗）的资源，如中断、信号、消息和I/O缓冲中信息 死锁的示例 两个进程竞争可重用资源示例 竞争可重用资源可能引起死锁 例中，P1和P2请求主存，假设可分配的空间为200KB。P1和P2执行到第二条语句时死锁发生。 竞争可消耗资源可能引起死锁 例中，当Receive阻塞时死锁发生。 资源分配图 用资源分配图表示死锁。其中圆形为进程，方形为资源，方形中的黑点数为资源数。 循环等待 存在进程和资源的环（循环等待），导致死锁。 死锁的条件死锁的必要条件： 互斥：一次只有一个进程可以使用一个资源 占用且等待：当进程等待其他资源时，继续占有已经分配的资源 不可抢占：不能强行抢占进程已经占有的资源 死锁的充分条件（其他教材上说这是第四个必要条件）： 循环等待：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源 死锁的解决方法针对这些条件，解决办法有： 死锁预防：禁止四个条件的任意一个条件发生 死锁避免：允许前三个条件，进行动态检查 死锁检测与解除：不限制资源访问或约束进程行为，而是检测死锁的存在并尝试解除 死锁的预防我们分析死锁的四个条件，并尝试禁止任意一个发生： 互斥：不能禁止（OS：亲，必须互斥的） 占有且等待：要求进程一次性请求所有资源，并阻塞这个进程直到所有资源请求能够满足 低效：进程可能会阻塞很长时间（实际上，只要有一部分资源，它就能够执行）；分配给进程的另一部分资源可能很长时间内不会被使用 可能事先不知进程所需的全部资源 不可抢占：占有资源的进程申请其他资源时若被拒绝，则释放最初的资源；或操作系统要求另一个进程释放资源 只有在资源状态容易保存和恢复情况下，这种方法才实用 循环等待：定义一个请求资源的顺序 系统把所有资源按类型进行线性排队，如 $R_i, R_j, R_k (i&lt;j&lt;k)$ 所有进程对资源的请求必须严格按资源序号递增的顺序提出（即，如果同时需要 $R_1, R_3$，必须先申请 $R_1$） 低效，原因类似于“占有且等待”（进程可能有了 $R_3$ 能继续执行，但它必须先申请 $R_1$ 才能申请 $R_3$） 死锁的避免死锁避免允许三个必要条件，并进行动态检查： 检查进程的资源申请 若分配后系统可能发生死锁，则不予分配（阻塞） 需要预知资源的请求 有两种拒绝方法： 资源分配拒绝：不允许该资源分配 进程启动拒绝：不启动该进程 资源分配拒绝——银行家算法 银行家算法（类似于银行决定是否允许贷款的原理），由 Dijkstra 提出 思想：当用户申请一组资源时，系统必须做出判断：如果把这些资源分出去，系统是否还处于安全状态。若是，就可以分配这些资源；否则，暂时不分配，阻塞进程。 系统状态：当前给进程分配资源的情况 安全状态指至少有一个资源分配序列（Px, Py, …, Pz，安全序列）不会导致死锁，所有进程Px, Py, …, Pz 能够运行结束 例矩阵的定义： Claim matrix $C$：每个进程提前声明需要的资源量。进程执行中申请的资源量不得超过 C。 Allocation matrix $A$：已分配给每个进程的资源量。 $C-A$：每个进程还可以申请的资源量。 Resource vector $R$：OS 总的资源量。 Available vector $V$：OS 目前的剩余资源量。也等于 $R$ 减去 $A$ 的每一行。 图1 先执行 P2。 图2 这一步以后 P1、P3、P4 均可被执行。这里选择执行 P1。 图3 这一步选择执行 P3。当然 P4 也是可以的。 周4 最后执行 P4。 由上可得，该例的一个安全序列为：P2、P1、P3、P4。 需要注意的是，这个过程是系统预先模拟出来的，而不是真实分配以后得到的。只有模拟出了安全状态，OS 才会真正进行分配。 例二 不安全状态示例 如图，在 (a) 的状态下，P1 请求 $(1, 0, 1)$。如果系统分配了，系统将进入不安全状态。 思考 安全序列是否唯一？否 安全状态是否一定没有死锁发生？ 若系统处于安全状态，且按照某个安全序列分配资源，则一定不会出现死锁。并非所有不安全状态都是死锁状态（比如前例中 P1 释放 1 个 R1 和 R3，后来再次需要这些资源，系统变成安全状态）但是这句话的逻辑似乎有点奇怪当系统进入不安全状态以后，便可能进入死锁状态 避免死锁的实质在于：如何避免系统进入不安全状态 资源分配算法总结算法的步骤如下： 判断需求的合理性（若 $allocated$ + $request$ &gt; $claim$ 则不合理） 尝试分配，定义新状态 判断新状态的安全性（银行家算法） 若安全则分配；若不安全则阻塞进程并还原状态 资源分配算法 伪代码 银行家算法 伪代码 死锁避免总结死锁避免的优点： 无须进行（死锁预防中的）抢占和回滚进程 比起死锁预防，限制少 死锁避免的使用限制： 必须事先声明每个进程请求的最大资源 进程必须是独立的，它们执行顺序没有同步的要求 分配资源的数量必须是固定的 占有资源时，进程不能退出（进程退出会导致计算结果失效） 死锁检测与解除死锁预防策略很保守：强加约束限制访问资源。而死锁检测则相反：只要有可能，就给进程分配其所请求的资源。 死锁检测对死锁的检测可以频繁的发生在每次资源请求时；也可以少检测，如定时检测，或系统资源利用率下降时检测，具体取决于死锁发生的可能性。 优点：可尽早检测死锁；算法相对简单。缺点：频繁检测会消耗处理器时间。 死锁检测算法死锁检测算法在银行家算法的变量基础上增加了： Request matrix $Q$：$Q_{ij}$表示进程 $i$ 请求 $j$ 类资源的数量 算法步骤：为未死锁的应用打标记。（约定资源种数用 $m$ 表示） 标记在 $Allocation$ 矩阵中一行全为零的进程； 初始化一个临时向量 $W$，令 $W$ 等于 $Available$ 向量； 查找是否存在进程 $i$：当前未被标记，且满足 $Q$ 的第 $i$ 行小于等于 $W$（即对所有的 $1 \\leq k \\leq m$，$Q_{ik} \\leq W_k$。若找不到这样的行，终止算法； 若找到这样的行，标记进程 $i$，并把 $Allcation$ 矩阵中的相应行加到 $W$ 中，即对所有 $1 \\leq k \\leq m$, 令 $W_k = W_k+A_{ik}$。然后返回 3。 当且仅当最终有未标记进程时，才存在死锁，未标记的进程都是死锁的。 看起来很像是银行家算法！ 银行家算法在 $C-A$ 矩阵中寻找是否小于当前资源量 $currrent\\_available$ 的行向量，如果有则将进程加入安全序列，并使 $currrent\\_available$ 增加该进程的 $Allocation$ 量。 死锁检测在 $Q$ 矩阵中寻找是否小于当前资源量 $W$ 的行向量，如果有则标记进程，并使 $W$ 增加该进程的 $Allocation$ 量。 区别在于，银行家算法是按进程可能申请的最多资源进行计算，所以能避免死锁发生，对应的资源分配策略会很严格；死锁检测算法是对进程正在申请的资源进行计算，所以检测的是死锁，对应的资源分配策略会比较松。 例题 先标记还未分配的 P4； 令 $W = A = (0,0,0,0,1)$； 注意到 Q 的第三列小于 $W$，标记 P3，并更新 $W=(0,0,0,1,1)$； P1、P2 无法被标记，死锁。 通过化简资源分配图进行死锁检测 在资源分配图中，找出其全部请求都能满足的进程节点 $P_i$，消去 $P_i$ 所有的请求边和分配边，使之成为孤立的结点。 重复步骤 1，直至无法化简为止。 资源分配图的化简示例 可完全简化图：能消去图中所有的边，使所有的进程结点都成为孤立结点的资源分配图（如上图、右下图）。 当资源分配图是不可完全化简时，存在死锁（如左下图）。 左图出现死锁 右图未死锁 死锁的解除检测到死锁后，需要按照某种可能的策略来解除。给出以下三个方法，以及三个方法下的不同策略。 撤消进程：撤消所有死锁进程，或连续撤消死锁进程直到不再存在死锁 回退：把进程回退到前面定义的某些检查点，并重新启动所有进程 抢占：连续抢占资源直到不再存在死锁 取消哪些进程、抢占哪些进程的资源呢？——选择原则：目前为止消耗处理器时间少，或输出少，或分配资源少，或剩余时间长，或优先级最低的进程 死锁解决办法总结 死锁解决办法总结（英文） 死锁解决办法总结（中文） 哲学家就餐问题1965年，Dijkstra出了一道同步考试题：假设有五台计算机都试图访问五份共享的磁带驱动器。后来，这个问题被Hoare重新表述为哲学家就餐问题。这个问题可以用来解释死锁和资源耗尽。 Dijkstra 怎么这么强（捶桌）.jpg 5 个哲学家围坐一张餐桌 5 只餐叉间隔摆放 思考或进餐 进餐时必须同时拿到两边的餐叉 思考时将餐叉放回原处 两个哲学家不能同时使用同一把叉子 避免死锁和饥饿 哲学家就餐问题图 方案一 先左后右，可能死锁123456789101112131415161718semaphore fork[5] = &#123;1, 1, 1, 1, 1&#125;;void main()&#123; cobegin &#123;philosopher(0); philosopher(1); philosopher(2); philosopher(3); philosopher(4);&#125;coend;&#125;void philosopher(int i)&#123; while(true) &#123; think; //思考 wait(fork[i]); //拿起左边的叉子 wait(fork[(i+1)%5]); //拿起右边的叉子 eat(); signal(fork[i]); //放回左边的叉子 signal(fork[(i+1)%5]); //放回右边的叉子 &#125;&#125; 显然，可能导致死锁。 方案二 先左后右，失败后随机等待一段时间，可能活锁123456789101112131415161718semaphore fork[5] = &#123;1, 1, 1, 1, 1&#125;;void main()&#123; cobegin &#123;philosopher(0); philosopher(1); philosopher(2); philosopher(3); philosopher(4);&#125;coend;&#125;void philosopher(int i)&#123; while(true) &#123; think; //思考 wait(fork[i]); //拿起左边的叉子 timeout(wait(fork[(i+1)%5], [0, T]) //若右边的叉子被占用，则放下左边叉，等待一段随机时间后再拿 eat(); signal(fork[i]); //放回左边的叉子 signal(fork[(i+1)%5]); //放回右边的叉子 &#125;&#125; 方案三 资源分级就是死锁预防中打破循环等待的方法。 为资源（这里是餐叉）分配一个偏序（partial order）或者分级（hierarchy）的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。 资源分级方案一 先低后高 为餐叉编号 就餐前，先取用编号较低的餐叉，再取用编号较高的餐叉 就餐毕，先放下编号较高的餐叉，再放下编号较低的餐叉 123456789101112131415161718192021semaphore fork[5] = &#123;1, 1, 1, 1, 1&#125;;void main()&#123; cobegin &#123;philosopher(0); philosopher(1); philosopher(2); philosopher(3); philosopher(4);&#125;coend;&#125;void philosopher(int i)&#123; while(true) &#123; think(); //思考 if (i != 4) wait(fork[i]); wait(fork[(i+1)%5]); //先左后右 else wait(fork[(i+1)%5]); wait(fork[i]); //先右后左 eat(); if (i != 4) signal(fork[(i+1)%5]); signal(fork[i]); //先右后左 else signal(fork[i]); signal(fork[(i+1)%5]); //先左后右 &#125;&#125; 资源分级方案二 奇先左偶先右 为哲学家编号 奇数号的哲学家必须首先拿左边的餐叉 偶数号的哲学家必须首先拿右边的餐叉 12345678910111213141516171819semaphore fork[5] = &#123;1, 1, 1, 1, 1&#125;;void main()&#123; cobegin &#123;philosopher(0); philosopher(1); philosopher(2); philosopher(3); philosopher(4);&#125;coend;&#125;void philosopher(int i)&#123; while(true) &#123; think(); //思考 if (i % 2 != 0) wait(fork[i]); wait(fork[(i+1)%5]); //先左后右 else wait(fork[(i+1)%5]); wait(fork[i]); eat(); signal(fork[(i+1)%5]); //先右后左 signal(fork[i]); &#125;&#125; 方案四 服务生方法 教授需要经过服务生允许以后才能吃饭 只允许有四个人同时进餐 12345678910111213141516171819semaphore fork[5] = &#123;1, 1, 1, 1, 1&#125;, room = 4;void main()&#123; cobegin &#123;philosopher(0); philosopher(1); philosopher(2); philosopher(3); philosopher(4);&#125;coend;&#125;void philosopher(int i)&#123; while(true) &#123; think; //思考 wait(room); //占据就餐位置 wait(fork[i]); //拿起左边的叉子 wait(fork[(i+1)%5]); //拿起右边的叉子 eat(); signal(fork[i]); //放回左边的叉子 signal(fork[(i+1)%5]); //放回右边的叉子 signal(room); //释放就餐位置 &#125;&#125; 引申：And 型信号量集（不做要求）哲学家就餐问题的引申：And型信号量集在一个原语中申请需要的多个临界资源，要么全部分，要么一个都不分配。AND型信号量集P原语为Swait(Simultaneous Wait)，V原语为Ssignal(Simultaneous Signal)。Swait(S1, S2, …, Sn)Ssignal(S1, S2, …, Sn)思考：采用and型信号量解决哲学家就餐问题 管程解决方案管程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748monitor dining_controller;cond ForkReady[5];bool fork[5] = &#123;1,1,1,1,1&#125;;void get_forks(int pid)&#123; int left = pid; int right = (pid + 1) % 5; // 获取左边的叉子 if (!fork[left]) cwait(ForkReady[left]); fork[left] = false; //获取右边的叉子 if(!fork[right]) cwait(ForkReady[right]); fork[right] = false;&#125;void release_forks(int pid)&#123; int left = pid; int right = (pid + 1) % 5; // 释放左边的叉子 if (!empty(ForkReady[left])) //如果没有人在等待这个叉子 fork[left] = true; else csignal(ForkReady[left]) // 让被阻塞在这里的进程继续 // 释放右边的叉子 if (!empty(ForkReady[right])) //如果没有人在等待这个叉子 fork[right] = true; else csignal(ForkReady[right]) // 让被阻塞在这里的进程继续&#125;void philosopher(int k)&#123; while (true) &#123; think(); get_forks(k); eat(); release_forks(k); &#125;&#125; 为什么采用管程方法不会发生死锁？因为在管程中被阻塞的进程会释放已有的资源，即不会出现抓着左叉子等右叉子的现象。 三(1) 内存管理：基本内存管理 计算机存储体系 程序的加载和链接高级语言的源代码转化为进程的 3 个基本步骤： 编译：用户源代码 -&gt; 经编译程序 (Compiler) -&gt; 若干目标模块 链接：一组目标模块 + 它们需要的库函数 -&gt; 经链接程序 (Linker) -&gt; 完整的加载模块 加载（装入）：加载模块 -&gt; 由加载程序 (Loader) -&gt; 装入内存 简单的认为： 编译负责：模块内变量名 -&gt; 逻辑地址 链接负责：模块间变量名 -&gt; 逻辑地址 加载负责：程序逻辑地址 -&gt; 物理地址（装入内存） 链接和加载场景 为表达清晰起见，首先介绍只涉及一个程序模块时的加载任务，因为这时不需要链接。介绍完加载后再聊多个模块的链接任务。 加载的任务 将可加载模块装入内存 地址重定位：将执行文件中的逻辑地址转化为内存物理地址的过程 加载方式分类（地址映射建立方式） 绝对加载方式：编译使用绝对地址 可重定位加载（静态重定位）方式：编译使用相对地址，加载时确定绝对地址 运行时加载（动态重定位）方式：执行时确定绝对地址 绝对加载方式 程序中的逻辑地址与实际内存地址完全相同，无需修改 在编译时就确定程序将驻留在内存中的具体位置 编译程序产生绝对地址的目标代码 为了便于程序的修改,对程序采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址 绝对加载方式示例 优点： 实现简单 缺点： 程序每次必须装入同一内存区 程序员必须事先了解内存的使用情况，根据内存情况确定程序的逻辑地址 不适于多道程序系统（多个程序的绝对内存地址可能冲突） 可重定位加载方式（静态重定位） 编译时采用相对地址，即编译器假设是加载到从零开始的内存位置 加载程序根据加载的位置将逻辑地址转换为物理地址（重定位） 静态重定位技术：地址映射在程序加载时进行，以后不再更改程序地址 静态重定位加载方式示例 优点：易实现，无需硬件支持 缺点：程序重定位后不能移动，不能重新分配内存，不利于内存的有效利用 运行时加载（动态重定位）方式 程序的地址转换不是在加载时进行，而是在程序运行到相应代码时动态进行 需要硬件支持：重定位寄存器，用于保存程序在内存中的起始地址 通过重定位寄存器内的起始物理地址和指令/数据的逻辑地址计算其物理地址 运行时加载示例 优点： 程序不必连续存放在内存中，可分散存储，可移动 （如动态链接库 dll）便于共享 有利于紧凑、碎片问题的解决 主流方式 缺点： 需要硬件支持，对应的软件算法比较复杂 同一地址，可能多次转换 小结 绝对加载 编译时执行地址绑定 编译时就知道进程将在内存中的驻留地址，生成绝对代码。即在可执行文件中记录内存地址，加载时直接定位在该内存地址 如果将来开始地址发生变化，就必须重新编译代码 静态重定位加载 加载时执行静态地址重定位 系统根据内存当时的使用情况，决定将目标代码放在内存的什么位置 不允许程序在内存中移动 动态执行时加载 执行过程中执行动态地址重定位 支持执行时进程在内存中移动 链接的任务 一组目标模块 -&gt; 一个包含完整程序和数据模块的加载模块，传递给加载器 地址重定位：在每个目标模块中，可能有到其他模块的地址访问。链接器创建一个单独的加载模块，它把所有目标模块逐个链接起来。 链接方式（链接的时机） 静态链接(Static linking) 加载时动态连接(Load-time Dynamic Linking) 运行时动态链接(Runtime Dynamic Linking) 静态链接程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块（执行模块），以后不再拆开。 两个问题： 相对地址的修改：由编译程序产生的所有目标模块中，使用的都是相对地址，其起始地址都为0，在链接成一个加载模块时修改模块的相对地址 变换外部引用地址：将每个模块中所用的外部调用符号也都变换为相对地址。 静态链接方式示意图 缺点： 不利于代码共享：每个应用都含有目标模块的拷贝（A、D 都需要 C 模块时，C 会在内存中出现两次） 不利于模块的独立升级：每次对某个目标模块的修改升级，都要打开整个加载模块 可能链接一些不会执行的模块，浪费存储空间和处理机时间。如 A 的代码为 if (cond) {call B;} else {call C;}，B、C 都会被链接，但不会被都执行。 加载时动态链接待加载的模块在加载内存时，如果该模块中有到外部模块的引用，加载程序将查找这些模块并加载内存，并把这些引用修改为相对应用程序模块开始处的相对地址。 优点： 便于各个模块的独立升级 便于实现模块的共享 缺点 可能链接一些不会执行的模块，浪费存储空间和处理机时间（同静态链接） 模块加载后不能移动位置 运行时动态链接 在程序执行中需要某目标模块时，由操作系统去找到该模块并将之加载内存，随后把它链接到调用者模块上 如 Windows 的 DLL 优点： 凡在执行过程中未被用到的目标模块，不会被调入内存和被链接到加载模块上 不仅可加快程序的加载过程，而且可节省大量的内存空间 支持分段系统 总结 地址映射时间 加载方式 链接方式 加载前（编译/链接时） 绝对加载 静态链接 加载时 可重定位加载/静态重定位 加载时动态链接 运行时 运行时加载/动态重定位 运行时动态链接 讲了一通概念，乱乱的。这个似乎不是很重要，讲得不详细。主要是为后面铺路吧。 内存管理的需求 重定位 保护 共享 逻辑组织 物理组织 重定位重定位 relocation（HTTP 的重定向是 redirect 233） OS 需要把活动进程换入或换出内存，但进程换入时若要放置在与换出前相同的区域，会存在诸多困难。因此需要将进程重定位到内存的不同区域。 操作系统需要知道进程控制信息、栈和入口点位置 处理器需要处理程序内部的内存访问，处理跳转指令、数据访问指令的地址转换 保护 进程以外的其他进程中的程序不能未经授权地访问（进行读操作或写操作）该进程的内存单元 程序在内存中的位置不可预测 需要既支持重定位，也支持保护的机制 处理器硬件必须具备这个能力 共享 多个进程正在执行同一程序时，允许每个进程访问该程序的同一个副本，要比让每个进程有自己独立的副本更有利 需要既支持重定位也支持共享的机制 逻辑组织 内存被组织成线性（或一维）地址空间 与此同时，程序按模块组织 可以独立编写和编译模块 可以为不同的模块提供不同的保护级别（只读、只执行） 模块可以被多个进程共享，与用户看待问题的方式一致 分段可以满足该需求。 物理组织在内存和外存之间完成移动信息的任务应该交给OS而不是程序员，因为： 不应让程序员负责管理内存 供程序和数据使用的内存可能不足 覆盖 (overlaying) 允许不同的模块占用相同的存储空间，但编程耗时 程序员不知道可用空间的大小和位置 内存分区 内存管理的主要操作是处理器把程序加载内存中执行 内存管理技术 使用 固定分区 IBM MFT 动态分区 IBM MVT 简单分页 没有使用，但为虚存分页的基础 简单分段 没有使用，但为虚存分段的基础 虚存分页 现代操作系统广泛实际使用 虚存分段 现代操作系统广泛实际使用 内存管理包含虚拟内存的复杂方案，基于分段和分页两种基本技术 固定分区 操作系统占据内存中某些固定部分，用户进程使用其余部分 分区数量固定 每个分区装入一个进程 两种划分方式：分区大小相等和分区大小不等，如图： 固定分区的两种划分方式 问题： 程序可能太大而不能放到一个分区中。此时，程序员必须使用覆盖技术设计程序，使得任何时候程序只需要有一部分放入内存 内存的利用率非常低：很小的程序也必须占据一个完整分区 由于装入的数据块小于分区大小，分区内部存在空间浪费，这种现象称作内部碎片 内部碎片 (internal fragmentation) 就是分区内部的碎片 分区大小不等可以缓解上述问题，使内部碎片更小。 但是，如果分区大小不等，就要考虑到放置算法，即把进程分配到分区的算法。 分区大小不等时的放置算法 最简单的方法是把每个进程分配到能够容纳它的最小分区中。在这种情况下，每个分区都需要维护一个调度队列，用于保存从这个分区换出的进程，如图 (a) 所示。这种方法的优点是，每个分区内部浪费的空间（内部碎片）最少。尽管从单个分区的角度来看这种技术是最优的，但从整个系统来看它却不是最佳的。如果某个时刻，系统中没有大小在 12MB 到 16MB 之间的进程。此时，即使系统中有一些更小的进程本可以分配到 16MB 的分区中，但 16MB 的分区将仍会保持闲置。因此，一种更可取的方法是为所有进程只提供一个队列，如图 (b) 。当需要把一个进程装入内存时，选择可以容纳该进程的最小可用分区。如果所有的分区都已被占据，则必须进行交换。 固定分区存在的问题： 分区的数量在系统生成阶段已经确定，因而限制了系统活动进程的数量 小作业不能有效地利用分区空间 动态分区动态分区：分区大小和数量不固定；OS 总是分配与进程需求完全一致的空闲内存空间。 动态分区的效果 如上图，动态分区虽然更灵活，但是会导致分区之间产生很多狭小的外部碎片（如 (h) 图中出现了 2 个 6M 和 1 个 4M 的碎片）。 外部碎片 (external fragmentation) 就是分区外部的碎片 于是有了紧凑技术 Compaction（又称为压缩）： 解决外部碎片问题的技术 操作系统移动进程，使进程占用的空间连续、所有空闲空间连成一片 但是紧凑费时，浪费处理器时间 动态分区放置算法首次匹配 First Fit 思想：从头开始扫描内存，选择大小足够的第一个可用块 实现：要求空闲分区以地址递增的顺序链接，从链首开始查找 评价： 简单，快速 为大作业分配大的内存空间创造条件 内存前端出现很多小的空闲分区，且每次查找都要经过这些分区 下次匹配/循环匹配 Next Fit 思想：从上一次放置的位置开始扫描内存，选择下一个大小足够的可用块 实现：空闲分区按地址从低到高排列（链接） 评价：通常比首次匹配性能差 常常在内存末尾分配空间，能使空闲的分区分布均匀 缺少大的空闲块，需要更多次数紧凑 最佳匹配 Best Fit 思想：选择空间大小与需求最接近的空闲块分配 实现：空闲分区按容量从小到大链接 评价：通常性能是最差的 产生的外部碎片都很小 内存中形成很多小到无法满足任何分配需求的块 需要更频繁地紧凑 最差匹配 Worst Fit 思想：选择最大的空闲分区分配 实现：空闲分区按容量从大到小链接 评价： 每次分配留下的空闲空间较大，便于再次利用 大的空间不容易保留，对大作业不利 例题 固定分区中的内存分配示例 操作系统采用动态分区存储管理技术。操作系统在低地址占用了100KB的空间，用户区主存从100KB处开始占用512KB。初始时，用户区全部为空闲，分配时截取空闲分区的低地址部分作为分配区。执行以下申请、释放操作序列：请求300KB、请求100KB、释放300KB、请求150KB、请求50KB、请求90KB。 采用首次适应算法时，主存中有哪些空闲分区？画出主存分布图，并指出空闲分区的首地址和大小。 采用最佳适应算法时，主存中有哪些空闲分区？画出主存分布图，并指出空闲分区的首地址和大小。 若随后又申请80KB，针对上述两种情况产生什么后果？说明了什么问题？ 分区分配算法示例 伙伴系统 固定分区方案限制了活跃进程的数量。并且，如果分区大小与进程大小不匹配，则内存空间的利用率非常低 动态分区方案维护复杂，并且引入了紧凑的额外开销 折中方案：伙伴系统 Buddy System 提出者：Donald E. Knuth 原理最初，可用于分配的空间被视为一个大小为$2^U$的块。 每次分配的块的大小为 $2^K$，$L \\leq K \\leq U$, 且 $2^L$ = 分配的最小块的大小 $2^U$ =分配的最大块的大小 通常， $2^U$ 是内存中整个可分配空间的大小 伙伴系统示例 释放 A 的时候，A 所在 64K 会和它的伙伴（从一个 128K 分裂出来的另一个 64K）进行合并，这就是所谓伙伴系统 释放的空间只能和自己的伙伴合并，即使另一个相邻空间也是同大小，也不会合并 伙伴系统的树状表示 评价 较为合理的折中方案，一定程度上克服了固定分区和动态分区的缺陷 是一种有效方案 UNIX 内核存储分配中使用了一种经过改进的伙伴系统 重定位概念： 逻辑地址 Logical：与当前数据在内存中的物理分配无关的访问地址，执行前要转换成物理地址 相对地址 Relative：逻辑地址的特例，相对于某些已知点的存储单元 物理地址 Physical/Absolute：内存中的实际地址 重定位的硬件支持 首地址经过 Adder 以后，还要进入 Comparator 判断是否有越界访问。 分页（重点，敲黑板）页和页框 将内存划分成大小固定、相等、相对较小的块 进程也划分成同样大小的块 页 Pages：进程中的块 页框 Frames：内存中的块 不会有外部碎片（回忆内部碎片、外部碎片是什么？） 将进程的页装入内存的页框 注意 D 进程是离散存放（相对地，A、B、C是连续存放）的！ 由于存在离散存放的情况，地址转换需要操作系统提供页表支持。 页表 页表是一种数据结构 每个进程一个页表 保存进程中每个页对应的页框 处理器使用页表生成物理地址 页表示例 每个进程的页表中，左边是页号，右边是页框号。 逻辑地址 分页模式下，逻辑地址 = 页号 + 页内地址 32位机的分页存储系统逻辑地址结构示意图 从图中可以得出，页的大小为 4KB($2^{12}$B)。 逻辑地址转换示例 c 图是分段的内容，可以先不看。 转换的实际情况可以看地址转换。 若给定一个逻辑地址空间中的地址为 $A$，页面的大小为 $L$，则页号 $P$ 和页内地址 $d$ 有以下关系： $$P=\\lfloor \\frac{A}{L} \\rfloor, d = A \\mod L$$ 例题：某系统的页面大小为 1 KB，设 $A = 2170 B$，试计算其页号 $P$ 与页内地址 $d$。 $$P=\\lfloor \\frac{2170}{1024} \\rfloor = 2, d = 2170 \\mod 1024 = 122$$ 逻辑地址到物理地址的转换 逻辑地址高位 =&gt; 页号 查页表，页号 =&gt; 页框号 页框号:逻辑地址低位 =&gt; 物理地址 页表的存储 页表存放在内存 PCB 保存有页表的起始地址（PCB 和页表都是每个进程一个） 页表寄存器存放当前运行进程的页表的起始地址 例题例题 1： 一个系统，内存容量共256K，存储块的大小为1K，共256块，编号为0～255。 第0～4块为操作系统所使用； 现有2个用户作业，作业1和作业2，其逻辑地址空间分别占2k和2.5k； 进入系统后，按块的大小划分分别占2页和3页，分布如图。 分页情况 请完成作业 2 的 2500 的地址转换： 例题 地址转换 示意图： 地址转换示意图 例题 2： 在普通分页存储管理系统中，逻辑地址的结构长度为18位，其中11~17表示页号，0~10位表示页内偏移量。若有一个作业的各页依次放入2、3、7号物理块，试问：逻辑地址1500应在几号页内?对应的物理地址是多少? 题解： 在页表中，有3个页表项，分别为(0,2)、(1,3)、(2,7) $页号=int(1500/2^{11})=0$ $页内偏移量=1500 \\mod 2^{11} = 1500$ $物理地址=2*2^{11}+1500=5596$ 评价分页存储管理的优点： 存在页内碎片，但碎片相对较小，内存利用率较高 实现了离散分配 无外部碎片 分页存储管理的缺点： 需要专门的硬件支持，尤其是快表 不支持动态链接，不易实现共享（动态链接、共享是以模块为单位，而分页以页为单位，不会考虑到模块） 后面讲虚存的时候还会提到分页 分段emmm 汇编 一个程序可以划分成几个段 segments 段长度可以不等 每个段都从 0 开始编址，并占用一段连续的地址空间 有最大段长限制 逻辑地址两部分组成：段号+段内偏移量 分段类似动态分区：分段使一个程序可以占据多个分区，且不必连续 消除了内部碎片 分段的性质 分页对用户透明（用户不可见分页），分段对用户可见 分段给程序员提供了组织程序和数据更方便的手段 程序员或编译器将程序和数据划分到不同的段 为实现模块化程序设计，程序和数据可能会进一步被划分成多个段 不便：程序员或编译器需要清楚最大段长的限制 逻辑地址分段模式下，逻辑地址 = 段号 + 段内偏移 分段的逻辑地址结构 一个分段存储管理系统中，地址长度为32位，其中段号占8位，则最大段长是多少字节？ 应为 $2^{32-8}B=4 MB$。 段表段表记录逻辑段和物理段的对应情况。 段表 逻辑地址转换示例段的大小不等，导致逻辑地址和物理地址间没有简单的对应关系。地址转换需要经历以下步骤： 提取段号：逻辑地址最左侧的 n 位 以段号为索引，查找段表中该段的起始物理地址 逻辑地址最右侧 m 位为偏移量，偏移量与段长度比较，若偏移量&gt;段长，则地址无效 物理地址：该段的起始物理地址+偏移量 评价分段存储管理的优点： 便于程序模块化设计 便于动态链接 便于保护和共享 无内部碎片 分段存储管理的缺点： 地址转换需要硬件的支持——段表寄存器 分段的最大尺寸受到主存可用空间的限制 有外部碎片 分页、分段对比 页是信息的物理单位，分页的目的是实现离散分配，减少内存的外部碎片，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。 分页存储管理系统不易实现“共享”和“运行时动态链接”，而分段系统易于实现“共享”。 三(2) 内存管理：虚拟内存管理虚存的前提： 分页或分段的硬件支持 操作系统必须有管理页或段在内存和辅存之间移动的软件 相关概念 虚拟内存：在存储分配机制中， 辅存可被看作主存的一部分来完成寻址。程序使用的地址与内存物理存储的地址不同，程序生成的地址会自动转换为物理地址。虚拟存储的大小受计算机系统寻址机制和可用辅存容量的限制，而不受主存实际大小限制 虚拟地址：在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主存的一部分那样。有时也称为逻辑地址 虚拟地址空间：分配给进程的虚拟存储 地址空间：用于某进程的内存地址范围 实地址：内存中存储位置的地址 硬件和控制结构分页和分段内存管理的两个基本特征： 进程中所有内存访问都是逻辑地址，这些逻辑地址会在运行时动态地转换为物理地址。 一个进程可划分为许多块（页和段），在执行过程中，这些块不需要连续地位于内存中 若上述特征存在，则在一个进程执行过程中，该进程不需要所有页或所有段都在内存中。 进程的执行过程： 操作系统仅读取包含程序开始处的一个或几个块进入内存 驻留集：任意时刻，进程驻留在内存的部分 访问一个不在内存中的逻辑地址时（称为内存失效），产生一个中断： 操作系统把被中断的进程置为阻塞状态 操作系统把该进程中包含引发内存失效的部分读入内存 操作系统产生一个磁盘 I/O 读请求 在执行磁盘 I/O 期间，操作系统调度另外一个进程运行 磁盘 I/O 完成后产生中断，操作系统将相应的进程置于就绪状态 提高系统资源利用率的方法： 内存中保留多个进程 每个进程仅装入了部分块 任何时刻内存中的进程至少有一个处于就绪状态 提高了处理器的利用率 进程可以比内存的全部空间还大 基于分页和分段的技术，操作系统和硬件只加载程序的一部分 程序员面对的是一个巨大内存，大小与磁盘存储器相关 实存储器（实存） 虚拟内存（虚存） 主存, 实际的物理内存 感觉更大的内存，且常分配在磁盘上 更有效地支持并发，并能减轻用户对内存的严格限制 使用和不使用虚存技术下分页和分段的特点 抖动和局部性原理 进程只有部分块在内存，这样可在内存中保留更多进程 操作系统必须“聪明”的管理这个方案 当内存空间几乎被进程块占据时，每读取一块，必须把另一块换出，如果出现抖动，处理器的大部分时间都用于交换而非执行指令 为了避免这种情况，操作系统试图根据最近的历史来猜测将来最可能用到的块 抖动：即将要用到的块被换出，系统又得很快将它取回，导致页面被频繁地换入换出，缺页率急剧增加 局部性原理： 存储器的访问呈簇性（簇 cluster：一组程序或数据的集合） 在很长一段时间内，使用的簇会发生变化 但在很短的时间内，处理器基本上只与固定的簇打交道 描述了进程中程序和数据引用的集簇倾向 在很短的时间内仅需要进程的一部分块 对将来可能会访问的块进行猜测，以避免抖动 局部性原理表明虚存方案是可行的。 分页 虚拟内存通常与使用分页的系统联系在一起 每个进程都有自己的页表 分页的虚存方案中，页表项变得更复杂 页表项 页表项 存在位 P：表明对应的页是否在内存 页框号：若页在内存，则有对应的页框号 修改位 M：表明相应页上次装入内存到现在是否修改过（若修改过，换出时要更新辅存上对应页；没修改就不用更新了） 地址转换其实也就是前面分页的地址转换,只是这里加上了内存等硬件结构。 页表位于内存 进程运行时，一个寄存器保存页表的起始地址 虚拟地址的页号用于检索页表，查找对应页框号 页框号与虚拟地址的偏移量结合起来形成物理地址 地址转换过程 例：某虚拟存储器的用户编程空间共32个页面，每页为1KB，内存为16KB。假定某时刻一用户页表中已调入内存的页面对应的物理块号如下表： 页号 物理块号 0 5 1 10 2 4 3 7 逻辑地址 0A5C(00010 1001011101) 对应的物理地址为：125C(0100 1001011101)。 二级页表每个进程一个页表，如果进程的逻辑地址空间大，则页表庞大。 例如，在 Vax 机中，每个进程虚存空间可达$2^{31}=2GB$，若每个页大小 $2^9=512B$，则需要 $2^{22}$ 个页表项。 显然，采用这种方法来放置页表的内存空间太大。为克服这个问题，大多数虚拟内存方案都在虚存（而非实存）中保存页表。这意味着页表和其他页一样都服从分页管理。 一个进程正在运行时，它的页表至少有一部分须在内存中，这一部分包括正在运行的页的页表项。 一些处理器使用两级方案来组织大型页表。在这类方案中有一个页目录，其中的每项指向一个页表。这种方案也称为二级页表。 示例：32位地址的两级页表 页尺寸为 4KB 虚拟地址空间为 4GB，由 $2^{20}$页组成 每个页表项 4 字节，可计算得页表大小总共需要 $4B \\times 2^{20} = 4MB$ 页表空间需 $4MB/4KB=2^{10}$ 页存储，因此可保留在虚存中，并建立根页表来索引根页表包含 $2^{10}$个页表项，占用 4KB 内存 32位地址的两级页表 两级分页的逻辑地址结构，及地址映射示意图 例题 1：某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为 $2^{10}$ 字节，页表项大小为 $2$ 字节。逻辑地址空间大小为 $2^{16}$ 页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是多少？ 这类计算题需要注意的是几个等量关系： 第二级页表也是页，所以页大小既指后面存数据的页面的大小，也指存页表项的二级页表的大小 而页目录就不是页了 如果页目录的长度为 $X$ 项，且一个页表的最大长度为 $Y$ 页，则一个进程可以有 $XY$ 页 回到题目，这个题有两种解法： 解法 1： 一个二级页表能存的页表项数 = 页大小 / 一个页表项的大小 $= 2^{10}/2 = 2^9$ 个 所以，二级页表的总数 = 总逻辑页数 / 一个二级页表能存的页表项数 = $2^7$ 页目录的表项数 = 二级页表的总数 = $2^7$ 解法 2： 二级页表总的项数 = 总逻辑页数 = $2^{16}$ 二级页表总的大小 = 总表项数 * 页表项大小 = $2^{17}$ 二级页表的总数 = 总的大小 / 一个二级页表能存的大小（换言之，页大小） = $2^7$ 页目录的表项数 = 二级页表的总数 = $2^7$ 头晕的时候做这题就很容易晕掉。 两级分页中的地址转换： 虚拟地址（逻辑地址）结构中分离出根页表号（如图8.3例虚拟地址前10位） 检索根页表，查找关于用户页的页表项 如果不在内存，产生一次缺页中断 若在内存，用虚拟地址中间页号（如前例虚拟地址中间10位）检索用户页表，查找对应的页表项 得到页框号，和页内偏移量一起形成物理地址 二级页表地址转换示意图 例题 2：80x86 硬件分页地址，32位逻辑地址空间、4KB页面、4B页表项，如何将逻辑地址 0x20021406 转换为物理地址？ 页面大小 4KB，所以最后 12 位为页内偏移量 一个二级页表的页表项数 = 页面大小/页表项大小 = 1KB，所以中间 10 位为页号 剩下前面的 32-10-12=10 位就是页表页号了 0x20021406 = 0010000000 0000100001 010000000110 顶级页表字段 0x80，用于选择顶级页表的第0x80表项，指向二级页表 二级页表字段 0x21，用于选择二级页表的第0x21表项，指向逻辑地址所在页框 页内偏移地址字段 0x406，逻辑地址在页框内的偏移量 例题 3 图 例题 3：在例题 2 和上面的表结构中，求逻辑地址 4197721 （注意没有 0x，是十进制）的物理地址？ $4197721 = 1024 * 2^{12} + 3417$ $1024 = 1 * 2^{10} + 0$ 页目录号 页号 页内偏移 1 0 3417 顶级页表字段为 1，用于选择顶级页表的第 1 表项，指向二级页表 202 二级页表字段 0，用于选择二级页表的第 0 表项，指向逻辑地址所在页框 505页内偏移地址字段 3417，逻辑地址在页框内的偏移量物理地址：$505 * 2^{12} + 3417 = 2071897$ 多级页表对于某些机器，二级页表也可能非常大；可采用多级页表，对外层页表再进行分页，如三级页表。 会增加额外的存储空间。 页表的级数越多，地址转换过程越复杂，转换的速度也越慢。 倒置页表上面的页表均使用页号作为索引，也就是说，有多少项虚拟页，就需要多少页表项；每个进程都需要有这么多页表项（即，页表大小和虚拟页数成正比），而实际的物理存储页数并没有这么多，不需要这么多页表项，导致严重的空间浪费。 于是发明了倒置页表（倒排页表）。页表结构称为“倒排”的原因是，它使用页框号而非虚拟页号来索引页表项（如下图）。另外，所有进程共用一张表倒排页表，因此无论有多少进程、支持多少虚拟页，页表大小只与物理页数成正比，只需要实存中的一个固定部分。 虚拟地址的页号部分使用一个简单的散列函数映射到散列表中，哈希值指向倒排页表。 倒排页表结构 使用时，计算出的散列函数会和每一个页号匹配（啊这 似乎有点慢），匹配到了的下标 $i$ 即是页框号。如果没匹配到，会通过链指针跳到下面一项。 转换检测缓冲区（快表）对于一级页表，每次虚存访问都可能会引起两次物理地址访问：一次取相应的页表项，另一次取需要的数据。 为了克服这个问题，大多数虚拟内存方案都为页表项使用了一个特殊的高速缓存，称为转换检测缓冲区 TLB (translation lookaside buffer，快表)。TLB 包含最近用过的页表项。 具有快表的地址转换流程： 给定一个虚拟地址，处理器首先检查 TLB 若命中，即页表项在TLB中，检索页框号形成物理地址 若未命中，即页表项不在TLB中，检索进程页表，查找相应页表项 若“存在位”已置位，页位于内存，用页框号+偏移量形成物理地址 若“存在位”未置位，页不在内存，产生缺页中断 (page fault)，装入所需页，更新页表 上面的描述中有三种情况： 页表项在 TLB 中，此时数据一定在内存中（正确性如何证明？可能和后面的换出算法有关） 页表项不在 TLB 中，但数据在内存中 页表项不在 TLB 中，数据也不在内存中 具有快表的地址转换示意图 具有快表的地址转换流程图 页表更新后需要回到出错指令，可能是因为中断恢复以后需要执行指令。 注意到在地址转换示意图中，处理器对 TLB 的查询是同时进行多项匹配的，这叫关联映射，需要硬件支持。 更复杂的是 TLB 和 CPU 高速缓存协同的相关操作。 页表项：可能在TLB中，也可能在内存或磁盘中 被访问的字：可能在高速缓存中，也可能在内存或磁盘中 TLB 和 CPU 高速缓存协同 用页号查询 TLB 或页表，找到页框号 用页框号和偏移量组合成实地址，然后查询缓存或内存，得到值 页尺寸 页尺寸是一个重要的硬件设计决策，它需要考虑多方面的因素。其中一个因素是内部碎片。显然，页越小，内部碎片的总量越少。为优化内存的使用，通常希望减少内部碎片；另一方面，页越小，每个进程需要的页的数量就越多，意味着更大的页表。对于多道程序设计环境中的大程序，这意味着活动进程有一部分页表在虚存而非内存中。因此，一次内存访问可能产生两次缺页中断：第一次读取所需的页表部分，第二次读取进程页。另一个因素是基于大多数辅存设备的物理特性，希望页尺寸比较大，从而实现更有效的数据块传送。 两个有意思的图： 缺页率：发生缺页的次数与总访问次数的比值。P：进程大小W：工作集大小N：进程的总页数 缺页率与分配页框数的关系（页尺寸一定） 上图表明，对固定的页尺寸，内存中的页框数增加时，缺页率下降。 这个很好理解，内存变大了能存下更多的东西，换出的频率会更低。 缺页率与页尺寸的关系 上图表明，页尺寸很小时，缺页率低；页尺寸增加时，缺页率增加；页尺寸较大时，缺页率下降。 前面一段是由于局部性原理，内存利用率高，换出少，缺页率会较低，当尺寸变大时，局部性原理被削弱（一页包含的单元可能很多都不是最近需要访问的了），换出多，缺页率增高；但当页尺寸大到一页包含整个进程时，不会发生缺页中断。 页尺寸示例 页尺寸的设计问题与物理内存的大小和程序大小有关。当内存空间变大时，应用程序使用的地址空间也相应增长。这在应用程序变得越来越复杂的个人计算机上最为明显。 大型程序中所用的当代程序设计技术可能会降低进程的局部性： 面向对象技术：对小程序和数据的引用会分散在不同的对象中 多线程应用：指令流会突然变化，引用分散在内存中 分段内容回顾 分段： 允许程序员把内存视作由多个地址空间或段组成 段大小不等，可以动态变化 内存访问时：段号+段内偏移量 优点： 简化了对不断增长的数据结构的处理 允许程序独立地改变或重新编译 有助于进程间的共享 有助于保护 段表项段表项类似于页表项，只是多了一个长度。 页表项 地址转换 逻辑地址=段号+段内偏移量，寄存器存储段表地址 根据段表地址和段号查找段表，找到相应段在内存中的基地址 得到物理地址=基地址+段内偏移量 分段和分页的地址转换类似。 地址转换 段页式用户的地址空间被程序员划分为许多段，每段划分为许多固定大小的页： 分段： 对程序员可见 支持数据结构增长（段长可变） 支持共享和保护 分页： 对程序员透明 消除外部碎片 有效利用内存 结合二者，就出现了段页式。 段页式的逻辑地址 用户地址空间被程序员划分成若干段，每段划分成若干页 程序员的角度：逻辑地址 = 段号:段内偏移量 系统的角度：段内偏移量 = 页号:页内偏移量 段表和页表 每个进程一个段表 每个段一个页表 段表项：含段长和对应页表的起始地址 页表项：含页框号、存在位P、修改位M等 地址转换虚拟地址（逻辑地址） = 段号 : 页号 : 偏移量 寄存器存放段表起始地址 根据段表起始地址和段号查找段表，得到对应段的页表起始地址 根据页表起始地址和页号查找页表，得到页框号 页框号和偏移量构成物理地址 段页式的地址转换 例题 1：32 位逻辑地址，段最大大小为 16 KB，页大小为 4KB，问地址中各部分长度。 段号 18 位 + 页号 2 位 + 偏移量 14 位 在段页式系统中（不考虑缓存、TLB 等），为了获得一条指令或数据，至少需访问几次内存？ 第一次，访问段表，从中获得该段的页表首址； 第二次，访问页表，从中取出逻辑地址指定的页面所在的页框号，并将该页框号和页内偏移量相加，形成物理地址； 第三次，根据物理地址，取出对应存储单元的指令或数据。 所以至少三次（如果发生缺页中断，次数会大于三） 保护和共享分段有助于实现保护和共享机制 保护：每个段都包括一个长度和一个基地址，可以控制非法访问 共享：一个段可以在多个进程的段表中被引用，实现共享 示例： 一个多用户系统，可同时接纳 40 个用户，每个都执行一个文本编辑程序 (Text Editor)。如果文本编辑程序有 160 KB 的代码和另外 40 KB 的数据区，则总共需有 8000KB 的内存空间来支持 40 个用户。如果 160 KB的代码是可重入的(Reentrant，即能被共享)，在内存中只需保留一份文本编辑程序的副本，此时所需的内存空间仅为 1760 KB(40×40+160)，而不是 8000 KB。 分页中的共享：假定每个页面 4KB，160KB 的共享代码需要 40 个页面，每个进程需要 40 个页表项来存储相应信息。 分页中的共享 分段中的共享：共享部分作为一个段，每个进程仅需一个段表项来存放共享段信息。 分段中的共享 下图说明了这类系统能实现的保护关系的类型。 系统能实现的保护关系的类型 操作系统软件内存管理设计的三个基本选择： 是否使用虚拟技术 使用分页还是分段，或二者同用 为各种存储管理特征采用的算法（本节主题） 为实现虚拟内存，操作系统需要考虑的策略（软件方面）： 读取策略 请求调页 (Demand Paging) 预调页 (Prepaging) 放置策略 驻留在内存中的位置 置换策略 基本算法 最优 (OPT) 最近最少使用 (LRU) 先进先出 (FIFO) 时钟 (CLOCK) 页缓冲 驻留集管理 驻留集大小 固定 可变 置换范围 全局 局部 清除策略 请求式清除 (Demand) 预约式清除 (Precleaning) 负载控制 多道程序度（系统并发度） 读取策略决定某页何时进入内存。 请求调页（Demand Paging，按需调页） 仅在引用页面时，才把相应的页面调入内存 进程首次启动时，会发生很多缺页中断 局部性原则表明，大多数将来访问的页面都是最近读取的页面，一段时间后，缺页中断会降低到很低的水平。 预调页（Prepaging） 额外读取所缺页面以外的页面 考虑大多数辅助储设备的特性：寻道、旋转延迟等 若进程的页面连续存储在辅存中，则一次读取多个页面会更有效 如果额外读取的页面未使用，则低效 放置策略 确定进程驻留在内存中的位置 分段系统中的重要设计内容，如首次匹配、循环匹配等 分页或段内分页中，放置策略无关紧要，因为硬件以相同的效率执行地址转换功能 对于非一致存储访问 (NUMA，NonUniform Memeory Access, NUMA)，需要自动放置策略 置换策略（重点）页面置换涉及的问题：具体淘汰哪个页面用以置换 置换策略 (Replacement policy)：读取新页时，如何选择内存中要淘汰的页面 目标：最近最不可能访问的页面 置换策略越精细，实现它的硬件和软件开销就越大 页框锁定 当页框被锁定时，当前存储在该页框中的页面不能被置换 操作系统内核和重要的数据结构保存在锁定的页框中 I/O缓冲区和时间要求严格的区域也可能保存在锁定的页框中 通过将锁定位与每个页框相关联来实现锁定 几种基本的置换算法 最佳 (Optimal, OPT，理想算法) 最近最少使用 (Least recently used, LRU) 先进先出 (First-in-first-out , FIFO) 时钟 (Clock) 评价置换算法的重要指标： 缺页率——给定时间内，发生缺页的次数与访问总次数的比值 最佳 (OPT) 置换下次访问距当前时间最长的页面 理想算法（不可实现），缺页率最少 OPT 算法示例 F表示所分配的页框在初始填满后产生缺页中断。 最近最少使用 (LRU) 置换内存中最长时间未引用的页面 根据局部性原理，这也是最近最不可能访问的页面 难以实施 每页添加最近访问时间戳——开销大 建立链表——开销大 LRU 算法示例 先进先出 (FIFO) 将分配给进程的页框视为循环缓冲区 页面以循环方式删除——简单的置换策略 置换驻留在内存中时间最长的页面 FIFO 算法示例 时钟 (CLOCK) 每个页框关联一个使用位 当页面首次加载到内存中或被引用时，使用位设置为1 用于置换的候选页框集视作一个循环缓冲区 发生缺页中断时，检查表针指向页面，如果使用位为 0，则新页面替换之,表针前移一个位置；如果使用位为 1，则清 0，表针前移一个位置。重复上述过程。 注意：命中时表针不移动，而是将根据第二条，将命中位的使用位设为 1 时钟算法 图 这个算法类似于 FIFO，但不同的是，在时钟策略会跳过刚访问过的页框。 示例 1：页 727 进入内存前，需要选择一个页置换。从指针当前位置开始，顺时针移动，最后选择页556置换。 时钟算法示例 2 图中 * 表示 use=1。注意第 5 步时，时钟实际上转了一圈，将所有点标记为 use=0 后，替换掉了第一个 2。 例题：假设系统为某进程分配了3个页框，其页面走向如下：7 0 1 2 0 3 0 4，求采用CLCOK页面淘汰算法，在初始3个页框装满后缺页中断的次数。 例题模拟 共三次缺页。 置换算法比较 几种置换算法比较（固定分配，局部置换） 改进 Clock 算法在Clock算法基础上，优先置换最近未访问、未修改（如果这块内存被修改了，换出时就涉及到写硬盘操作）页面。 每个页框处于下列情形之一（u:访问位，m:修改位）： 1类(u=0, m=0)：最近未被访问，又未被修改，最佳淘汰页。 2类(u=0, m=1)：最近未被访问，但已被修改页。 3类(u=1, m=0)：最近已被访问，但未被修改。 4类(u=1, m=1)：最近已被访问且被修改，最不应淘汰页。 2 和 3 类选择谁先淘汰呢？其实先淘汰谁都是可以的。根据 LRU 的原则，我们优先选择 2 进行淘汰。 算法流程： 从指针当前位置开始扫描，这次扫描对使用位不作任何修改，选择遇到的第一个页框 (u=0,m=0) 置换；——会置换掉 u=0, m=0 若第 1 步失败，重新扫描，选择遇到的第一个 (u=0,m=1) 的页框置换。这一过程中，将使每个扫描过的页框u置0；——会置换掉 u=0, m=1 若第 2 步失败，则再次重新扫描，重复第 1 步；——会置换掉 u=1, m=0 若第 3 步失败，则再次重新扫描，重复第 2 步；——会置换掉 u=1, m=1 改进型时钟置换算法实现简单，性能比较理想，被广泛采用（如早期 Linux）。（后来 Linux 使用类 LRU 算法） 页缓冲 置换的页，如果被修改过，就得写回辅存，代价较大。 在内存中采用页缓冲，提高了分页性能，并允许使用更简单的页面替换策略（如 FIFO）。 置换的页面： 未修改，放入空闲页链表（由可用来存放读入页的一系列页框构成）尾部 已修改，放入修改页链表（已修改页按簇、成批写回磁盘会更快）尾部 页缓冲的一个作用是起了类似于磁盘的高速缓存的功能。若进程访问在页缓冲的页，该页就可以被直接放到驻留集中。 （可是为什么要拿一部分内存来作页缓冲，而不是直接把这部分内存加到进程里呢？可能是因为页缓冲是全局的，而不是每个进程都有一个） 除此之外，页缓冲的修改页链表还有一个作用，就是使已修改的页按簇写回，大大减少了 I/O。这便是和清除策略的联动。 置换策略和高速缓存大小对于较大的高速缓存，替换页会对性能产生影响：如果选择替换的页在高速缓存中，则该高速缓存块及内存中所对应的页将失效。 在使用页缓冲的系统中，可以使用页缓冲区中的页放置策略来提高高速缓存性能。 大多数操作系统通过从页缓冲区中选择任意页框来放置高速缓存中需置换的页，但如果使用细致的页放置策略，能减少 10%~20% 的高速缓存失效。 具体的高速缓存结构、页放置策略超出了本书的范围。 驻留集管理驻留集定义 分配和置换驻留集管理设计到了分配和置换。 页框分配，即给每个活动进行分配多少个页框 分配给每个进程的内存越小，可以驻留在内存中的进程越多 若一个进程在内存中的页面少，则缺页率相对较高 给进程分配的页框数超出一定大小后，由于局部性原理，缺页率下降到稳定水平 置换范围，即计划置换的页集局限于产生缺页的进程本身，还是内存内的所有进程 分配和置换算法 固定分配：在内存中为每个进程提供固定数量的页框 可变分配：允许分配给每个进程的页框数在进程的生命周期内变化 局部置换：仅在该进程的驻留页中选择置换对象 全局置换：在整个内存中选择置换对象，只要不是锁定的页，都可以作为候选页 两两组合就有如下情况： 组合 局部置换 全局置换 固定分配 分配给进程的页框数固定；从分配给该进程的页框中选择被置换的页 此方案逻辑上不存在 可变分配 为了保存进程的工作集，分配给进程的页框数不时变化；从分配给该进程的页框中选择被置换的页 从内存中所有可用页框中选择被置换的页；进程驻留集大小不断变化 固定分配，局部置换 需要事先确定分配给一个进程的页框数量 如果给进程分配的数量太少，将会产生较高的缺页率 如果给进程分配的数量太多，内存中只有较少的程序，增加处理器空闲时间（时间用于交换） 可变分配，全局置换 最容易实现的方法，在很多操作系统里采用 操作系统维护一个空闲页框列表 当缺页中断发生时，一个空闲页框分配给缺页的进程 如果没有空闲页框，操作系统必须选择一个内存中的页框（没有锁定，没有被内核占用）作为置换对象 如果选择置换对象不当，将容易再次产生缺页中断，使用页缓冲可以缓解这个问题 可变分配，局部置换 当一个新进程装入内存时，分配一定数量的页框作为它的驻留集 当缺页中断发生时，从进程驻留集中选择一页用于置换 不时重新评估进程的页框分配情况，增加或减少分配的页框，以提高整体性能 这种组合的关键要素： 决定驻留集大小的原则 驻留集大小变化的时机 于是产生了工作集的概念。尽管真正的工作集策略很难实现，但它可作为比较各种策略的标准。 工作集定义：进程在虚拟时刻为 $t$、参数为 $Δ$ 的工作集 $W(t, Δ)$，表示该进程在 $t$ 时刻，过去的 $Δ$ 个虚拟时间单位（即 $t-Δ+1, t-Δ+2, …, t$ 时刻）被访问到的页的集合。 虚拟时刻的定义是靠进程访问内存的次数实现：例如进程一系列的内存访问为 $r(1),r(2),…r(i)$， $r(i)$ 表示第 $i$ 次对内存页的访问，对应的虚拟时间为 $1$,$2$,…$i$。 $Δ$ 为给定的虚拟时刻时，进程的窗口大小。 显然，虚拟时刻窗口越大，则工作集越大。即： $$W(t, \\Delta+1) \\supseteq W(t, \\Delta)$$ 如下为一个工作集的示例。 工作集示例 对于固定的 $Δ$ ，工作集大小随时间变化的情况：稳定阶段和快速变化阶段交替出现。这是因为局部性原理。 工作集大小随时间变化的情况 工作集的概念可用于指导有关驻留集大小的策略： 根据工作集来决定驻留集的大小 周期性的从驻留集中移去不在工作集中的页（近似 LRU） 只有驻留集包含工作集时，才执行进程 这种策略很有吸引力，因为它采用了一个公认的原理——局部性原理，并利用该原理设计了一个可以减少缺页中断的内存管理策略。遗憾的是，工作集策略仍然存在许多问题: 工作集大小随时间变化 给每个进程测量工作集不现实 $Δ$ 最优值未知 所以产生了近似工作集策略（代表性算法：PFF，VSWS）： 用缺页率指导驻留集 缺页率低于某个阈值时，减小驻留集 缺页率超过某个阈值时，增加驻留集 例题设某计算机的逻辑地址空间和物理地址空间均为 64KB，按字节编址。若某进程最多需要 6 页存储空间，页的大小为 1KB。操作系统采用固定分配局部置换为此进程分配 4 个页框，如下表所示。 页表 & 时钟置换算法图 若该进程执行到 260 时刻时，要访问逻辑地址为 17CAH 的数据，请回答： 该逻辑地址对应的页号是多少？ 若采用先进先出 (FIFO) 置换算法，该逻辑地址对应的物理地址是多少？要求给出计算过程。 若采用时钟 (CLOCK) 置换算法，该逻辑地址对应的物理地址是多少？要求给出计算过程（设搜索下一页的指针沿着顺时针方向移动，且当前指向 2 号页框，所有页框 use 标志均为 1，如上图所示） 1KB 页号意味着 17CAH 的后十位为页内偏移地址，前 6 位（000101B，5）为页号（故需要置换） FIFO 应该换掉最早装入的 7 号页框。故换入后，页框号为 7，物理地址为 7 拼接 17CAH 的后十位，为 1ECAH。 根据时钟算法，程序会查找一圈，将四个页框依次标记为 use=0；然后遍历到 2，淘汰掉 2 号页框并换入。物理地址为 2 拼接 17CAH 的后十位，为 0BCAH。 平均访问时间若缺页率为 $p$，内存的访问时间为 $ma$，发生缺页时的访问时间为 $da$，则平均访问时间为： $$(1-p)*ma+p*da$$ 就是一个简单的已知概率算期望。 发生缺页时访问时间 $da$ 的构成： 缺页中断服务时间 页面写出时间（若需置换） 页面调入时间—— 20ms（寻道时间+旋转时间+数据传送时间） 重新访问内存指令时间 由于 $ma$ 很小（&lt;10ns），因此很低的缺页率也会导致很大的平均访问时间。 例题 1： 假设内存的访问时间为 $10ns$，发生缺页的访问时间为 $21ms$，若因为缺页而出现的性能降低不超过 10%，则缺页率的最大数值为多少？ 下降 10% 的有效访问时间应不超过 10*(1+10%)=11ns $$11 \\geq (1-p)*10+21*10^6*p$$ 解得 $p \\leq 5 \\times 10^{-8}$。 可见很低的缺页率也会导致很大的平均访问时间。 例题 2： 请求分页管理系统中，假设某进程的页表内容如下： 某进程的页表 页面大小为 4 KB，一次内存的访问时间是 100ns，一次快表 (TLB) 的访问时间是 10ns，更新快表的时间为 20ns，处理一次缺页的平均时间为 $10^8$ns (只更新页表，不更新快表)，进程的驻留集大小固定为 2，采用最近最少使用置换算法 (LRU) 和局部淘汰策略。假设：① TLB 初始为空；② 有效位为 0 表示页面不在内存。 设有虚地址访问序列 2BEAH、1CADH、2242H，问： 依次访问上述三个虚地址，各需要多少时间？ 基于上述访问序列，虚地址 1CADH、2242H 的物理地址是多少？ 页大小为 4 KB，故页内偏移占后 12 位。三次访问的页号分别为 2、1、2。 第一问计算访问时间，访问流程可参考 转换检测缓冲区（快表） 中的流程图，如下。 具有快表的地址转换流程图 访问第 2 页：访问 TLB + 访问页表（访问内存） + 更新 TLB + 访问页面（访问内存） = 230ns 访问第 1 页：访问 TLB + 访问页表（访问内存） + 处理缺页 + 访问 TLB + 访问页表（访问内存） + 更新 TLB + 访问页面（访问内存）= 100000340ns 再次访问第 2 页：访问 TLB + 访问页面（访问内存）= 110ns 第二问，在访问 1CADH 时发生缺页，根据 LRU 和局部淘汰策略，将把 0 页换出，故更新后，1 页的页框号将为 CA2H。1CADH 的物理地址为 CA2CADH；2242H 的物理地址为 B2F242H。 清除策略清除策略用于确定何时将修改过的页写回辅存。 按需清除 (Demand cleaning)：只有当该页被置换时，才写回辅存。但缺页中断后，需进行两次页传送（写回原页 和 读入新页），降低处理器利用率 预清除 (Precleaning)：将修改的多页在被置换前，成批写回辅存。但预先写回辅存的页，在置换前可能又会被修改，使得预清除意义不大 一种较好的方法是结合页缓冲技术的按需清除：去掉了 写回原页 和 读入新页 的成对关系。当页被置换时，不立即将该页写回磁盘，而是加入页缓冲；页缓冲就负责在某个时刻将修改的页成批写回辅存。 加载控制加载控制决定驻留在内存中的进程的数量，这称为多道程序度 (multiprogramming level，也称系统并发度)。 加载控制对于有效的内存管理来讲非常重要： 内存驻留的进程太少 -&gt; 所有进程都阻塞的概率变大 -&gt; 大量时间花在交换上 内存驻留的进程太多 -&gt; 平均每个进程的驻留集变小 -&gt; 不够用 -&gt; 频繁缺页中断 -&gt; 抖动 多道程序度对处理器利用率的影响 一种思路是 L=S 准则 (Denning 1980)：发生缺页的平均时间 L 等于处理缺页故障的平均时间 S，此时处理器的利用率最大。 （相当于处理完一个缺页后，刚好下一个缺页发生了） 另一种思路是监测 Clock 置换算法中指针扫描的速度： 速度低，缺页率低，增加多道程序度 速度高，缺页率高或多道程序度高，降低多道程序度 进程挂起系统并发度减小时，一个或多个当前驻留进程须被挂起 (换出)。可以有下面 6 种选择方式: 最低优先级进程 缺页中断的进程 最后被激活的进程 具有最小驻留集的进程 最大空间的进程 具有最大剩余执行时间的进程 四 I/O 管理与磁盘调度五 文件系统概述文件文件是用户或系统创建的数据集。从用户的角度来看，文件是操作系统的重要组成部分 文件拥有的理想属性： 长期存在（文件存储在硬盘或其它辅存中，用户退出系统时文件不会消失） 可在进程间共享（文件有名字，具有允许受控共享的相关访问权限） 结构（文件可以组织成为层次结构或更复杂的结构，以反映文件之间的关系） 文件系统文件系统是提供存储数据的手段，且提供一系列对文件进行操作的功能接口（创建、删除、打开、关闭、读、写等）。 文件系统还会为文件维护一组属性（所有者、创建时间、修改时间等）。 文件结构讨论文件时通常要用到如下 4 个术语： 域：基本数据单元。包含一个值（如雇员的名字、日期、传感器读取的值），定长或变长 记录：域的集合，可视为应用程序的一个单元。如雇员记录，，其中包含域：名字、工作名、雇用日期等。 文件：一组相似记录的集合，可被用户和应用程序视为一个实体。文件通过名字访问，且访问控制通常在文件级实施 数据库：相关数据的集合，元素中存在明确关系。数据库供不同应用程序使用。 文件管理系统文件管理系统需满足以下目标： 满足数据管理要求和用户需求 保证文件中的数据有效 优化性能 为各种类型的存储设备提供 I/O 支持 最大限度地减少丢失或破坏数据的可能性 为用户进程提供标准 I/O 接口例程集 在多用户系统中为多个用户提供 I/O 支持 第一条中，用户需求的最小范围应包含： 用户能够： 创建、删除、读取和修改文件 受控地访问其他用户的文件 允许进行哪些类型的访问 以适合问题的形式重组文件 在文件间移动数据 备份文件，且在文件遭到破坏时恢复文件 通过名字而非数字标识符访问自己的文件 文件系统架构 文件系统架构 设备驱动 最底层 直接与外围设备（或它们的控制器或通道）通信 负责启动设备上的 I/O 操作 处理 I/O 请求的完成 通常视为操作系统的一个组成部分 基本文件系统 称为物理 I/O 层 与计算机外部环境的基本接口 处理在磁盘间或磁带系统间的数据块 关注数据块在辅存的放置位置 关注数据块在内存缓冲区的放置位置 通常视为操作系统的一个组成部分 基本I/O管理程序 负责所有文件I/O的初始化和终止 维护处理设备I/O，调度和文件状态的控制结构 选择要执行I/O的设备 关注调度磁盘和磁带访问以优化性能 I/O缓冲区的指定和辅存的分配 通常视为操作系统的一个组成部分 逻辑I/O 使用户和应用程序能够访问记录 提供一种通用的记录I/O能力 维护文件基本数据 访问方法 文件系统中与用户最近的一层 提供应用程序和文件系统以及保存数据的设备之间的标准接口 不同的访问方法反映了不同的文件结构以及访问和处理数据的不同方式 ??? 文件管理功能 用户和应用程序通过文件操作与文件系统交互，通过目录确定文件的位置。 授权用户以特定的方式访问特定的文件； 用户通过文件操作函数，基于字符流／或记录来操作文件； 系统对文件的I/O是以块为单位，基于块来完成输入／输出； 操作系统需要为文件在磁盘上分配空闲块，同时还需要管理空闲空间。 文件管理的要素 ？？？ 文件的组织和访问（重点）文件组织 (file organization) 指文件中记录的逻辑结构，由用户访问记录的方式确定。 选择文件组织的 5 个重要原则： 快速访问 易于修改 节约存储空间 维护简单 可靠性 原则的优先级取决于使用文件的应用程序。 五种基本文件组织： 堆 顺序文件 索引顺序文件 索引文件 直接或散列文件 堆文件 最简单的文件组织形式 按照到达的顺序收集数据 每条记录由一串数据组成 目的是积累大量数据并保存 通过穷举查找方法检索记录 堆文件 顺序文件 最常见的文件组织形式 记录有固定的格式 所有记录的长度都相同：每个域的位置、长度等相同 每个记录中有一个关键域，唯一标识这个记录 记录按照关键域存储和排序 通常用于批处理应用中 可以很容易地存储在磁盘和磁带 顺序文件 索引顺序文件 保留顺序文件的关键特征：记录按照关键域组织 增加了支持随机访问的索引和溢出文件 索引提供快速接近目标的查找能力 溢出文件类似日志文件，要往文件中插入记录时，可以将其放在溢出文件中，并由主文件中它(即所插入记录)的前一个记用指针指向它 可按批处理方式合并溢出文件 索引可以有多级，类似于多级页表 索引顺序文件 索引文件： 只能通过索引访问记录 可以使用变长度记录 完全索引包含主文件中每条记录的索引项 部分索引只包含有感兴趣域的记录的索引项 主要用于信息及时性要求比较严格且很少对所有数据进行处理的应用程序 索引文件 直接文件或散列文件 直接访问磁盘中任意一个地址已知的数据块 使用基于关键字的散列 典型应用场景： 快速访问； 固定长度的记录 一次只访问一条记录 例子: 目录 价格表 调度 名字列表 文件目录文件目录里每个文件项包含的信息： 基本信息 地址信息 访问控制信息 使用信息 硬链接硬链接目录不允许目录链接，防止目录套娃（ggd） 文件分配方法（重点）","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.lyh543.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"软件工程 重点","date":"2020-09-07T12:24:32.000Z","path":"computer-science/software-engineering-classnote/","text":"教材（据说很烂）： 软件工程——共同演进的方法和实践 本门课程的判断题对的居多（？还有这种操作） 第一章 软件工程背景知识重点 软件的四个组成成分（等式）、组成成分的定义（PPT） 软件的特点（书上大标题，简答题） 软件的双重作用 软件工程的目标（一句话） 软件工程的七原则（大标题） IEEE 软件工程知识体系涵盖的十个方面（大标题） “缺乏有力的方法学的指导和有效的开发工具的支持，这往往是产生软件危机的原因之一。” 软件危机的表现（书上） PPT 上 Misunderstanding &amp; Reality 软件工程中文档的作用是什么 提高软件开发过程的能见度 记录开发过程的有关信息，便于使用与维护 作为开发人员阶段工作成果和结束标志 提高开发效率 提供软件运行、维护、培训的有关资料 便于用户了解软件功能和性能 题 软件产品的开发主要是（研制） 软件是一种（逻辑产品） 软件工程的出现主要是由于（软件危机的出现） 第二章 软件过程模型重点 软件过程模型的定义是什么？列举至少四种模型 定义补充：软件过程模型能直观表达软件开发全过程，明确规定要完成的主要任务、活动和开发策略 瀑布模型：线性、文档驱动 瀑布模型适用于 xx 情况 瀑布模型的特点（一二点背标题、三点全背）、缺点（全背） 螺旋模型：风险驱动 优缺点（全背） 增量模型：增量是可以运行的，程序的运行版本在早期就可以得到 优缺点、需要注意的问题 适用于软件需求不明确、设计方案有一定风险的软件项目 如何选择过程模型（PPT 背第三点） 软件工程以质量为中心，软件过程、方法和工具为三要素（工具不是过程模型） 软件生存周期分为几个阶段，每个阶段的提交x是什么 可行性研究、项目开发计划 -&gt; 项目开发计划、可行性分析报告 需求分析 -&gt; 软件需求说明书 概要设计 -&gt; 概要设计说明书 详细设计 -&gt; 详细设计说明书 编码 -&gt; 源程序清单 测试 -&gt; 测试报告 维护 -&gt; 维护报告 CMMI 五个级别的名字和侧重点 增量模型和螺旋模型的异同点？ 相同：都是非整体的、迭代式开发方式 不同： 迭代层级不同：增量模型为活动级的迭代；螺旋模型是过程级的迭代 需求分析时间不同：增量模型常先做总体需求分析和设计，再编码和测试逐个增量包开发；螺旋模型在开发周期内采用瀑布模型 交付软件的方式不同：增量模型每次增量开发都在上一次增量的基础上提交新的一部分软件；螺旋模型每次迭代每次提交一个新的软件版本 减少风险的方式不同：增量模式通过避免使用未成熟的技术和经常的客户反馈等方法减少风险；螺旋模型则是直接引入风险分析 题 大多数软件系统不容易变化，除非他们在设计时考虑了变化（√） 目前的绝大多数软件都不适合快速原型模型（x，其实绝大多数适合） 下面按个选项不属于能力成熟度模型的级别（重复级、确定级、高效级√、优化级） （原型化方法）是用户和设计交换最频繁的方法 对增量模型，以下叙述错误的是（C）A. 使用增量模型开发软件时，把软件产品分解为一系列的增量构建来设计B. 增量构建的开发可以采用瀑布模型C. 第一个增量构建往往实现软件的高级功能D. 采用增量模型比采用瀑布模型和快速原型模型更需要精心的设计 常用的三种软件过程模型：瀑布模型、演化模型、增量模型 第三章 需求分析重点 需求的定义（背） 功能性需求和非功能性需求的定义和区别（背，理解例子，列举五种非功能性需求） 需求分析的 4 个步骤的定义 需求分析的主要任务：PPT + 准确定义未来系统的目标，确定为了满足用户的需求，系统应该做什么，并用需求规格说明书规范的形式、准确地表达用户需求 结构化分析方法要建立哪三种模型，（以什么为核心），每个图分别对应哪种建模 数据流图的四种符号 数据流图中的每个加工至少有一个输入和一个输出 结构化分析方法的分析策略是（自顶向下、逐步求精） 讲过的图的名字（UML、部署图、顺序图（时序图）等） UML 中动态模型的描述工具：顺序图、活动图、状态图 用例图由哪些元素组成？主要用途？ 元素：用例、参与者、关系、系统 用途：用于需求的获取、定义和分析 UML 中什么是参与者？可以通过提出什么问题来明确参与者？（PPT） 谁或者什么。。。。。。 画用例图（注意可能有 include 和 extend） 顺序图的组成元素：类、角色、生命线、对象、激活期、消息 用例图是显示一组用例、参与者、以及他们关系的图；用例图从用户的角度（而不是开发者）描述对软件产品的需求，分析产品所需的功能和动态行为 用例图的作用：用来对需求建模，用例图是至关重要的，他的正确与否直接影响了用户对最终产品的满意度 用例图的内容是：参与者、用例、泛化、扩展和 xxxx 题 数据流图的组成元素中，（数据流）用于描述数据处理所需的输入或输出 在 UML 图中，（顺序图）图用于描述为实现一个用例多个对象之间动态的交互关系，以及的对象的生存期 UML 状态图可以用来描述多个对象之间的行为协作（×）因为顺序图是多个对象之间的 状态图是一个对象的 有效的需求变更管理需要对变更带来的潜在影响及可能的成本费用进行评估。（√） 需求分析和设计，在这两个阶段主要确定目标系统的（逻辑模型），不涉及软件的（物理实现） UML 状态图用于描述一个对象所能达到的所有状态以及引起状态改变的（事件） UML用例图中，（包含）用例是指经过封装后可以在各种不同的基本用例中复用的用例（但实际意思是被包含，这是答案的问题） 以下针对需求分析作用的描述中，错误的是（B）A. 使开发者和用户对需求达成一致B. 使程序接口定义明确C. 使开发工作有章可循D. 使测试有理可依 如果使用增量模型，任何需求都可以很好控制（√） UML 活动图用于描述一个对象所能到达的所有状态以及引起状态转变的事件。（x）活动图没讲，其实是状态图 软件需求可以分为哪两类？软件需求过程包括哪几个阶段？ 分类：功能、非功能需求 阶段：需求获取、分析、定义 出现软件缺陷的首要原因是 / 项目失败的首要原因是（B）A. 设计技术不成熟B. 需求不清C. 代码错误D. 进度压力 （B）这一活动开始时作为系统工程或业务过程的一部分，接下来作为软件需求分析的第一步。A. 确定软件开发过程B. 定义产品的目标和范围C. 进行项目估算D. 定义项目度量 如下图 成员方法是指向自己的 私有方法是 13 题 - A 卷 13 题 - A 卷图 13 题 - B 卷 13 题 - B 卷图 第四章 软件设计工程 软件设计包含两类主要活动：教材 45 页后，背下来 创新设计不属于软件设计（而是需求分析、需求定义的一部分） 模块划分不是划分越多越好（接口会变多，形成 U 形的） 简述模块化和软件成本的关系 模块的扇入数大好不好？什么情况下好/不好？ 衡量模块独立的两个标准：内聚、耦合（分别表示什么含义） 独立性强的模块应该是（高内聚）、（低耦合）的模块 内聚、耦合的集中类型的定义和含义 顺序内聚那页 PPT 看一下（包括例子） 内部耦合那页 PPT 设计应该是（模块化的），换言之，软件应该在逻辑上划分为多个模块和子系统 结构化设计的基本思想：将系统设计成由相对独立、功能单一的模块组成的层次结构（√） 要去理解程序结构的深度、宽度、扇入数、扇出数 重构的定义 P50 4.3.7 第一段话最后引号内 设计 = 概要设计 + 详细设计 概要设计 = 体系结构设计 + 接口设计 + 数据设计 用户界面设计由一系列的分析开始（三种分析 背 PPT） 接口方面 = 内部接口 + 外部接口 外部接口 = 软件和硬件、其他软件的接口；软件和用户的接口 根据信息隐藏原则，模块……（P49 书上原话） 信息隐藏原则有利于提高模块的内聚性 五种架构风格：数据中心架构（包含黑板架构）、数据流架构、调用和返回架构、面向对象架构、层次架构 结构化程序定义：。。。。看 PPT 流程图的主要缺点 看 PPT 三点 体系结构的另一种分类：单主机结构（集中式体系结构）、分布式结构、（？） 第七章 软件测试技术 软件测试的基本原则（只背标题，但要理解意思） 软件测试的目标（7 条标题） 什么情况下叫发生了一个软件缺陷（5 点） 软件测试只能证明程序有错误，不能证明没有错误 软件测试的各个阶段只能有测试员而不能由程序员自己进行（×），模块测试可以 测试用例的定义（3 部分） 软件测试的评估准则（3 点，背名字） 覆盖率的定义？能否达到 100 %？为什么？ 测试与质量保证（84 页第 3 点）“软件测试人员的目标是……” 白盒测试、黑盒测试、灰盒测试定义（86 页） 是由独立的测试人员吗 需要有编程能力吗？（有，因为白盒测试） 简述软件测试和软件调试的相同点、不同点（86 页软件调试与测试全背） 测试用例的测试应该力求（）而非着眼于是正确的（85 页 7.1.3） 根据不同的覆盖准则设计测试用例 各种覆盖的强弱关系（并非单调递增，PPT 的反例） 分支覆盖又叫判定覆盖 基本路径测试（可能出大题）画控制流图、基本路径 测试用例 基本路径集合不是唯一的，但路径数目唯一 黑盒测试的三种方法 状态测试的定义 错误猜测法、因果图法（P109 第三点 继承测试用例 第二段的最后一句话） 大题用边界值分析 静态范围的测试很广……（目的，基本思想，P95） 通用评审过程 6 个步骤名（大部分问题在“准备”发现） 评审的三种类型名（P96）哪种是正式的 题 为了提高测试的效率，应该（在完成编码以后指定软件的测试计划） 下列评审类型中不属于静态评审类型的是（自查） 软件测试的目的是（尽可能多地发现软件系统中的错误） 在黑盒测试中，边界值分析法作为等价类划分法的（有效补充） 在等价类划分方法中。既可以定义为输入等价类，也可以定义为（输出等价类） 第八章 软件测试策略 四个级别的测试，其主要目的（测试依据）是什么（P101） 系统测试的定义（P109最后一行）、理解验收测试的关注点，测试用例是如何得到的，是否需要客户的参与（P111）；在多个级别中进行 改进的 V 模型中，测试的计划和用例要提前，一旦有了xx就可以测试xx 理解回归测试，回归测试可以在所有测试级别下进行，并可应用在功能和非功能测试中；应该尽量采用自动化测试 四个测试分别应使用白盒/黑盒方法？ 驱动模块、桩模块的含义；被测试模块需要驱动模块的时候，测试样例通常是在驱动模块中进行 单元测试的主要内容（五个方面，P104）整段话背下来 为什么单元测试的依据不是代码（P104 图上两句话） 集成测试有哪三种集成方法（自顶向下、自底向上、Smoke） 自顶向下、自底向上集成测试的定义及优缺点（P107、108） 自顶向下鉴真式测试法有两种组合策略：深度优先策略和广度优先策略 五种系统测试策略的名字 压力测试：“高一个数量级” 现场测试：α测试、β测试的定义 题目 单元测试主要针对模块的几个基本特征进行测试，该阶段不能完成的测试是（A）A. 系统功能B. 局部数据结构C. 重要的执行路径D. 错误处理 不属于系统测试的主要内容是（接口测试） 系统测试是把软件、硬件、环境连在一起的全面测试（√） 单元测试时，对所有出错处理的路径都要测试。（√） 第五章 生产率度量 软件生产率度量基于功能点（间接）的度量和代码量（直接）的度量 FP 计算（表格后公式都会给） FP/LOC 的相关度量 LOC 的优缺点（背） LOC、FP 的换算 不要苛刻。。。。。。。。。（√） 成本估算的方法之一是 COCOMO 模型 题 软件的功能和质量是不可测的，现有的评价依据都是主观评价（×，度量） 问题分解不适用于（A）A. 对软件详细设计B. 进行项目估算C. 制定项目计划D. 细化软件功能 第九章 软件维护 ISO 2008 对软件维护的定义（P118） 到第一个句号 维护是软件生命周期花费最多的时间（测试也很多） 四种维护，及占的百分比 软件维护随时间，纠错性维护的工作量逐渐降低 软件维护的必要性，七点（P118） 软件维护的困难性，四点 可维护性的定义` 估算维护工作量的模型，理解四个参数 软件维护技术：程序理解、软件正向工程、软件逆向工程 软件再工程的定义 软件逆向工程的主要内容、看下过程 P-CMM 是什么，五个级别名称 P137 图 第十章 软件项目管理 项目管理的四个要素，最重要的 三种团队组织形式、名字、缩写 沟通是横向的还是垂直的？那种会带来更高的士气和满意度？模块化程度高/低的适合哪一种？ 团队有没有/有一个/多个领导者？ 虚拟团队的定义、优缺点；对虚拟团队，目标是最重要的方面 产品下面的第一句话 P135 第二段 软件项目管理的第一个活动：确定软件范围 项目估算的方法：分解技术、经验模型 P146 10.6.2 第一段前两句话、最后一段 产品的前两句话（P135 第二段） 知道问题分解是用来干什么 软件质量保证涵盖整个开发过程","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程","slug":"软件工程","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"电子科技大学四年游记","date":"2020-09-04T12:52:59.000Z","path":"others/something-about-uestc/","text":"本文更新于 2020.10.18，文中信息可能已失效。 常用网址最常用的网站推荐直接记域名，直接敲域名比在官网反复跳转快多了。 教务系统：http://eams.uestc.edu.cn/eams 一卡通，可进行挂失：http://ecard.uestc.edu.cn 学生邮箱（注意事项）：http://mail.std.uestc.edu.cn 教务处：http://www.jwc.uestc.edu.cn 教务系统联系方式一览表：http://www.jwc.uestc.edu.cn/web/News!view.action?id=64 校历、全校课表、培养方案（电子版）、各类（查分、转专业）申请表、均可在教务处网站搜索到 清水河畔（校内论坛）：https://bbs.uestc.edu.cn/ 校车 396路 通勤车时刻表：https://bbs.uestc.edu.cn/forum.php?mod=viewthread&amp;tid=1430861 返校代理（注意事项）：https://vpn.uestc.edu.cn/ 图书馆预约研修室：http://reservelib.uestc.edu.cn/ 视觉形象识别系统（校徽矢量图6‘哦p、PPT 等资源）：https://vi.uestc.edu.cn/ 在线教材（官方只提供了少部分教材，且几乎没有课程提供 PDF）：http://zxkc.uestc.edu.cn/ 学校官网是 www.uestc.edu.cn，必须加 www！uestc.edu.cn 域名是没有 A 记录的。教务处网站也是如此。 关于学校地址中/英文官网拉到最下面即是。 中文 英文及邮编 清水河 成都市高新区（西区）西源大道2006号 No.2006, Xiyuan Ave, West Hi-Tech Zone, 611731 沙河 成都市建设北路二段四号 No.4, Section 2, North Jianshe Road, 610054 九里堤 成都市九里堤西路8号 610031 关于学生邮箱 学生邮箱无需“激活账号”，可直接登录，默认密码是身份证号倒数第七位至倒数第二位。 目前尚不清楚学生邮箱在大一进校以后多久可用，保守估计这个时间在一个月以内。 学生邮箱可用于申请： 一个包含 1T Onedrive 空间的账号 JetBrains 全家桶 使用学生证还可以认证 GitHub Student Developer Pack 由于泥电学生邮箱是外包的且没有购买 SSL 证书，在邮箱客户端使用 IMAP、POP3 等不能使用 SSL 证书进行验证。强制要求 SSL 的客户端（如 Outlook for Android）似乎无法登陆学生邮箱（安卓上可使用 Gmail for Android 代替）。 由上条原因，以及推送可能不及时等问题，建议仅将学校邮箱用于申请上述学生优惠，不要作为主力邮箱。 关于返校代理登录 https://vpn.uestc.edu.cn/ 后即可通过在浏览器中修改网址达到用学校 IP 访问任意网址的效果。 http://www-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/ 将会代理到 https://www.uestc.edu.cn/可见，将原网址中的 . 改写为 - 即可成功代理。 以下为更多规则： 规则 例子 实际访问网站 原网址中的 . 需改写为 - 原网址中的 - 需改写为 -- 访问指定端口，需在后面加上 -&lt;端口号&gt;-p http://www-uestc-edu-cn-80-p.vpn.uestc.edu.cn:8118/ http://www.uestc.edu.cn:80/ 以 https 协议访问，需在最后加上 -s http://www-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/ https://www.uestc.edu.cn/ 以 https 协议访问指定端口，使用 -&lt;端口号&gt;-p-s http://www-uestc-edu-cn-443-p-s.vpn.uestc.edu.cn:8118/ https://www.uestc.edu.cn:443/ 关于认证登录页面连上 UESTC-WiFi 后如果没有弹出认证登录页面，可手动输入 http://wifi.uestc.edu.cn/ 或 http://10.253.0.213/ 关于 eduroam 的账号密码 来源：https://info.uestc.edu.cn/info/1044/1631.htm eduroam 联盟用户连接 SSID：eduroam，802.1x 认证，为全球 eduroam 联盟成员提供上网服务，eduroam 联盟内全球漫游。 我校师生的用户名为：工资号或学号@uestc.edu.cn，如：工资号 123456 对应的账号为 123456@uestc.edu.cn，密码为统一身份认证密码。 关于全校必修的学分这类课程是全校必修（大概），都是去研究院大楼上，应该不会算保研的吧（至少计院 2017-2020 年保研政策都没有，具体还是看各学院的文件），所以“60 万岁，多一分浪费”，放轻松就好。 以下内容为我个人经验，仅供参考，可能根据学院、年份和上课时段有差异。 电装实习我在 2019 年 10 月（大二上）的时候参加了电装实习。 电装实习就是电焊工，按照图纸将零件插入 PCB 板，然后用电烙铁将零件固定上去即可。具体制作的东西根据分组而不同，我做的是无线耳机（其实就是一个 FM 发射器 + 一个收音机）。 课程总时长： 第一天晚上讲授（开始前会发一张 A4 纸，要抄 PPT 上的笔记，结束时上交）+ 初步制作 第二天全天完成制作 基础工程训练基础工程训练共 12 周课时，每周学习一上午/一下午/一晚上。 该课程的每周内容、授课老师均不同。具体分组和课表可见“何倩鸿老师”微信公众号。 “何倩鸿老师”微信公众号 其中，每节课的大致内容如下： 课程名 课程内容 摸鱼攻略 下轮 即轮空、放假的意思。因此 12 周的课时被安排到了 1-17 周，其中有 5 周是放假或“下轮” 放假 yes 数控课 在二楼机房学习 G-Code 编程基础。课后会有一道检测题，题目每年都相同，可以问学长要答案代码 无需听课，可带电脑摸鱼 数控编程 数控课的高阶版。课后没有检测 无需听课，可带电脑摸鱼 数控车 使用自动化车床打磨器件，需要将“数控课”的课后代码输入进车床 7 人一组，有机会摸鱼 数控铣 使用自动化车床铣器件，需要做一些基础工作，以及调用程序代码 9-10 人一组，有机会摸鱼 数控雕铣 使用 MasterCam 软件画自己喜欢的图案，完成以后老师将图案雕在铁块上 10 人一组画两个图，有机会摸鱼 铣工 手工使用机器打磨器件 4 人一组，不方便摸鱼 钳工 1、2 即所谓的“磨锤子”，两周完成 2 人一组，不方便摸鱼，但挺好玩 特种加工 操作电脑调用代码完成电火花切割；课上会有时间写实验报告，记得带实验报告 10 人一组，每组只需要操作两分钟，很水 钣金 手工冷加工薄金属片，即不加热，靠剪、轧操作 每个人都要做，不水，不过是流水线作业，不懂直接问前后的同学就可以了 车工 手工操控车床把圆柱形原件切割出形状 6 人一组，有机会摸鱼 焊接 有经常看到的电焊以及高端的激光焊接 6 人一组，每组有一个人做，其他人看，很水 我参加的是晚上场，十点左右结束。无论做得好坏/做没做完，到点了一定会结束（所以不用担心做不完回不了寝室）。不过好坏会稍微影响分数。 另外，课程结束后需要提交实验报告，而实验报告必须使用教材附赠的版本，不能复印。也就是说，强制购买教材。 最后的实验报告水一水就可以了，我把实验报告用非常潦草的字体填满就交了，最后总分 86。反正不计入保研，六十万岁 电工电气实训电工电器共 10 周课时，每周学习一上午/一下午/一晚上。 该课程主要学习电工知识，虽然部分东西很复杂，但某些常识也最好要掌握（要不可能以后换个电灯泡都不会换hhh）。内容如下： 周时 课程内容 第一周 安全知识介绍 第二周 使用 220V 三相电和变压器点亮 3 个电灯泡 第三周 使用时延开关、双刀双掷开关、镇流器、启辉器等点亮日光灯 第四周 画电路图（可参考之前时段上课的同学） 第五周 使用 220V 三相电、自锁开关、按钮开关等启动电机 第六周 使用 PLC 编程一个跑马灯（这周的内容不会写进实验报告） 第七周 使用 PLC 编程回转搅拌供料单元 第八周 使用 PLC 编程机械手 第九周 使用 PLC 编程传送带，以及将七至九周的内容串联起来 第十周 使用 MCGS 组态软件编程触控屏 这门课的两个部分各要交一个实验报告。 我参加的是晚上场，十点左右结束。无论做得好坏/做没做完，也是到点了就一定会结束。 体测大学生体育测试是教育部要求的，每年测一次。 $$总分=\\frac{\\sum{前三年成绩}}{3} \\times 50\\% + 第四年成绩 \\times 50\\%$$ 每次测试满分 100 分，总分 &gt; 60 为及格，但 总分 &gt; 50 即可毕业（所以及格这个标准没什么用的）。 男女生都要测的项目有：身高体重、立定跳远、肺活量、坐位体前屈、视力、50m（视力不计入总分） 男生要测的项目有：1000m、引体向上 女生要测的项目有：800m、仰卧起坐 有图片形式的评分细则但是我懒得找了。 据某辅导员说，没有因为体测而比不了业的先例。这究竟是为什么呢，小编也不知道。 关于培养方案、选课指南 2020 届本科培养方案 pdf，其他届的可以在“上一篇”/“下一篇”找到 选课指南","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://blog.lyh543.cn/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"数据传输协议的速率（USB/PCIE）","date":"2020-09-04T11:51:04.000Z","path":"computer-science/data-transfer-protocol-speed/","text":"USB/雷电 以下速率均包含校验位。实际数据的传输速率达不到对应值。 以下速率均指单向最大速率。 协议 别名 别名 理论传输速率（含校验位） USB 2.0 480 Mbps USB 3.0 USB 3.1 gen 1 USB 3.2 gen 1 5 Gbps USB 3.1 gen 2 USB 3.2 gen 2 10 Gbps USB 3.2 gen 2 x 2 20 Gbps USB 4 20 20 Gbps USB 4 40 40 Gbps 雷电 2 20 Gbps 雷电 3 40 Gbps 雷电 4 40 Gbps PCIE 以下速率均包含校验位。实际数据的传输速率达不到对应值。 以下速率均指单向最大速率。 协议 数据/数据+校验位 理论传输速率（含校验位） PCIE 1.0 8b/10b 每条 2.5 Gbps PCIE 2.0 8b/10b 每条 5 Gbps PCIE 3.0 128b/130b 每条 8 Gbps PCIE 4.0 128b/130b 每条 16 Gbps","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"微信小程序开发的 tips","date":"2020-08-30T03:49:06.000Z","path":"front-end/wechat-mini-program-tips/","text":"在 iOS 设备上测试在开发测试过程中，我注意到 iOS 和模拟器、安卓设备等略有不同。如下： iOS 的 JavaScript 没有 Promise.finally()。可以自己在 app.js 中手动添加如下代码： 1234567891011121314App(&#123; OnLaunch() &#123; // ios 端没有 Promise.finally()，需要自己定义 Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) ); &#125;; &#125;&#125;) iOS 中 wx.showActionSheet 的 itemColor 参数仅支持 #000000 十六进制形式，不支持 red 等颜色（安卓/模拟器均支持）。 设置转发功能在需要转发的每个页面的 js 下添加 onShareAppMessage 函数即可。函数模板如下： 1234567891011121314151617onShareAppMessage: function (res) &#123; if (res.from === 'button') &#123; // 来自页面内转发按钮 console.log(res.target) &#125; return &#123; title: '云开发技术训练营', path: \"pages/home/home, imageUrl:\"https://hackwork.oss-cn-shanghai.aliyuncs.com/lesson/weapp/4/weapp.jpg\", success: function (res) &#123; // 转发成功 &#125;, fail: function (res) &#123; // 转发失败 &#125; &#125;&#125;, 如果想要自动设置所有页面的转发，可以参考 https://www.cnblogs.com/xyyt/p/12614181.html。 小程序配置的细节如删掉 tabBar、下拉小程序不出现空白、改变背景颜色、禁止页面下拉、自定义顶部导航栏。可见 https://cloudbase.net/community/guides/handbook/tcb09.html。 带参小程序码获取带参小程序码官方文档 带参数的微信小程序可以在服务器以 HTTPS 调用 API 或在小程序的云函数中获取。这里给出后者的示例代码。 由于 wxacode.get 总共只能生成十万个小程序码，因此我们使用 wxacode.getUnlimited。代价是，参数 scene 字符串长度不能大于 32。（openid 的长度为 28，数据库记录的 _id 长度为 32） 12345678910111213141516171819202122232425262728293031323334//云函数 index.js/*获取某活动的签到二维码文档：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html调用方法：wx.cloud.callFunction(&#123; name: \"get_check_in_wxacode\", data: &#123; id: activity_id, &#125;, success()&#123;&#125;, fail()&#123;&#125;&#125;*/const cloud = require('wx-server-sdk');cloud.init(&#123; env: cloud.DYNAMIC_CURRENT_ENV&#125;);exports.main = async (event, context) =&gt; &#123; console.log(event); console.log(context); try &#123; const result = await cloud.openapi.wxacode.getUnlimited(&#123; scene: event.id, path: 'pages/activities/activities' &#125;); return result; &#125; catch (err) &#123; return err; &#125;&#125; 注意，这个 API 获取的二维码在小程序发布之前都不能被正确识别，无论是微信扫码进入小程序亦或是小程序内 wx.scanCode()。在正式发布后，开发版/体验版/正式版都可以正确识别。 微信扫码进入小程序，可用以下方法在上述 path 页的 onLoad 函数中获取 scene 值： 1234onLoad(query) &#123; // scene 需要使用 decodeURIComponent 才能获取到生成二维码时传入的 scene const scene = decodeURIComponent(query.scene)&#125; 调用 wx.scanCode() 的识别方法如下： 1234567891011121314151617181920212223function resolve_url (url) &#123; let array = url.split('?'); let obj = &#123; __path: array[0] &#125;; if (array[1] != undefined) &#123; let option_arr = array[1].split('&amp;'); option_arr.forEach(element =&gt; &#123; let option = element.split('='); if (option.length == 2) &#123; obj[option[0]] = option[1]; &#125; &#125;); &#125; return obj;&#125;wx.scanCode(&#123; success: res =&gt; &#123; let path = res.path; // path='pages/activities/activities?scene=xxxxxxxx' let obj = resolve_url(path); const scene = console.log(obj.scene); &#125;&#125;) 小程序码处理小程序中需要将获取的 result 中的 buffer 转为 base64 编码，即可作为 wxml 的 &lt;image&gt; 控件的 src 参数，呈现在屏幕上。 12345678910111213141516171819wx.cloud.callFunction(&#123; name: \"get_check_in_wxacode\", data: &#123; id: app.globalData.current_activity._id &#125;, success(res) &#123; let wxacode_url = \"data:image/png;base64,\" + wx.arrayBufferToBase64(res.result.buffer); that.setData(&#123; wxacode_url: wxacode_url // 可作为 wxml &lt;image&gt; 控件的 src 参数 &#125;) &#125;, fail(err) &#123; console.log(err) wx.showToast(&#123; title: '获取签到二维码失败 请联系管理员', icon: 'none' &#125;) &#125;&#125;) 效果图 更新：大图预览和下载功能可以直接调用 wx.previewImage() 一行代码完成，不用下面这么麻烦。 配合 WeUI 小程序的 gallery 控件即可实现大图预览功能。 图片下载功能，同样是利用 base64 编码的文件。申请权限以后，先用 base64 编码的字符串 wx.getFileSystemManager().writeFile() 生成临时文件，再将临时文件 wx.saveImageToPhotosAlbum() 保存到相册。微信 API 会保存到默认的相册位置（安卓版微信 7.0.16 会保存到 /sdcard/Pictures/Weixin），且不会向小程序返回路径或文件名。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647downloadWxacode() &#123; let that = this; wx.authorize(&#123; // 申请权限 scope: \"scope.writePhotosAlbum\", success: res =&gt; &#123; wx.getFileSystemManager().writeFile(&#123; // 存到临时文件 filePath: wx.env.USER_DATA_PATH + '/temp.png', data: that.data.wxacode_url.slice(22), // 把 data:image/png;base64, 去除 encoding: 'base64', success: res =&gt; &#123; wx.saveImageToPhotosAlbum(&#123; // 存到相册 filePath: wx.env.USER_DATA_PATH + '/temp.png', success: function (res) &#123; console.log(res); wx.showToast(&#123; title: '保存成功', icon: 'none', duration: 5000 &#125;) &#125;, fail: function (err) &#123; console.log(err) wx.showToast(&#123; title: '保存失败', icon: 'none' &#125;) &#125; &#125;) &#125;, fail: err =&gt; &#123; console.log(err) wx.showToast(&#123; title: '保存失败', icon: 'none' &#125;) &#125; &#125;) &#125;, fail: err =&gt; &#123; console.log(err) wx.showToast(&#123; title: '没有写入相册的权限', icon: 'none' &#125;) &#125; &#125;);&#125; 绕开审核限制 更新于 2020.9.14，之后可能失效 我实现了一个社团活动管理的小程序，任何人可以创建活动，但审核的时候，“创建活动”这个功能导致小程序没有通过审核，大概意思就是个人小程序不能作为信息公开的平台。 去开个公司专门用于审核肯定是不现实的。于是，就只能和审核员斗争了 经过观察，我发现审核员只是测试功能，不会动代码/数据库。 因此，我加入一段代码，每次启动时读取数据库配置，如果存在 can_upload: true，才显示添加活动相关组件，否则就不显示。成功通过审核。 当然，以后也可能有复查导致小程序下架，不过我目前还没有被下架/警告过。","tags":[{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.lyh543.cn/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.lyh543.cn/tags/JavaScript/"},{"name":"tips","slug":"tips","permalink":"https://blog.lyh543.cn/tags/tips/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.lyh543.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Visual Studio Code 使用小技巧","date":"2020-08-29T00:40:23.000Z","path":"microsoft/vscode-tips/","text":"常用快捷键 快捷键 作用 Ctrl+Shift+F 在当前文件夹下的文本文件中搜索文本内容 Ctrl+P 在当前文件夹下的文本文件中搜索文本名 Ctrl+Shift+P 执行命令（大部分没有提供入口的插件可以在这里找到入口） 插件推荐 插件 备注 VS Code 同步设置 跨设备用户必备 Git Graph 在 Git 目录下 VS Code 的状态栏显示 Markdown All in One Markdown 必备 图床 Markdown 必备 HTML 服务器 Web 前端必备 wsl 中调用 VS CodeVS Code 对 wsl 的支持还是非常不错的。在 wsl 中执行 1code 即可调用 Windows 的 VS Code，并可以在 VS Code 看到 wsl 的目录。 字数统计用正则表达式统计代码行数 参考 https://www.jianshu.com/p/972a07c241b0 一行中第一个非空字符不是 / 或 # 或 { 或 } 的行 1^\\s*[^\\s/#&#123;&#125;]+.*$ 在 VS Code 中在某个文件夹下按 Ctrl+Shift+F，用正则表达式，搜索结果数即为有效行数。 该方法对支持在目录下进行正则表达式搜索的编辑器均适用。 统计中文字符数用 LaTeX 写中文论文的时候，可以用这招统计字数。 1[\\u2E80-\\u9FFF]","tags":[{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"https://blog.lyh543.cn/tags/Visual-Studio-Code/"},{"name":"tips","slug":"tips","permalink":"https://blog.lyh543.cn/tags/tips/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://blog.lyh543.cn/tags/Microsoft/"}]},{"title":"Windows Terminal 使用小技巧","date":"2020-08-28T08:00:14.000Z","path":"microsoft/windows/windows-terminal-tips/","text":"添加到 PATH添加到 PATH 后，在 cmd 或者 VS Code 敲 wt 就能打开 Windows Terminal。 添加的方法就不多说了，看图。 添加到 PATH 右键菜单“Windows Terminal Here”最近的新版本 Windows Terminal 也有一个 Open in Windows Terminal，但不是很好用：使用 Open in Windows Terminal 的窗口是在自己的路径的，但在这个窗口新起的标签页就又变成了 C:\\Windows\\System32。希望之后能修复这个 bug，目前可以用下面这个方法解决。 将以下文本粘贴到一个空 txt 后，改为 reg 格式。然后双击导入注册表即可。 1234567891011Windows Registry Editor Version 5.00; 添加 Windows Terminal Here[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@&#x3D;&quot;Windows Terminal Here&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@&#x3D;&quot;wt.exe&quot;; 删除自带的 Open in Terminal[-HKEY_CLASSES_ROOT\\PackagedCom\\ClassIndex\\&#123;9f156763-7844-4dc4-b2b1-901f640f5155&#125;] 注：还需要配置启动目录为 null，见配置文件。 效果 配置文件我的 Windows Terminal (v1.8.1521) 配置文件因为太长，故以文件形式放出。","tags":[{"name":"tips","slug":"tips","permalink":"https://blog.lyh543.cn/tags/tips/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://blog.lyh543.cn/tags/Microsoft/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.lyh543.cn/tags/Windows/"},{"name":"Windows Terminal","slug":"Windows-Terminal","permalink":"https://blog.lyh543.cn/tags/Windows-Terminal/"}]},{"title":"Web App 开发入门的第 0 步","date":"2020-08-16T02:39:42.000Z","path":"development/about-web-app-development/","text":"由于微信小程序需要审核且要求严格，想要把微信小程序移植为网页端的 Web App。就花了一晚上初步了解了一下，得到了一些入门的结论，因此也是给了“杂谈”的标签。 程序结构对于微信小程序，只需要写前端的 WXML + WXSS + JS（分别对应 HTML + CSS + JS）就可以了。 而对于一个 Web App，仅有前端则不够。因为 Web App 前端是不能直接访问数据库的。 如果前端能直接访问数据库，那么任何人都可以在浏览器中修改前端代码，以任意方式访问数据库。（而微信小程序代码不开源、不能修改，并且小程序的云数据库只能从小程序中访问，所以直接访问数据库也不会有安全问题）。 对于数据库访问的解决办法，是在数据库服务器上用 node/Django 搭建一个后端，作为前端和数据库的桥梁。前端 JS 和 后端 node/Django 交互，node/Django 和数据库交互。 前端框架前端框架流行的有 Angular、React、Vue。但框架是什么？ 上述框架对于 JS 就类似与 Qt 对于 C++。 框架本身是基于其原生语言编写的； 框架的某些语法（如 Qt 的信号槽）能够让开发者快速实现原生语言需要写很多代码才能实现的功能（如使用 Qt 在 C++ 实现异步操作）； 框架代码在编译过程中也会被转为原生语言。 对于学习哪些框架，对于前端开发者当然是都得学，而其他开发者的话就是按需了 2333 Material Design 界面Material Design 大法好。 对于 Material Design 的实现，目前比较中意前两款： MDUI：仅包含 CSS 和 JS（JS 用于实现某些过渡动效），不依赖框架，直接改控件就行（理论上还可以应用到微信小程序上hhhh）。且有丰富文档：Material Design 指南中文版 MDUI 开发文档 Material-UI：基于 React 框架，包含了很多 React 组件。这里有一个 React 全家桶 + Material-UI 的项目。 Vuetify：基于 Vue 框架。电子科大的 ACM OJ 前端就是用 Vuetify 实现，并且开源在 GitHub，可供参考。 Materialize：也是不依赖框架，不过目前无中文文档。 后端框架如果想基于 Python，可以使用 Flask 或 Django。前者属于轻量级，数据库什么的插件需要自己找，自定义程度高；Django 插件很多（自带用户认证等），自己的 Model 兼容多种数据库，并且还有 Django REST Framework 这个 REST API 框架，能够迅速构建一个 REST API 后端。最终我采用的是 Django + REST Framwork 作为后端。 如果想基于 Java，Spring 也是一个不错的选择。我也是打算通过 Spring 后端学习一下 Java 基础，毕竟大多数后端工程师还是要求会 Java 的。 图标生成https://www.favicon-generator.org/","tags":[{"name":"项目开发","slug":"项目开发","permalink":"https://blog.lyh543.cn/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"杂谈","slug":"杂谈","permalink":"https://blog.lyh543.cn/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"JavaScript 入门","date":"2020-07-24T06:12:48.000Z","path":"front-end/javascript/","text":"运行 JavaScript在 Chrome 按 F12 打开“开发者模式”，即可在 Console 中输入 js 代码并运行。 运行 js 代码 JavaScript 语法基础 行尾需要 ; 注释为 // 字符串和 Python 相同，可用单/双引号，可使用 \\n \\\\ 等扩展 函数名推荐使用驼峰法来命名 camelCase 打印输出使用 console.log()。注意，在命令行执行的命令会被自动套上 console.log()，因此才会有输出。 12console.log(\"童鞋，欢迎开始JavaScript的学习~\\nJavaScript是一门非常流行的编程语言，只要是有浏览器的地方就少不了JavaScript；\\n网页、小程序、甚至App、桌面应用等都少不了JavaScript；\\nJavaScript玩得溜的人我们可以称其为前端开发工程师；\\n前端开发工程师是需求量极大的岗位\\n\");console.log('123%c456%c789', 'color: red', 'color: blue'); 注意，%c 配合后面的参数可以用于修改颜色。 修改输出颜色 数据数学运算123136+384; //加法(110/0.5+537-100)*2; //加减乘除2**5; //指数运算符 声明 letlet 用于声明变量。在脚本中，变量不能被声明第二次（调试窗口是可以的）。 12345let a; // 声明a = 1; // 赋值let b = 2; // 声明并赋值let a; // 重复声明，报错b = \"123\"; // 重新赋值为新的类型，允许 常量 const和 C/C++ 相同。只是少了变量类型。 12const window_weight = 3840;const window_height = 2160; 字符串字符串的函数真是太多啦！我们字符串真是太好啦！ 字符串文档 数组和 Python 类似，形式如同 [1, 2]，下标从 1 开始，并且不要求数组内元素同类型： 12movielist=[\"肖申克的救赎\",\"霸王别姬\",\"这个杀手不太冷\",\"阿甘正传\",\"美丽人生\"];Console.log(movielist[2]); // \"这个杀手不太冷\" 流程控制for有和 C++ 类似的 for，以及遍历数组的 forEach 成员函数。 12345678let str = '';for (let i = 0; i &lt; 9; i++) &#123; str = str + i;&#125;console.log(str);// expected output: \"012345678\" 1234567const array1 = ['a', 'b', 'c'];array1.forEach(element =&gt; console.log(element));// expected output: \"a\"// expected output: \"b\"// expected output: \"c\" 还有 for-of 和 for-in。for-of 和 forEach 都是遍历元素（for-of 好像完爆 forEach？），而 for-in 是遍历下标。对于 Object，for-in 还能遍历 key。 12345678910111213a = [9,8,7];for (let i of a) console.log(i)// 9// 8// 7for (let i in a) console.log(i)// 0// 1// 2 12345678910b = &#123;c:1, d:2&#125;;for (let i of b) console.log(i)// Uncaught TypeError: b is not iterablefor (let i in b) console.log(i)// c// d 常用函数文档 join() 将数组按指定分隔符拼接为字符串； push() 在数组末尾追加元素（返回值为新数组的长度）； pop() 返回并移除最后一个元素； 除此之外还有： concat() 返回由当前数组和其他数组/元素组合而成的新数组； reverse() shift() 返回并移除第一个元素； slice() 抽取当前数组中的一段元素组合成一个新数组，即 Python 的切片； sort() 原地排序数组； splice() unshift() 在数组开头追加元素（返回值为新数组长）； 用时再查阅文档。 对象对象赋值： 12345movie=&#123; name: \"霸王别姬\", img: \"https://img3.doubanio.com/view/photo/s_ratio_poster/public/p1910813120.webp\", desc: \"风华绝代。\"&#125; 读取对象： 123//两种方法都行console.log(move.name);console.log(movie[\"name\"]); 修改对象： 123movie.englishname = \"Farewell My Concubine\"; // 添加属性delete movie.img; // 删除属性movie.desc = \"人生如戏。\"; // 修改属性 函数与调用函数函数定义有非常多的形式： 123456789101112131415161718192021222324function square(number) &#123; return number * number;&#125;;square(5);// 匿名函数let square = function(number) &#123; return number * number&#125;;square(5)// 箭头函数（Arrow Function）const multiply = (x, y) =&gt; &#123; return x * y;&#125;const sum= (x, y) =&gt; x + y;// 连&#123;&#125;和return语句都可以省掉console.log(multiply(20, 4));console.log(sum(20, 4));// JavaScript 函数scrollToPosition() &#123;&#125;,yellowTap:function()&#123;&#125;, 需要注意的是，箭头函数中的 this 是 Window 而不会再是这个类。如果需要使用类，最好还是写匿名函数： 1234567891011// 匿名函数（定义在 Vue 中的 methods）// 输出 Vue &#123;_uid: 0, _isVue: true, $options: &#123;…&#125;, _renderProxy: Proxy, _self: Vue, …&#125;add: function () &#123; console.warn(this)&#125;// 箭头函数（定义在 Vue 中的 methods）// 输出 Window &#123;window: Window, self: Window, document: document, name: \"\", location: Location, …&#125;add: () =&gt; &#123; console.warn(this)&#125; 调用其他文件的函数如需要调用 /utils/date.js 中的 getDate() 函数。 在 date.js 中这样写道： 1234// date.jsexport function getDate() &#123; // function body&#125; 在需要调用的地方写： 123import &#123;getDate&#125; from '/utils/date.js';getDate(); // 即可调用 此外，如果在 date.js 中只有一个 export 函数，还可以默认引用： 1234// date.jsexport default function () &#123; // function body&#125; 在需要调用的地方写： 123import getDate23333 from '/utils/date.js'; // 可自定义函数名getDate23333(); // 即可调用 关于 import 和 export 更多的方法还可参考文章。 异步因为刚开始学习异步，再加上没有系统性的学习 Promise、await、async，仅作为开发工具，学了自己需要的部分，这里就不发表自己的拙见了。丢几个看过的文章链接： 阅读过的链接： 使用 Promise讲的非常详细。 理解 JavaScript 的 async/await Using await outside of an async function 异步Promise及Async/Await可能最完整入门攻略","tags":[{"name":"编程语言入门","slug":"编程语言入门","permalink":"https://blog.lyh543.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"},{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.lyh543.cn/tags/JavaScript/"}]},{"title":"CSS（萌新向）","date":"2020-07-23T03:26:56.000Z","path":"front-end/css/","text":"Cascading Style Sheets (CSS)，层叠样式表，用于为 HTML、XML 等代码添加样式。其优点在于，能够批量选择 XML 中的某些组件，然后进行批量渲染。 css 的参考手册：https://www.w3school.com.cn/cssref/index.asp 注释CSS 的注释使用 /*this is a commemnt*/。 选择器选择器就是选择一些组件，然后就可以对选择的组件进行批量美化。 选择器 样例 样例描述 .class .intro 选择所有拥有 class=”intro” 的组件 #id #firstname 选择拥有 id=”firstname” 的组件 element view 选择所有 view 组件 element, element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after view::after 在 view 组件后边插入内容 ::before view::before 在 view 组件前边插入内容 class 和 id 的区别是，id 往往是唯一的，而 class 表示了一类。 字体属性和文本属性选中了 title 类，并将其按照如下设置进行渲染。 12345.title&#123; font-size: 20px; font-weight: 600; text-align: center;&#125; 其中 font-size 是属性；20px 是值；font-size: 20px 合起来是声明。 更多方法可见： 字体属性 备注 font-family 规定文本的字体系列。 font-size 规定文本的字体尺寸。 font-weight 规定字体的粗细。 文本属性 备注 color 设置文本的颜色。 line-height 设置行高。 text-align 规定文本的水平对齐方式。 图片为图片添加圆角和阴影可以给图片添加圆角和阴影。 12345.imglist .img&#123; border-radius: 8px; box-shadow: 5px 8px 30px rgba(53,178,225,0.26); /* rgba 中的 alpha 为透明度，取值 0~1 之间，越靠近 0 越透明 */&#125; 圆角和阴影 圆形图片示例 XML： 123&lt;view class=\"imglist\"&gt; &lt;image class=\"circle\" mode=\"widthFix\" src=\"https://hackwork.oss-cn-shanghai.aliyuncs.com/lesson/weapp/4/logo.jpg\"&gt;&lt;/image&gt;&lt;/view&gt; 示例 CSS： 12345.imglist .circle&#123; width: 200px; height: 200px; border-radius: 100%;&#125; 圆形图片 盒模型盒模型教程：https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model 盒模型参数：https://www.w3school.com.cn/cssref/pr_padding.asp 常用大小单位英文|中文cm|厘米px|像素em|在 font-size 中使用是相对于父元素的字体大小 更多详见：https://www.w3school.com.cn/css/css_units.asp 背景属性 背景属性 备注 background 在一个声明中设置所有的背景属性。 background-color 设置元素的背景颜色。 background-image 设置元素的背景图像。 background-size 规定背景图片的尺寸。 background-repeat 设置是否及如何重复背景图像。 如，想要给 id 为 wxmlinfo 的 view 组件加一个背景颜色以及 id 为 studyweapp 的 view 组件添加一个背景图片： 123456789#wxmlinfo&#123; background-color: #dae7d9;&#125;#studyweapp&#123; background-image: url(https://hackwork.oss-cn-shanghai.aliyuncs.com/lesson/weapp/4/bg.png); background-size: cover; background-repeat: no-repeat;&#125; 渐变与动画见 https://cloudbase.net/community/guides/handbook/tcb05 包括创造渐变色图片 Gradient、滤镜 Filter、变形 Transform、过渡 Transition 和动画 Animation。 由于时间关系就不细看了。 导入其他配置文件1@import \"common.css\";","tags":[{"name":"编程语言入门","slug":"编程语言入门","permalink":"https://blog.lyh543.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"},{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.lyh543.cn/tags/CSS/"}]},{"title":"微信小程序开发入门","date":"2020-07-22T14:04:25.000Z","path":"front-end/wechat-mini-program/","text":"你真的需要微信小程序吗？首先，在入坑微信小程序之前，你需要想清楚这个问题。 微信小程序的优点有： 只需要写前端（Web App 一般需要前、后端），开发周期短 跨 Android/iOS 平台 有成熟的 WeUI 框架和控件可以使用，并且微信原生 API 非常多，官方文档为中文且很详尽 能够轻松做到 Serverless 云开发 云服务的各项服务都有免费额度，流量不大的开发者能够白嫖 为数不多但非常致命的缺点是： 需要严格审核，甚至于某些功能（如任意用户均可上传的留言板/公开相册/云盘等）无法上架小程序 微信小程序 API 随时可能变化，而小程序必须使用最新的 API（而不像 Pypi、npm 等可以使用指定版本的插件），可能导致原来的程序完全无法工作。如 wx.getUserInfo() 函数改版后，在用户未授权过的情况下调用此接口，将不再出现授权弹窗，会直接进入 fail 回调（详见《公告》)。 如图 常用文档链接 WXML 文档 WXSS 文档 CSS 参考手册 JavaScript 微信 API 文档 WeUI 框架代码 WeUI 图标 非常详细的官方入门教程 因为太详尽了，因此本博文很多部分都是直接复制教程。 文件结构和页面组成文件结构在开发者工具的编辑器里可以看到小程序源文件的根目录下有 app.js、app.json 和 app.wxss app.json：小程序的公共设置，可以对小程序进行全局配置，决定页面文件的路径、窗口表现、设置多 tab 等； app.wxss：小程序的公共样式表，可以配置整个小程序的文字的字体、颜色、背景，图片的大小等样式； app.js：小程序的逻辑（这个可以先放着，不用管） pages 文件夹：这里存放着小程序的所有页面，展开 pages 文件夹就可以看到有 index 和 logs 两个页面文件夹； 页面组成在每一个页面文件夹里都有四个文件，这四个文件的名称都是一样的，它们分别为： json 文件，和上面的 app.json 作用基本相同，只是 app.json 控制的是整个小程序的设置，而页面的 json 文件只控制单个页面的配置（因为有时候全局配置就够用了，所以页面配置有时候是空的）； wxml 文件（类似于 xml），小程序的页面结构，文字、图片、音乐、视频、地图、轮播等组件都会放在这里； wxss 文件（类似于 css），小程序的页面样式，和 app.wxss 一样是控制样式，而页面的 wxss 文件是控制单个页面的样式； js 文件，控制小程序页面的逻辑。 app.jsonjson 基本语法 大括号 {} 保存对象； 中括号 []保存数组； 各个数据之间由英文字符逗号 , 隔开； 字段名称（属性名）与值之间用 : 隔开，字段名称在前，字段的取值在后； 字段名称用 &quot;&quot; 给包着； app.json 配置app.json 的配置文档：https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html 默认的 app.json 如下： 1234567891011121314&#123; \"pages\":[ \"pages/index/index\", \"pages/logs/logs\" ], \"window\":&#123; \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"test\", \"navigationBarTextStyle\":\"black\" &#125;, \"style\": \"v2\", \"sitemapLocation\": \"sitemap.json\"&#125; window 是配置全局的页面设置，见 https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html。 pages 则是小程序的页面。默认展示第一项（这里是 pages/index/index）的内容。在 pages 中新增一项 pages/home/home，编译后会自动创建 pages/home 文件及页面组成中的四个文件。 wxml 和 wxsswxml刚才创建的 pages/home/home.wxml 的语法类似于 xml。 &lt;text&gt;pages/home/home.wxml&lt;/text&gt; 被称作组件。 &lt;text&gt; 被称为标签。 组件需要被开始标签和闭合标签包含，前面的 &lt;text&gt; 是开始标签，后面的 &lt;/text&gt; 是结束标签。 &lt;view&gt; 组件是可以嵌套写的，如： 123456&lt;view&gt; &lt;view&gt; &lt;view&gt;WXML 模板&lt;/view&gt; &lt;view&gt;从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; wxml 模板WXML 支持模板，即定义好会复用的 WXML 片段，然后在其他地方调用即可。 教程：https://cloudbase.net/community/guides/handbook/tcb09.html官方文档：https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/import.html wxsswxss 的官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html wxss 美化的知识和 css 相同，css 的参考手册：https://www.w3school.com.cn/cssref/index.asp 和 CSS 相同的知识就放在 CSS 中了。 较 CSS，WXSS 定义了新的单位：rpx。规定 750rpx 是一屏幕宽。如在 iPhone6（宽度为 375px）上，750rpx = 375px。 对于全局样式和局部样式（来源）： 定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。 链接和图片链接 navigator将一个小程序页面链接到另一个小程序页面的组件叫 navigator。 我们添加一个页面，路径为 /page/imgshow/imgshow。新的 app.json 部分代码如下： 123456\"pages\":[ \"pages/home/home\", \"pages/index/index\", \"pages/logs/logs\", \"pages/imgshow/imgshow\"], 在 /pages/home/home.wxml 加入以下代码： 123&lt;view class=\"index-link\"&gt; &lt;navigator url=\"../imgshow/imgshow\" class=\"item-link\"&gt;让小程序显示图片&lt;/navigator&gt;&lt;/view&gt; 此时编译运行，点击让小程序显示图片即可跳转到 /pages/imgshow/imgshow.wxml。 但是这里的 让小程序显示图片 并没有以超链接的形式给出，可以修改 wxss 以更改其样式。在 /pages/imgshow/imgshow.wxss 中加入以下代码： 1234567.item-link&#123; margin: 20px; padding:10px 15px; background-color: #4ea6ec; color: #fff; border-radius: 4px;&#125; 编译。效果如下： navigator 组件 点击蓝色部分即可跳转到对应页面。 图片 image对于图片，只需要知道怎么插入图片就行了。其他仅作了解，用到的时候再查。 插入图片先放文档：https://developers.weixin.qq.com/miniprogram/dev/component/image.html 将以下代码复制到 imgshow.wxml： 123&lt;view class=\"imglist\"&gt; &lt;image class=\"imgitem\" src=\"https://hackwork.oss-cn-shanghai.aliyuncs.com/lesson/weapp/4/weapp.jpg\"&gt;&lt;/image&gt;&lt;/view&gt; 图片展示 显示模式其中，image 组件共有 13 种 mode（其中 5 种缩放、8 种裁剪。参见 image 的文档）。如想“宽度不变，高度自动变化，保持原图宽高比不变”，则可以修改代码： 123&lt;view class=\"imglist\"&gt; &lt;image class=\"imgitem\" mode=\"widthFix\" src=\"https://hackwork.oss-cn-shanghai.aliyuncs.com/lesson/weapp/4/weapp.jpg\"&gt;&lt;/image&gt;&lt;/view&gt; 然后在 imgshow.wxss 给图片添加 wxss，指定宽度为占满屏幕： 123.imglist .imgitem&#123; width: 100%;&#125; 效果如下： 缩放模式 圆角和阴影还可以给图片添加圆角和阴影。 12345.imglist .img&#123; border-radius: 8px; box-shadow: 5px 8px 30px rgba(53,178,225,0.26); /* rgba 中的 alpha 为透明度，取值 0~1 之间，越靠近 0 越透明 */&#125; 圆角和阴影 圆形图片示例 XML： 123&lt;view class=\"imglist\"&gt; &lt;image class=\"circle\" mode=\"widthFix\" src=\"https://hackwork.oss-cn-shanghai.aliyuncs.com/lesson/weapp/4/logo.jpg\"&gt;&lt;/image&gt;&lt;/view&gt; 示例 CSS： 12345.imglist .circle&#123; width: 200px; height: 200px; border-radius: 100%;&#125; 圆形图片 背景此外，还支持修改文字的背景。参见 CSS。 卡片风格示例官方示例，有点好看。代码见网页最后。 示例 WeUI 框架WeUI 是一套小程序的 UI 框架，所谓 UI 框架就是一套界面设计方案。 有了组件，我们可以用它来拼接出一个内容丰富的小程序，而有了一个 UI 框架，就能让我们的小程序变得更加美观。 体验 WeUI 小程序这是微信发布的基于 WeUI 的模板小程序。 微信小程序码 代码地址：https://github.com/Tencent/weui-wxss 下载以后将 dist 文件夹下的代码导入 微信开发者工具，运行，即可得到上述效果。 不过，需要注意的是，WeUI 模板小程序中很多元素是使用 view 组件模拟，其效果不如对应的原生组件（如 button searchbar tabbar 等）。因此，使用模板前可以在文档中搜索一下是否有对应的原生组件。 使用 WeUI 在我们的项目的根目录新建 style 文件夹； 将模板中的 /dist/style/weui.wxss 导入我们项目中的 style 文件夹； 在我们项目的 app.wxss 添加一行代码： 1@import 'style/weui.wxss'; 按照官方代码的形式编写自己的代码，就能渲染成模板小程序的样子。 需要注意的是，这个小程序只使用 view 和 input 控件就渲染了绝大多数页面。包括 button 等也是用 view 渲染的。 不过实际编写中，由于 button 在配合表单等有更多的功能，可以使用 button，然后使用 WeUI 中的 class 作用于 button 之上。 Flex 布局(1)Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 官方教程上对示例代码有更加清晰的解释。 WXML： 12345&lt;view class=\"flex-box\"&gt; &lt;view class='list-item'&gt;Python&lt;/view&gt; &lt;view class='list-item'&gt;小程序&lt;/view&gt; &lt;view class='list-item'&gt;网站建设&lt;/view&gt;&lt;/view&gt; WXSS： 123456789101112131415.list-item&#123; background-color: #82c2f7; height: 100px; text-align: center; border:1px solid #bdd2f8; flex: 1; /*各版块 1:1 等分*/ display: flex; /*给 list-item 组件添加 display: flex 后，文字呈现水平居中的结构*/ align-items:center; /*垂直居中*/ justify-content: center; /*水平居中*/&#125;.flex-box&#123; display: flex; /*给 flex-box 组件添加 display: flex 后，三个 item 呈现左右而不是上下结构*/&#125; display: flex; 对于 flex-box 来说，就是让其内容左右分布；对于 list-item 来说，就是让其文字水平居中。 Flex 布局 Flex 布局(2)下面参考官方的 WeUI 小程序中的 Flex 重新编写以上代码。 其中 WXML 和 WXSS 都是参考 Git 仓库 的对应文件进行修改/照搬。 XML： 12345&lt;view class=\"weui-flex\"&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;Python&lt;/view&gt;&lt;/view&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;小程序&lt;/view&gt;&lt;/view&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;网页建设&lt;/view&gt;&lt;/view&gt;&lt;/view&gt; WXSS 直接复制对应的文件： 1.placeholder&#123;margin:5px;padding:0 10px;text-align:center;background-color:var(--weui-BG-1);height:2.3em;line-height:2.3em;color:var(--weui-FG-1)&#125; 最后记得在 /app.wxss 中 @import &quot;/style/weui.wxss&quot;;。 编译运行，效果图如下： Flex 布局 这也太香了吧。 JavaScript 数据绑定教程 什么是数据绑定呢？就是把 WXML 中的一些动态数据分离出来放到对应的 js 文件的 Page 的 data 里。 只需要将 WXML 的代码写成： 1&lt;view&gt;&#123;&#123;username&#125;&#125;，您已登录，欢迎&lt;/view&gt; 然后同名 JS 写成： 12345Page(&#123; data: &#123; username:\"张明\" &#125;&#125;) 即可导入变量。 常用变量类型有：字符串、数字、布尔值、对象、数组。 其中对象类似于 Python 字典的形式，数组类似于 Python 列表的形式（下标从 0 开始）。 在 WXML 中访问对象的方法是 .，访问数组的方法是 [i]。 如下是对象和数组嵌套的一个示例： 12345678910111213141516171819202122232425data: &#123; movies: [ &#123; name: \"肖申克的救赎\", englishname: \"The Shawshank Redemption\", country: \"美国\", year: 1994, img: \"https://img3.doubanio.com/view/photo/s_ratio_poster/public/p480747492.webp\", desc: \"有的人的羽翼是如此光辉，即使世界上最黑暗的牢狱，也无法长久地将他围困！\", actor: [ &#123; name:\"蒂姆·罗宾斯\", role:\"安迪·杜佛兰\" &#125;, &#123; name:\"摩根·弗里曼\", role:\"艾利斯·波伊德·瑞德\" &#125;, ] &#125;, &#123; // ... &#125; ],&#125; 访问 1&#123;&#123;movies[0].actor[0].role&#125;&#125; 可以得到 &quot;安迪·杜佛兰&quot;。 由于比较简单就不多说了，详细教程可看本节开头的教程链接。 列表渲染和条件渲染文档 这是 WXML 的功能，可以对 JS 的数据渲染的时候进行 for 遍历和 if 判断。 下面的九九乘法表是一个很好的例子： 1234567&lt;view wx:for=\"&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;\" wx:for-item=\"i\"&gt; &lt;view wx:for=\"&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;\" wx:for-item=\"j\"&gt; &lt;view wx:if=\"&#123;&#123;i &lt;= j&#125;&#125;\"&gt; &#123;&#123;i&#125;&#125; * &#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 也可以使用 hidden 代替 if 进行条件渲染： 123&lt;view hidden=\"&#123;&#123;i &gt; j&#125;&#125;\"&gt; &#123;&#123;i&#125;&#125; * &#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125;&lt;/view&gt; 将上述 [1, 2, 3, 4, 5, 6, 7, 8, 9] 放到 js 的 data 中即可实现渲染 js 的数据。 不过，如果 js 的 data 是动态变化的，每次 data 改变就会导致重新渲染列表。解决方法是增加 wx:key 作为列表中 item 的唯一标识符。详见：https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html 如不提供 wx:key，会报一个 warning。但是如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 wx:key 可以有两种： 如果是 item 本身（如上例），则可以用 wx:key=&quot;*this&quot;； 如果 item 是一个对象，想用其属性如 name，则可以用 wx:key=&quot;name&quot;； 除此之外，还可以用其下标：wx:key=&quot;index&quot;。 1234567&lt;view wx:for=\"&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;\" wx:for-item=\"i\" wx:key=\"*this\"&gt; &lt;view wx:for=\"&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;\" wx:for-item=\"j\"&gt; &lt;view wx:if=\"&#123;&#123;i &lt;= j&#125;&#125;\"&gt; &#123;&#123;i&#125;&#125; * &#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 获取表单内容WeUI 小程序提供了表单，但是没有提供 JS。而按照这个小程序的写法，是不能在点击按钮触发的 bindtap 函数中获取表单的信息的。因此，对于表单，更推荐另一种写法：链接 123456789101112131415161718192021222324&lt;form bindsubmit=\"formSubmit\" bindrest=\"formReset\"&gt; &lt;view&gt;开关选择器按钮&lt;/view&gt; &lt;switch name=\"switch\"/&gt; &lt;view&gt;滑动选择器按钮slider&lt;/view&gt; &lt;slider name=\"process\" show-value &gt;&lt;/slider&gt; &lt;view&gt;文本输入框&lt;/view&gt; &lt;input name=\"textinput\" placeholder=\"要输入的文本\" /&gt; &lt;view&gt;单选按钮radio&lt;/view&gt; &lt;radio-group name=\"sex\"&gt; &lt;label&gt;&lt;radio value=\"male\"/&gt;男&lt;/label&gt; &lt;label&gt;&lt;radio value=\"female\"/&gt;女&lt;/label&gt; &lt;/radio-group&gt; &lt;view&gt;多选按钮checkbox&lt;/view&gt; &lt;checkbox-group name=\"gamecheck\"&gt; &lt;label&gt;&lt;checkbox value=\"game1\"/&gt;王者荣耀&lt;/label&gt; &lt;label&gt;&lt;checkbox value=\"game2\"/&gt;欢乐斗地主&lt;/label&gt; &lt;label&gt;&lt;checkbox value=\"game3\"/&gt;连连看&lt;/label&gt; &lt;label&gt;&lt;checkbox value=\"game4\"/&gt;刺激战场&lt;/label&gt; &lt;label&gt;&lt;checkbox value=\"game5\"/&gt;穿越火线&lt;/label&gt; &lt;label&gt;&lt;checkbox value=\"game6\"/&gt;天天酷跑&lt;/label&gt; &lt;/checkbox-group&gt; &lt;button form-type=\"submit\"&gt;提交&lt;/button&gt; &lt;button form-type=\"reset\"&gt;重置&lt;/button&gt;&lt;/form&gt; 这里需要重点注意的是 form 和 button 控件。form 的 bindsubmit 配合 &lt;button form-type=&quot;submit&quot;&gt;，可以使得在按下这个 button 的时候，form 将表单中的内容作为参数，调用 bindsubmit 函数。 不过需要注意的是，组件中的 name 项必须写，否则是不会记录其内容的。 更多组件：轮播、音频、视频、cover、地图教程链接 如果没有需要则可以跳过。 JavaScript 微信 APIJavaScript 入门知识就放在另一篇博客了。 wx 是小程序的全局对象，用于承载小程序能力相关 API。 小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，了解网络状态等。 可以在微信开发者工具的控制台 Console 里输入 wx，了 解 一 下 这 个 对 象（共 700+ 个成员函数）。 文档 获取信息登录获取网络状态下面列举的代码，可以直接在微信开发者工具的调试器中的 Console 输入。在电脑模拟器和真机调试的输出也会不同。 文档就不给出了，随手百度/谷歌，第一个就是。 12345wx.getNetworkType(&#123; success(res) &#123; console.log(res) &#125; &#125;); 获取用户信息12345wx.getUserInfo(&#123; success(res) &#123; console.log(res); &#125;&#125;); 获取设备信息1234567891011wx.getSystemInfo(&#123; success (res) &#123; console.log(res.model) console.log(res.pixelRatio) console.log(res.windowWidth) console.log(res.windowHeight) console.log(res.language) console.log(res.version) console.log(res.platform) &#125;&#125;) 获取场景值文档 场景值用来描述用户进入小程序的路径。如扫二维码、搜索等。场景值获取方式和对应含义可见文档。 设置当前页面设置页面标题123wx.setNavigationBarTitle(&#123; title: '控制台更新的标题'&#125;) 下拉操作需要在 app.json 或页面对应的 json 设置 &quot;enablePullDownRefresh&quot;: true。 1234567891011Page(&#123; onPullDownRefresh: function () &#123; //下拉时触发的函数 this.onShow(); // 触发 onShow 函数，可根据需要改为其他代码 function sleep (time) &#123; return new Promise((resolve) =&gt; setTimeout(resolve, time)); &#125; sleep(500).then(() =&gt; &#123; //睡眠 500ms wx.stopPullDownRefresh() //停止下拉的状态 &#125;) &#125;,&#125;) 图片、缓存和文件教程 点击事件 事件是视图层到逻辑层的通信方式，当我们点击 tap、触摸 touch、长按 longpress 小程序绑定了事件的组件时，就会触发事件，执行逻辑层中对应的事件处理函数。 小程序框架的视图层由 WXML 与 WXSS 来编写的，由组件来进行展示。将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。 点击按钮触发页面滚动首先在测试页面的 WXML 首尾增加两个 button（两个 button 之间沿用九九乘法表的代码）： 12345678910111213&lt;button type=\"primary\" bindtap=\"scrollToPosition\"&gt;滚动到指定位置&lt;/button&gt;&lt;view class=\"pagetop\" style=\"background-color:#333;width:100%;height:400px\"&gt;&lt;/view&gt;&lt;view wx:for=\"&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;\" wx:for-item=\"i\" wx:key=\"*this\"&gt; &lt;view wx:for=\"&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;\" wx:for-item=\"j\" wx:key=\"*this\"&gt; &lt;view wx:if=\"&#123;&#123;i &lt;= j&#125;&#125;\"&gt; &#123;&#123;i&#125;&#125; * &#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;button type=\"primary\" bindtap=\"scrollToTop\"&gt;滚动到页面顶部&lt;/button&gt;&lt;view id=\"pageblock\" style=\"background-color:#333;width:100%;height:400px\"&gt;&lt;/view&gt; 注意 button 属性里有一个 bindtap，它的值对应的 js 函数就是当按钮按下时调用的函数。 于是我们在同名 JS 下写两个函数调用 wx.pageScrollTo。 123456789101112131415Page(&#123; scrollToTop() &#123; wx.pageScrollTo(&#123; scrollTop: 0, duration: 300 &#125;) &#125;, scrollToPosition() &#123; wx.pageScrollTo(&#123; scrollTop: 6000, duration: 300 &#125;) &#125;) 然后编译。 按钮 点击“滚动到指定位置”可以滚到 6000px 的位置（由于总长没有 6000，因此就是滚到末尾）；点击“滚动到页面顶部”可以滚动到顶部。 也可以滚动到指定 XML 选择器的位置。 12345678910111213scrollToTop() &#123; wx.pageScrollTo(&#123; duration: 3000, selector:\".pagetop\" &#125;)&#125;,scrollToPosition() &#123; wx.pageScrollTo(&#123; duration: 300, selector:\"#pageblock\" &#125;)&#125;, 消息提示框 Toast依旧是 button 通过 bindtap 绑定到调用 wx.showToast 的函数。 1&lt;button type=\"primary\" bindtap=\"toastTap\"&gt;点击弹出消息对话框&lt;/button&gt; 1234567toastTap() &#123; wx.showToast(&#123; title: '购买成功', icon: 'success', duration: 2000 &#125;)&#125;, 模态对话框依旧是 button 通过 bindtap 绑定到调用 wx.showModel 的函数。不过这里增加了用户的两个选项。 1&lt;button type=\"primary\" bindtap=\"modalTap\"&gt;显示模态对话框&lt;/button&gt; 123456789101112131415modalTap() &#123; wx.showModal(&#123; title: '学习声明', content: '学习小程序的开发是一件有意思的事情，我决定每天打卡学习', showCancel: true, confirmText: '确定', success(res) &#123; if (res.confirm) &#123; console.log('用户点击了确定') &#125; else if (res.cancel) &#123; console.log('用户点击了取消') &#125; &#125; &#125;)&#125;, 模态对话框 手机震动一样的套路，把函数改为 wx.vibrateLong() 即可。 Navigator 组件和页面路由 APINavigator 组件可以做到的事情，使用 JavaScript 调用小程序也能路由 API 也可以做到。Navigator 组件的内容是写死的，而 JavaScript 则可以提供动态的数据。 页面路由 API Navigator open-type 值 含义 wx.redirectTo redirect 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 wx.navigateTo navigate 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。 wx.navigateBack navigateBack 关闭当前页面，返回上一页面或多级页面。 wx.switchTab switchTab 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 wx.reLaunch reLaunch 关闭所有页面，打开到应用内的某个页面 事件对象教程链接事件 文档 在前面的列表渲染里，我们知道点击电影列表里的某一部电影，要进行页面跳转显示该电影的详情，我们需要给该电影创建一个页面，那如果要显示数千部的电影的详情，一一创建电影详情页显然不合适，毕竟所有电影的详情页都是同一一个结构，有没有办法所有电影详情都共用一个页面，但是根据点击的链接的不同，渲染相应的数据？答案是肯定的，要解决这个问题，首先我们要了解链接组件的点击信息。 当点击组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象，通过 event 对象可以获取事件触发时候的一些信息，比如时间戳、 detail 以及当前组件的一些属性值集合，尤其是事件源组件的 id。 如，在 WXML 中有一个按钮如下: 1&lt;view id=\"tapTest\" data-hi=\"Weixin\" bindtap=\"tapName\"&gt; Click me! &lt;/view&gt; 在 JS 中定义一个 tapName 函数： 12345Page(&#123; tapName: function(event) &#123; console.log(event) &#125;&#125;) 点击按钮可以看到以下信息： 12345678910111213141516171819202122232425262728293031323334&#123; \"type\":\"tap\", \"timeStamp\":895, \"target\": &#123; \"id\": \"tapTest\", \"dataset\": &#123; \"hi\":\"Weixin\" &#125; &#125;, \"currentTarget\": &#123; \"id\": \"tapTest\", \"dataset\": &#123; \"hi\":\"Weixin\" &#125; &#125;, \"detail\": &#123; \"x\":53, \"y\":14 &#125;, \"touches\":[&#123; \"identifier\":0, \"pageX\":53, \"pageY\":14, \"clientX\":53, \"clientY\":14 &#125;], \"changedTouches\":[&#123; \"identifier\":0, \"pageX\":53, \"pageY\":14, \"clientX\":53, \"clientY\":14 &#125;]&#125; 对比 WXML 可以注意到： 1&lt;view id=\"tapTest\" data-hi=\"Weixin\" bindtap=\"tapName\"&gt; Click me! &lt;/view&gt; event.currentTarget.id 对应 WXML 中的 id； event.currentTarget.dataset.hi 对应 data-hi；事实上，在 WXML 中，这些自定义数据以 data- 开头，多个单词由连字符 - 连接。在 JS 中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。参考 这样就可以访问 event.currentTarget.id 或 event.currentTarget.dataset.hi 来实现传递按钮的参数了。 还注意到，在本例中，currentTarget 和 target 是一样的。 但是，如果在多个组件中触发了 bindtap（如外层的 view 和内层的 image 组件都有 bindtap，点击了图片，则两个 bindtap 对应的函数都会被触发）。 我们点击的是图片 image 组件，却分别触发了绑定在 image 组件以及 image 的父级（上一级）组件 view 的事件处理函数，我们称这为事件冒泡。 此时，两个函数中的 currentTarget 都对应 image 组件的信息，而 target 对应的是本身组件（view 或 image）的信息。 变量传递 这节讲的是组件是如何携带数据的，事件对象数据的作用以及数据如何跨页面渲染。 在链接中携带数据最简单的就是在链接中携带数据。 如，新建两个页面：pages/home/detail/detail 和 pages/lifecyle/lifecycle。 在 pages/lifecyle/lifecycle.wxml 中写一个跳转组件： 1&lt;navigator id=\"detailshow\" url=\"./../home/detail/detail?id=lesson&amp;uid=tcb&amp;key=tap&amp;ENV=weapp&amp;frompage=lifecycle\" class=\"item-link\"&gt;点击链接看控制台&lt;/navigator&gt; 点击即可跳转到 pages/home/detail/detail。那，如何在 detail 获取数据呢？ 在 detail.js 写一个 onLoad 函数即可（这个 onLoad 函数和 data 平级）： 123onLoad: function (options) &#123; console.log(options)&#125;, 显示 {id: &quot;lesson&quot;, uid: &quot;tcb&quot;, key: &quot;tap&quot;, ENV: &quot;weapp&quot;, frompage: &quot;lifecycle&quot;}。即，参数被解析为了一个 JS 对象，就可以用 options.id 访问数据。 跨页面数据渲染讲到这里，其实就已经可以实现了。流程如下： 在 detail.js 中的 data 添加一个 detail 对象，如下： 12345detail:&#123; name:\"\", img:\"\", desc:\"\"&#125;, 在 detail.js 的 onload 函数中，将参数值赋给 detail。 在 detail.wxml 中使用 等进行渲染。 小程序和页面的生命周期 App() 函数注册小程序，Page() 函数注册小程序中的一个页面，他们都接受的是对象 Object 类型的参数，包含一些生命周期函数和事件处理函数。App() 必须在 app.js 中调用，必须调用且只能调用一次。开发者可以添加任意的函数或数据变量到 Object 参数中，用 this 可以访问。 App.js 中的函数及触发时刻如下： 1234567891011onLaunch(opts) &#123; console.log('onLaunch监听小程序初始化。',opts)&#125;,onShow(opts) &#123; console.log('onShow监听小程序启动或切前台',opts)&#125;,onHide() &#123; console.log('onHide监听小程序切后台')&#125;, onLaunch 是监听小程序的初始化，初始化完成时触发，全局只会触发一次，所以在这里我们可以用来执行获取用户登录信息的函数等一些非常核心的数据，如果 onLaunch 的函数过多，会影响小程序的启动速度。onShow 是在小程序启动，或从后台进入前台显示时触发，也就是它会触发很多次，在这里就不大适合放获取用户登录信息的函数啦。这两者的区别要注意。 每个页面的 JS 中的函数及触发时刻如下： 12345678910111213141516171819onLoad: function(options) &#123; console.log(\"onLoad监听页面加载\",options)&#125;,onReady: function() &#123; console.log(\"onReady监听页面初次渲染完成\")&#125;,onShow: function() &#123; console.log(\"onShow监听页面显示\")&#125;,onHide: function() &#123; console.log(\"onHide监听页面隐藏\")&#125;,onUnload: function() &#123; console.log(\"onUnload监听页面卸载\")&#125;, 推荐自己测试一下。 globalDataapp.js 中还有一个 globalData，顾名思义就是全局数据。 可以直接在 app.js 中定义 globalData 的参数。 12345App(&#123; globalData: &#123; userInfo: null &#125;&#125;) 可以在 app.js 的其他函数中修改： 1234567891011App(&#123; onLaunch: function() &#123; var that = this; wx.getUserInfo(&#123; success(res)&#123; console.log(\"wx.getUserInfo得到的数据\",res) that.globalData.userInfo = res.userInfo &#125; &#125;) &#125;&#125;) 在其他页面中访问全局变量可以使用 getApp()（文档）: 123let app = getApp()console.log('user页面打印的app', app)console.log('user页面打印的globalData', app.globalData.userInfo) 网络 API教程 云函数云函数即在云端（腾讯提供的临时服务器）执行的 JavaScript 函数。 某些函数需要调用 npm 包，但我们不能在每台手机上安装所有 npm 组件。因此，我们将 npm 包和需要这些包的函数部署在云上，手机上只需要调用这些云函数即可。 教程 wx.cloudwx.cloud 对象有以下成员。云函数、云数据库、云存储都是通过这个对象进行使用。 12345678CloudID: ƒ () //用于云调用获取开放数据callFunction: ƒ () //调用云函数database: ƒ () //获取数据库的引用deleteFile: ƒ () //从云存储空间删除文件downloadFile: ƒ () //从云存储空间下载文件getTempFileURL: ƒ () //用云文件 ID 换取真实链接init: ƒ () //初始化云开发能力uploadFile: ƒ () //上传文件至云存储空间 开通云开发服务见上教程。需要记住环境 ID。环境即是云函数、数据库等需要上传的一个地方。 指定小程序的 ID以云开发的形式创建项目，然后在 app.js 可以看到： 12345678910111213141516171819App(&#123; onLaunch: function () &#123; if (!wx.cloud) &#123; console.error('请使用 2.2.3 或以上的基础库以使用云能力') &#125; else &#123; wx.cloud.init(&#123; // env 参数说明： // env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源 // 此处请填入环境 ID, 环境 ID 可打开云控制台查看 // 如不填则使用默认环境（第一个创建的环境） // env: 'my-env-id', traceUser: true, &#125;) &#125; this.globalData = &#123;&#125; &#125;&#125;) 取消注释第 12 行，并且修改为自己的环境 ID。 编写云函数在 cloudfunctions 目录下，每个文件夹都对应一个云函数。 我们关注 login 函数。打开 cloudfunctions/login/index.js： 12345678910111213141516171819202122232425262728293031323334// 云函数模板// 部署：在 cloud-functions/login 文件夹右击选择 “上传并部署”const cloud = require('wx-server-sdk')// 初始化 cloudcloud.init(&#123; // API 调用都保持和云函数当前所在环境一致 env: cloud.DYNAMIC_CURRENT_ENV&#125;)/** * 这个示例将经自动鉴权过的小程序用户 openid 返回给小程序端 * * event 参数包含小程序端调用传入的 data * */exports.main = async (event, context) =&gt; &#123; console.log('服务端打印的event',event) console.log('服务端打印的context',context) // 可执行其他自定义逻辑 // console.log 的内容可以在云开发云函数调用日志查看 // 获取 WX Context (微信调用上下文)，包括 OPENID、APPID、及 UNIONID（需满足 UNIONID 获取条件）等信息 const wxContext = cloud.getWXContext() return &#123; event, openid: wxContext.OPENID, appid: wxContext.APPID, unionid: wxContext.UNIONID, env: wxContext.ENV, &#125;&#125; 1-10 行初始化云环境； 18-35 行则导出了一个叫做 main 的箭头函数，其接受两个参数 event 和 context，可通过 console.log 查看： event 包含用户的 openid 和小程序的 appid， openid 就相当于用户的身份证，我们可以根据 openid 获取到用户的昵称、头像等信息； context 对象则是云函数的调用信息和运行状态。 这段函数执行过程只是调用 cloud.getWXContext() 并返回其结果，在调用云函数的地方可以接收。 需要强调的是，云函数的 console.log 的返回结果是在云开发控制台而不是开发者工具的控制台里。 部署云函数 右键云函数目录，选择在终端中打开，输入 npm install 命令下载依赖文件； 然后再右键云函数目录，点击“创建并部署：所有文件”； 在云开发控制台–云函数–云函数列表查看云函数是否部署成功。 编写调用云函数的方法现在将目光转向 pages/index/index.js。这是云开发小程序模板的首页的 JS 文件。其中有一个函数 onGetOpenid 是首页中“获取 openid” 按钮通过 tapbind 绑定的函数。这个函数调用了云函数： 1234567891011121314151617181920onGetOpenid: function() &#123; // 调用云函数 wx.cloud.callFunction(&#123; name: 'login', data: &#123;&#125;, success: res =&gt; &#123; console.log('[云函数] [login] user openid: ', res.result.openid) app.globalData.openid = res.result.openid wx.navigateTo(&#123; url: '../userConsole/userConsole', &#125;) &#125;, fail: err =&gt; &#123; console.error('[云函数] [login] 调用失败', err) wx.navigateTo(&#123; url: '../deployFunctions/deployFunctions', &#125;) &#125; &#125;)&#125;, 可见，调用云函数是通过 wx.cloud.callFunction 函数，再通过参数指定是哪个函数、参数和成功/失败的回调函数。 进阶调试教程 云服务选取云数据库教程 文档 微信给的云数据库是 JSON 数据库，也就是每条记录以 JSON 的形式上传。这点类似于 MongoDB，甚至某些查询语句也和 MongoDB 类似。 创建项目时，以云开发的形式创建项目，然后在 /pages/databaseGuide/databaseGuide.js 可以看到如何操作数据库。首先需要手动在云开发-数据库页面新增集合（类似于 MySQL 的表）。 云数据库使用有以下注意事项： 小程序一次获取的记录数不能超过 20 条，云函数不能超过 100 条。必要时可通过文档 给出的示例代码进行多次获取然后拼接； 小程序不支持数据批量更新（即 db.collection().where().update()），仅云函数支持； 云函数不兼容回调函数风格（即 .get({success, fail, complete})），仅支持 Promise 风格（即 .get().then().catch()）； 并不是每次云函数执行都会在新的环境开始执行，连续执行云函数也可能在上一次的环境下执行，因此变量初始化一定要在 main 函数里完成，才能保证变量每次被初始化了。 新增记录1234567891011121314151617181920212223242526onAdd: function () &#123; const db = wx.cloud.database() db.collection('counters').add(&#123; data: &#123; count: 1, &#125;, success: res =&gt; &#123; // 在返回结果中会包含新创建的记录的 _id this.setData(&#123; counterId: res._id, count: 1 &#125;) wx.showToast(&#123; title: '新增记录成功', &#125;) console.log('[数据库] [新增记录] 成功，记录 _id: ', res._id) &#125;, fail: err =&gt; &#123; wx.showToast(&#123; icon: 'none', title: '新增记录失败' &#125;) console.error('[数据库] [新增记录] 失败：', err) &#125; &#125;)&#125;, 查询记录123456789101112131415161718192021onQuery: function() &#123; const db = wx.cloud.database() // 查询当前用户所有的 counters db.collection('counters').where(&#123; _openid: this.data.openid &#125;).get(&#123; success: res =&gt; &#123; this.setData(&#123; queryResult: JSON.stringify(res.data, null, 2) &#125;) console.log('[数据库] [查询记录] 成功: ', res) &#125;, fail: err =&gt; &#123; wx.showToast(&#123; icon: 'none', title: '查询记录失败' &#125;) console.error('[数据库] [查询记录] 失败：', err) &#125; &#125;)&#125;, 更多的查询语法见链接 更新记录123456789101112131415161718onCounterInc: function() &#123; const db = wx.cloud.database() const newCount = this.data.count + 1 db.collection('counters').doc(this.data.counterId).update(&#123; data: &#123; count: newCount &#125;, success: res =&gt; &#123; this.setData(&#123; count: newCount &#125;) &#125;, fail: err =&gt; &#123; icon: 'none', console.error('[数据库] [更新记录] 失败：', err) &#125; &#125;)&#125;, 需要注意的是，小程序端为了避免批量更新，不允许对查询的数据进行更新。 如果查询的数据只有一项，可以通过查询获取其 id，再对 id 更新； 如果需要更新很多项，可以考虑使用云函数。 删除记录123456789101112131415161718192021222324252627onRemove: function() &#123; if (this.data.counterId) &#123; const db = wx.cloud.database() db.collection('counters').doc(this.data.counterId).remove(&#123; success: res =&gt; &#123; wx.showToast(&#123; title: '删除成功', &#125;) this.setData(&#123; counterId: '', count: null, &#125;) &#125;, fail: err =&gt; &#123; wx.showToast(&#123; icon: 'none', title: '删除失败', &#125;) console.error('[数据库] [删除记录] 失败：', err) &#125; &#125;) &#125; else &#123; wx.showToast(&#123; title: '无记录可删，请见创建一个记录', &#125;) &#125;&#125;,","tags":[{"name":"编程语言入门","slug":"编程语言入门","permalink":"https://blog.lyh543.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"},{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.lyh543.cn/tags/JavaScript/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.lyh543.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"面试和简历","date":"2020-07-07T03:55:42.000Z","path":"others/resume-and-interview/","text":"简历 技能分为：精通–熟悉–了解 项目经历：详细描述，甚至可用十行 面试时随身携带简历 面试自我介绍 内向 × 内敛 √ 为什么选择本公司 自己喜欢这份职业 × 贵公司排名 xxx（谈了解） √ 有在这里定居的打算 √","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://blog.lyh543.cn/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"MySQL","date":"2020-07-07T00:32:50.000Z","path":"sql/mysql/","text":"本篇作为 SQL Server 的补充。SQL Server 有不少很不错的功能。 MySQL 8 特性在 MySQL 8 中写表的名字最好把数据库带上，如 test_tb.table1。否则可能会报错。 表操作创建表设置主键自增12345CREATE TABLE user( userid INT(4) PRIMARY KEY NOT NULL AUTO_INCREMENT, username VARCHAR(16) NOT NULL, userpassword VARCHAR(32) NOT NULL); 主键自增是为了防止 id 重复，如果存 NULL，他就会设置为目前最大的 id + 1； 主键自增只有主键可以设置； 修改表表改名1RENAME TABLE test.login TO test.login_backup 更改表的定义官方文档 用下面这种方式可以修改属性名或属性定义。原表中该属性的分量也会自动转换类型。 12ALTER TABLE test.top100_countCHANGE id id INT PRIMARY KEY; 数据操作数据处理类型转换在需要类型转换的时候（如将 A 表的 SELECT 的 TEXT 数据 INSERT 进 B 表的 INTEGER 属性），MySQL 会自动完成类型转换（如 TEXT 转为 VARCHAR(10) 或 INTEGER）。 字符串替换、拼接、截取 字符串的替换使用 replace(date, &#39;.&#39;, &#39;&#39;)，会将 date 中的 . 删去； 字符串的拼接使用 concat(date, time)，会将两个字符串进行拼接； date + time 会尝试将两个字符串转为数字以后相加。如果无法转为数字则报错； left(date, 3) 和 right(date, 3) 分别取 date 的左三个字符和右三个字符； 示例代码： 123INSERT IGNORE INTO test.online_count_2 (date_time, count)SELECT CONCAT(REPLACE(date, '.', ''), REPLACE(time, ':', '')), count FROM test.online_count; 对于 online_count 中记录为 (07.01, 12:30, 12345) 的行，导入 online_count_2 的内容是 (7011230, 123450)。 数据插入插入子查询的结果忽略部分错误我们想要将 A 表的数据插入 B 表，但是直接插入的话部分行会是无法插入的（如 A 的部分行插入 B 会使得 B 的主键重复）。这会导致插入操作被终止，所有行都没有被插入 B 表。 如果我们想要在插入的时候忽略掉掉错误行，把其他正确行插入，可以使用 IGNORE 关键字： 123INSERT IGNORE INTO A(VALUE1, VALUE2)SELECT * FROM B 执行 .sql 代码如执行 ~/run.sql： 1source ~/run.sql","tags":[{"name":"SQL","slug":"SQL","permalink":"https://blog.lyh543.cn/tags/SQL/"}]},{"title":"数据挖掘之 Hadoop Spark","date":"2020-07-02T01:55:28.000Z","path":"computer-science/hadoop-spark/","text":"这里只用到了 Hadoop 的 Hadoop Distributed File System (HDFS)，即分布式文件系统。而数据处理是交给 Spark 了。 安装Hadoop 和 Spark 在 Linux 下的安装方法 注意 Hadoop 的 namenode 默认管理 Web 页面是 http://localhost:9870/，而从 hdfs 协议访问 namenode 是从 9000 端口。 Hadoop 分布式文件管理管理 HDFS 的命令和 Linux 的命令很像。 123456cd $HADOOP_HOME./sbin/start-dfs.cmd # 启动hdfs dfs -mkdir /mydata # 创建目录hdfs dfs -put /path/to/file /mydata # 上传hdfs dfs -cat /mydata/file # 读取hdfs dfs -rm -r /mydata # 删除 为配合后面的测试，将爬虫爬取的二手价格数据下载后，上传到 HDFS： 1234cd $HADOOP_HOME./sbin/start-dfs.cmdhdfs dfs -mkdir /mydatahdfs dfs -put ershoufang_price.txt /mydata 文件上传成功 Spark还需要安装 pyspark。 1pip3 install pyspark 然后将环境变量写入 /etc/profile： 12export PYSPARK_PYTHON=python3export PYSPARK_DRIVER_PYTHON=python3 需要注销才能生效。 顺便一提，安装过程中还会自动安装 py4j，因为 Spark 是运行于 Java 之上，需要用 Python 读取 JVM 中的对象。 读取文本文件尝试读取上面上传的 ershoufang_price.txt。这里的 localhost:9000 可以在 Web 端看到。然后编写一下的 Python 代码，尝试从 HDFS 读取文本文件的内容。 12345678910111213141516171819from pyspark.sql import SparkSession# SparkSession 操作 SparkSQL DataFrame，读取结构化数组spark = SparkSession \\ .builder \\ .appName(\"Spark SQL basic example\") \\ #.config(\"spark.some.config.option\", \"some-value\") \\ .getOrCreate()# SparkContext 用于读取文本文件，读取分结构化数据sc = spark.sparkContextfilePath = \"hdfs://localhost:9000/mydata/ershoufang_price.txt\"textFile = sc.textFile(filePath)# 返回的 textFile 是 RDD (resilient distributed dataset)，是文件在 Spark 中的表示方法data = textFile.collect() # collect 是将所有 datanode 的数据收集整合到 namenode# 返回的 data 是一个 list，其中每个元素对应 txt 的每一行print(data) 如果输出了 44&#39;, &#39;杭州,下沙,77,17382,44&#39;, &#39;杭州,下沙,77,17382,44&#39;, &#39;杭州,下沙,77,17382,44&#39;, &#39;杭州,下沙,77,17382,44&#39;, &#39;杭州,下沙,92,20924,43&#39;] 等，则正常。 如果报错：Python in worker has different version 2.7 than that in driver 3.7, PySpark cannot run with different minor versions.Please check environment variables PYSPARK_PYTHON and PYSPARK_DRIVER_PYTHON are correctly set.，则检查一下是否把环境变量加入 /etc/profile。 统计城市房源数并存入临时数据库接下来尝试将数据存到数据库。为测试语法，这里直接输出到 Spark SQL 的全局临时表中，然后做一个简单的查询。 这里的代码是紧接着上面的 textFile = sc.textFile(filePath)。 1234567891011121314151617181920212223from pyspark.sql import SparkSession, RowfilePath = \"hdfs://localhost:9000/mydata/ershoufang_price.txt\"textFile = sc.textFile(filePath)# 返回的 textFile 是 RDD (resilient distributed dataset)，是文件在 Spark 中的一个表示# data = textFile.collect() # collect 是将所有 datanode 的数据收集整合到 namenode# # 返回的 data 是一个 list，其中每个元素对应 txt 的每一行# print(data)# 将 item 变为 (北京,1)def to_pair(item): item_list = item.split(',') return item_list[1], 1# 将 (北京,1)(北京,1)(成都,1) 整合为 (北京,2)(成都,1)rdd = textFile.map(to_pair).reduceByKey(lambda x, y: x + y)# 将上述 rdd 转为 DataFrame，放进临时表rowRdd = rdd.map(lambda x: Row(city=x[0], count=x[1]))dataFrame = spark.createDataFrame(rowRdd)dataFrame.createGlobalTempView('city')spark.sql('SELECT * FROM global_temp.city ORDER BY count desc LIMIT 5').show() 输出结果如下： 123456789+----+-----+|city|count|+----+-----+|高新| 5717||江北| 5100||渝中| 4920||和平| 4770||南岸| 4710|+----+-----+ 重新运行代码，并在 dataFrame.createGlobalTempView(&#39;city&#39;) 一行打断点暂停。暂停以后可进入 localhost:4040，即 Spark 的管理页面。 Spark 管理页面 将数据存入 MySQL 数据库这里首先需要提前配好 MySQL 数据库。 然后为 Spark 下载额外的 jar 包，用以操作 MySQL 数据库。 12wget https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.20/mysql-connector-java-8.0.20.jar # 根据数据库版本而定mv mysql-connector-java-8.0.20.jar /usr/local/spark/jars 接着上文的 dataFrame = spark.createDataFrame(rowRdd) 写： 12345678910dataFrame = spark.createDataFrame(rowRdd)# dataFrame.createGlobalTempView('city')# spark.sql('SELECT * FROM global_temp.city ORDER BY count desc LIMIT 5').show()MySQL_Conn = 'jdbc:mysql://localhost:3306/test_db?serverTimezone=UTC'conn_param = &#123;'user': 'root', 'password': 'lyh54333', 'driver': 'com.mysql.cj.jdbc.Driver'&#125;dataFrame.write.jdbc(MySQL_Conn, 'city_count', 'overwrite', conn_param)","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据挖掘","slug":"数据挖掘","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"}]},{"title":"华迪大数据专业实习日记","date":"2020-07-01T15:24:32.000Z","path":"computer-science/big-data-learning-diary/","text":"这次在华迪做专业实习，一点都不水，还特硬核。 6.30上午：Python 基础，可参考廖雪峰博客。 下午：Python 的语法糖；Sracpy 爬虫 7.1上午：爬虫和 Redis 进行结合，进行更复杂的爬虫（用爬到的链接再进行爬虫）。 下午：配环境：Hadoop、Spark。这里开始我转战 Linux 了，就没有跟着老师的教程走了，而是自己去找教程。一配配一天不是开玩笑的。 7.2上午：使用 HDFS + Spark 处理分布式数据库 下午：Flask 入门。 知识就这么多，剩下的就是做项目了。","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]},{"title":"Python 爬虫 —— Scrapy","date":"2020-07-01T07:41:43.000Z","path":"python/scrapy/","text":"原理 爬虫原理 流程如下： 爬虫告诉引擎，需要爬取哪些链接 urls 引擎把链接发给调度器 调度器收到链接后，进入队列 调度器从队列里取出链接，告诉下载器开始下载 下载完毕后，把结果交给爬虫 爬虫把结果中取回数据，交给管道 管道将数据存储到 MySQL/文本文件等 准备工作安装 Python 3 后， 1pip3 install scrapy （可选）在本地安装 Redis 数据库，端口 5376，用户名 root，密码 123456；然后安装 Python 调用 Redis 的库： 1pip3 install redis 简单爬虫这里针对一个列表的网页爬取其列表内容，示例为 https://mobile.ithome.com/ 的新闻标题、链接等信息。 建立目录第一步，建立项目。 1scrapy startproject my_spider D:\\ # 建立项目 会建立如下目录： 12345678910my_spider/ scrapy.cfg my_spider/ __init__.py items.py pipelines.py settings.py spiders/ __init__.py ... 然后可以在 PyCharm 中打开 D:\\my_spider。 其中，settings.py 中 ROBOTSTXT_OBEY = True 表示会自觉遵守页面规定，如果不让爬虫则不会进行爬虫。 生成爬虫代码第二步，切换目录，然后生成一个爬虫： 12cd /d D:\\my_spiderscrapy genspider ithome mobile.ithome.com # 生成爬虫 此时 D:\\my_spider\\my_spider\\spiders 下会自动生成 ithome.py，内容如下： 123456789import scrapyclass IthomeSpider(scrapy.Spider): name = 'ithome' allowed_domains = ['mobile.ithome.com'] start_urls = ['http://mobile.ithome.com/'] def parse(self, response): # 解析 (parse) 网页的方法 pass 这里可以将 start_urls 链接改为 https。 定义数据结构第三步，定义数据结构。这里没有直接使用 Python 原生的继承于 object 的 class，而是选择继承 scrapy.Item 的类。这样定义的数据结构，更方便 Scrapy 处理。定义放在 D:\\my_spider\\my_spider\\items.py。 12345678import scrapyclass IthomeData(scrapy.Item): def __init__(self): title = scrapy.Field() time = scrapy.Field() abstract = scrapy.Field() url = scrapy.Field() 解析网站第四步，定义数据结构后，开始解析爬虫获得的数据。爬虫本质获得的是 start_urls 对应的 html 文件， 然后解析 html，将解析到的数据进行处理。 我们用 Chrome 打开 https://mobile.ithome.com/，右键一个标题并“检查”，可以看到该 HTML 的结构。 mobile.ithome.com 详情 同时，在命令行执行 scrapy shell https://mobile.ithome.com/。看到以下输出： 12345678910111213141516172020-07-01 16:55:01 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://mobile.ithome.com/&gt; (referer: None)2020-07-01 16:55:02 [asyncio] DEBUG: Using proactor: IocpProactor[s] Available Scrapy objects:[s] scrapy scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s] crawler &lt;scrapy.crawler.Crawler object at 0x000001AEBC19F0A0&gt;[s] item &#123;&#125;[s] request &lt;GET https://mobile.ithome.com/&gt;[s] response &lt;200 https://mobile.ithome.com/&gt;[s] settings &lt;scrapy.settings.Settings object at 0x000001AEBC19BC70&gt;[s] spider &lt;DefaultSpider 'default' at 0x1aebc4e6730&gt;[s] Useful shortcuts:[s] fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)[s] fetch(req) Fetch a scrapy.Request and update local objects[s] shelp() Shell help (print this help)[s] view(response) View response in a browser2020-07-01 16:55:02 [asyncio] DEBUG: Using proactor: IocpProactorIn [1]: 200 表示正常。输入 response 并回车： 12In [1]: responseOut[1]: &lt;200 https://mobile.ithome.com/&gt; 接下来解析 response。解析的方法是使用 xpath。 XPath 即为 XML 路径语言，它是一种用来确定 XML 文档中某部分位置的计算机语言。XPath 基于 XML 的树状结构，提供在数据结构树中找寻节点的能力。 在 Chrome 中右键想要爬取的第一个标题，然后 Copy Xpath，如下图： 获取 Xpath 然后作为 response 的 xpath 成员函数的参数，执行，结果如下，如果输出不是 [] 则正确。使用 extract_first 看到其内容。 12345In [12]: response.xpath('//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li[1]/div/h2/a')Out[12]: [&lt;Selector xpath='//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li[1]/div/h2/a' data='&lt;a href=\"https://www.ithome.com/0/491...'&gt;]In [14]: response.xpath('//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li[1]/div/h2/a').extract_first()Out[14]: '&lt;a href=\"https://www.ithome.com/0/491/113.htm\" target=\"_blank\"&gt;小米NFC碰碰贴要回来了？小米高管：大家喜欢的话我们就做&lt;/a&gt;' 可以看到，标题已经出来了，并且和前面的图是一致的。 然后尝试找到遍历的方法。html 里，ul 是列表（unordered list），下面的每一个元素为 li（list item）。将上面的 Xpath 从 li 分开，因为我们需要在 Python 中遍历每个元素。注意在 Xpath 中下标从 1 开始，而在 Python 中下标从 0 开始。 1234In [16]: response.xpath('//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li')[0].xpath('./div/h2/a').extract_first() # 注意第二个 Xpath 的开头有个 .Out[16]: '&lt;a href=\"https://www.ithome.com/0/491/113.htm\" target=\"_blank\"&gt;小米NFC碰碰贴要回来了？小米高管：大家喜欢的话我们就做&lt;/a&gt;'In [17]: response.xpath('//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li')[1].xpath('./div/h2/a').extract_first() # 测试下一篇文章是否也是对应的Out[17]: '&lt;a href=\"https://www.ithome.com/0/491/111.htm\" target=\"_blank\"&gt;荣耀30系列强势霸榜618，蝉联多日销量冠军，立减300仅要2699起&lt;/a&gt;' 再进一步获取其文本和链接，使用 text() 函数和 @href： 1234In [18]: response.xpath('//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li')[0].xpath('./div/h2/a/text()').extract_first()Out[18]: '小米NFC碰碰贴要回来了？小米高管：大家喜欢的话我们就做'In [36]: response.xpath('//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li')[0].xpath('./div/h2/a/@href').extract_first()Out[36]: 'https://www.ithome.com/0/491/113.htm' 用同样的方法可以获取其时间、摘要： 1234In [41]: response.xpath('//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li')[0].xpath('./div/div/p').extract_first()Out[41]: '&lt;p&gt;小米早前曾发布了一款名为“小米NFC碰碰贴”的产品。今日小米集团智能硬件部总经理刘新宇表示，当时碰碰贴概念太超前，如今大家喜欢，“那我们就做新版碰碰贴”。似乎也在暗示小米NFC碰碰贴产品即将回归&lt;/p&gt;'In [48]: response.xpath('//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li')[0].xpath('./div/h2/span/text()').extract_first()Out[48]: '今日 17:35' 到这里就已经成功一半了。 编写解析函数 parse() 是 spider 的一个方法。 被调用时，每个初始 URL 完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的 URL 的 Request 对象。 回到 D:\\my_spider\\my_spider\\spiders\\ithome.py，编写 parse 成员函数。parse 函数的思想就是，遍历 ul 的 li，取出我们需要的信息存进 item，然后返回 item。这里直接上代码。 12345678910111213141516171819202122# ithome.pyimport scrapyfrom my_spider.items import IthomeDataclass IthomeSpider(scrapy.Spider): name = 'ithome' allowed_domains = ['mobile.ithome.com'] start_urls = ['https://mobile.ithome.com/'] def parse(self, response): li_list = response.xpath('//*[@id=\"wrapper\"]/div[1]/div[3]/ul[1]/li') item_list = [] for li in li_list: item = IthomeData() item[\"title\"] = li.xpath('./div/h2/a/text()').extract_first() item[\"url\"] = li.xpath('./div/h2/a/@href').extract_first() item[\"abstract\"] = li.xpath('./div/div/p').extract_first() item[\"time\"] = li.xpath('./div/h2/span/text()').extract_first() item_list.append(item) return item_list 注意，import 引入 item 的方式有点不一样，这里是 from my_spider.items import IthomeData。 编写管道管道则是将上面 parse 函数的解析出来的 item_list 进行处理、存储。这里为简化代码，直接输出；当然也可以写入文本文件、存储到数据库等。代码如下： 1234# pipelines.pyclass MySpiderPipeline: def process_item(self, item, spider): print(item) 运行爬虫最后的最后，运行爬虫。可以直接在 D:\\my_spider\\my_spider 目录下运行 scrapy crawl ithome，也可以在该目录下编写以下 python 代码并运行。 123from scrapy.cmdline import executeexecute('scrapy crawl ithome'.split(' ')) 如果部分输出如下则正常（IT 之家貌似爬虫和直接访问得到的 HTML 不一样？可能做了防爬虫。至少方法是对的）。 123456789101112&#123;'abstract': '&lt;p&gt;今天小米10 Pro手机正式推送MIUI 12.0.1稳定版更新，并且不是稳定版内测，这意味着小米10 ' 'Pro手机普通用户也可以方便升级MIUI 12.0.1稳定版系统了。&lt;/p&gt;', 'time': '今日 23:09', 'title': '小米 10 Pro 正式推送 MIUI 12 稳定版', 'url': 'https://www.ithome.com/0/493/559.htm'&#125;2020-07-01 18:20:38 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://mobile.ithome.com/&gt;&#123;'abstract': '&lt;p&gt;今日消息人士Jon_Prosser也曝光了代号为C68的苹果AirPower充电板原型机的真机照：此次曝光的AirPower充电板似乎解决了过热问题，其已可满足AirPods ' 'Pro和一块Apple Watch同时充电&lt;/p&gt;', 'time': '今日 22:37', 'title': '苹果AirPower充电板原型机曝光！Apple Watch/AirPods可一起充电', 'url': 'https://www.ithome.com/0/493/555.htm'&#125;","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://blog.lyh543.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Caddy 2","date":"2020-06-25T12:46:22.000Z","path":"linux/caddy/","text":"Caddy 优缺点最近了解了一下 Caddy，准备从 Nginx 转到 Caddy。本文指的 Caddy 均为 Caddy 2。 Caddy 官方文档Caddy 中文文档 Caddy 的优点有： 自动申请 TLS 证书（一大卖点！） 语法简洁 缺点有： 插件较 Nginx 少 文档不多，而且网上的讨论也不多 安装 Caddy参考链接：下载 | 安装 由于 yum 自带的是 Caddy 1，而我按官网从 yum 下载 Caddy 的方法貌似会报错，因选择了手动安装。 安装好以后，编写一个简单的 Caddyfile 用于测试： 12mkdir /etc/caddyvim /etc/caddy/Caddyfile 输入如下内容，然后保存： 123:2015Hello world! 启用 Caddy 服务并启动，然后查看其状态： 123456789# 启用sudo systemctl daemon-reloadsudo systemctl enable caddy# 启动sudo systemctl start caddy# 查看状态systemctl status caddy 如果是 active (running)，则安装成功！如果是 failed，请检查 Caddyfile 的位置是否正确（按官方的配置，应该是 /etc/systemd/system/caddy.service）。 验证一下网站服务，curl 获取网站内容： 1curl localhost:2015 如果返回 Hello world! 即正确。 以后，如果修改了 Caddyfile，使用 systemctl reload caddy 即可使其重新读取配置文件。 运行 CaddyCaddy 可以由用户运行，也可以由 caddy 用户以 systemctl 的形式在后台运行。 由于 systemctl 运行出错时的提示很少，推荐学习、测试的时候使用用户身份运行，测试完成以后使用 systemctl。 以用户身份运行及停止： 12caddy startcaddy stop 这两条命令会读取当前目录的 Caddyfile，所以记得提前切换到 /etc/caddy。 以系统身份运行及停止： 12systemctl start caddysystemctl stop caddy 查看调试信息： 1systemctl status caddy 两种方法的重新加载分别为： 12caddy reloadsystemctl reload caddy Caddyfile 常见配置在不进行额外设置的情况下，Caddy 都是 443 端口自动申请 HTTPS，80 端口重定向到 443 端口的。 常见配置，入门 Caddyfile 时也可以参考一下，对 Caddyfile 有个基本的认识。 Caddyfile 入门官方教程 Hello World!如果只打算定义一个网站，Caddyfile 的第一行是网址，后面的就是一个或多个指令 directive： 123localhostrespond \"Hello, world!\" 将上述文本保存在 /etc/caddy/Caddyfile，然后使用 systemctl reload caddy 重新读取后，就可以尝试用浏览器或 curl 打开该网站： 12$ curl https://localhostHello, world! 定义多个网站一个文件可以定义多个网站。但是需要将上述语法改为下面的等价语法： 123localhost &#123; # 大括号前必须有空格 respond \"Hello, world!\"&#125; 就可以在多个语法块中定义每个网站了。 import 其他配置文件参考 也可以在多个文件中定义配置。如在 a.txt 写入以下内容： 123a.com &#123; respond \"Hello, world!\"&#125; 在 b.txt 写入以下内容： 123b.com &#123; respond \"Nice to meet you!\"&#125; 然后在 Caddyfile 中写入： 123# 以 Caddyfile 形式导入两个 txtimport a.txtimport b.txt 即可。 和 Nginx 一样，你需要提前将 a.com 和 b.com 的域名解析以 A 形式指向你的服务器 IP。 静态网站 file_server参考 1234example.com &#123; root * /var/www file_server&#125; 访问 https://example.com 会看到服务器 /var/www/ 的内容。如果存在 index.html，则会打开这个网页。还可指定别的 index： 123456example.com &#123; root * /var/www file_server &#123; index www.index.html &#125;&#125; 还可以使用浏览器浏览文件夹 + 重定向 + 加上反斜线。 123456789example.com &#123; redir /v /v/ handle /v/* &#123; uri strip_prefix /v file_server browse &#123; root /etc/uestcmsc_webapp/getproxy/ &#125; &#125;&#125; 反向代理 reverse_proxy参考 123example.com &#123; reverse_proxy localhost:5000&#125; 三行即可。访问 https://example.com 实际上访问的是服务器的 5000 端口。 利用以下配置可将 https://example.com/proxy 反向代理到 localhost:5000。 123example.com &#123; reverse_proxy /proxy localhost:5000&#125; 还可利用以下配置可将 https://example.com 反向代理到 localhost:5000/proxy。 1234example.com &#123; uri replace / /proxy 1 reverse_proxy localhost:5000&#125; 上述配置表示，在反向代理之前，将 uri 的前 1 个 / 替换为 /proxy。 重定向 redir参考 123www.example.com &#123; redir https://example.com&#123;uri&#125;&#125; 访问 www.example.com 会 302 Redirect 重定向到 https://example.com。 也可以使用 permanent： 123www.example.com &#123; redir https://example.com&#123;uri&#125; permanent&#125; 访问 www.example.com 会 301 Move permanently 重定向到 https://example.com。 按顺序执行 route参考 上述语法 file_server、reverse_proxy、redir 可以混合使用。 123456example.com &#123; reverse_proxy /proxy localhost:5000 redir /github github.com redir /google google.com file_server * /var/www/html/&#125; 这会使得 example.com/proxy、example.com/github、example.com/google 以及 example.com 的其他地址执行对应的功能。 但是，默认情况下，在执行过程中，指令的执行顺序会根据指令名进行调整。比如，file_server 是最后执行的。如果改成以下代码，file_server 则不会被运行，因为在执行到 file_server 之前，/google 已经被重定向了。 123456example.com &#123; reverse_proxy /proxy localhost:5000 redir /github github.com file_server /google /var/www/html/ redir * google.com&#125; 如果真的需要这么做，可以将所有命令包含在 route 的语句块中。语句块中的内容将被顺序执行： 12345678example.com &#123; route &#123; reverse_proxy /proxy localhost:5000 redir /github github.com file_server /google /var/www/html/ redir * google.com &#125;&#125; 处理 handlehandle 类似于 Nginx 中的 location，是一种类似于分支逻辑的 HTTP handler logic（HTTP 处理逻辑）。 12345678example.com &#123; handle /foo/* &#123; file_server &#125; handle / &#123; reverse_proxy 127.0.0.1:8080 &#125;&#125; 上述语法就会将 /foo 下面的网址以 file_server 运行，对其他则会进行反向代理。实现的功能和 route 类似，不过我猜测 handle 处理这类问题更高效。 定义错误页面 handle_errors参考 基于静态网站定义 404 页面的代码如下： 12345678example.com &#123; root * /var/www/ file_server handle_errors &#123; rewrite * /&#123;http.error.status_code&#125;.html file_server &#125;&#125; 访问到不存在的网址则会显示 /404.html 的内容（但网址不会变化，仍然是访问的网址）。 rewrite url try_files参考 这三条命令都是修改 uri 用。 rewrite 将匹配的 uri 修改为指定的 uri； uri 在原 uri 上进行修改； try_files 将 uri 修改为列出路径中，路径对应的文件（文件夹）存在的第一项。 修改以后，只是访问的路径变化，并不会在地址栏有所体现。 12345678910111213141516171819example1.com &#123; rewrite * /foo.html # 将所有路径修改为 foo.html&#125;example2.com &#123; uri replace / /proxy 1 # 将第一个 / 修改为 /proxy，即在链接前添加一个 /proxy reverse_proxy localhost:9000 # example2.com/ =&gt; localhost:9000/proxy&#125;example2.com &#123; route /api/* &#123; uri strip_prefix /api reverse_proxy localhost:9000 &#125;&#125;example3.com &#123; try_files &#123;path&#125; /index.php # 如果 &#123;path&#125; 存在，访问 &#123;path&#125;；否则访问 index.php&#125; 占位符 placeholders上文的 {uri} 即是一种占位符。更多的占位符可见：https://caddyserver.com/docs/caddyfile/concepts#placeholders 匹配串 matchers配置文件中一个很重要的部分是匹配串（matchers）如 / /proxy。在 https://caddyserver.com/docs/caddyfile/matchers 做了详细介绍。 泛域名 HTTPS?当然，以上域名只做到了单域名 HTTPS，对于泛域名解析 HTTPS 则会麻烦得多。这是由于在 Let’s Encrypt，单域名 HTTPS 证书可以使用 HTTP 验证（在网站对应的指定路径放一个指定的 HTML），而泛域名 （如*.example.com HTTPS 证书则需要使用 DNS 验证（在指定的域名下放一个 DNS 解析）。前者交给 Caddy 做非常方便，而后者就不那么方便了。 对于该问题，有以下解决办法： Caddy 2 的确可以通过插件调用各 DNS 提供商的 API 来实现修改 DNS，但是 Caddy 2 官方的插件只有很少，像国内阿里云、腾讯云都没有开发。貌似可以在阿里云将域名的 DNS 解析服务器改为 CloudFlare 的，然后利用 CloudFlare API 实现，但是这里我没有深入研究。 相比于 Caddy 2，Caddy 1 就提供了不少插件（但仍然没有阿里云）。如有需求可改为 Caddy 1。 使用 On-Demand TLS 技术。这是 Caddy 研发的一种技术。 在第一次 TLS 握手时，如果发现本地没有 HTTPS 证书或已过期以后，就立刻向 Let’s Encrypt 申请证书，成功后保存该证书，并完成此次握手；此后如果发现存在 HTTPS 证书且有效，就会使用该证书完成握手。 该方法的优点非常明显，就是可以用对访问到的每个域名申请 HTTPS 证书的方法，代替 DNS 验证。缺点也很明显，由于 HTTPS 证书申请需要时间，再加上国内网络问题，在首次访问某域名时，需要等待 10-40 秒不等供 Caddy 服务器申请证书。 我最终采用了这种方式，因为使用泛域名解析只是为了跳转到主域名上，实际上没有几个人会访问这些域名的。 On-Demand TLS 语法如下： 123456*.example.com &#123; tls &#123; on_demand &#125; redir https://example.com&#123;uri&#125; permanent&#125; 最后一种无奈之举，就是不使用 HTTPS。如果该域名只是做一个 redir，其实不使用 HTTP 也还可以接受。 Caddy 不使用 HTTPS 的语法是，在域名后指定 80 端口。 123*.example.com:80 &#123; redir https://example.com&#123;uri&#125; permanent&#125;","tags":[{"name":"编程语言入门","slug":"编程语言入门","permalink":"https://blog.lyh543.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Caddy","slug":"Caddy","permalink":"https://blog.lyh543.cn/tags/Caddy/"}]},{"title":"DSL 的误解（转载）","date":"2020-06-23T03:25:34.000Z","path":"computer-science/misunderstanding-on-dsl/","text":"https://www.yinwang.org/blog-cn/2017/05/25/dsl","tags":[{"name":"转载","slug":"转载","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"编写自己的 LaTeX 模板","date":"2020-06-13T08:11:55.000Z","path":"latex/latex-making-own-template/","text":"一般来说，网上的 LaTeX 模板已经足够用了，只需要会用就行了，基础语法请看LaTeX 基础。 如果想要自己编写模板，则涉及到了一些高级一点的语法。 texdoc 手册遇到不会的语法，常用自带的手册。可以使用 texdoc &lt;command&gt; 查询。 常用纸张布局 此部分源码及 PDF 见：https://github.com/lyh543/UESTC_LaTeX_Template/blob/master/Course_Thesis_others/心理学漫谈 12% 参考 Word 默认格式\\usepackage[a4paper, inner=3.18cm, outer=3.18cm, top=2.54cm, bottom=2.54cm, bindingoffset=0cm]&#123;geometry&#125; 页眉控制 此部分源码及 PDF 见：https://github.com/lyh543/UESTC_LaTeX_Template/blob/master/Course_Thesis_others/心理学漫谈 注意中括号的内容的含义如下：H, F 页眉页脚、L, C, R 左中右部分、O, E 奇偶页。 1234567891011121314\\usepackage&#123;fancyhdr&#125;\\fancyhead&#123;&#125; % 清空之前的格式\\fancyhead[HL]&#123;心理学漫谈结课论文&#125;\\fancyhead[HR]&#123;\\zhdate*&#123;2019/1/13&#125;&#125;\\fancyfoot[FC]&#123;\\thepage&#125;\\setlength&#123;\\headsep&#125;&#123;5pt&#125; % 设置页眉距\\begin&#123;document&#125;\\pagestyle&#123;fancy&#125; % 正文运用 fancy\\maketitle\\thispagestyle&#123;fancy&#125; % 标题页默认没有页眉，这句强制添加页眉 摘要（不分页无大标题） 此部分源码及 PDF 见：https://github.com/lyh543/UESTC_LaTeX_Template/blob/master/Course_Thesis_others/心理学漫谈 不需要 \\section 或 \\chapter 或 \\begin{abstract}，直接写就行。 123&#123;\\bfseries 摘要：&#125;随着社交网络渗透到人们生活的方方面面，刷朋友圈似乎已称为大学生生活不可缺少的一部分……&#123;\\bfseries 关键字：&#125;朋友圈；嫉妒；心理分析 修改 Abstract、Reference 为中文摘要、参考文献 此部分源码及 PDF 见：https://github.com/lyh543/UESTC_LaTeX_Template/blob/master/Course_Thesis_others/心理学漫谈 1234\\renewcommand\\refname&#123;参考文献&#125;\\renewcommand&#123;\\abstractname&#125;&#123;\\textbf&#123;\\large &#123;摘\\quad 要&#125;&#125;&#125; %更改摘要二字的样式\\begin&#123;document&#125;% ... 中文数字、日期参见 texdoc zhnumber。 12\\zhdate&#123;2019/1/13&#125; % 生成 2019 年 1 月 13 日\\zhdate*&#123;2019/1/13&#125; % 生成 2019 年 1 月 13 日 星期日 newcommand 和 newenvironment123456789101112\\newcommand&#123;\\customcmd&#125;&#123;\\realthing&#125;\\newenvironment&#123;customenv&#125;&#123;&#125;\\customcmd\\begin&#123;customenv&#125; % ...\\end&#123;customenv&#125;","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://blog.lyh543.cn/tags/LaTeX/"}]},{"title":"PyQt5 开发","date":"2020-06-01T08:00:45.000Z","path":"python/pyqt/","text":"最近学 PyQt5，走了不少弯路，放几个教程和博客链接供需要的人参考。 PyQt Examples（PyQt各种测试和例子） PyQt4 PyQt5，非常详尽：https://github.com/PyQt5/PyQt PyQt5 入门：https://www.cnblogs.com/linyfeng/category/1546338.html PyQt Designer 设计居中可缩放的窗口：https://my.oschina.net/shadai/blog/699004 Python 多线程访问数据库导致访问冲突的解决方法：https://www.eertime.com/archives/288.html PyQt5 + matplotlib 实现画图：https://whuhan2013.github.io/blog/2017/03/28/pyqt-matplotlib-learn/ 也可以用 Qchart 实现画统计图，或用 Qpainter 实现画图 PyQt5 + Qchart 实现定时更新、自动改变画布大小的的柱状图：https://github.com/lyh543/Some-Codes/blob/master/2020/NetworkMonitor/archive/plot_dynamic_bars.py 参考项目 1：https://github.com/PyQt5/PyQt/blob/master/QtChart/HorizontalBarChart.py 参考项目 2：https://github.com/PyQt5/PyQt/blob/master/QtChart/SplineChart.py 常见错误QObject::startTimer: Timers cannot be started from another thread 错误在使用 QThread 建立多线程后，最好不要调用别的线程创建的实例的方法（该对象如果引入了 Timer 之类的，就会报此类错误）。 正确的“调用”方法应该是使用触发器，具体方法可见 https://www.cnblogs.com/linyfeng/p/12239856.html。","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.lyh543.cn/tags/Qt/"},{"name":"GUI","slug":"GUI","permalink":"https://blog.lyh543.cn/tags/GUI/"}]},{"title":"数模自学笔记——灰色模型","date":"2020-06-01T02:26:08.000Z","path":"mcm/self-study/grey-model/","text":"参考资料：《数学建模算法与应用（第2版）》（司守奎主编）https://wenku.baidu.com/view/7864cb58866fb84ae45c8d65https://wenku.baidu.com/view/eb12b9d233d4b14e8524689f.html 灰色系统，顾名思义，是白色系统和黑色系统的中间态。 白色系统是指一个系统的内部特征是完全已知的，即系统的信息是完全充分的。而黑色系统是指一个系统的内部信息对外界来说是一无所知的，只能通过它与外界的联系来加以观测研究。灰色系统内的一部分信息是已知的，另一部分信息时未知的，系统内各因素间具有不确定的关系。 灰色模型可用于对已知信息少的系统预测未来的发展，适合于“已知过去十年的指标数据，求预测未来十年的指标数据”此类题目。 GM(1,1) 标准模型模型引入灰色模型（Gray Model）这里仅讨论常用的 GM(1,1) 标准模型。 已知序列 $$x^{(0)}=\\left(x^{(0)}(1), x^{(0)}(2), \\cdots, x^{(0)}(n)\\right)$$ 求预测 $$x^{(k)}$$ 这个序列的元素即为 $x^{(0)}(i)$ 的预测值。（这其实和拟合有一点 相似，不过拟合可能是已知上百个点，而灰色模型只需要几个点） 首先通过计算累加序列将序列变为光滑、递增的序列： $$x^{(1)}=\\left(x^{(0)}(1), \\sum_{i=1}^{2} x^{(0)}(i), \\cdots, \\sum_{i=1}^{n} x^{(0)}(i)\\right)$$ 这个过程称为一次累加生成（1-AGO, Accumulating Generation Operator） 接下来建立基本模型 $GM(1,1)$，即白化方程（顾名思义，将灰色模型变成白色模型的方程）是一阶微分方程，即 $$\\frac{\\mathrm{d} x^{(1)}}{\\mathrm{d} t}+a x^{(1)}=b$$ 其中，$a$，$b$ 为使用最小二乘法算出的常数，其公式为： $$\\begin{array}{c}{[a, b]^{\\mathrm{T}}=\\left(\\boldsymbol{B}^{\\mathrm{T}} \\boldsymbol{B}\\right)^{-1} \\boldsymbol{B}^{\\mathrm{T}} \\boldsymbol{Y}} \\\\\\boldsymbol{B}=\\left[\\begin{array}{cc}-z^{(1)}(2) &amp; 1 \\\\-z^{(1)}(3) &amp; 1 \\\\\\vdots &amp; \\vdots \\\\-z^{(1)}(n) &amp; 1\\end{array}\\right], \\boldsymbol{Y}=\\left[\\begin{array}{c}x^{(0)}(2) \\\\x^{(0)}(3) \\\\\\vdots \\\\x^{(0)}(n)\\end{array}\\right]\\end{array}$$ 其中 $$z^{(1)}(k)=0.5 x^{(1)}(k)+0.5 x^{(1)}(k-1)$$ 解上述微分方程可得： $$\\hat{x}^{(1)}(t+1)=\\left[x^{(0)}(1)-b / a\\right] \\mathrm{e}^{-a t}+b / a$$ 然后对累计序列进行还原可得： $$\\hat{x}^{(0)}(t+1)=\\hat{x}^{(1)}(t+1)-\\hat{x}^{(1)}(t)=\\left(1-\\mathrm{e}^{a}\\right)\\left[x^{(0)}(1)-b / a\\right] \\mathrm{e}^{-a t}$$ 模型检验模型检验有三种方法：残差检验、后验差比值、小误差概率。 残差检验残差检验需要先计算绝对残差序列： $$e^{(0)}(i)=\\left|x^{(0)}(i)-\\hat{x}^{(0)}(i)\\right| \\quad i=1,2, \\ldots, n$$ 然后计算相对残差： $$\\varepsilon_i=\\frac{e^{(0)}(i)}{X^{(0)}(i)} \\times 100 \\% \\quad i=1,2, \\ldots, n$$ 求平均得平均相对残差： $$\\bar{\\varepsilon}=\\frac{1}{n} \\sum_{i=1}^{n} \\varepsilon_{i}$$ 给定 $\\alpha$，当 $\\overline\\varepsilon&lt;\\alpha$，且 $\\varepsilon_n&lt;\\alpha$ 成立，称模型为残差合格模型。 当 $\\alpha$ 没有给出时，可取 $\\alpha = 1%$。 后验差比值计算原始序列和残差序列的标准差，分别记作 $S_1$ 和 $S_2$。 $$\\begin{aligned}S_{1}^{2} &amp;=\\frac{1}{n} \\sum_{k=1}^{n}\\left[x^{(0)}(k)-\\bar{x}^{(0)}\\right]^{2} \\\\S_{2}^{2} &amp;=\\frac{1}{n} \\sum_{k=1}^{n}[e^{(0)}(k)-\\bar{e}^{(0)}]^{2}\\end{aligned}$$ 其中， $$\\bar{x}^{(0)} =\\frac{1}{n} \\sum_{k=1}^{n} x^{(0)}(k), \\bar{e}^{(0)}=\\frac{1}{n} \\sum_{k=1}^{n} e^{(0)}(k)$$ 然后计算后验差比值： $$C=\\frac{S_2}{S_1}$$ 后验差比值的精度标准将在后面与小误差概率一并给出。 小误差概率计算绝对残差序列的均值： $$\\bar{e}^{(0)}=\\frac{1}{n} \\sum_{k=1}^{n} e^{(0)}(k)$$ 然后计算以下概率： $$p=P\\left\\{\\left|e^{(0)}(k)-\\bar{e}^{(0)}\\right|&lt;0.6475 S_{1}\\right\\}$$ 下表为灰色模型预测精度等级。 等级精度 后验差比值 $C$ 小概率误差 $p$ 好 $\\leqslant 0.35$ $\\geq 0.95$ 合格 $0.35&lt;c \\leqslant 0.50$ $0.80 \\leqslant p&lt;0.95$ 勉强 $0.50&lt;c \\leqslant 0.65$ $0.70 \\leqslant p&lt;0.80$ 不合格 $&gt;0.65$ $&lt;0.70$ 基于背景值优化的改进 GM(1,1) 模型该部分由 @Anne_kj 撰写。 设原始非负数据序列为$$X^{(0)}=\\left\\{x^{(0)}(1), x^{(0)}(2), \\cdots, x^{(0)}(n)\\right\\}$$作一次累加 (1 - AGO) 得： $$X^{(1)}=\\left\\{x^{(1)}(1), x^{(1)}(2), \\cdots, x^{(1)}(n)\\right\\}$$ 其中，$x^{(1)}(k)=\\sum_{i=1}^{k} x^{(0)}(i), \\quad k=1,2, \\cdots, n$ 对生成序列 $X^{(1)}(k)$ 建立灰色白化微分方程为： $$\\frac{d x^{(1)}(t)}{d t}+a x^{(1)}(t)=u$$ 将上式在区间 $[k, k+1]$ 上积分，得： $$x^{(1)}(k+1)-x^{(1)}(k)+a \\int_{k}^{k+1} x^{(1)}(t) d t=u$$ 其中，$k=1,2, \\cdots, n-1$。则有： $$x^{(0)}(k+1)+a \\int_{k}^{k+1} x^{(1)}(t) d t=u$$ 设 $z^{(1)}({k}+1)=\\int_{k}^{k+1} x^{(1)}(t) dt$ 为 $x^{(1)}(t)$ 在区间 $[k, k+1]$ 的背景值，则有 $$x^{(0)}(k+1)+a z^{(1)}(k+1)=u$$ 然而函数 $x^{(1)}(\\mathrm{t})$ 并不知道，但根据一阶微分方程的解为指数函数，故可令： $$x^{(1)}(t)=ce^{bt}$$ 并假设该曲线过点 $\\left(k, x^{(0)}(k)\\right)$ 及 $\\left(k+1, x^{(0)}(k)\\right),$ 则有 $$x^{(1)}(k)=c e^{b k}, \\quad x^{(1)}(k+1)=c e^{b(k+1)}$$ 由以上两式可解得： $$\\begin{array}{l}b=\\ln x^{(1)}(k+1)-\\ln x^{(1)}(k) \\\\c=\\frac{x^{(1)}(k)}{e^{b k}}=\\frac{\\left[x^{(1)}(k)\\right]^{k+1}}{\\left[x^{(1)}(k+1)\\right]^{k}}\\end{array}$$ 因此背景值为： $$\\begin{aligned}\\mathrm{z}^{(1)}(k+1) &amp;=\\int_{k}^{k+1} x^{(1)}(t) d t=\\int_{k}^{k+1} c e^{b t} d t \\\\&amp;=\\frac{x^{(1)}(k+1)-x^{(1)}(k)}{\\ln x^{(1)}(k+1)-\\ln x^{(1)}(k)}\\end{aligned}$$ 待辨参数 $a, u$ 可用最小二乘法求出 $$\\hat{\\Phi}=[\\hat{a} \\hat{u}]^{T}=\\left(B^{T} B\\right)^{-1} B^{T} Y$$ 其中 $$Y=\\left[\\begin{array}{c}x^{(0)}(2) \\\\x^{(0)}(3) \\\\\\vdots \\\\x^{(0)}(n)\\end{array}\\right],B=\\left[\\begin{array}{cc}-z^{(0)}(2) &amp; 1 \\\\-z^{(0)}(3) &amp; 1 \\\\\\vdots &amp; \\vdots \\\\z^{(0)}(n) &amp; 1\\end{array}\\right]$$ $z^{(1)}(k+1)$ 为由前面分析确定的背景值。 求出待辨识参数后，可得白化方程的离散解为： $$\\hat{x}^{(1)}(k+1)=\\left[x^{(1)}(1)-\\frac{\\hat{u}}{\\hat{a}}\\right] e^{-\\hat{a} k}+\\frac{\\hat{u}}{\\hat{a}}$$ 进行一次累減还原，可得原始数据序列的模拟值为： $$\\begin{aligned}\\hat{x}^{(0)}(k+1) &amp;=\\hat{x}^{(1)}(k+1)-\\hat{x}^{(1)}(k) \\\\&amp;=\\left(1-e^{a}\\right)\\left[x^{(1)}(1)-\\frac{\\hat{u}}{\\hat{a}}\\right] e^{-\\hat{a} k}\\end{aligned}$$ GM(1, 1) 新陈代谢模型若要进一步提高预测精度，可采用 GM(1, 1) 新陈代谢模型。首先采用原始序列建立 一个 GM(1, 1) 模型，按上述方法求出一个预测值，然后将该预测值补入已知数列中，同时 去除一个最旧的数据；在此基础上再建立 GM(1, 1) 模型，求出下一个预测值，以此类推。通过预测灰数的新陈代谢，逐个预测，依次递补，可以得到之后几期的数据，对原始数据数量进行有效扩充。 例题例题可见本文开头的链接。","tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"数模自学笔记","slug":"数模自学笔记","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%A8%A1%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"name":"数理统计","slug":"数理统计","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}]},{"title":"数模自学笔记——数理统计","date":"2020-05-25T13:39:23.000Z","path":"mcm/self-study/mathematical-statistics/","text":"面对一批数据进行分析和建模，首先需要掌握参数估计和假设检验这两个数理统计的最基本方法，给定的数据满足一定的分布要求后，才能建立回归分析和方差分析等数学模型。——《数学建模算法与应用（第2版）》（司守奎主编） “概率论与数理统计”，数理统计就是基于概率论的一个学科。只是数模对其要求会比概率论课程高一些。 统计分布临界值表 参数估计和假设检验推导见概率论课本。 正态分布正态分布的 $\\mu$ 的一个置信水平为 $1-\\alpha$ 的置信区间为$$\\bigg( \\overline{X} \\pm \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n-1) \\bigg)$$MATLAB 也直接提供了 $t$ 检验的公式： 12345x0=[506 508 499 503 504 510 497 512514 505 493 496 506 502 509 496];x0=x0(:);mu=mean(x0);[h,p,ci]=ttest(x0,mu,0.05) 而正态分布的 $\\sigma^2$ 的一个置信水平为 $1-\\alpha$ 的置信区间为$$\\bigg( \\frac{(n-1)S}{\\chi^2_{1-\\alpha/2}(n-1)}, \\frac{(n-1)S}{\\chi^2_{\\alpha/2}(n-1)}\\bigg)$$MATLAB 也直接提供了方差检验的公式： 12x2=[6.661, 6.661, 6.667, 6.667, 6.664];[h4,p4,ci4,st4]=vartest(x2,var(x1),'Alpha',0.1) 总体均值差的公式为$$\\bigg(\\overline{X_1}-\\overline{X_2} \\pm t_{\\alpha/2}(n_1+n_2-2)S_w\\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}}\\bigg)$$可使用 ttest2 进行检验。 123x1=[6.683, 6.681, 6.676, 6.678, 6.679, 6.672];x2=[6.661, 6.661, 6.667, 6.667, 6.664];[h,p,ci,st]=ttest2(x1,x2,'Alpha',0.1) 经验分布函数概率论没讲过。书上也讲了一堆定义，反正挺晦涩难懂的。又说这个函数收敛于什么什么函数，总之奇奇怪怪的。 一上图，我就猜到什么意思了。 经验分布函数 可以猜到，上面画的这个图就是经验分布函数，颇有离散型随机变量分布函数的意味。 但是，当点足够多的时候，这个经验分布函数就趋近于真实的函数了！（那是不是跑一下插值就是连续函数，美滋滋了） 如果真的用到了，再去翻书的定义吧（P130）。 Q-Q 图qwq Q：Quantile，分位数 Q-Q 图的作用是，给定一组观测数据（如上的经验分布函数的数据），然后确定了分布模型的参数 $\\theta$ 后，直观地检测拟合效果好坏的方法。 其方法大致是：将这些观测数据确定的经验分布函数的分位数，和计算出的分布函数对应的分位数，分别作为横纵坐标，画在一张图上。如果拟合效果好，这些点应该在 $y=x$ 上。如下图： Q-Q 图 具体作法依旧是用到的时候翻书。 非参数检验非参数检验，顾名思义，就是检验的不是参数，而是整个分布函数。 非参数检验又分为两种：$\\chi^2$ 拟合优度（goodness-of-fit）检验和柯尔莫哥洛夫检验。 前者可检验离散性和连续型变量。方法大致是将 $(-\\infty, +\\infty)$ 分为 $k$ 段，计算每段的概率和观测频率，通过运算得到 $\\chi^2$ 值用以检验。 柯尔莫哥洛夫检验。。。留个坑吧。这部分都挺难的，准备先粗略过一遍，所有章节学完以后，再回来看。 秩和检验秩 Rank：排序后的名次 用于判断两个分布有无显著差异。 方法是，将两个分布的数混起来然后排序。排完序以后，将其中一个分布的名次数加起来，称作秩和。 然后根据 $n_1$、$n_2$、$t$ 查表。如果秩和在中间部分，则可认为无明显差异。 Bootstrap这个是统计学的 Bootstrap，不是网页 css 框架的那个。 Bootstrap 是在样本点不够的情况下，从已知的信息中（有放回地）抽抽抽。抽出来的数每 $n$ 个数分为一组，美其名曰，一组容量为 $n$ 的样本。 对于每一组样本都可以算出一个随机变量，就可以对算出来的所有随机变量进行计算，得到该随机变量的均方误差、标准误差、区间估计等信息。 这种方法的好处在上面也就提到了，在样本点较少的情况下会有奇效。 这种方法需要在计算机上做大量的计算，随着计算机威力的增长，它也成为了流行的方法。 非参数 Bootstrap非参数 Bootstrap 是指，分布函数未知，仅知道一堆样本点。现在要计算某估计量 $\\theta$ （这里估计量甚至可以取中位数）的标准差 $\\sqrt{D(\\hat\\theta)}$、均方误差 $MSE=E[(M-\\theta)^2]$ 和置信区间等。 那么就只需要在给出的样本点里面抽抽抽就可以了。 我们在给定的样本中有放回地抽 $B$ 个大小为 $n$ 的样本（共抽 $Bn$ 次），对于每个样本，计算出 $\\theta$ 的估计 $\\hat\\theta^*_i$，则 $\\theta$ 的标准误差的 Bootstrap 估计为 $$\\hat\\sigma_{\\hat\\theta}=\\sqrt{\\frac{1}{B-1}\\sum_{i=1}^B(\\hat\\theta^*_i-\\overline\\theta^*)^2}$$ 其中 $\\overline\\theta^*$ 是原样本的 $\\theta$ 的估计值。 $\\theta$ 的均方误差的 Bootstrap 估计为 $$E_*(\\theta^*)=\\frac{1}{B}\\sum_{i=1}^B(\\hat\\theta^*_i-\\overline\\theta^*)^2$$ MATLAB 也提供了 bootstrp 函数，估计量函数可用匿名函数指定，函数返回 $B$ 个 $\\hat\\theta^*_i$。 Bootstrap 置信区间的求法相对有所不同。其方法是，对算出来的 $B$ 个 $\\hat\\theta^*_i$ 进行排序。在 $\\alpha/2$ 和 $1-\\alpha/2$ 位（下标为 $\\left[B \\times \\alpha/2, B \\times(1-\\alpha/2) \\right]$）的就是置信水平 $1-\\alpha$ 的 Bootstrap 置信区间。 参数 Bootstrap对于参数 Bootstrap，相较于上面多了一个分布函数的形式 $F(x;\\beta)$（参数未知）。 其做法是，先对分布函数和已知的样本点，计算出 $\\beta$ 的最大似然估计 $\\hat\\beta$，并代入至函数得 $F(x;\\hat\\beta)$。 然后，用分布函数 $F(x;\\hat\\beta)$ 产生 $Bn$ 个随机点。接下来的操作就和上面完全一样了。 方差分析方差分析用于检验单因素是否有影响，即在水平 $A_j (j=1,2,\\cdots,s)$ 下，进行多次试验，验证需要假设 $\\mu_1=\\mu_2=\\cdots=\\mu_s$。 3 个前提： 总体服从正态分布 个体是相互独立 组间方差相等 具体验证方法依旧是看书。 回归分析这部分的公式较多，所以依旧是只介绍思想，具体公式请范翻书。 拟合和回归拟合和回归分析的区别在哪里呢？ In short, curve fitting is a set of techniques used to fit a curve to data points while regression is a method for statistical inference. Curve fitting encompasses methods used in regression, and regression is not necessarily fitting a curve.Both curve fitting and regression try to find a relationship between variables. In the case of regression there are many more constraints in that relationship.What’s the difference between curve fitting and regression | Quora 翻译一下就是拟合是一些算出曲线的方法，而回归分析还要进行分析。 多元线性回归多元线性回归分析的模型是： $$\\begin{cases}y = \\beta_0 + \\beta_1x_1 + \\cdots + \\beta_mx_m + \\varepsilon \\\\\\varepsilon \\sim N(0, \\sigma^2)\\end{cases}$$ 其中 $\\beta_i$ 为未知系数，称为回归系数。 现在测得 $n$ 个独立的 $[y, x_1, x_2, \\cdots, x_m]$ 的观测值，第 $i$ 个为 $[b_i, a_{i1}, a_{i2}, \\cdots, a_{im}]$。 $m$ 个待估计参数、$n$ 组观测值。 第一步，进行参数估计。即以最小二乘法的原理，按公式计算得 $m$ 个 $\\beta$，以及残差（算得的 $\\beta_m$ 和每组的 $x_m$ 计算出的 $y_m’$ 减去 $y_m$ 的差，即一个误差） 第二步，验证回归模型的正确性（即，是不是线性回归模型）。判断标准是 $\\beta_i$ 是不是全为 0。一种思想是运用 $F$ 检验。另一种思想就是计算副判定系数 $R^2$。 第三步，对回归系数进行假设检验、区间估计。这里需要判定的是，$\\beta_i$ 中哪些是 0。 最后对回归模型进行预测，并给出区间估计。 MATLAB 工具 regress。 多元二项式回归MATLAB 工具 rstool。 非线性回归需要回归分析的函数同样是使用匿名函数定义。 MATLAB 工具 用途 nlinfit 计算回归系数 nlparci 计算回归系数的置信区间 nlpredic 计算预测值及其置信区间 nlintool 工具箱函数 灰色模型灰色模型类似于拟合和回归分析，但是区别是灰色模型给的参考点较少，一般用于估计行业质量发展（如“已知过去十年的指标数据，求预测未来十年的指标数据”）。更详尽的分析请移步 灰色模型。 游程检验用于检测一个样本序列是否排列随机。算法是将序列中大于平均值的记为 1，小于平均值的记为 0，再数连续的 0 或 1 的数量，最后查表。用到了再仔细学。","tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"坑","slug":"坑","permalink":"https://blog.lyh543.cn/tags/%E5%9D%91/"},{"name":"数模自学笔记","slug":"数模自学笔记","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%A8%A1%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"name":"数理统计","slug":"数理统计","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}]},{"title":"服务器一键搭建 V2Ray + WebSocket","date":"2020-05-22T03:26:55.000Z","path":"linux/build-v2ray/","text":"前置需求 一个域名，且已以 A 记录指向服务器 Docker 一键安装法安装 Docker一键脚本安装。如果不行，可以尝试到 Docker 官网上找方法，或者参考另一篇博文。 1bash &lt;(curl -s https://get.docker.com) 安装 V2Ray 服务器端一行命令，但是有需要修改的参数。 参考：https://github.com/pengchujin/v2rayDocker 1docker run -d --name v2ray -p 443:443 -p 80:80 -v $HOME/.caddy:/root/.caddy pengchujin/v2ray_ws:0.10 YOURDOMAIN.COM V2RAY_WS &amp;&amp; sleep 3s &amp;&amp; sudo docker logs v2ray YOURDOMAIN.COM：指向你的服务器 IP 的域名 修改好上述命令后，粘贴到命令行中执行。 三条命令监控 V2Ray： 123docker start v2ray # 启动 v2ray 并重新申请 SSL 证书docker stop v2ray # 停止 v2raydocker logs v2ray # 输出日志，可在这里查看 vmess 链接 链接可在 docker logs v2ray 中查看。 logs 中有一个安卓链接，一个 ios 链接，PC 用安卓的链接即可。 shell 脚本安装法https://github.com/233boy/v2ray/tree/master 部分错误及解决方案更新 V2Ray 客户端如果服务器给了 V2Ray 链接，但本地无法使用这个成功连接，可能是镜像中的 V2Ray 版本太老。下面将下载最新的 V2Ray 客户端并替换。 首先进入容器内的命令行： 1docker exec -it v2ray /bin/sh 在容器中的命令行中依次执行： 12345cd /usr/binwget https://github.com/v2ray/v2ray-core/releases/latest/download/v2ray-linux-64.zipunzip v2ray-linux-64.zip v2ray v2ctlrm v2ray-linux-64.zipexit 退出容器后，再重启 V2Ray 客户端： 1docker restart v2ray 配置 BBR搭上梯子以后，发现有时候丢包率有 40% 左右。 Google 了一下，说是可以开启 BBR 以实现加速。BBR 是什么、为什么能提升代理的速度、如何开启，可以看下面两篇博客。 注意，BBR 是针对 TCP 发包的，也就是说，设置好以后，对于所有代理软件和服务器上的所有网页等都会生效。 BBR是什么？ 转载：Ubuntu 18.04/18.10快速开启Google BBR的方法 提示：Ubuntu 18.10 依然可以用该方法开启 BBR，而对于 19.04 和 20.04、貌似官方直接给你开启了 BBR，不需要重复开启了。 修改系统变量并保存生效 1234sudo suecho \"net.core.default_qdisc=fq\" &gt;&gt; /etc/sysctl.confecho \"net.ipv4.tcp_congestion_control=bbr\" &gt;&gt; /etc/sysctl.confsysctl -p 查看内核是否已开启 BBR 123$ sysctl net.ipv4.tcp_available_congestion_control# 显示以下即已开启：net.ipv4.tcp_available_congestion_control = bbr cubic reno 查看 BBR 是否启动 123$ lsmod | grep bbr# 显示以下即启动成功：tcp_bbr 20480 14 借助国内的服务器进行中转有些时候会发现，即使开启了 BBR，速度依旧很慢。但是如果经由国内的服务器中转（即本地客户端 &lt;-&gt; 国内服务器 &lt;-&gt; 国外服务器 &lt;-&gt; Google），速度会快一些。 下面将基于国外服务器已经按上文搭建好 V2Ray 客户端的情形下，在本地客户端进行反向代理。 假设国外服务器的域名为 proxy-server.mydomain.com，国内服务器域名为 transit-server.mydomain.com。 国外服务器国外服务器已经按照上文搭建好服务器，并得到了其 VMESS 链接。 国内服务器国内服务器需要使用反向代理。可以用 Nginx/Apache 实现，也可以用 Caddy 实现。这里使用 Caddy。 安装 Caddy 后，在 /etc/caddy/Caddyfile 中写入： 12345transit-server.mydomain.com &#123; reverse_proxy proxy-server.mydomain.com:443 &#123; header_up Host &#123;http.reverse_proxy.upstream.hostport&#125; &#125;&#125; 然后重启（或重载） Caddy： 12sudo systemctl stop caddysudo systemctl start caddy 本地客户端将国外服务器的 VMESS 链接导入 V2Ray 客户端后显示，配置的服务器域名为 proxy-server.mydomain.com。将域名改为 transit-server.mydomain.com，其他配置不变即可。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"代理","slug":"代理","permalink":"https://blog.lyh543.cn/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"面对SSH暴力破解，给你支个招|九州云（转载）","date":"2020-05-20T01:07:02.000Z","path":"linux/use-iptables-to-protect-ssh-from-brute-force-attack/","text":"转载自 面对SSH暴力破解，给你支个招|九州云。为防链接挂掉，转载一手。 在最近一次云上线的过程中，频繁遇到绑定公网浮动 IP 的云主机遭受外界 SSH 暴力破解攻击及用户设置弱密码的问题，由此引发的安全问题引起了针对防御 SSH 暴力破解的思考。 SSH 暴力破解hydra 和 medusa 是世界顶级密码暴力破解工具，支持几乎所有协议的在线密码破解，功能强大，密码能否被破解关键取决于破解字典是否足够强大。在网络安全渗透过程中，hydra 和 medusa 是必备的测试工具，配合社工库进行社会工程学攻击，有时会获得意想不到的效果。图示两款工具使用密码字典穷举 SSH 密码的过程。 穷举 SSH 密码 iptables 限制 ssh 访问频率面对暴力破解，根据其工作原理可知：降低其试错频率，提高其试错次数，从而将破解时间提高到不可容忍的程度，是一条有效的防范手段。 提高攻击方试错次数，无非是提升密码长度，扩展密码复杂度，定期更换密码这些手段。而降低攻击方的试错频率其实也是一条值得一试的防御手段。 通过调用 iptables 的 state 模块与 recent 模块，实现对 SSH 访问的频率限制。这里重点解释下不常用的 recent 扩展模块。 recent 模块Recent，该扩展能够动态的创建 IP 地址列表，用于后期以多种不同形式做出匹配。该扩展支持以下多种选项： Recent 选项 iptables 规则内容要实现对 SSH 访问频率的控制，iptables 规则如下两条： 1234# 若是SSH访问，源IP在最近访问列表中，且60秒内访问次数大于等于3次，则丢弃。iptables -I INPUT -p tcp –dport 22 -m state –state NEW -m recent –name SSH_RECENT –rcheck –seconds 60 –hitcount 3 -j DROP#若是SSH访问，则将源IP加入最近访问列表中。iptables -I INPUT -p tcp –dport 22 -m state –state NEW -m recent –name SSH_RECENT –set 实现效果实现效果如下图所示。高频率的密码试错将被终结，直至一分钟超时后才可重新开始。 实现效果 在 /proc/net/xt_recent 目录中，存在名为 SSH_RECENT 的一个日志文件。文件中记录了上面输入的 iptables 规则记录的最近访问 SSH 服务的源 IP 信息以及访问时间。其中默认记录的 oldest_pkt 是 20 个，可以通过 modprobe ipt_recent ip_pkt_list_tot=50 调大。默认记录的源 IP 是 100 个，可以通过 modprobe ipt_recent ip_list_tot=1024 扩大记录数量。 iptables 实现远程开启 ssh 功能任何一次靠谱的网络攻击都起步于网络侦查。如果攻击者在网络侦查阶段未发现目标开启 SSH 登录服务，这也将挫败其针对 SSH 发起攻击的计划。这里常用的操作都是更改 SSH 的默认 22 端口至其他端口号上以迷惑端口扫描软件。实际通过 nmap 等工具还是可以扫描到端口上捆绑的具体服务，如下图所示。这里通过一个取巧的办法，利用指定报文长度的 ICMP 作为钥匙，开启主机上的 SSH 服务。通过这种方式隐藏 SSH 服务端口。 picture 5 iptables 规则内容以指定包长的 ICMP 报文，作为钥匙，开启对端的 SSH 服务。具体 iptables 规则如下所示。 1234567891011# 用 78 字节的 icmp 数据包作为钥匙(包含 IP 头部 20 字节，ICMP 头部 8 字节)，将源 IP 加入 SSH 白名单iptables -A INPUT -p icmp –icmp-type 8 -m length –length 78 -m recent –name SSH_ALLOW –set -j ACCEPT# 检查访问 SSH 服务的源 IP 是否在白名单中，且白名单中的IP有效期为15秒。若在白名单中则放行通讯。iptables -A INPUT -p tcp –dport 22 -m state –state NEW -m recent –name SSH_ALLOW –rcheck –seconds 15 -j ACCEPT#对于已建立的SSH连接放行iptables -A INPUT -p tcp –dport 22 -m state –state ESTABLISHED -j ACCEPT#其他SSH无关匹配全部拒止iptables -A INPUT -p tcp –dport 22 -j DROP 实现效果最终可以实现下图所示效果。在未使用指定包长ICMP之前，SSH服务无法通行（步骤1）。在使用指定包长ping之后（步骤2），使用SSH可以正常连接（步骤3）。以此实现了指定包长ICMP作为钥匙开启SSH通信服务的效果。其原理与上节限制SSH通信频率的原理一致。 picture 6 Fail2ban防止SSH暴力破解安装Centos上可以直接通过yum install fail2ban –y安装。安装完成后，可在/etc/fail2ban路径下找到程序运行的相应文件。在filter.d目录下存放有fail2ban支持的所有过滤器，action.d目录下存放有fail2ban支持的所有动作。通过在jail配置文件中组合多种过滤器与动作，可以实现各种自定义的防御功能（不仅限于SSH防护）。 配置及运行对于fail2ban而言，每个.conf配置文件都可以被同名的.local文件重写。程序先读取.conf文件，然后读取.local文件。.local中的配置优先级更高。通过新建jail.local，增加下述配置，运行fail2ban-client start来实现对SSH暴力破解的防御。 1234567891011121314151617181920212223242526272829303132[DEFAULT]#白名单ignoreip = 127.0.0.1/8#解封禁时间bantime = 600#试错窗口时间findtime = 600#容许试错次数maxretry = 3[ssh-iptables]#使能enabled = true#选择过滤器filter = sshd#选择防御动作action = iptables[name=SSH, port=ssh, protocol=tcp]#邮件通知sendmail-whois[name=SSH,dest=yang.hongyu@99cloud.net, sender=test@email.com]#SSH日志路径logpath = /var/log/secure#容许试错次数（优先级比default高）maxretry = 1 运行效果通过对目标主机的SSH试错，/var/log/secure日志中记录了SSH登录的错误信息。fail2ban通过对该文件的分析，识别出当前正在遭遇到SSH的暴力破解，继而触发防御功能。fail2ban-client status命令可以查看当前fail2ban的运行状态，遭遇SSH暴力破解后，识别到的攻击IP被添加至Banned IP list中，实际阻断功能则是fail2ban通过在iptables中下发针对攻击IP的阻断规则来实现。 Denyhost防止SSH暴力破解Denyhost工作原理与Fail2ban基本一致，同样是分析SSH的日志文件，定位重复的暴力破解IP。与Fail2ban通过写iptables规则阻断攻击IP的访问不同，Denyhost通过将攻击IP记录到hosts.deny文件来实现屏蔽攻击IP对SSH的访问。 Denyhost安装：1234wget \"downloads.sourceforge.net/project/denyhosts/denyhosts/2.6/DenyHosts-2.6.tar.gz\"tar -xzf DenyHosts-2.6.tar.gzcd DenyHosts-2.6python setup.py install Denyhost配置及运行12345678910111213141516171819202122#生成配置文件副本cd /usr/share/denyhosts/#生成配置文件副本cp denyhosts.cfg-dist denyhosts.cfg#生成执行文件副本cp daemon-control-dist daemon-controlchmod 700 daemon-control#自定义配置文件denyhosts.cfg#SSH log路径SECURE_LOG = /var/log/secure#存储SSH拒止host信息的配置文件路径HOSTS_DENY = /etc/hosts.deny#拒止时间,此处配置为10分钟PURGE_DENY = 10m#无效用户登录重试次数限制DENY_THRESHOLD_INVALID = 5#有效用户登录重试次数限制DENY_THRESHOLD_VALID = 10#ROOT用户登录重试次数限制DENY_THRESHOLD_ROOT = 1#启动运行./daemon-control start Denyhost效果：从Denyhost的运行日志中看出，对目标主机的多次SSH密码试错触发了Denyhost的防御功能。攻击者的IP被添加至hosts.deny文件，该IP下的SSH访问也被拒止。 网络安全，何来一招鲜可能有些人要说使用密钥登录就能完美解决SSH暴力破解的问题。这里要说一段历史。2006年Debian Linux发行版中发生了一件有意思的事，软件自动分析工具发现了一行被开发人员注释掉的代码。这行被注释掉的代码用来确保创建SSH秘密钥的信息量足够大。该代码被注释后，密钥空间大小的熵值降低到215。这意味着不论哪种算法和密钥长度，最终生成的密钥一共只有32767个，复杂度比一个纯6位数字的密码的复杂度更差。该错误在两年之后才被发现，无疑相当多的服务器上都利用这这种存在缺陷的弱密钥。（引用自：Violent Python：A Cookbook for Hackers） 网络安全没有一招鲜。前文中列举的四种安全加固方式也无法抵御运维人员设置的弱密码，及攻击者的社工密码库。运维人员，唯有提高自身安全意识，合理利用安全工具，才能保障网络安全。","tags":[{"name":"转载","slug":"转载","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"网络安全","slug":"网络安全","permalink":"https://blog.lyh543.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"MATLAB GUIDE（萌新向）","date":"2020-05-15T12:47:50.000Z","path":"matlab/matlab-guide/","text":"第一次从命令行到 GUI，总是不那么顺利的，尤其是 GUIDE 快被 MATLAB 弃用了，导致一向以文档详细著称的 MATLAB，也没有花多少笔墨在 GUIDE 上。 我因为数模需要速成 GUI，无奈没有很好的教程，走了很多弯路。因此我在数模交完论文之后，简单理一下速成 GUI 的思路。 实例代码MATLAB 为 GUIDE 编写的 Hello World 级别教程：https://ww2.mathworks.cn/help/matlab/creating_guis/about-the-simple-guide-gui-example.html 简单概念fig 和 m 的关系按上面的教程，打开 guide 并绘制了图形，就会自动生成一个 m 文件。简单的来说，fig 文件保存了 GUI 的窗口的样子，而 m 将会保存程序的逻辑。 各类函数的意义接着上文说，你会看到创建了一堆函数，那么具体是什么呢？ 现在假设我们想创建一个加法器（不是），具有两个按钮 + 和 - 和一个文本框，前者会使文本框内内容 +1，后者会 -1。 通过在 guide 命令新建的 fig 文件上，我们能很快糊出下面的图，并且把两个按钮改名为 + 和 -： fig 文件 然后保存，得到 m 文件，虽然代码有很多注释，但为读者方便对比差异（如果有），我还是完整贴一下代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function varargout = test_gui(varargin)% TEST_GUI MATLAB code for test_gui.fig% TEST_GUI, by itself, creates a new TEST_GUI or raises the existing% singleton*.%% H = TEST_GUI returns the handle to a new TEST_GUI or the handle to% the existing singleton*.%% TEST_GUI('CALLBACK',hObject,eventData,handles,...) calls the local% function named CALLBACK in TEST_GUI.M with the given input arguments.%% TEST_GUI('Property','Value',...) creates a new TEST_GUI or raises the% existing singleton*. Starting from the left, property value pairs are% applied to the GUI before test_gui_OpeningFcn gets called. An% unrecognized property name or invalid value makes property application% stop. All inputs are passed to test_gui_OpeningFcn via varargin.%% *See GUI Options on GUIDE's Tools menu. Choose \"GUI allows only one% instance to run (singleton)\".%% See also: GUIDE, GUIDATA, GUIHANDLES% Edit the above text to modify the response to help test_gui% Last Modified by GUIDE v2.5 17-May-2020 22:18:27% Begin initialization code - DO NOT EDITgui_Singleton = 1;gui_State = struct('gui_Name', mfilename, ... 'gui_Singleton', gui_Singleton, ... 'gui_OpeningFcn', @test_gui_OpeningFcn, ... 'gui_OutputFcn', @test_gui_OutputFcn, ... 'gui_LayoutFcn', [] , ... 'gui_Callback', []);if nargin &amp;&amp; ischar(varargin&#123;1&#125;) gui_State.gui_Callback = str2func(varargin&#123;1&#125;);endif nargout [varargout&#123;1:nargout&#125;] = gui_mainfcn(gui_State, varargin&#123;:&#125;);else gui_mainfcn(gui_State, varargin&#123;:&#125;);end% End initialization code - DO NOT EDIT% --- Executes just before test_gui is made visible.function test_gui_OpeningFcn(hObject, eventdata, handles, varargin)% This function has no output args, see OutputFcn.% hObject handle to figure% eventdata reserved - to be defined in a future version of MATLAB% handles structure with handles and user data (see GUIDATA)% varargin command line arguments to test_gui (see VARARGIN)% Choose default command line output for test_guihandles.output = hObject;% Update handles structureguidata(hObject, handles);% UIWAIT makes test_gui wait for user response (see UIRESUME)% uiwait(handles.figure1);% --- Outputs from this function are returned to the command line.function varargout = test_gui_OutputFcn(hObject, eventdata, handles) % varargout cell array for returning output args (see VARARGOUT);% hObject handle to figure% eventdata reserved - to be defined in a future version of MATLAB% handles structure with handles and user data (see GUIDATA)% Get default command line output from handles structurevarargout&#123;1&#125; = handles.output;% --- Executes on button press in pushbutton1.function pushbutton1_Callback(hObject, eventdata, handles)% hObject handle to pushbutton1 (see GCBO)% eventdata reserved - to be defined in a future version of MATLAB% handles structure with handles and user data (see GUIDATA)% --- Executes on button press in pushbutton2.function pushbutton2_Callback(hObject, eventdata, handles)% hObject handle to pushbutton2 (see GCBO)% eventdata reserved - to be defined in a future version of MATLAB% handles structure with handles and user data (see GUIDATA) 这博客真好水，放一段全是注释的代码，87 行就有了 注意 27 行到 44 行被 Begin initialization code - DO NOT EDIT 和 End initialization code - DO NOT EDIT 字样的注释包围了，这便是我们的函数的主函数。只是做了一些看不懂的初始化。确实，虽然他对于 GUI 的实现非常重要，但是我们的重点不在这里。 OpeningFcn12345% --- Executes just before test_gui is made visible.function test_gui_OpeningFcn(hObject, eventdata, handles, varargin)handles.output = hObject;guidata(hObject, handles); 这个函数。。。Fcn 是 function 的意思，看起来是 test_gui 这个文件的什么重要开场函数。确实，就相当于一个 init 函数，在程序运行时就会执行。 这个。。。guidata，hObject 和 handles 是个啥。不知道不知道，后面再说。 OutputFcn12% --- Outputs from this function are returned to the command line.function varargout = test_gui_OutputFcn(hObject, eventdata, handles) 这个函数看说明，应该就是程序的返回值用的，比如正常返回 0，错误返回非 0 之类的。 pushbutton1_Callback好了！这个是重点！ pushbutton，按钮？是我们刚才弄的两个之一吗？ 确实，在 fig 上双击先创建的按钮，会弹出上面的窗口。除了字体、字号、String 等设置以外，我们看到了他！Tag: pushbutton1。 啊所以这个函数名是靠 Tag 名绑定窗口按钮的？是的！这是 MATLAB 设定。所以，你可以同时把 tag 和函数名的 pushbutton1 改为 plus_button。 那这个 Callback？啊其实就是当按钮被按下时，会调用的 回调（Callback）函数。 那那那那那个静态窗口是不是就没有 Callback 函数呢，而还有一个 pushbutton2_Callback 函数呢？ 确实！ 总结一下，handlebutton1 关联了 Tag 叫这个名字的控件，而 Callback 是指这个函数是会在控件被触发时调用的 回调函数。 handles既然我们知道 1. OpeningFcn 在开场时会执行；2. 当 + 按钮被按下，pushbutton1_Callback 会被触发，那我会写了！ 123456function test_gui_OpeningFcn(hObject, eventdata, handles, varargin)counter = 0;function pushbutton1_Callback(hObject, eventdata, handles)counter = counter + 1;disp(counter); 咦？有点问题？ 根据 MATLAB 知识，两个函数的 counter 是不互通的。他们之间貌似也没有相互调用啊。那那那那咋办呢？ 声明为全局变量？不会吧，要是 GUI 程序不用全局变量就没法写，那也太蠢了吧？ 确实有别的办法，因为有一个东西，能沟通程序的控件的所有内容，她就是，handles。 handle （此处非 handles）是句柄，也就是一个类似于指针的东西。如果你也不知道指针，那……那就不管了。 简单的理解，MATLAB 的 handles 就是一个结构体，装了各种各样的数据，包括 GUI 的，包括你的程序需要使用的。 为什么要搞这个东西呢？因为从上面来看，MATLAB GUI 的实现方式是将所有东西都包装成函数，主函数没有什么存在意义。而没有主函数，如果不使用全局变量，数据就很难交互（比如，这个 pushbutton1 按下时，想读取那个输入框的内容时，就需要跨函数交互了）。 因此，如果将所有数据存在一个结构体下面，同时将这个结构体作为所有 Callback 函数的参数，问题就解决了！还真是，这个结构体就叫 handles！ 所以如果想保存数据/更新数据以供其他函数读取，就可以保存到 handles 下面。 但是但是！并不是说 handles.value = 1; 就是上面说的把数据保存在 handles 下面了。因为根据 MATLAB 知识，你修改的是你的函数下的 handles，并不是系统给你的 handles 了。 因此，引入一个新的语句： 1guidata(hObject, handles); 该句将你函数内的这个 handles 传给“系统”。至于为什么要 hObject，别问，问就是不知道，你能要求一天速成的人完全明白这一切的一切吗？会用就行了。（这是竞赛交卷以后马上写的，防杠标签） 传给了系统，这句话的意思，是指当别的 Callback 函数被调用时，它的 handles 应该是你在这个函数 guidata 传给“系统”，“系统”调用 Callback 函数时，就会把你的这个 handles 复制一份给它。至于这个“系统”是什么，请参照上一段。 https://ww2.mathworks.cn/matlabcentral/answers/47189-purpose-of-guidata-hobject-handles 读取、写入 handles 值因此，写入 handles 的语句应该如下： 12handles.counter = 0;guidata(hObject, handles); 读取则是由 Callback 函数得来。其实也可以手动获取： 1handles = guidata(hObject); 你会发现，读写原来是一个函数！ 有毒吧，用 ReadGUIData 和 WriteGUIData 不好吗？ 修改静态文本框于是，你觉得你又会了！（总觉得有问题） 1234567function test_gui_OpeningFcn(hObject, eventdata, handles, varargin)counter = 0;guidata(hObject, handles);function pushbutton1_Callback(hObject, eventdata, handles)counter = counter + 1;disp(counter); 当你准备运行这段代码时， disp？那不是命令行的东西吗？ 哦哦，突然想起我要输出在静态文本框里。 静态文本框？输出？静态的东西不能修改，怎么能用来输出？ 是的，我被骗了。我还以为有一种动态文本框的存在。然而 Google 很久都没有——直到我发现了下面的代码： 12set(handles.text1,'String','Hello World');% 别忘了 guidata(hObject, handles); 嗯？ 突然意识到什么。 赶紧看看我的静态文本框的属性。 （植物）！这个静态文本框的 Tag 为 text1，而且属性 String 的值正是正在屏幕上显示的 静态文本！ 原来这都是可以直接 set 的啊。。。。 顺便一提，还有 get。 get: 1str = get(handles.text, 'String'); 由于某些原因（一天速成就不要求这些了叭），不推荐通过直接查询/修改 handles.text 的成员，而是推荐 get 和 set 其属性。 加法器（不是）那我是不是用 handles 存 counter 数据，用 set(handles.text1,&#39;String&#39;,counter); 输出就可以了？ 于是你又觉得你好了！ 确实。这次是真的好了（？）。运用上面提到的内容，以及 MATLAB 基础知识，你就能实现一个加法器（不是）了。 一段非常简单的代码。复制保存为 test_gui.m，并且下载 test_gui.fig，在 MATLAB 中运行 test_gui.m 即可看到一个加减按钮和即时显示结果的简单小程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function varargout = test_gui(varargin)% Begin initialization code - DO NOT EDITgui_Singleton = 1;gui_State = struct('gui_Name', mfilename, ... 'gui_Singleton', gui_Singleton, ... 'gui_OpeningFcn', @test_gui_OpeningFcn, ... 'gui_OutputFcn', @test_gui_OutputFcn, ... 'gui_LayoutFcn', [] , ... 'gui_Callback', []);if nargin &amp;&amp; ischar(varargin&#123;1&#125;) gui_State.gui_Callback = str2func(varargin&#123;1&#125;);endif nargout [varargout&#123;1:nargout&#125;] = gui_mainfcn(gui_State, varargin&#123;:&#125;);else gui_mainfcn(gui_State, varargin&#123;:&#125;);end% End initialization code - DO NOT EDIT% --- Executes just before test_gui is made visible.function test_gui_OpeningFcn(hObject, eventdata, handles, varargin)handles.counter = 0;set(handles.text2, 'String', handles.counter);handles.output = hObject;guidata(hObject, handles);function varargout = test_gui_OutputFcn(hObject, eventdata, handles) guidata(hObject, handles);% Get default command line output from handles structurevarargout&#123;1&#125; = handles.output;% --- Executes on button press in pushbutton1.function pushbutton1_Callback(hObject, eventdata, handles)handles.counter = handles.counter + 1;set(handles.text2,'String',handles.counter);guidata(hObject, handles);% --- Executes on button press in pushbutton2.function pushbutton2_Callback(hObject, eventdata, handles)handles.counter = handles.counter - 1;set(handles.text2,'String',handles.counter);guidata(hObject, handles); 结语如果你能独立写出加法器（不是），那么你应该能算是入门了。至于 popupmenu 等控件的使用方法和其他一些细枝末节，相信聪明的你一定也可以的！ 有毒的结尾 顺便，最后说一句，将控制台 MATLAB 代码改成带有 GUI 的，推荐前者尽量使用函数，主函数几乎只用于调用函数。","tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"},{"name":"GUI","slug":"GUI","permalink":"https://blog.lyh543.cn/tags/GUI/"}]},{"title":"数模自学笔记——插值和拟合","date":"2020-05-11T13:39:23.000Z","path":"mcm/self-study/interpolation-and-curve-fit/","text":"插值和拟合的概念和区别插值曲线要过数据点，拟合曲线整体效果更好。 插值需要对准了才能插，拟合要求的是最接近的结果、最好的总体效果。 左二图为插值，右二图为拟合 一维插值 变量之中存在的函数关系，有时不能确定，而是通过获得的数据来找出两个变量间可能存在的连续。——《数学建模算法与应用（第2版）》（司守奎主编） 未知 $f(x)$，但已知 $f(x)$ 的很多观测点 $(x_i, y_i)$，要找一个（可以分段的）函数 $\\varphi(x) \\approx f(x)$，并且强制要求 $\\varphi(x)$ 经过所有观测点。 公式就略写了，要是用到了，看书就行。 分段线性插值简单的说，就是把每两个节点用直线连接起来。因此其函数表达式也较为显然。 有意思的是，虽然函数计算每点的插值时只用到左右两个点，但这个函数随着点数 $n$ 的增加，收敛于 $f(x)$，即 $\\lim\\limits_{n\\to\\infty} I_n(x) = f(x)$。因此也是用的最多的（如利用三角函数表计算任意三角函数值）。 拉格朗日插值从思想上来说，Lagrange 插值法是通过函数 $f(x)$ 的已知的 $n+1$ 个点 $(x_j, y_j)$，构造出一个多项式 $p(x)$ 来近似 $f(x)$。（这个多项式最高为 $n$ 次，经过全部 $n+1$ 个点） 在 Lagrange 插值中，已知 $n+1$ 个点 $(x_j, y_j)$，则应用 Lagrange 插值公式得到的 Lagrange 插值多项式 为： $$p(x) \\approx \\sum_{j=0}^k y_j l_j(x)$$ 其中 $$l_j(x) = \\prod_{i=0, i \\neq j}^n\\frac{x-x_i}{x_j-x_i}=\\frac{(x-x_0)}{(x_j-x_0)} \\cdots \\frac{(x-x_{j-1})}{(x_j-x_{j-1})} \\frac{(x-x_{j+1})}{(x_j-x_{j+1})} \\cdots \\frac{(x-x_{k})}{(x_j-x_{k})}$$ 但也是介绍一下概念，并没有太多展开。 样条插值样条 spline 插值的目标就是使函数连续，且在连接处具有连续的曲率。 即，在每一段上 $S(x)$ 是 m 次多项式，且在整段上，$S(x)$ 具有 $m-1$ 阶导数，则称 $S(x)$ 为样条函数。使用样条函数作为结果，就是样条插值。 由于 $m=1$ 时，不用考虑其导数，因此分段线性插值也是样条插值（23333 三次样条插值考虑次数为三的样条插值。由上面的定义我们可以设 $n$ 个区间的表达式为： $$S_i(x) = a_i x^3 + b_i x^2 + c_i x + d_i$$ 共有 $4n$ 个待定系数。 条件对应的方程有： (1) $S(x)_i=y_i (i=1,2,..n)$；(2) 相邻两段的函数值、一阶导数、二阶导数在临界点相同。 共 $(4n-2)$ 个表达式，还需给出两个表达式。由此引出了三个版本的样条插值。 $S’(a)=y_0’, S’(b)=y_n’$。这叫完备三次样条插值函数。 若令 $y_0’ = y_n’ = 0$，样条曲线在端点呈水平状态。 若以 $x_0 \\sim x_3$ 求三次 Newton 插值多项式（不懂这是什么）$N_a(x)$，以 $x_{n-3} \\sim x_n$ 求三次 Newton 插值多项式$N_b(x)$，然后令 $S’(a)=N’_a(a), S’(b)=N’_b(b)$，这叫 Lagrange 三次样条插值函数。 $S’’(a)=y_0’’, S’’(b)=y_n’’$。这叫自然边界条件。 $S’’(a)=S’’(b), S’(a)=S’(b)$，这叫周期条件。 MATLAB 插值工具箱一维插值1y = interp1(x0, y0, x, &lt;method&gt;) 其中 &lt;method&gt; 可选： &#39;nearest&#39;：最近项插值 &#39;linear&#39;：线性插值（默认） &#39;spline&#39;：立方样条插值，边界条件为 &#39;not-a-knot&#39;（见下） &#39;cubic&#39;：立方插值 立方样条插值立方样条插值更推荐使用 csape： 12pp = scape(x0, y0, &lt;conds&gt;, &lt;valconds&gt;); % pp 是 polynomial pieces，多项式分段（函数）y = fnval(pp, x); 其中 &lt;conds&gt; 为： 留空，使用 Lagrange 边界条件 &#39;complete&#39;：完备立方样条插值，即边界为一阶导数值，值在 &lt;valconds&gt; 中给出，若留空则按 Lagrange 边界条件 &#39;not-a-knot&#39;：非扭结条件，即要求前两段表达式的三阶导数相等，且后两段的三阶导数相等，在没有边界条件时常用 &#39;periodic&#39;：周期条件，即 $S’’(a)=S’’(b), S’(a)=S’(b)$ &#39;sencond&#39;：边界为二阶导数值，值在 &lt;valconds&gt; 中给出，若留空则取 $[0,0]$ 顺便，还可以将 fnval 改写为匿名函数，然后跑积分： 123456x0 = [0 3 5 7 9 11 12 13 14 15];y0 = [0 1.2 1.7 2.0 2.1 2.0 1.8 1.2 1.0 1.6];x = 0:0.02:15;pp = csape(x,y);int1 = integral(@(t)fnval(pp,t), 0,15) % int1 = 22.5788 这和 interp1 后运用积分定义 $\\int_a^b f(x)dx = \\lim_{n\\to\\infty}\\sum_{i=1}^n f(x_i)$（其中 $x_i$ 取两端点的平均值）求得的结果非常接近。 1234567x0 = [0 3 5 7 9 11 12 13 14 15];y0 = [0 1.2 1.7 2.0 2.1 2.0 1.8 1.2 1.0 1.6];x = 0:0.002:15;method = \"spline\";y = interp1(x0, y0, x, method);int2 = (sum(y)-(y(1) + y(end))/2) * 0.002 % int2 = 22.5788 二维插值二维插值，即节点为二维的插值问题。如测定了若干点的海拔（结点值），然后更精确的绘图。 这里不讲原理，直接讲应用了。 1z = interp2(X0, Y0, Z0, X, Y, &lt;method&gt;) 其中 X0 Y0 Z0 为大小相同的网格变量。如果读者不清楚什么是网格变量，或数据不是以网格变量给出的、而是以 x y 向量形式给出的，请参考 meshgrid。 &lt;method&gt; 与一维插值相同。 同时，二维的三次样条插值仍然可以使用 csape，只是输入参数有所变化。如需要，请自行查阅 MATLAB 文档。 如果输入的是散乱的 $n$ 个节点的 $x$、$y$、$f(x,y)$ 值，可以使用 griddata 进行插值： 1Z = griddata(x0, y0, z0, X, Y, &lt;method&gt;) &lt;method&gt; 与一维插值相同。 曲线拟合与最小二乘法曲线拟合就是给定 $n$ 个点，寻求一个函数 $f(x)$ 与给定的点在某种准则下最为接近，即拟合的最好。 线性最小二乘法是最常用的方法，其基本思想为，设 $$f(x) = a_1r_1(x) + a_2r_2(x) + \\cdots + a_nr_n(x)$$ 其中 $r_k(x)$ 为事先选定的一组线性无关的函数；$a_k$ 为待定系数。 拟合目标（准则）是使得 $y_i$ 与 $f(x_i)$ 的距离 $\\delta_i$ 的平方和最小，称为最小二乘准则，即 $$\\min_{a_1, a_2, \\cdots a_n} J=\\sum_{i=1}^n \\delta_i = \\sum_{i=1}^n [f(x_i)-y_i]^2$$ 可由线性代数知识证明，$r_k(x)$ 一旦确定且线性无关，则 $\\{a_1, a_2, \\cdots a_n\\}$ 有唯一的解。 现在的问题就在于 $r_k(x)$ 的选取。如果通过机理分析（通过对数据和现象的分析对事物内在规律做出的猜想、模型假设）能知道 $x$ 和 $y$ 的函数关系，就很容易了。如果不知道，则一般可以通过作图，然后直观地判断应该用什么样的函数。常见的曲线有： 直线 $y=a_1x+a_2$ 多项式 $y=a_1x^m + \\cdots + a_mx + a_{m+1}$（一般 $m=2,3$，不宜太高） 单支双曲线 $y = \\frac{a_1}{x} + a_2$ 指数函数 $y = a_1e^{a_2x}$ 最小二乘法 MATLAB 代码由于上述的证明 $\\{a_1, a_2, \\cdots a_n\\}$ 有唯一的解过程略，这里不写运用原理解最小二乘法。如需要，可查阅《数学建模算法及应用（第二版）》。 多项式拟合可使用 polyfit。也可以直接使用带 GUI 的工具箱函数 cftool。 12a = polyfit(x0, y0, m); % m 为次数，a 为多项式拟合的系数组成的向量y = polyval(a, x); % 多项式求值 最小二乘规划上面求参数 $\\{a_1, a_2, \\cdots a_n\\}$ 的过程，可以说是是在求参数值使得目标函数值最小。咦，这不就是最优化问题吗？ 所以这里的内容其实回到了规划问题，只是目标函数变成了最小二乘（least square，lsq）的形式，即目标函数变为 $$\\min F(\\boldsymbol{x}) = \\sum_{i=1}^m f_i^2(\\boldsymbol{x}),\\quad\\boldsymbol{x}\\in \\mathbf{R}^n$$ 注意这里的向量 $\\boldsymbol{x}$ （下同）实际上是参数，对应上面的 $f(x)$ 中的参数 $\\{a_1, a_2, \\cdots a_n\\}$；而这里的 $f_i(\\boldsymbol{x})$ 对应的是上面的 $\\delta_i = [f(x_i)-y_i]$。 对于这类规划问题，MATLAB 提供了以下函数，现整合为下表，且一并包含了 polyfit 函数： 函数名 适用情况 输入参数中的 $(x_i, y_i)$ 数据处理 polyfit 对参数为线性函数对 $\\boldsymbol{x}$ 为多项式函数 无需处理，直接作为函数参数 lsqlin 对参数为线性函数 需转化为对应矩阵元素 lsqcurvefit 对参数可为非线性函数 无需处理，直接作为函数参数 lsnonlin 对参数可为非线性函数 需转化为对应关于参数的函数 lsqnonneg 对参数为线性函数要求参数非负 需转化为对应矩阵元素 上表中的“对参数为线性函数”指 $f_i(\\boldsymbol{x})$ 对于 $\\{a_1, a_2, \\cdots a_n\\}$ 为线性函数。一个非线性的例子是：$y=e^{-a_1x_1}\\sin(a_2x_2)$。 顺便一提，由于最小二乘问题能化为二次规划问题，lsqlin 能解决的问题也可以使用 quadprog 解决。 最后，说了这么多，可能还是 cftool 好用（逃 曲线拟合与函数逼近上面的是用曲线去接近一些离散点的数据，下面考虑用一个（简单的）曲线接近一个（复杂的）函数曲线，这便是函数逼近。 与曲线拟合的最小二乘准则对应，函数逼近常用最小平方逼近，即 $$\\min_{f(x)} J = \\int_a^b [f(x)-y(x)]^2$$ 就是把 $y_i$ 改成 $y(x)$，把求和改成积分。合理。 之后的理论证明和解释因为有点高深，故略过，直接放一个例题的代码，以后需要的时候就照搬叭。 求 $f(x)=\\cos x, x \\in [-\\frac{\\pi}{2}, \\frac{\\pi}{2}]$ 在 $H = {\\rm Span}\\{1, x^2, x^4\\}$ 中的最小平方逼近多项式。 123456789syms xbase=[1,x^2,x^4];y1=base.'*basey2=cos(x)*base.'r1=int(y1,-pi/2,pi/2)r2=int(y2,-pi/2,pi/2)a=r1\\r2xishu1=double(a) % 符号数据转化成数值型数据xishu2=vpa(a,6) % 把符号数据转化成小数型的符号数据 解得 xishu1 = 0.9996 -0.4964 0.0372，即所求最小平方逼近多项式为 $$y = 0.9996 - 0.4964x^2 + 0.0372x^4$$ 例题 黄河小浪底调水调沙问题由于这部分内容比较简单，在数模中多是作为题目中的一个小点，因此纯插值拟合的题不难。 题目来源：《数学建模算法与应用（第2版）》（司守奎主编）节 5.5 黄河小浪底调水调沙问题 题目 题目重述略。 问题分析问题一要求我们通过给定 24 个时刻的数据，估计任意时刻的数据以及总排沙量，我们采用插值的方式得到任意时刻的数据，再对插值函数进行积分得到总排沙量。 问题二要求我们确定排沙量与水流量的关系，我们对数据进行拟合即可。 变量及名词解释 符号 含义 $t$ 观测时刻，以 6 月 29 日零点开始计时，以秒为单位 $w_t’$ 观测到 $t$ 时刻的水流量，单位 $m^3/s$ $s_t’$ 观测到 $t$ 时刻的含沙量，单位 $kg/m^3$ $S_t’$ 观测到 $t$ 时刻的排沙量，单位 $kg/s$ $S(t)$ 估计排沙量关于时刻的函数 $S$ 整个过程的总排沙量 $t_k$ 第 $k$ 次观测的时间点 $S(w)$ 估计排沙量关于水流量的函数 模型建立与求解问题一由于题目的时间是以日期、时分给出的，我们需将其化为以秒为单位的正整数。可得以下关系： $$t_k = 3600(12k-4) \\quad k = 1,2,\\cdots,24.$$ 由物理公式可知，排沙量=含沙量*水流量，即： $$S_t’ = s_t’ w_t’$$ 通过数据处理我们可以得到观测到的每个时刻的排沙量。 对这些数据进行三次样条插值，边界条件为非扭结条件，则可得到任意时刻的估计排沙量 $S(t)$。代入任意时刻即可求得该时刻的估计排沙量。 对 $S(t)$ 进行积分，就能得到总的排沙量。 编写 MATLAB 代码如下： 12345678910111213141516171819202122232425hold off;data = [ 1800 1900 2100 2200 2300 2400 2500 2600 2650 2700 2720 2650 2600 2500 2300 2200 2000 1850 1820 1800 1750 1500 1000 900; 32 60 75 85 90 98 100 102 108 112 115 116 118 120 118 105 80 60 50 30 26 20 8 5];t = 3600*(8:12:8+23*12);sand = data(2,:) .* data(1,:);T = t(1):t(end);% 插值pp = csape(t,sand,\"not-a-knot\");Sand = fnval(pp,T);SandTotal = integral(@(t)fnval(pp,t),T(1),T(end));% 输出排沙量和时间的函数关系图fplot(@(t)fnval(pp,t),[t(1) t(end)],'b-');hold on;plot(t,sand,'r*');hold off;pause% 输出总排沙量和时间的函数关系图f = @(time) integral(@(t)fnval(pp,t),T(1),time);fplot(f,[t(1) t(end)]) 得到函数图及输出如下： 总排沙量、总含沙量和时间的关系图 计算得从第一个检测时刻到最后一个检测时刻，共排沙约 $1.8440\\times 10^{11} kg$。 问题二问题二要求我们用已知数据拟合出排沙量 $S_t’$ 和水流量 $w_t’$ 的函数关系。 考虑到 7.4 8:00 时水流量最大，以该时刻为临界的前后两个时段可能是不同的状态，我们对函数分段进行拟合，前一段为 6.29 8:00 至 7.4 8:00，后一段为 7.4 8:00 至 7.10 20:00。其中中间时刻 7.4 8:00 被计算两次。 由于我们并不清楚其函数关系，所以先以上述数据绘制两幅散点图，然后使用 cftool 进行拟合。 编写 MATLAB 代码如下： 123456789101112131415161718192021data = [ 1800 1900 2100 2200 2300 2400 2500 2600 2650 2700 2720 2650 2600 2500 2300 2200 2000 1850 1820 1800 1750 1500 1000 900; 32 60 75 85 90 98 100 102 108 112 115 116 118 120 118 105 80 60 50 30 26 20 8 5];t = 3600*(8:12:8+23*12);sand = data(2,:) .* data(1,:);T = t(1):t(end);w1 = data(1,1:11);w2 = data(1,11:24);S1 = sand(1:11);S2 = sand(11:24);nexttile;plot(w1,S1, '*');title('前半段的散点图');nexttile;plot(w2,S2,'*');title('后半段的散点图');cftool 左为前半段的散点图，右为后半段的散点图 我们考虑对左图使用线性函数拟合，右图使用二次曲线拟合，并验证其 $R^2$ 值。 对于左图，使用线性拟合的结果为 $S_1(w) = 250.6w -3.734\\times 10^5$，$R^2=0.986$；对于右图，使用二次曲线拟合的结果为 $S_2(w) = 0.08882w^2 - 124.8w + 3.332\\times 10^4$，$R^2=0.9408$（相比一次下 $R^2=0.8837$）。 综上， $$S(w) = \\begin{cases}250.6w -3.734\\times 10^5 &amp; t &lt; t_{11} \\\\0.08882w^2 - 124.8w + 3.332\\times 10^4 &amp; t \\geq t_{11}\\end{cases}$$ 拟合效果图","tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"数模自学笔记","slug":"数模自学笔记","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%A8%A1%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"name":"插值和拟合","slug":"插值和拟合","permalink":"https://blog.lyh543.cn/tags/%E6%8F%92%E5%80%BC%E5%92%8C%E6%8B%9F%E5%90%88/"}]},{"title":"C# 入门笔记","date":"2020-05-08T02:35:28.000Z","path":"csharp/csharp/","text":"本篇的链接：https://docs.microsoft.com/zh-cn/learn/paths/csharp-first-steps/该教程浅显易懂，挺适合零基础编程基础的同学。当然也可以去看微软的其他入门教程。 Hello World!以下为一段 C# 代码的完整框架。 123456789101112using System;namespace CSharp&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); &#125; &#125;&#125; 注意，C# 严格区分大小写。因此，不能使用 console.WriteLine 或 Console.writeline。 该函数在末尾自带 \\n，等价于 Console.Write(&quot;Hello World!\\n&quot;)。 变量和数据类型数据类型 数据类型 中文 代码中的写法 输出时的写法 string 字符串 &quot;Hello world!&quot; Hello world! char 字符 &#39;H&#39; H int 字整数 123 123 decimal 十进制文本 12.3m 12.3 bool 布尔类型 true false True Fause 1Console.WriteLine(true); 该语句会输出 True。 声明变量1string firstName; 变量名称的规则和 C++、Python 等语言类似： 不许使用特殊字符 不能数字开头 不能是关键字 区分大小写 下面是一些约定： 推荐使用 CamelCase，如 thisIsCamelCase。 请勿使用缩写（约定好的缩写除外，如 msg） 变量名不应包含其数据类型，如 string strValue; 是不被推荐的。这可能是强大的 Visual Studio 能够通过智能感知查到变量名的类型。原文如下： 你可能会看到使用类似 string strValue; 样式的一些建议。这是几年前的热门样式。但是，大多数开发者不会再遵循此建议。 使用变量在对变量赋值前使用变量，会报错。 对变量赋值的方法和 C++ 相同。 1234string message = \"123\";string msg2;msg2 = \"213\"; var 类型1var msg = \"this is a message\"; var 和 C++ 的 auto 一样，在初始化的时候，编译器根据等号右边的值的类型（在这里是 string），将变量名声明为相同类型。 注意这些都是在编译阶段完成的，也就是说，不能在之后改变其数据类型，再将 int 值赋给 msg。 另外，var 变量必须在使用的时候进行初始化。 var 变量被叫做隐式类型本地变量。 为什么使用 var 类型呢？ var 关键字已被 C# 社区广泛采用，因此，如果你查看书籍或联机中的代码示例，很有可能会看到使用的是 var 关键字，而不是实际的数据类型名称。因此，我们想确保在此模块中将它引入。但 var 关键字在 C# 中具有重要用途。由于在编写高级代码之前你可能不甚了解，因此在某些情况下，初始化变量时，数据类型可能不太明显。实际上，在某些情况下， C# 可能会为代码提供一种新的数据类型，并可能无法提前为其指定可预测的命名。再说一次，这是 C# 的一项高级功能，我们将在其他模块中进行介绍。开始之际，我们建议声明变量时继续使用实际的数据类型名称。声明变量时使用数据类型有助于你有目的性地编写代码。 基本字符串格式设置这部分的内容很少有教程在刚开始的时候专门用一节提过，但是个人认为很有必要。 转义字符和其他编程语言一样 \\n \\t \\&quot; \\\\ 等都是支持的。 C# 的 \\u 是 utf-16 编码。如下面的代码： 1Console.WriteLine(\"\\u4f60\\u597d，世界！\"); 会输出 你好，世界！。 逐字字符串不少语言都支持 跨行字符串 （或 verbatim string literal raw string 字符串字面量）这一特性，即在写字符串的时候加一定的前缀、后缀，即可逐字的保留字符串中的内容，无需转义。 其他语言的类似情况可参考 逐字字符串在各语言中的表达式。 如下面的代码： 123string testString = @\"verbatim\\string\"; 等价于： 1string testString = \"verbatim\\n\\\\\\nstring\"; 使用 Console.WriteLine(testString) 会输出： 123verbatim\\string 字符串串联和 C++、Python 相同的是，C# 可以使用 + 对字符串进行串联。 123string a = \"Hello\", b = \"World\";string message = a + \" \" + b + \"!\";// 也可以使用字符串和字符进行串联 但是 C# 还可以用 字符串内插。 1string message = $\"&#123;a&#125; &#123;b&#125;!\"; 字符串内插通过使用“模板”和一个或多个内插表达式将多个值合并为单个文本字符串。内插表达式是一个变量，由一个左大括号和一个右大括号符号 { } 括起来。 当文本字符串以 $ 字符为前缀时，该字符串将变为模板。 这里涉及到两个概念 内插表达式 和 模板。请读者务必分清。 甚至可以逐字文本和字符串内插嵌套。其中 $ 和 @ 的顺序可以交换，先解析字符串内插，再逐字文本。 12string projectName = \"First-Project\";Console.WriteLine($@\"C:\\Output\\&#123;projectName&#125;\\Data\"); 基本数字运算操作这部分 C# 和 C++ 相同。 C# 支持 +=、-=、*=、++、-- 等，并且 ++ -- 也分为前缀加和后缀加。 if-elseif-else这部分 C# 和 C++ 也完全相同。放一段代码以供参考： 12345678910111213141516if (total &gt;= 16)&#123; Console.WriteLine(\"You win a new car!\");&#125;else if (total &gt;= 10)&#123; Console.WriteLine(\"You win a new laptop!\");&#125;else if (total == 7)&#123; Console.WriteLine(\"You win a trip for two!\");&#125;else&#123; Console.WriteLine(\"You win a kitten!\");&#125; 数组和 foreach声明数组下面以声明一个 String 类型数组为例： 1string[] firstArray = new string[3]; 注意到，执行该语句后，firstArray 的元素将被初始化。 那为什么不初始化单个的变量，导致在使用变量前会报错说“未初始化”呢？ 根据 Stack Overflow 的回答，对于变量也是会进行初始化的，但是，由于在未初始化之前使用变量是一个很像 bug 的行为，于是就规定这种行为不合法了。 对元素赋值123firstArray[0] = \"firstElement\";firstArray[1] = \"secondElement\";firstArray[2] = \"thirdElement\"; 获取数组元素的值结合内插表达式，可以写出如下语句： 123Console.WriteLine($\"First: &#123;firstArray[0]&#125;\");Console.WriteLine($\"Second: &#123;firstArray[1]&#125;\");Console.WriteLine($\"Third: &#123;firstArray[2]&#125;\"); 另外，可使用 firstArray.Length 获取数组的长度。 foreach12345string[] names = &#123; \"Bob\", \"Conrad\", \"Grant\" &#125;;foreach (string name in names)&#123; Console.WriteLine(name);&#125; 上述代码的运行结果： 123BobConradGrant 不过，对于 string[] name = new string[10] 这种数组，无论后面的变量是否使用，都会被遍历到。 使用 C# 创建具有约定、空格和注释的易读代码这部分并非针对 C#，而是针对所有开发者，写代码应该注意以下几点： 应该正确地使用首行缩进 写代码应该多使用空格，以更清楚地传达代码意图 使用代码注释，但也要有原则的使用 这部分讲的深入浅出，推荐阅读： https://docs.microsoft.com/zh-cn/learn/modules/csharp-readable-code/","tags":[{"name":"C#","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"编程语言入门","slug":"编程语言入门","permalink":"https://blog.lyh543.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"}]},{"title":"数模自学笔记——图与网络模型及方法","date":"2020-04-27T16:00:00.000Z","path":"mcm/self-study/graphs/","text":"其实离散数学的时候讲过，数据结构又讲过，数模再讲一遍。 什么问题能抽象为图论举了一堆例子，然后得出结论： 能够把问题抽象为两种：元素，以及元素之间的关系 上面的这种问题就可以抽象为图论 基本概念图的元素 $G=(V, E)$ $Vertex$ 为顶点，$Edge$ 为边 $V={v_1, v_2, v_3, v_4}, E={e_1, e_2, e_3, e_4}$ $e=(u, v)$ 无向边 $e=&lt;u, v&gt;$ 有向边（弧），$u$ 为始点（弧尾），$v$ 为终点（弧头），统称端点 边与点：相关联 点与点：邻接点/不邻接的 边与边：邻接边 自回路（环） 计算机科学叫自环 图的分类孤立结点 零图（只有孤立节点） 平凡图（只有一个结点） $(n, m)$ 图（$n$ 点 $m$ 边）无向图 有向图 混合图平行边 重数 多重图 线图（非多重图）简单图（无环的线图） 阶（顶点的个数）完全图同构图 图的记法关联矩阵（$n*m$ 矩阵，存储边和点关联的次数） 邻接矩阵 邻接表（略） 度度、入度、出度 握手定理（欧拉定理）：无向图中，所有结点的度数的总和等于边数的两倍推论：度数为奇数的结点数为偶数 路 路 边不重复 点不重复 通路 简单通路（边不重复） 基本通路（除端点外任意两点都不同） 回路（起点和终点相同） 简单回路（边不重复的回路） 基本回路/圈（起点和终点相同的长为正的基本通路） 约定：凡指基本通路或路均认为此路不是圈。 易知，图中若点 u 与 v 间存在通路，则 u 与 v 间必存在基本通路；若过点 u 存在简单回路，则过点 u 必存在基本回路。 最短路问题这里最短路指的是单源最短路。 这里放一个 Dijsktra 算法的描述。虽然数据结构和离散都讲过，还有代码，但是数模的描述还是稍微有一点不同的。 Dijkstra 算法 另外也可以用线性规划求解： $$\\min \\sum_{(i,j) \\in E} w_{ij}x_{ij} \\\\\\text{such that}\\sum_{j=1, (i,j)\\in E}^n x_{ij} - \\sum_{j=1, (i,j)\\in E}^n x_{ji} =\\begin{cases}1 &amp; i = 1 \\\\-1 &amp; i = n \\\\0 &amp; i \\neq 1, n\\end{cases} \\\\~\\\\x_{ij} \\geq 0, (i, j) \\in E$$ 例题不少，可以看看 PPT。 子图上面的概念是针对任何图，下面我们针对 这部分概念只是介绍一下，具体什么的定义还是去看 PPT 吧。 子图：所有的顶点和边都属于图 G 的图称为 G 的子图。 真子图：若这个节点子集或边子集是真子集，则称这个子图为真子图 生成子图：含有 G 的所有顶点的子图称为 G 的生成子图。 （点）导出子图：由该图顶点的一个子集和该图中两端均在该子集的所有边的集合组成的图 （边）导出子图：由该图边的一个子集和以该子集中的边相关联的点组成的图 G 的补图：从完全图删除 G 的所有边得到的图 G1 在 G 的补图：从 G 中删除 G1 的所有边得到的图 树 无圈的连通图称为树。树中度为 1 的点称为树叶，其余点称为分枝点。 定理：设 $G$ 是具有 $n$ 个点 $m$ 条边的图，则以下关于树的命题等价。 $G$ 是树。 $G$ 中任意两个不同点之间存在唯一的路。 $G$ 连通，删去任一边便不连通。 $G$ 连通，且 $n=m+1$。 $G$ 无圈，且 $n=m+1$。 $G$ 无圈，添加任一条边可得唯一的圈。 居然是一条一条可以证明的，而且是从定义的仅仅 9 个字出发的。精妙精妙。证明略。读者可以自己思考。 一波定义： 有向树：去掉边方向后是一棵树的有向图根树：恰有一个顶点的入度为 0，其余顶点的入度均为 1 的有向树 根：入度为 0 的顶点 叶：出度为 0 的顶点 分支：出度不为 0 的顶点$m$ 叉树：所有顶点出度不大于 $m$ 的根树完全 $m$ 叉树：各顶点出度要么为 0，要么为 $m$ 的 $m$ 叉树 定理： 设完全 $m$ 叉树的叶子树为 $t$，分支树为 $i$，则有：$$(m-1)i=t-1$$ 证明从 各顶点出度之和=弧数 出发。 生成树关于连通图： 边连通度：删掉任意 $k$ 边，图都连通（但不对 $k+1$ 成立），则该图的边连通度为 $k$点连通度：删掉任意 $k$ 点，图都连通（但不对 $k+1$ 成立），则该图的点连通度为 $k$ 树的边连通度、点连通度都是 1。 生成树定义： 若图 G 的生成子图T是树，则称T为G的生成树。 定理：连通图的生成树必存在。 证明：给定连通图 G，若 G 无圈，则 G 就是自己的生成树。若 G 有圈，则任取 G 中一个圈 C，记删去 C 中一条边后所得之图为 H1。显然在 H1 中，圈 C 已不存在，但仍连通。若 H1 中还有圈，重复以上过程，直至得到一个无圈的连通图 H。H 便是 G 的生成树。 没错，这就是“破圈法”——求生成树的一个算法。 最小生成树定义： 在权图 G 中，边权之和最小的生成树称为G的最优树。 Krusual 算法好评： Kruskal 算法","tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"图论","slug":"图论","permalink":"https://blog.lyh543.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数模自学笔记","slug":"数模自学笔记","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%A8%A1%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Python 面向对象编程","date":"2020-04-22T14:29:15.000Z","path":"python/python-oop/","text":"在学 Python OOP 之前，我在想，怎么还没到结构体，后来才恍然大悟，结构体是 C 的东西，C++ 有了类以后，（不考虑效率问题）就不需要结构体了，而 Python 也是这样，有了类，还需要结构体做什么呢？ 该篇博客默认读者曾学过至少一门 OOP 语言。 Python 和 C++ 的对同一个概念的称呼的简单对照表： Python C++ 类 class 类 class 实例 instance 对象 object 方法 methods 成员函数 member functions 属性 attributes 成员变量 member variables 类和实例类的定义： 12345678class Student(object): # object 表示被继承的类，如果没有继承类，就写 object def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 由类生成的东西，在 C++ 中叫对象 object，但是在 Python 中叫实例 instance。可能是因为 Python 的对象被用来指代东西了吧，比如类对象、方法对象。 创建 实例，并调用实例对应的关联函数（关联函数被称为实例的方法 Method）： 1234bart = Student('Bart Simpson', 59)lisa = Student('Lisa Simpson', 87)bart.print_score()lisa.print_score() 从第一段代码还可以看出，类的构造方法是 __init__。 另外，在定义类的时候，每个函数无论在声明、还是在使用时，都要写明第一个参数是 self（C++ 只在静态成员函数的时候需要写明） 和 C++ 不同的是，外部代码在使用对象的时候，Python 还可以创建成员： 1bart.grade = 'A' 类属性由于 C++ 需要初始化变量，所以 C++ 类一般先是一堆变量声明，再是成员函数。 到了 Python 这里，不需要声明，直接就是几个方法，反而有点不习惯。 如果想要给类弄一个属性（类似于 C++ 的静态成员），也是可以的，而且方法也浅显易懂： 123456789class Student(object): course = 'Chinese' def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 类属性是可以被实例属性覆盖的。并且，如果删除了示例的属性，会还原为类属性。 12345678print(Student.course) # 显示 Chinesebart = Student('Bart', 95)print(bart.course) # 显示 Chinesebart.course = 'Math' # 示例属性覆盖类属性print(bart.course) # 显示 Mathprint(Student.course) # 显示 Chinesedel bart.course # 删除示例实心print(bart.course) # 显示 Math 私有成员如上，Python 并没有 C++ 一样的，必须写明对象是 public，否则就是私有 private 的。而 Python 如何在类中创造私有成员呢： 1234567class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) 此时能够正常执行 print_score 函数，但无法访问 __name 了： 1234567&gt;&gt;&gt; bart = Student('bart', 95)&gt;&gt;&gt; bart.print_score()bart: 95&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute '__name' 此时，如果需要获取 name、修改 name 时，就需要在类里面添加 getName 和 setName。这是面向对象编程的经典操作。 需要注意的是： 形如 __xxx__ 的变量名是特殊变量，可以直接访问； 其实也可以通过访问 _Student__name 来访问 __name，Python 解释器也只是改了一个名字。仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。当然还是强烈建议不要访问。 大多数 Python 代码还遵循这样一个约定：带有一个下划线的名称 (例如 _spam) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。也就是说，不应该去访问它，虽然他并不是私有成员。 继承继承： 123456789101112class Animal(object): def run(self): print('Animal is running...')class Dog(Animal): passclass Cat(Animal): passDog().run()# 输出 Animal is running... 注意：如果基类定义在另一个模块中，可以使用： 1class DerivedClassName(modname.BaseClassName): 多继承多继承的语法没什么好说的。 123456class DerivedClassName(Base1, Base2, Base3): &lt;statement-1&gt; . . . &lt;statement-N&gt; 但是多继承涉及到的问题就挺麻烦了（C++ 对多继承问题的处理可以参考博客 C++ 面向对象——继承、派生和多态）： 如果有两个不同父类有同一个属性 你可以理解为 Python 的处理办法是深度优先、从左至右地搜索父类的属性，搜到了第一个，就不会管后面的同名属性了。简单粗暴。 真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 super() 的协同调用。 这种方式在某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大。 如果出现了菱形关联，如同在 C++ 那篇博客题到的下图左边的情况（右边是 C++ 默认的实现）： AMCar 但是 Python 的 动态改变的方法解析顺序 可以保证只调用每个父类一次。（用 C++ 的话来说就是，所有基类都是虚基类 virtual base） 只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序） 后面这句不大明白。 多态多态，即子类重载父类的同名方法： 123456class Dog(Animal): def run(self): print('Dog is running...')Dog().run()# 输出 Dog is running... 所有函数默认都是虚函数的。 运算符重载Python 也支持运算符重载，但是和 C++ 的不一样，C++ 可以对任意运算符进行重载，Python 只能通过重载系统给定的的对应的函数，来重载部分运算符。 方法名 重载说明 运算符调用方式 __init__ 构造函数 对象创建: X = Class(args) __del__ 析构函数 X 对象收回 __add__/__sub__ 加减运算 X+Y，X+=Y/X-Y，X-=Y __or__ 运算符` ` _repr__／__str__ 打印／转换 print(X)、repr(X)／str(X) __call__ 函数调用 X(*args, **kwargs) __getattr__ 属性引用 X.undefined __setattr__ ,属性赋值 X.any=value __delattr__ 属性删除 del X.any __getattribute__ 属性获取 X.any __getitem__ 索引运算 X[key]，X[i:j] __setitem__ 索引赋值 X[key]，X[i:j]=sequence __delitem__ 索引和分片删除 del X[key]，del X[i:j] __len__ 长度 len(X) __bool__ 布尔测试 bool(X) __lt__，__gt__ 特定的比较 依次为X&lt;Y，X&gt;Y __le__，__ge__ X&lt;=Y，X&gt;=Y __eq__，__ne__ X==Y，X!=Y __radd__ 右侧加法 other+X __iadd__ 实地（增强的）加法 X+=Y(or else __add__) __iter__，__next__ 迭代 I=iter(X)，next() __contains__ 成员关系测试 item in X(X为任何可迭代对象) __index__ 整数值 hex(X)，bin(X), oct(X) __enter__，__exit__ 环境管理器 with obj as var: __get__，__set__，__delete__ 描述符属性 X.attr，X.attr=value，del X.attr __new__ 创建 在__init__之前创建对象 更多的数学符号重载请看 Python 文档|模拟数字类型。","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"}]},{"title":"数模自学笔记","date":"2020-04-13T05:14:41.000Z","path":"mcm/self-study-note/","text":"本篇原内容已迁移至 数模自学笔记 规划问题。 所有自学笔记的链接：Tags: 数模自学笔记","tags":[]},{"title":"数模自学笔记——规划问题","date":"2020-04-13T02:27:07.000Z","path":"mcm/self-study/optimization/","text":"本章内容：线性规划 整数规划 非线性规划 规划问题 建模思路无非就是把这些规划化成对应规划的标准形式，然后就可以丢进 MATLAB 里跑了。 线性规划用 linprog。整数线性规划用 intlinprog。二次规划使用 quadprog。 非线性约束中，对于无约束优化用 fminunc 或 fminsearch，对于有约束优化用 fmincon。 对于要求一系列函数中最大值的极小值，可以使用 fminimax。 除此之外，还有 fminbnd、fseminf、fminimax。这些函数都是解决非线性规划问题，但算法不一样。可能平时不用学习，但在实战中如果遇到 fmincon 函数失效的情况，可以考虑使用一下。 注意，MATLAB 不提供解 非线性规划+整数规划 问题的函数，也不支持两个自变量相乘（如 xy &lt;= 3）的问题。如果必要，可以上遗传算法 ga，或使用 LINGO 进行编程。 以上函数的用法类似，可以使用传统的输入参数 $Aeq$、$beq$ 等进行求解，也可以使用 Problem-Based Approach。 函数的使用方法可以用的时候再查表。 非线性约束条件的规划问题转化为线性规划问题的方式可看优化 | 线性规划和整数规划的若干建模技巧。 蒙特卡罗法的正确性（或者说，有效性？）是由概率统计保证的。假设随机投点投入高值区的概率为 $0.00001$，投 $10^6$ 次，则最优解在高值区的概率为 $$1-0.99999^{10^6} = 0.9999546$$ 例题 线性规划 题目来源：《数学建模算法与应用（第2版）》（司守奎主编）例 1.4 完成下面的线性规划。 $$\\min z=\\left|x_{1}\\right|+2\\left|x_{2}\\right|+3\\left|x_{3}\\right|+4\\left|x_{4}\\right|$$$$s.t.\\left\\{\\begin{array}{rrrrr}x_{1}&amp;-x_{2}&amp;-x_{3}&amp;+x_{4}&amp; \\leq&amp; -2 \\\\x_{1}&amp;-x_{2}&amp;+x_{3}&amp;-3 x_{4}&amp; \\leq&amp; -1 \\\\x_{1}&amp;-x_{2}&amp;-2 x_{3}&amp;+3 x_{4}&amp; \\leq&amp; -\\frac{1}{2}\\end{array}\\right.$$ 进行变量替换： $$\\begin{cases}u_i = |x_i| + x_i \\\\v_i = |x_i| - x_i\\end{cases}$$ 问题转化为自变量为 $u_i$ $v_i$ 的线性规划。 使用 Problem-Based Approach 的 MATLAB 代码如下： 12345678910111213141516171819u = optimvar('u',4,'LowerBound',0);v = optimvar('v',4,'LowerBound',0);absx = (u + v)/2;x = (u - v)/2;z = absx(1) + 2*absx(2) + 3*absx(3) + 4*absx(4);cons1 = x(1) - x(2) - x(3) + x(4) &lt;= -2;cons2 = x(1) - x(2) + x(3) - 3*x(4) &lt;= -1;cons3 = x(1) - x(2) - 2*x(3) + 3*x(4) &lt;= -1/2;prob = optimproblem('Objective',z);prob.Constraints.cons1 = cons1;prob.Constraints.cons2 = cons2;prob.Constraints.cons3 = cons3;problem = prob2struct(prob);% problem.options = optimoptions('linprog','Display',\"off\");[sol,fval,exitflag,output] = linprog(problem) 解得 sol = [0 4 0 0 0 0 0 0]。由 varindex(prob) 可得 sol 各值和 $u_i, v_i$ 的对应关系。可得除了 $u_2=4$ 以外，其他都是 $0$。 代入 $x_i$ 后可得，当 $x_2 = 0, x_1 = x_3 = x_4 = 0$ 时，$\\min z = 4$。 例题 整数规划 题目来源：《数学建模算法与应用（第2版）》（司守奎主编）练习 2.4 设计知识点：整数规划、蒙特卡罗、分布检验 题目-1 题目-2 一篇题解：https://docsplayer.com/25899644-Microsoft-word-a-doc.html 看起来是一个整数规划，但是第二问却无从下手。看到上面的题解才发现了有意思的东西。 第一小问第一小问挺简单的，就是给定了价值矩阵，求一个整数规划。不过题目中仍有 case 的情况，即： $$k_i=\\begin{cases}0 &amp; \\sum\\limits_{j=1}^4 x_{ij} &lt; 4 \\\\1 &amp; \\sum\\limits_{j=1}^4 x_{ij} = 4\\end{cases}$$ 其中 $x_{ij}$ 为 $0-1$ 变量，当第 $i$ 名运动员参加 $j$ 项目时为 $1$。$k_i$ 也是 $0-1$ 变量，当第 $i$ 名运动员参加全部四项项目时为 $1$。 将这个条件化为线性约束条件时，答案用的很妙： $$0 \\leq \\sum\\limits_{j=1}^4 x_{ij} - 4k_i \\leq 3$$ 如果问这是怎么推出来，其实也可以由 优化 | 线性规划和整数规划的若干建模技巧 给的大 $M$ 法推。 不过这里由于 $x,y$ 都是 $0-1$ 变量，所以约束条件是不唯一的。不过答案给的这一种比较美观、简洁。 第二小问第二问的话，有点无从下手，因为价值矩阵是不确定的，没法规划。 有意思的地方就在于，第一问没有让求最乐观情况下的最优解，而最乐观的情况下的最大值，也就比目标值多了 $0.3$。这意味着，运动员在绝大多数地方必须发挥最好，仅有一两次机会发挥不好。夺冠的概率很低很低。 因此，不再追求夺冠率的极大值（毕竟可能也就 $1\\times10^{-20}$ 和 $2\\times10^{-20}$ 的区别），而是追求期望分数的极大值（前提是该分配下的最乐观情况能够夺冠），即： $$ \\max S = 平均期望的总分数 \\\\s.t. \\quad 最乐观情况的总分数 \\geq 236.2 $$ 这种想法还有一种原因，文章在结语里提到，在实际生活中这是一种很自然的想法。 考虑到实际生活中教练基本是按每位运动员平均得分以及稳定程度确定阵容，因此…… 第二个有意思的地方在于他对第二问计算得分期望的概率函数换了一个方式建模。我的想法是用蒙特卡罗法模拟足够多次，通过这些数据作出它的曲线。 但是文章模拟了 70 次，然后就交给 lillietest 函数，检验出来是正态分布，接下来就按照正态分布做了。这是我没想到的。这也是数据处理的一个思路， ——说不定就是个正态分布了呢？ 建模技巧非线性约束条件的规划问题转化为线性规划问题的方式可看优化 | 线性规划和整数规划的若干建模技巧。 选择地购买若干种资产或存银行生息，使净收益尽可能大，总体风险尽可能小。 这里可以进行多目标优化。 另外一种做法就是枚举收益值（如 $\\Delta a=0.01$），对于每个收益值求最小风险，然后作函数图。 如果非线性规划问题要求实时算法，则可以使用罚函数方法，但计算精度较低。 如果非线性规划问题不要求实时算法，但要求精度高，则可以使用 Lingo 软件编程求解或使用 Matlab 的 fmincon 命令求解。 例题 国赛 2009D 会议筹备知识点：线性规划、整数规划、多目标规划、线性回归。 题目链接：http://special.univs.cn/service/jianmo/sxjmtmhb/2009/1009/864452.shtml优秀论文：https://wenku.baidu.com/view/d32ba04669eae009581bec2c.htmlPPT 讲解：https://wenku.baidu.com/view/67e207a6284ac850ad024229.html?rec_flag=default&amp;sxts=1587173703951上面两个资料各有优缺点，可以对比参考。优秀论文 2：https://wenku.baidu.com/view/5e238f01de80d4d8d15a4f73.html简化版的题目的建模，简化为整数建模：https://wenku.baidu.com/view/5c1657c03186bceb19e8bbef.html 请你们通过数学建模方法，从经济、方便、代表满意等方面，为会议筹备组制定一个预订宾馆客房、租借会议室、租用客车的合理方案。 审题：从三个方面分析，应该看出来这是多目标规划。 宾馆的预定与会议室的租借都是 0—1 规划模型，我们在考虑宾馆和会议室的时候，当宾馆预订时，此会议室可以开，也可以不开，但是当某个会议室租借时，对应的宾馆就必须预订。 宾馆和会议室之间的对应关系为 $y_{ij}\\leq x_{ij}$。 租车要考虑多少代表参加哪个分组会议，题目中没有这方面的信息，可以按照平均的、随机的方式处理。 题目没有提到的东西，就可以假设为平均的、随机的。用好这些假设，简化问题。 优化的约束条件中有： $$y=\\begin{cases}1 &amp; x &gt; 0 \\\\0 &amp; x = 0\\end{cases}$$ 显然该约束条件无法在 MATLAB 中直接调用 intlinprog 求解。 可以将约束条件转化为： $$\\varepsilon y \\leq x \\leq My$$ 其中 $\\varepsilon$ 为足够小的数，$M$ 为足够大的数。","tags":[{"name":"最优化","slug":"最优化","permalink":"https://blog.lyh543.cn/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"},{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"数模自学笔记","slug":"数模自学笔记","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%A8%A1%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"MATLAB 符号编程","date":"2020-03-31T14:00:58.000Z","path":"matlab/matlab-syms/","text":"符号对象 (Symbolic Objects 不同于普通的数值计算) 是 Matlab 中的一种特殊数据类型，它可以用来表示符号变量、表达式以及矩阵。利用符号对象能够在不考虑符号所对应的具体数值的情况下能够进行代数分析和符号计算 (symbolic math operations)，例如解代数方程、微分方程、进行矩阵运算等。符号对象需要通过 sym 或 syms 函数来指定, 普通的数字转换成符号类型后也可以被作为符号对象来处理。我们可以用一个简单的例子来表明数值计算和符号计算的区别： 2/5+1/3 的结果为 0.7333 (double类型数值运算)，而 sym(2)/sym(5)+sym(1)/sym(3) 的结果为 11/15，且这里 11/15 仍然是属于 sym 类型, 是符号数。 – MATLAB符号对象与符号运算 符号编程即 $y = ax^2 + bx + c$ 此类函数，并可以对其进行求极限、求导、积分等操作。 除此之外，符号编程还有精确的优点，比如可以用 sym(1)/sym(3) 来表示精确的分数。 sym 类型和 double 一样，sym 也是一种类型，可以用 whos 命令查看。 sym 类型不仅可以存储 x y 这样的数学意义上的（而不是编程意义上的）变量，还可以存储 1、1/3 这样的数。但请注意，这里的 1/3 是精确的，而不是用浮点数存储的 double 类型的 0.33333...。 sym 类型的数值可以和 double 类型互相转换，转换方法和其他的类似。 123a = sym(1) # 将 double 值转换为 symb = a/3； # b 为 sym, 1/3c = double(b) # 将 sym 转为 double, c = 0.3333 除此之外，还可以使用 vpa() 函数来求一个 sym 数值的任意精度的小数（没错，任意！）。不过请注意， vpa 的返回值仍然是一个 sym。 另外请注意，sym 也支持加减乘除幂运算，也支持等于和不等于，但是不支持大于、小于。如需大于、小于，可以考虑将其转为 double 再比较，或者使用 sort 函数，这之后小的会在前面，大的会在后面。 函数代值可以在定义 f 的时候就显式地指出其自变量 f(x,y)，然后就可以用 f(1,2) 的形式代入。 1234syms x y;syms f;f(x,y) = x^2 + y^2;f(1,2) # 输出 5 将 x = 1, y = 2 代入，返回 5。注意这里返回的 5 同样是一个 syms。 此外，还有使用 subs 和 eval 的方法，如下例： 12345678910111213141516171819% 来源链接 https://blog.csdn.net/zengxiantao1994/java/article/details/77943305f = sin(x^x / x^2/exp(x));% 利用符号计算求f(x)的二阶导数% diff函数用于求导数或者向量和矩阵的比较。% 如果输入一个长度为n的一维向量，则该函数将会返回长度为n-1的向量，向量的值是原向量相邻元素的差d2f = diff(f, x, 2); % 第一种方法：利用subs函数求d2f在x=1时的值。d2fx1 = subs(d2f, x, 1); % d2fx1 = 2.2082 % 第二种方法：x赋值1后，利用eval函数求d2f在x = 1时的值x = 1;d2_fx1 = eval(d2f); %d2_fx1 = 2.2082 % 第三种方法：将d2f转化成匿名函数，求其在x = 1时的值% vectorize的含义就是将乘转成点乘等。 '*' -&gt; '.*'； '/' -&gt; './'； '^' -&gt; '.^'； 最后再将替换结果中的“..”删除一个\".\"。F = eval(['@(x)',vectorize(char(d2f))]);F(1) % ans= 2.2082 解方程123syms x;y = x^2 + 2*x;solve(y-1,x); 解 y-1=0 关于 x 的方程。返回： 12[- 2^(1/2) - 1 2^(1/2) - 1] 另有： 123456equa = x^2 + 2*x == 1;solve(equa);syms u veqns = [2*u + v == 0, u - v == 1];S = solve(eqns,[u v]) 以上都是 solve 函数。如有必要，还可以考虑使用 roots（给定多项式系数）fzero、fsolve（给定匿名函数）、vpasolve，用法可查看官方文档或博客。 化简表达式1s = simplify(cos(x)^2-sin(x)^2) 返回 cos(2*x)。 求极限1s = limit((1+1/n)^n, n, inf); 返回 exp(1)。 求级数1s = symsum(1/factorial(x), 0, Inf) 当然，如果上下界使用整数，这就是一个普通的求和过程（无需用 for 语句）。 返回 exp(1)。 求导1s = y^3+x^2; diff(s,y); 返回 3*y^2。 另有求 dim 阶导数： 1diff(X,n,dim) 另外，对于矩阵 A，diff(A) 是差分。 另外可以求近似导数 $f’(x)=\\lim\\limits_{h \\to 0} \\frac{f(x+h)-f(x)}{h}$： 1234h = 0.001;X = 1:h:2;Y = sin(X);D = diff(Y)/h; 积分1int(x^2); 返回 x^3/3。 另有以下形式： 123int(expr,var);int(expr,a,b);int(expr,var,a,b); 泰勒展开1taylor(exp(x),x,0,'order',3) 2 阶泰勒展开，返回 x^2/2+x+1。 解常微分方程1dsolve('Dy=(50-0.01*y)*y','y(0)=4','x'); % 二阶导的写法为'D2y' 详见MATLAB 解常微分方程。 分段函数分段函数：pw = piecewise(cond1,val1,cond2,val2,...,otherwiseVal)，如y=piecewise(x&lt;0,-x^2,x^2);。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"}]},{"title":"SQL SERVER 基础","date":"2020-03-23T01:31:21.000Z","path":"sql/sql-server/","text":"此篇博客来自《数据库管理及应用》课程的第三章。教材为《数据库系统及应用》（第 2 版，魏祖宽 主编）。 MySQL 相关语法见 MySQL。 SQL 简介 SQL：Structured Query Language SQL 决不仅仅是一个查询工具，还用于控制 DBMS 提供给用户的所有功能： 数据定义(Data definition)：SQL 可用于定义被存放数据的结构和组织，以及数据项之间的关系。 数据检索(Data retrieval)：SQL 能使用户或应用程序从数据库中检索数据并使用这些数据。 数据操纵(Data manipulation)： 用户或应用程序通过 SQL 更改数据库，如增加新数据，删除旧数据，修改已存入的数据等。 存取控制(Access control)：SQL 可用来限制用户检索，增加和修改数据的权限，保护所存储的数据不被非法存取。 数据共享(Data sharing)：SQL 可用于调整数据让并发用户共享，以保证用户之间彼此不受影响。 数据完整性(Data integrity)：SQL 能对数据库的完整性条件作出规定，以使其不会因为修改紊乱或系统出错而被破坏。 SQL 有以下特点： 支持数据库的三级模式 高度非过程化 面向集合的操作方式（操作对象和结果均为集合） 集 DDL（数据定义语言）、DML（数据操作语言）、DCL （数据控制语言）的功能于一体。下面是三部分用到的关键词： DDL：CREATE、DROP、ALTER DML： SELECT、INSERT、UPDATE、DELETE DCL：GRANT、REVOKE SQL Server 运行环境环境配置这部分就请百度吧。 Server 方面，教材讲的是 SQL Server 2000。当然也可以使用最新版的 SQL Server 2019。 编辑器方面，可以使用 SQL Server 配套的 SQL Server Management Studio，也可以使用 VS Code 的 SQL 插件。 SQL 样式指南 数据库操作开始讲语法之前，先说两点： SQL Server 对大小写不敏感 注释的形式为 --单行注释 和 /*跨行注释*/ 创建数据库 数据库中的所有数据和对象（如表、存储过程、触发器和视图）都存储在三种操作系统文件中： 第一类是主文件，扩展名为 mdf（priMary Database Files），该文件包含数据库的启动信息及数据信息，每个数据库都有一个主文件。 第二是次要文件，也称从文件，扩展名为 ndf（secoNdary Database Files），这些文件含有主文件以外的所有数据。可选。次要文件的主要用处是，当数据库中的数据量非常大时，需要多个次要文件来提高数据访问效率，或使用多个次要文件将数据扩展到多个不同的磁盘驱动器上。 第三类是事务日志，扩展名为 ldf（Log Databse Files），这些文件包含用于恢复数据库的日志信息。每个数据库都必须至少有一个日志文件。 创建数据库的过程可以像下面这么简单。 1Create Database HIS 也可以指定一些参数： 123456789101112131415161718CREATE DATABASE HISON PRIMARY -- ON PRIMARY 关键字，表明与该关键字相邻的文件为主文件( NAME = HIS_DATA1, -- SQL Server 使用的逻辑名称 FILENAME = 'D:\\HIS_DATA1.mdf', -- 文件名 SIZE = 10, -- 文件的初始大小 MAXSIZE = 1500, -- 文件的最大大小 FILEGROWTH = 5 ), -- SQLServer 每次扩大文件的大小，默认为 10%( NAME = HIS_DATA2, FILENAME = 'D:\\HIS_DATA2.ndf', -- ndf 是次要文件 SIZE = 10, MAXSIZE = 500, FILEGROWTH = 5 )LOG ON -- LOG ON 为关键字，见后( NAME = HIS_LOG, FILENAME = 'D:\\ HIS_LOG.ldf', SIZE = 5MB, MAXSIZE = 500MB, FILEGROWTH = 5MB ) LOG ON 用来指定数据库的 SQL Server 事务日志将存储在一个与数据库对象不同的设备上。如果数据库所在的物理设备被破坏而日志还可以使用（如果该日志所在的设备没有被破坏），使用一个以前的数据库备份和一个未破坏的日志的脱机复制，可以将数据库恢复到发生故障时刻的数据库的状态。 修改数据库123456789101112131415161718ALTER DATABASE HISADD FILE( NAME = HIS_DATA3, FILENAME = 'd:\\data\\HIS_DATA3.ndf', SIZE = 10, MAXSIZE = 1000, FILEGROWTH = 5 )ALTER DATABASE HISMODIFY FILE( NAME = HIS_DATA2, FILENAME = 'd:\\data\\HIS_DATA1.mdf', SIZE = 10, MAXSIZE = 1500, FILEGROWTH = 5 )ALTER DATABASE HISREMOVE FILE HIS_DATA2 可以看到有三种操作：ADD FILE、MODIFY FILE、REMOVE FILE，其中前两者要指定的参数创建数据库相同。 删除数据库1DROP DATABASE HIS 不能删除系统数据库（msdb，master，model 和 tempdb） 数据类型看看就好（逃 数据类型 功能 范围 注释 CHAR(n) 固定长度字符串 长度范围 1~8000 默认 1 NCHAR(n) 固定长度 Unicode 字符串 长度范围 1~4000 默认 1 VARCHAR(n) 变长字符串 长度范围 1~8000 默认 1 NVARCHAR(n) 变长 Unicode 字符串 长度范围 1~4000 默认 1 TEXT 变长字符数据 最长 $2^{31}-1$ 字节 行中存储指向第一个数据页的指针。实际的文本是以 B-树 页面存储 NTEXT 变长 Unicode 字符数据 最长 $2^{30}-1$ 字节 同上 DEC(n,m)DECIMAL(n,m)NUMERIC(n,m) 数值型，n 是总位数，m 是小数点右边的位数 n 范围 1~38m 范围 0~n 默认 n=38, m=0 INTINTEGER 整数 范围 $-2^{31}$~$2^{31}-1$ FLOAT(n) 浮点数，n 是尾数位数 范围 1~53 如果 n 为 1~24 则指定单精度；如果 n 为 25~53 则指定双精度（8字节）；默认 53 REAL 等价于 FLOAT(24) SMALLDATETIME 四字节日期和时间 日期范围 ? ~ 6-6-2079 时间精度是自午夜开始的 1 分钟之内 DATETIME 八字节日期和时间 日期范围 ? ~ 12-31-9999 时间精度：3.33毫秒之内 BINARY(n) 定长二进制数据 长度范围 1~8000 字节 默认 1 VARBINARY(n) 变长二进制数据 长度范围 1~8000 字节 默认 1 IMAGE 变长二进制数据，用于储存图形数据 最长 $2^{31}-1$ 字节 行中存储指向第一个数据页的指针。实际的数字以 B-树 的页面存储 表操作创建表下面的代码将创建一个 Medicine 表，包含五个属性，并且定义了数据类型。 1234567CREATE TABLE Medicine ( Mno VARCHAR(10) PRIMARY KEY, -- 主键 Mname VARCHAR(50) NOT NULL, -- 非空 Mprice DECIMAL(18,2) NOT NULL, -- 非空 Munit VARCHAR(10) DEFAULT '克', -- 默认值为 '克' Mtype VARCHAR(10)) 常用的完整性约束如下： 主键约束：PRIMARY KEY 唯一性约束：UNIQUE 非空值约束：NOT NULL 外键约束：FOREIGN KEY 主键也同时需要满足非空、唯一。 下面是外键的演示： 1234567891011121314151617CREATE TABLE RecipeMaster ( Rno VARCHAR(10) PRIMARY KEY, Pno VARCHAR(10) NOT NULL, Dno VARCHAR(10) NOT NULL, DGno VARCHAR(10), Rdatetime DATETIME,)CREATE TABLE RecipeDetail ( Rno varchar(10), Mno varchar(10) FOREIGN KEY REFERENCES medicine(Mno), Mamount decimal(18, 0), CONSTRAINT Rnofk FOREIGN KEY(Rno) REFERENCES RecipeMaster(Rno), --最后一行的逗号是可选的); 外键约束最后一张表 RecipeDetail 用两种方法进行了外键约束。 一种形式是在列后面进行约束： 12Mno varchar(10) FOREIGN KEY REFERENCES medicine(Mno)-- FOREIGN KEY 后的 Mno 指的是该表的属性列的名称，即第一个 Mno 另一种形式是作为表级的约束： 12CONSTRAINT RnoForeignKey FOREIGN KEY(Rno) REFERENCES RecipeMaster(Rno)-- RnoForeignKey 是外键名称（而非外键列名称），不需和后面保持一致，也可以省略 修改表修改表有四种操作，如下： 12345ALTER TABLE 〈基表名〉 [ ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;], --更改列 [ ADD &lt;新列名&gt; &lt;数据类型&gt; &lt;约束规则&gt;], --新增列 [ DROP COLUMN &lt;列名&gt;], --删除列 [ DROP CONSTRAINT &lt;约束规则&gt;]; --删除约束规则 如下的代码向处方明细表 RecipeDetail 增加一列存储药品单价。 12ALTER TABLE RecipeDetail ADD Price Decimal(5, 3) 注意，使用 ALTER TABLE 语句在表中增加列，如果新增列定义为 NOT NULL 列，必须用 Default 指定缺省值。否则，没有指定缺省值，当给表增加新列时，表中原有记录的新增列将自动为 NULL，这样就会违背 NOT NULL 的定义而出错。在 CREATE TABLE 时，NOT NULL 列可以不指定缺省值。但即使表中没有一个记录，SQL Server 2000 也不允许用 ALTER TABLE 指定没有缺省值的 NOT NULL 列。 删除表1DROP TABLE RecipeMaster 此外，还可以使用参数： 123DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE];-- RESTRICT：拥有表的对象（Check、Foreign Key、视图、触发器、存储过程、函数等）时禁止删除；-- CASCADE：级联删除表的所有对象 数据操作数据查询在介绍查询语句的格式之前，我们先来看一下用 SELECT 、FROM 和 WHERE 表达的简单查询语句。 从关系 Doctor(Dno, Dname, Dsex, Dage, Ddeptno, Dlevel, Dsalary) 中找出所有主任医师级别的男医生的信息，其 SQL 语句为： 123SELECT * FROM Doctor WHERE Dlevel='主任医师' and Dsex='男'; 该查询语句显示了大部分 SQL 查询语句的结构特征，即 select-from-where 形式。 FROM 语句说明了查询语句针对的关系，在这里就是对 Doctor 关系； WHERE 是一个条件语句，说明了我们查询的元组需要满足的条件； SELECT 说明要输出元组的哪些属性列。这里使用 SELECT * 输出了所有属性列。 SQL 样式指南 中指出，关键字应当右对齐，元素名应当左对齐，形成两边向中间对齐的“川流”。（对于双关键字如 ORDER BY，第二个关键字 BY 应在川流右边，和元素一样左对齐） 说完了查询语句的最基础的 select-from-where 形式，下面我们来说说查询语句的基本结构。 123456SELECT [ DISTINCT|ALL ] &lt;目标列表达式&gt; [, &lt;目标列表达式&gt;] … FROM &lt;表名或视图名&gt;[, &lt;表名或视图名&gt; ] … [ INTO &lt;新表名&gt; ] [ WHERE &lt;条件表达式&gt; ] [ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ] [ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]; 从上面我们可以看到： 上述各子句的排列顺序不能改变 SELECT 子句和 FROM 子句是必须的，其他子句都是可选的 该语句执行顺序如下： FROM：指定数据的来源。 WHERE：依据约束条件对元组进行过滤。 GROUP BY：对元组进行分组。 HAVING：依据分组的选择条件对组进行过滤（与 GROUP BY 搭配使用）。 SELECT：对上述结果按照列表达式选出元组中的属性分量值，形成结果集。 DISTINCT 选项表示去掉结果集中的重复元组； 系统默认为 ALL，表示不去重复。 ORDER BY：对结果集按指定列进行排序 ASC 表示将结果按升序排序（默认) ； DESC 表示按降序排序。 INTO：将结果放入指定的新表（默认输出到屏幕）。 简单查询本节介绍单表查询，即数据源只涉及一张表的查询。 SELECT上面讲了 SELECT * 可以查询所有列，如果用户只对一部分属性列感兴趣，可以使用： 12SELECT Dname, Dno, Ddeptno FROM Doctor 语句的效果是：从 Doctor 表中取出一个元组，取出该元组在属性 Dname、属性 Dno 和属性 Ddeptno 上的分董值，形成一个新的元组输出。对 Doctor 表中的其他元组做相同的处理。 注意，上面的语句输出的属性列是按照 SELECT 后面内容的顺序，可以和原表不同。 如果想要去掉重复内容，可以使用 DISTINCT： 12SELECT DISTINCT Ddeptno FROM Doctor 如果想查询所有内容，就是前文的 SELECT * 语法。 SELECT 的内容，还可以是属性列的库函数运算表达式、属性列与常量之间的算术运算表达式。 123-- 查询医生的姓名及年薪SELECT Dname, Dsalary * 12 FROM Doctor 以上计算的表达式的列不会有列标题。我们可以使用“别名”： 1234567-- 结果的表头为 姓名 和 年薪，而非 Dname 和（空）SELECT Dname AS 姓名, Dsalary * 12 AS 年薪 FROM Doctor-- AS 可省略，即上面的代码和下面等价：SELECT Dname 姓名, Dsalary * 12 年薪 FROM Doctor AS 可省略（但为了代码的可读性，不推荐删除）。 如果省略了 AS，并且别名中有空格，需要给别名加引号。 表也可以有别名。但是当为表指定了别名时，在查询语句中的其他用到表名的地方都要使用别名，不能再使用原表名。 WHERE下面我们主要说 WHERE 后的 &lt;行选择条件&gt;。 比较大小运算符（用 $\\theta$ 统称）有 &gt; &lt; = &lt;&gt; != &gt;= &lt;=（其中 != 等价于 &lt;&gt;。MSSQL 还有非标准的 !&lt; &gt;!，但也等价于 &gt;= 和 &lt;=）。 所有的 &lt;行选择条件&gt; 还可以配合逻辑运算符 AND OR NOT。 1234567891011121314-- 查询男医生的信息SELECT * FROM Doctor WHERE Dsex = '男'-- 查询年龄在 40 岁以下的医生信息SELECT * FROM Doctor WHERE Dage &lt; 40-- 查询年龄在 40 岁以下的男医生信息SELECT * FROM Doctor WHERE Dage &lt; 40 AND Dsex = '男' 确定集合 IN。IN 的含义是指当属性列的值与指定集合中的某一个常量相等时，结果为真。NOTIN 含义正好相反。 12345-- 查询部门编号为 102, 103 和 201 的医生信息SELECT * FROM Doctor WHERE Ddeptno IN ('102', '103', '201') /* 等价于 WHERE Ddeptno='102' OR Ddeptno='103' OR Ddeptno='201' */ 确定范围 BETWEEN ... AND。其含义是当属性列的取值在上限值和下限值的范围内，结果为真。NOT BETWEEN ... AND 含义正好相反。 12345-- 查询年龄在 35~40 岁之间的医生信息SELECT * FROM Doctor WHERE Dage BETWEEN 35 AND 40 /*等价于 WHERE Dage&gt;=35 AND Dage&lt;=40 */ 字符串比较。字符串比较可以用到以下运算符： 直接使用 = 来判断两个字符串完全相同； 使用 &gt; &lt; 等比较运算符，比较的是其 ASCII 或 Unicode 码； 使用 LIKE 关键字搭配通配符。SQL Server 提供了以下通配符： _ 匹配任意一个字符 % 匹配任意长的字符 [] 匹配一定范围内的任何单个字符，如 [abcdef] 或 [a-f] 匹配 a、b……或 f 字符 [^] 匹配范围之外的字符 如果用户查询的字符传本身就含有 % 等字符，要使用 ESCAPE 对通配符进行转义。（SQL Server 默认为 \\，但也推荐显式地指定转义字符） 1234567891011121314-- 查询副级职称的医生信息SELECT * FROM Doctor WHERE Dlevel LIKE '副％'-- 查询姓“欧阳”且全名为三个汉字的医生的姓名SELECT Dname FROM Doctor WHERE Dname LIKE '欧阳_';-- 查询包含 “葡萄糖_5%_150mL” 的药物SELECT * FROM Medicine WHERE Mname LIKE '%葡萄糖\\_5\\%\\_150mL%' ESCAPE '\\' 对于中文占几个字符的问题，在 SQL Server 2000 和 2019 版上，我得到了相同的测试结果： 对于 CHAR varchar nvarchar 和 text 类型，一个 _ 等价于一个汉字，即 &#39;欧阳_&#39; 匹配欧阳开头的三个汉字；对于 nchar，结果有些出人意料，对于 nchar(10) 类型的列，欧阳________（共八个下划线）才能匹配到欧阳开头的三个汉字，并且，同时也能匹配欧阳开头的四个汉字。 对于后面这点，我没有继续深入下去，只是简单搜索了一下，得到以下的结论： 如果会在一列中出现不同语言，一定要使用 nvarchar。 对于纯中文，那就尽量使用 nvarchar，绝对不要使用 nchar 吧。 空值 NULL。NULL 在数据库表示不确定的值。空和非空语法格式分别为 IS NULL 和 IS NOT NULL。 1234-- 查询没有药品信息的处方SELECT * FROM RecipeDetail WHERE Mno IS NULL ORDER BYORDER BY 在输出的时候对元组进行排序。默认为升序 ASC（小的在前）。降序关键字为 DESC。 当排序列含空值时，若为按升序排序，排序列为空值的元组最后显示；若为按降序排序，排序列为空值的元组最先显示。也就是说，在排序中可以把 NULL 理解成极大值。 12345678910-- 查询所有男医生的基本信息，按照年龄升序输出显示SELECT * FROM Doctor WHERE Dsex='男' ORDER BY Dage-- 查询所有医生信息，按部门编号升序排序，相同元素按年龄降序排序显示SELECT * FROM Doctor ORDER BY Ddeptno ASC, Dage DESC TOPTOP 的功能是： 使用 SELECT 语句进行查询时，可能只希望列出结果集中的前儿个结果而不是全部结果。例如，统计医生的年薪时只取薪水最高的前三名，这时就可以使用 TOP 谓词限制输出的结果。 TOP 的语法如下： 1TOP n [percent] [WITH TIES] 加上 percent，表示查询的是前 n%；加上 WITH TIES，表示包括并列的结果。 TOP 放在 SELECT 后，查询列表之前。如有 DISTINCT，则在 DISTINCT 后。 TOP 通常与 ORDER BY 一起。如果不使用 ORDER BY，系统会按照主键进行排序。 值得注意的是，当使用 WITH TIES 时，要求必须使用 ORDER BY。（请读者思考为什么？） 下面是两个例子： 123456789-- 查询医院年龄最大的三名医生姓名，年龄。SELECT TOP 3 Dname, Dage FROM Doctor ORDER BY Dage DESC-- 查询医院年龄最大的医生姓名，年龄。SELECT TOP 1 WITH TIES Dname, Dage FROM Doctor ORDER BY Dage DESC 聚合函数聚合函数（Aggregate Functions）又称统计函数、集合函数、聚类函数、聚集函数，是指把数据集进行统计、求和、求平均等汇总操作的函数。 123-- 统计在岗医生人数SELECT COUNT(DISTINCT Dno) FROM Diagnosis 聚类函数的输出只有一行。如下： 行数 青年医生人数 1 5 常用的聚类函数有：count()、sum()、avg()、max()、min()。 以上函数都可以在列名前添加 DISTINCT 关键字，表示不计算重复分量值。 GROUP BY上面的查询结果都是整体或者整体的聚合函数，使用 GROUP BY 函数可以将数据按分组输出、对每一组数据按照聚合函数进行统计输出。 根据 ISO 标准，若使用了 GROUP BY 子句，SELECT 目标列中的每一项在每一个组中都必须是单值的（相同），即 SELECT 语句的查询目标列只能是： GROUP BY 分组依据的列、聚集函数、常量，或前三种形式的组合。 以下代码不能运行： 1234SELECT employer_name, department, max(salary) FROM employer_salary GROUP BY department;-- employer_name 在同 department 下可能有不同值，因此是非单值的项 下面是按部门编号统计不同部门的医生人数的代码： 123456789-- 按部门编号统计不同部门的医生人数SELECT Ddeptno 部门编码, COUNT(Dno) 人数 FROM Doctor GROUP BY Ddeptno/*** 1. SQL 先将医生按照他们所属的部门进行分组，这样就将所有的医生分为四组。** 在每一组中，所有的医生具有相同的部门编号。** 2. 对每一组，SQL 计算该组的人员个数。*/ 12345678select name from reviewer A where (select count(stars) from rating B where A.rid=B.rid group by rid) &gt;=3 HAVING 和 WHERE 的语法类似，但 HAVING 是和 GROUP BY 搭配使用的。在 WHERE、GROUP BY、HAVING 同时出现时，代码的执行顺序如下： 按 WHERE 子句找出满足条件的数据行； 按 GROUP BY 子句指定的列，对经 WHERE 子句筛选后的结果进行分组； HAVING 子句在 GROUP BY 分组之后选择符合条件的分组结果。 借助下面的例子能很好的理解这三者的关系。 1234567-- 按部门统计男医生的平均年龄不超过 40 岁的部门编号，并按平均年龄升序显示SELECT Ddeptno 部门编号, AVG(Dage) 平均年龄 FROM Doctor WHERE Dsex='男' GROUP BY Ddeptno HAVING AVG(Dage)&lt;=40 ORDER BY AVG(Dage) 连接查询 同时涉及多个关系表的查询称为连接查询。用来连接两个表的条件称为连接条件或连接谓词。多表间的连接运算遵循笛卡儿规则，但“笛卡儿”查询是无条件查询。这种连接操作会产生大量的无意义的数据记录。因此，在进行连接时加上一些限制条件，进行连接运算，这样产生的数据记录是笛卡儿连接结果集的子集。进行连接运算的表，必须存在着有某种关系的公共列，连接运算实际是比较各表的公共列值，如果满足条件的连接产生组合输出行。 连接操作的实现连接操作的执行大致有三种方法：嵌套循环法，排序合并法和索引连接法。 下面简单介绍这三种方法的执行步骤。 循环嵌套法 (NESTED-LOOP) 在表 1 中找到第一个元组，然后从头开始扫描表 2，逐一查找满足连接条件的元组，找到后就将表 1 中的第一个元组与该元组拼接起来，形成结果表中一个元组。 对表 1 剩下的元组依次执行该操作，直到表 1 中的全部元组都处理完毕。 排序合并法 (SORT-MERGE) 按连接属性对表 1 和表 2 排序。 对表 1 的第一个元组，从头开始扫描表 2，顺序查找满足连接条件的元组，找到后就将表 1 中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表 2 中第一条大于表 1 连接字段值的元组时，对表 2 的查询不再继续。 找到表 1 的第二条元组，然后从刚才的中断点处继续顺序扫描表 2，查找满足连接条件的元组，查询的方法与上面类似。 重复上述操作，直到表 1 或表 2 中的全部元组都处理完毕为止。 索引连接法 (INDEX-JOIN) 对表 2 按连接字段建立索引。 对表 1 中的每个元组，依次根据其连接字段值查询表 2 的索引，从中找到满足条件的元组，找到后就将表 1 中的一个元组与该元组拼接起来，形成结果表中一个元组。 内连接连接方式有内连接和外连接。内连接只在两个表中找出满足连接条件的结果并输出，而外连接会输出一张表的所有元组和另一张表满足连接条件的记录。相比而言，内连接更常用。 内连接的方式依旧是 select-from-where，只是需要指出列来自哪一张表。 自然连接分为等值连接（WHERE 的条件是 =）和非等值连接（其他）。等值连接如下面四例：非等值连接咕咕咕了 123456789101112131415161718192021222324252627-- 内连接-- 查询每个处方的用药信息SELECT RecipeDetail.*, Medicine.* FROM RecipeDetail, Medicine WHERE RecipeDetail.Mno = Medicine.Mno-- 查询急诊内科医生的出诊信息SELECT Doctor.Dname, Diagnosis.* FROM Doctor, Diagnosis, Dept WHERE Doctor.Dno = Diagnosis.Dno AND Doctor.DdeptNo = Dept.DeptNo AND Dept.DeptName = '急诊内科'-- 下例为自然连接-- 查询开出处方的医生信息。SELECT Rno, Pno, D.Dno, Dname, Dsex, Dage, Ddeptno, Dlevel FROM RecipeMaster R, Doctor D WHERE R.Dno=D.Dno-- 当为表指定了别名时，在查询语句中的其他用到表名的地方都要使用别名，不能再使用原表名-- 查询急诊内科每位医生的出诊数量。SELECT Doctor.Dname, count(*) 出诊数量 FROM Doctor, Diagnosis, Dept WHERE Doctor.Dno = Diagnosis,Dno AND Doctor.Ddeptno = Dept.Deptno AND Dept.DeptName = '急诊内科' GROUP BY Doctor.Dname 自连接是一种特殊的内连接。 它是指相互连接的表在物理上为同一张表，但可以在逻辑上分为两张表。使用自连接时必须为两个表取别名，使之在逻辑上成为两张表。可以把自连接理解为同一张表（或视图）的两个副本之间的连接，使用不同别名来区别副本，处理过程与不同表之间的连接相同。 1234-- 在医院部门表中，需要医院的各部门名称和上级部门名称SELECT A.DeptName 部门名称, B.DeptName 上级部门 FROM Dept AS A, Dept AS B WHERE A.ParentDeptNo = B.DeptNo 外连接外连接在前面简单说过了，就是输出表 1，和两张表的连接情况。下面是书上的详细介绍： 内连接操作只从两个表中找出满足连接条件记录的结果输出。在某些应用中，我们也希望输出那些不满足连接条件的元组的信息。比如查看全部医生所属的部门信息，包括暂时没有医生的部门情况。如果用内连接实现，则只能找出有医生的部门信息，对不满足关系表 Doctor.DdeptNo=Dept.DeptNo 条件的元组是查找不出来的。这种情况就需要用外连接来实现。即两张表的连接查询，要输出一张表的所有元组，另外一张表输出满足连接条件的记录。如果没有满足条件的元组，则用 NULL 匹配输出。我们称这种连接查询为外连接，是其他连接方式的扩展。 SQL SERVER数据库系统的命令格式如下：看不懂预警 123456SELECT &lt;查询列表&gt; [ INTO &lt;新表名&gt; ] FROM &lt;基表1|视图1&gt; [ AS 别名1 ] &#123;&lt; LEFT | RIGHT | FULL &gt; [ OUTER ] JOIN&#125; &lt;基表2|视图2&gt; [ AS 别名2 ] ON &lt;连接条件&gt; 我们现在只需要关注第四行： 其中，LEFT OUTER JOIN 表示左外连，输出左表的所有记录相关列值；右表输出与左表匹配的记录（如果没有与左表匹配的记录，则使用 NULL 匹配输出）；RIGHT OUTER JOIN 表示右外连，输出右表的所有记录相关列值；左表输出与右表匹配的记录（如果没有与右表匹配的记录，则使用 NULL 匹配输出）；FULL OUTER JOIN 表示全外连接，是左外连接与右外连接所产生结果的并集。 下面是外连接的例子： 12345-- 在医院部门表中，查询医院的各部门名称和该部门医生姓名SELECT DeptName 部门名称, DName 医生姓名 FROM Dept LEFT OUTER JOIN Doctor ON Dept.DeptNo = Doctor.Ddep1no 上面这个例子的输出如下： 行号 部门名称 医生姓名 1 XX 医院 NULL 2 门诊部 NULL 3 消化内科 杨财 4 急诊内科 郝亦伟 5 急诊内科 罗晓 6 门内三诊室 刘伟 7 社区医疗部 NULL 8 家庭病床病区 邓英超 内连接能方便的实现这样的功能吗？如果只使用上面介绍的内连接，只会输出存在医生的部门，而不会输出医生为 NULL 的部门。如果使用右外连，可能有医生的部门名称会出现 NULL。 嵌套查询SQL 支持嵌套查询。那么，在哪里可以嵌套呢？ 可以在 WHERE 和 FROM 的地方进行嵌套。 来看一个 WHERE 嵌套的例子： 1234567-- 查询与医生刘伟有诊断关系患者姓名。SELECT Pname FROM Patient WHERE Pno IN (SELECT Pno FROM RecipeMaster WHERE Dno = (SELECT Dno FROM Doctor WHERE Dname = '刘伟')) 外层的查询被称为主查询（或父查询），内层的 SELECT 查询子句被称为子查询。子查询还允许嵌套子查询，但最多嵌套 255 层。 该查询的执行顺序如下： 首先执行 SELECT Ono FROM Doctor WHERE Dname=&#39;刘伟&#39;，返回 21； 然后执行 SELECT Pno FROM RecipeMaster WHERE Ono =&#39;21&#39;，返回201； 最后执行 SELECT Pname FROM Patient WHERE Pno IN(&#39;201&#39;)，返回查询结果。 注意该查询的写法。当医院有且仅有一个名字叫刘伟的医生时，该查询才能正确运行；如果有多个或者没有名字叫刘伟的医生，该查询将会出错。主要原因是比较运算符 =、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;= 只能与返回单值的子查询相连。所以，建议这些运算符最好不要与子查询连接使用，最好用 IN、NOTIN、ANY、ALL、EXISTS、NOT EXISTS 等比较运算符代替。 ININ 在 WHERE 部分已经提到过了，这里仅放一下配合嵌套查询的语法： 12345678910111213-- 查询所开处方不包含药品“胃立康片”的医生姓名SELECT Dname FROM Doctor WHERE Dno IN (SELECT Dno FROM RecipeMaster WHERE Rno IN (SELECT Rno FROM RecipeDetail WHERE Mno NOT IN (SELECT Mno FROM Medicine WHERE Mname = '胃立康片'))) ANY ALL上面的 IN 是查询子表有没有这个分量值，而 ANY 做的事情是配合比较运算符，查询子表中是否有值满足这个比较式。ALL 则配合比较运算符，查询子表中是否所有值都满足这个比较式。 ALL 关键字可省略。（顺便，SELECT 后的 ALL 也可以省略） 12345678-- 查询小于任何男医生年龄的女医生姓名和年龄SELECT Dname AS 姓名, Dage AS 年龄 FROM Doctor WHERE Dsex＝'女' AND Dage &lt; ALL -- ALL 可省略 (SELECT Dage FROM Doctor WHERE Dsex='男') EXISTS嵌套查询中，还可用 EXISTS 运算符与相关子查询相连。其形式如下： 1WHERE [NOT] EXISTS (子查询) 带 EXISTS 谓词的子查询不返回查询的数据，只产生逻辑真值和逻辑假值。基本思想为：如果 EXISTS 运算符限定的子查询有查询记录返回，那么该条件为真，否则为假。NOT EXISTS 则反之。 1234567891011121314-- 使用相关查询-- 查询给姓名为“刘景”的患者开过处方的医生。SELECT Dno AS 医生编号, Dname AS 姓名, Dsex AS 性别, age AS 年龄, Dlevel AS 职称 FROM Doctor WHERE EXISTS (SELECT * FROM RecipeMaster WHERE RecipeMaster.Dno = Doc.Dno AND EXISTS (SELECT * FROM Patient WHERE Patient.Pname = '刘景' AND Patient.Pno = RecipeMaster.Pno)) 该查询还可以使用如下的不相关子查询： 123456789101112-- 使用不相关查询-- 查询给姓名为“刘景”的患者开过处方的医生。SELECT Dno AS 医生编号, Dname AS 姓名, Dsex AS 性别, age AS 年龄, Dlevel AS 职称 FROM Doctor WHERE Dno IN (SELECT Dno FROM RecipeMaster WHERE RecipeMaster.Pno IN (SELECT Pno FROM Patient WHERE Patient.Pname = '刘景')) 除此之外，还可以用连接查询。 12345678-- 使用连接查询-- 查询给姓名为“刘景”的患者开过处方的医生。SELECT D.Dno AS 医生编号, D.Dname AS 姓名, D.Dsex AS 性别, D.age AS 年龄, D.Dlevel AS 职称 FROM Doctor AS D, RecipeMaster AS R, Patient AS P WHERE D.Dno = R.Dno AND R.Pno = P.Pno AND Pname = '刘景' 这说明同一个查询可以有多种实现方式。 由于查询优化器可以对多表连接查询进行更多的优化，总体上来说，多表连接查询的执行效率会高于子查询的执行效率。 FROM 嵌套上面一例还可以使用 FROM 嵌套。有完没完啦 12345678910-- 使用连接查询和 FROM 嵌套-- 查询给姓名为“刘景”的患者开过处方的医生。SELECT D.Dno AS 医生编号, D.Dname AS 姓名, D.Dsex AS 性别, D.age AS 年龄, D.Dlevel AS 职称 FROM Doctor, (SELECT RecipeMaster.Dno FROM RecipeMaster, Patient WHERE RecipeMaster.Pno=Patient.Pno AND Patient.Pname='刘景') AS R WHERE Doctor.Dno=R.Dno 注意，由于 FROM 嵌套子查询的结果没有名字，必须给它取一个别名。 集合查询 在关系代数中可以用集合操作的并、交、差来组合关系。在查询结果上， SQL 提供了对应的操作，条件是这些查询结果提供的关系具有相同的属性和属性类型列表。保留字 UNION、INTERSECT、EXCEPT 分别对应关系代数中的并、交和差运算符。进行集合查询连接多个 SELECT 语句时，只能在最后 SELECT 查询表达式之后指定 ORDER BY 子句，决定查询记录的输出顺序。但 ORDER BY 子句后面不能引用列名，仅能引用相应列在查询列表中的顺序号。 算了直接看例子吧。 在医院数据库中，为了提高系统处理效率，要定期对患者的诊断信息归档。假定患者诊断归档信息表为 DiagnosisBak, 如果医生要查询患者“刘景”的近期和历史诊断信息，以便分析患者的病因。其查询语句如下： 123456789101112SELECT DGno AS 诊断号, Dname AS 医生姓名, Symptom AS 症状, Diagnosis AS 诊断, DiagDateTime AS 时间 FROM DiagnosisBak AS DiagB, Doctor AS Doc, AS Patient P WHERE DiagB.Dno = Doc.Dno AND P.Pno = DiaB.Pno AND P.Pname = '刘景' UNIONSELECT DGno, Dname, Symptom, Diagnosis, DiagDateTime FROM Diagnosis AS Diag, Doctor AS Doc, Patient AS P WHERE Diag.Dno = Doc.Dno AND P.Pno = DiaB.Pno AND P.Pname ='刘景' 数据插入插入元组也就是一行一行地插入。使用 insert-into-values： 12INSERT INTO Doctor(Dno, Dname, Dsex, Dage, DDeptNO, Dlevel)VALUES ('145', '王军', '男', 28, '101', '医师') 可以省略表名 Doctor，表示向目标表所有列插入数据； 可以省略列名 (Dno,Dname,Dsex,Dage,DDeptNO,Dlevel)，但 VALUE 就必须按照默认的顺序；使用列名，可以交换顺序； 对于省略部分列名的情况，对应列使用默认值，或 NULL。 12INSERT INTO DoctorVALUES ('145', '王军', '男', 28, '101', '医师') 插入子查询的结果用 insert-into-select，把查询内容直接插到另一个表。不求两个表列名相同，只求长度、对于位置的数据类型兼容。 12345-- 统计每个医生每天诊断的患者数量，并把结果存入数据库INSERT INTO DiagNum (Dno, DiagDate, PatientNum)SELECT Dno, Rdatetime, COUNT(DGno) FROM RecipeMaster GROUP BY Dno, Rdatetime 数据修改如果某些数据发生了变化，就需要对表中已有的数据进行修改。 可以使用 update-set-where 语句对数据进行修改，其语句的一般格式为： 123UPDATE &lt;基表名&gt; SET &lt;列名1&gt;=&lt;表达式2&gt;，&lt;列名2&gt;=&lt;表达式2&gt;…[WHERE &lt;条件表达式&gt;] 其功能就是修改指定表中满足 WHERE 子句条件的元组，将这些元组在 SET 子句给出的属性列分量值用 &lt;表达式&gt; 的值取代。 如果省略 WHERE 子句，则表示要修改表中所有元组（称作无条件修改）。 UPDATE 语句中 WHERE 子句的作用和写法同 SELECT 语句中的 WHERE 子句一样。 12345678910111213141516171819-- 无条件修改-- 将所有医生的年龄增加 1 岁UPDATE Doctor SET Dage = Dage + 1-- 修改某一元组的值-- 将编号为 '423' 的患者的社会保险号，修改为 '20073425'。UPDATE Patient SET Pino = '20073425' WHERE Pno = '423'-- 带子查询的修改语句-- 将门诊部所有医生的工资上浮 10%UPDATE Doctor SET Dsalary = Dsalary + Dsalary * 0.1 WHERE Ddeptno IN (SELECT DeptNo FROM Dept WHERE DeptName = '门诊部') 数据删除当确定不再需要某些元组时，可以使用删除语句 DELETE。删除语句的一般格式为： 12DELETE FROM &lt;即表明&gt;[WHERE &lt;行选择条件&gt;] 其功能是从指定表中删除满足 WHERE 子句条件的所有元组。 如果省略 WHERE 子句，则表示删除表中所有元组，但表的定义仍在字典中。也就是说，DELETE 语句删除的是表中的数据，而不是关于表的定义。 123456789101112131415161718-- 删除所有医生的记录DELETE FROM Doctor-- 这条 DELETE 语句删除了 Doctor 表中的所有元组，使 Doctor 表成为空表-- 删除某一个元组-- 将编号为 '423' 的患者从系统中删除DELETE FROM Patient WHERE Pno = '423'-- 将门诊部所有医生的信息删除DELETE FROM Doctor WHERE Ddeptno IN (SELECT DeptNo FROM Dept WHERE DeptName = '门诊部') 视图在数据库的基本概念中降到数据库的三层模式结构（外模式、模式、内模式）。而外模式对应到数据库中的概念就是视图。 视图是一种特殊类型的表。它是从一个或多个基表（或视图）导出的表，是基本表的部分行或列数据的组合。视图可定义在一个或多个基表上，或者其他视图上。视图本身并不存储任何数据，只提供了一种访问基表中数据的方法。可以简单地认为视图是一个逻辑虚表。数据库中只存放视图的定义，而不存放视图包含的数据。当基本表中的数据发生变化后，从视图查询出的数据也会随之变化。从这个意义上说，视图就像一个窗口，用户透过它可以看到自己感兴趣的数据。当视图建立后，用户可以像基表一样对视图进行数据查询，在某些特殊情况下，还可以对视图进行修改和插入操作。 视图的定义定义视图的 SQL 语句是 CREATE VIEW，其一般格式为： 123CREATE VIEW &lt;视图名&gt; ［ (视图列名) ］ AS &lt;子查询&gt;[ WITH CHECK OPTION J （一千行纪念！） 视图列名可以省略，如果省略了，则视图的列名由查询语句中查询结果显示的列名组成。但下列三种情况下必须明确指定 视图列名： 某个目标列不是单纯的属性名，而是聚集函数或列表达式 多表连接时选出几个同名列作为视图的字段 需要在视图中为某个列启用新的更合适的名字 若视图列表不省略，则属性列的个数应与子查询的目标列个数相一致。 视图不能为列指定数据类型和长度，而是默认为数据源的类型和长度。 &lt;子查询&gt; 可以是任意的 SELECT 语句，但不允许包含 ORDER BY 子句和 DISTINCT 短语。 WITH CHECK OPTION 选项表示对视图进行更新操作（插入、修改和删除）时会进行检查，要保证插入、修改和删除的行满足视图定义中 &lt;子查询&gt; 的条件表达式。 1234567891011-- 为消化内科诊断的患者信息建立一个视图CREATE VIEW DiagView AS SELECT DGno, P.Pno, Pname, Doc.Dno, Dname, Symptom, Diagnosis, DiagDateTime FROM Diagnosis AS Diag, Doctor AS Doc, Patient AS P WHERE Diag.Dno = Doc.Dno AND P.Pno = Diag.Pno AND Doc.DdeptNo IN (SELECT DeptNo FROM Dept WHERE DeptName = '消化内科') 本例中省略了视图 DiagView 的列名，隐含视图列名由子查询中SELECT 目标列组成。 RDBMS 执行 CREATE VIEW 语句的结果只是把视图的定义存入数据字典，并不执行其中的 SELECT 语句。只有对视图执行查询操作时，才按视图的定义从相应基本表中检索数据。 1234567891011121314151617/* 为消化内科诊断的患者信息建立一个视图 要求进行修改和插入操作时仍需保证该视图只有消化内科的患者 */CREATE VIEW DiagView AS SELECT DGno, P.Pno, Pname, Doc.Dno, Dname, Symptom, Diagnosis, DiagDateTime FROM Diagnosis AS Diag, Doctor AS Doc, Patient AS P WHERE Diag.Dno = Doc.Dno AND P.Pno = Diag.Pno AND Doc.DdeptNo IN (SELECT DeptNo FROM Dept WHERE DeptName = '消化内科') WITH CHECK OPTION/* 这意味着，以后对该视图进行修改、删除操作时 RDBMS 会自动加上 DeptName='消化内科' 的条件 若进行插入操作，RDBMS 自动检查插入医生的 DeptName 属性列的值是否为消化内科 如果不是则拒绝执行操作 */ 视图不仅可以建立在基本表上，还可以建立在已定义好的视图上，或建立在基本表和视图之上。 1234567-- 为消化内科 2007 年诊断的患者信息建立一个视图。CREATE VIEW DiagView_check_2007 AS SELECT * FROM DiagView_check WHERE DiagDateTime &gt; '2007-1-1' AND DiagDateTime &lt; '2007-12-30'-- 这里的视图 DiagView_check_2007 就是建立在视图 DiagView_check 之上的 定义视图时可以根据应用的需要设置一些派生属性列，这样的视图称为带表达式的视图。 123456789-- 将消化内科医生的年薪建立一个视图CREATE VIEW Doc_Deg_sal (Dno, Dname, Salary) AS SELECT Dno, Dname, Dsalary * 12 FROM Doctor WHERE DdeptNo IN (SELECT DeptNo FROM Dept WHERE DeptName = '消化内科')-- 视图中的 Salary 属性列的值通过计算得到 还可以用带有聚集函数和 GROUP BY 子句的查询来定义视图，这种视图称为分组视图。 12345-- 定义视图反映各部门的医生人数CREATE VIEW Dept_num (Deptno, Dnumber) AS SELECT Ddeptno, COUNT(Dno) FROM Doctor GROUP BY Ddeptno 上面两例中，由于 SELECT 语句中的目标列包含有表达式和聚集函数，且在查询语句中没有为这样的列指定别名，则在 CREATE VIEW 中必须明确定义视图的各个属性列名。 视图的删除1DROP VIEW &lt;视图名&gt; [CASCADE] 使用 CASCADE 级联删除语句，把该视图和它导出的所有视图一起删除。 若基本表被删除，由该基本表导出的所有视图仍存在，但已无法使用。删除这些视图需显式地使用 DROP VIEW 语句。 123456-- 删除视图 DiagView_checkDROP VIEW DiagView_check/* 由于 DiagView_check 视图还导出了 DiagView_check_2007 视图， 上述删除操作将被使 DiagView_check_2007 视图不能再使用 可以使用级联删除语句将两个视图都删除 */DROP VIEW DiagView_check CASCADE 视图的查询视图的查询和基本表查询完全一样。 视图的更新根据视图的定义，一个视图要么是只读的视图要么是可更新的视图。 对一个只读的视图就只能执行 SELECT 语句。所有视图都至少是可读的。 对可更新的视图，用户就可以执行 INSERT、UPDATE 或 DELETE 操作。 这里提到的操作，均为对数据的更新操作，而不是 DELETE VIEW 等对视图本身的操作。 由于视图是不存储数据的虚表，数据是来自其他基表的部分数据，对视图的更新最终是对基表的更新。因此只能对特殊的视图进行更新。下面将介绍视图更新操作的限制条件。 只能对直接定义在一个基表上的视图进行插入、修改、删除等更新操作。 对定义在多个基表或多个其他视图之上的视图，数据库管理系统不允许进行更新操作。 上面这一点其实有一点歧义。首先肯定的是，SQL Server 不允许会影响多个基表的修改操作；然而，如果修改操作不会影响到多个基表（举个例子，视图 V1 基于基表 T，视图 V2 为 V1 和 T 的连接的结果，则修改 V2 只会影响到基表 T），这种操作是允许的。 12345678-- 在医院数据库中，创建了医生与患者的诊断信息视图-- 该视图为不可修改视图CREATE VIEW DiagView AS SELECT DGno, P.Pno, Pname, Doc.Dno, Dname, Symptom, Diagnosis, DiagDateTime FROM Diagnosis Diag, Doctor Doc, Patient P WHERE Diag.Dno = Doc.Dno AND P.Pno = Diag.Pno 如果视图数据只来源于一个基表，但 SELECT 语句含有 GROUP BY、DISTINCT 或聚集函数等，除可执行删除操作外，不能进行插入或修改操作。 这个操作感觉从逻辑上说没有问题，可能会在数据库的实现上可能导致效率低下。 123456-- 在医院数据库中，统计每位医生每天诊断工作量，建立如下视图-- 该视图除可执行删除操作外，不能进行插入或修改操作CREATE VIEW DiagNum (Dno, DiagDate, PatientNum） AS SELECT Dno, Rdatetime, COUNT(DGno) FROM RecipeMaster GROUP BY Dno, Rdatetime 如果视图中包含由表达式计算的列，则不允许进行更新操作。 123456-- 在药品信息表中，为药品单价提高 15% 后建立药品价格视图-- 不能修改该视图中的药品单价CREATE VIEW MedicineNewPrice (Mno, Mname, Newprice, Munit, Mtype) AS SELECT Mno, Mname, Mprice * 1.15, Munit, Mtype FROM Medicine WHERE Mprice * 1.15 &gt;= 30 如果视图满足上述 3 个条件，但该视图中没有包含基表的所有 NOT NULL 列，则不能对该视图进行插入操作。 原因是，对视图的插入实际是对基表的插入操作。当视图没有包含基表的所有 NOT NULL 列时，在向视图进行插入时（实际上是向基表插入），系统会默认认为，视图中没有包含的那些列的分量值为 NULL，这与基本定义中的 NOT NULL 相矛盾。 视图的作用复制粘贴警告 视图是定义在基本表之上的一个虚表，对视图的操作最终是对基本表的操作，且视图操作中有许多限制条件。这样看来视图似乎没有什么作用。但实际上，如果能合理地利用视图将带来许多好处。 视图能简化用户的操作 当视图中数据不是直接来自基本表时，定义视图能够简化用户的操作。 基于多张表连接形成的视图 基于复杂嵌套查询的视图 含导出属性的视图 视图对重构数据库提供一定程度的逻辑独立性 当我们重构数据库时会改变数据库的逻辑结构，如增加新的关系或改变原有关系的属性列等。要保证数据的逻辑独立性，使用户的应用程序不受影响，就要使用户的外模式保持不变。 视图是构建外模式的一种方式。 数据库重构最常见的方法是把基本表做“垂直“划分，将一个基本表分成多个基本表。例如将医生 Doctor 关系表： Doctor(Dno,Dname,Dsex,Dage,Ddeptno,Dlevel,Dsalary) 分为 Doctor_x(Dno,Dname,Dsex,Dage) 和 Doctor_y(Dno,Ddeptno,Dlevel,Dsalary) 两个关系。那么用户应用程序中原来对 Doctor 关系的操作就要转换为对 Doctor_x 和 Doctor_y 的操作，修改麻烦。 这时可建立一个 Doctor 视图： 1234CREATE VIEW Doctor(Dno, Dname, Dsex, Dage, Ddeptno, Dlevel, Dsalary AS SELECT Doctor_x.Dno, Dname, Dsex, Dage, Ddeptno, Dlevel, Dsalary FROM Doctor_x, Doctor_y WHERE Doctor_x.Dno = Doctor_y.Dno 这样应用程序就不必修改。 当然，视图只能在一定程度上提供数据的逻辑独立性。如果视图是不可更新的，则应用程序中修改数据的语句仍要随着基本表结构的改变而改变。 视图为用户提供多个视角看待同一数据 提高数据的安全性 对不同用户定义不同视图，使得每个用户只能看到他有权看到的数据. 例如，医生关系中每个医生的薪水是保密的。就可以定义一个不包括薪水字段的视图供用户操作，不让用户直接操作基本表。这样，就在一定程度上提高了数据的安全性。 保证数据的完整性 若在视图定义时使用了 WITH CHECK OPTION 选项，那么 SQL 就能保证进入基本表中的元组都能满足 WHERE 子句中给出的限定条件。 索引 建立索引是加快查询速度的有效手段 索引由 DBMS 内部实现，属于内模式范畴 建立索引 DBA或表的属主（即建立表的人）根据需要建立 有些 DBMS 自动建立以下列上的索引: PRIMARY KEY 和 UNIQUE 维护索引 DBMS 自动完成 使用索引 DBMS自动选择是否使用索引以及使用哪些索引 索引的分类根据索引与数据表的存储特点可以分为：聚簇索引、非聚簇索引和唯一索引。 聚簇索引 建立聚簇索引后，基表中数据也需要按指定的聚簇属性值的升序或降序存放。也即聚簇索引的索引项顺序与表中记录的物理顺序一致 在一个基本表上最多只能建立一个聚簇索引 聚簇索引的用途：对于某些类型(范围查找)的查询，可以提高查询效率 聚簇索引的适用范围 很少对基表进行增删操作 很少对其中的变长列进行修改操作 123-- CREATE CLUSTER INDEX Stusname ON Student(Sname); 非聚簇索引 数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。 索引中的项目按索引键值的顺序存储，而表中的信息按另一种顺序存储（也可以由聚簇索引规定）。 在搜索数据值时，先对非聚集索引进行搜索，找到数据值在表中的位置，然后从该位置直接检索数据。 由于索引包含描述查询所搜索的数据值在表中的精确位置的条目，这使非聚集索引成为精确匹配查询的最佳方法。 唯一索引 唯一索引确保索引列不包含重复的值。在多列唯一索引的情况下，该索引可以确保索引列中每个值组合都是唯一的。 聚集索引和非聚集索引都可以是唯一的。因此，只要列中的数据是唯一的，就可以在同一个表上创建一个唯一的聚集索引和多个唯一的非聚集索引。 创建PRIMARY KEY或UNIQUE约束会在表中指定的列上自动创建唯一索引。 在同一个列组合上创建唯一索引而不是非唯一索引可为查询优化器提供附加信息，所以最好创建唯一索引。 索引的原则 选择数据量较大的表建立索引 一般来说，对于数据量较大的表，数据库系统越有机会找到最短路径，索引越能更好地改善响应的时间，越能显示出优势。 索引对于列中的数据多而杂的列是特别有用。例如，在医院信息系统中，如果对患者诊断信息建立索引，速度提高的效果就比较明显。但是，不适宜在性别列上建立索引，因为有大量重复值，对其索引反而会降低查询速度。 对于数据量较小的表最好不要建立索引，因为对小表索引，速度提高不仅不明显，反而会增大系统的开销，除非有特殊需要，要建立唯一索引来加强唯一。 建立索引的数量要适量（需要付出代价） 尽管对一个基表可以建立多个索引，提高查询速度，但不宜建立太多的索引，最好不超过 3 个。 索引要占用磁盘空间 系统要维护索引结构，维护索引结构系统要花费一定的开销，尤其是经常要插入或删除的表，其维护索引结构的代价是很大的，因此建立索引会减慢插入、修改、删除的执行速度。 用户应该在加快查询速度和降低更新速度之间作出权衡。对于一个仅用来查询的表来讲，建立多个索引是比较合适的，但对更新操作比较频繁的表来讲最好少建立一些索引。 选择合适的时机建立索引 通常，建立索引应选择在表中装入数据之后。如果先建立索引后装入数据，则每次插入一行数据都要对索引进行更新，这样会很浪费时间。 但是，如果要保证装入数据的唯一性，则只能以牺牲系统性能为代价，而在装入数据前建立唯一性索引。 优先考虑主键列建立索引 当主键包含多列时，最好把数据差异最多的列放在索引命令列表的首位。 如果各列数据种类相近，则最好把经常用到的列放在前面。 最好选择包含大量非重复值的列，如医生编号。 如果只有很少的非重复值，如性别只有男和女，最好不要使用索引查询，此时采用顺序扫描更为有效。 索引的创建与删除1234567891011121314151617-- 创建单列索引-- 在药品基本信息表中，在药品名称上，按照升序创建非聚簇索引CREATE NONCLUSTERED INDEX MedIndexON Medicine(Mname ASC) -- 创建复合索引-- 在处方详细信息表中，在处方编码和药品编码上，创建聚簇索引CREATE CLUSTERED INDEX RDIndexON RecipeDetail (Rno ASC, Mno DESC) -- 创建唯一索引-- 在医生基本信息表上，在医生编码上，创建唯一索引CREATE UNIQUE INDEX DoctorIndexON Doctor (Dno ASC)-- 删除 DoctorIndex 索引DROP INDEX DoctorIndex 完整性约束完整性约束是加在数据库模式上的一个具体条件，它规定什么样的数据能够存储到数据库系统中。 按照完整性约束条件作用的对象分： 类型约束 属性约束 关系变量约束 数据库约束 按照完整性约束条件声明时的位置分： 列级约束 表级约束 按状态分类 静态: 对静态对象的约束是反映数据库状态合理性的约束 动态: 对动态对象的约束是反映数据库状态变迁的约束，新旧值之间满足的约束 主键约束分为以下三种写法： 123456789101112131415161718192021222324--列级约束CREATE TABLE RecipeMaster( Rno VARCHAR(10) PRIMARY KEY, DGno VARCHAR(10) Rdatetime DATETIME)--表级约束：单属性主键CREATE TABLE Medicine( Mno VARCHAR(10), Mname VARCHAR(50) NOT NULL, Mprice DECIMAL(18,2) NOT NULL, Munit VARCHAR(10), Mtype VARCHAR(10), PRIMARY KEY(Mno))--表级约束：多属性组合主键CREATE TABLE RecipeDetail( Rno VARCHAR(10), Mno VARCHAR(10) NOT NULL, Mamount DECIMAL(18,0), PRIMARY KEY(Rno,Mno)) UNIQUE 约束写法： 123456CREATE TABLE Dept( DeptNo VARCHAR(10) PRIMARY KEY, DeptName VARCHAR(50) UNIQUE, ParentDeptNo VARCHAR(10), Manager VARCHAR(10)) 注意： 在一个关系中，PRIMARY KEY 只有一个，而 UNIQUE 可以声明多个； PRIMARY KEY 要求属性取值不能为 NULL，而 UNIQUE 允许属性取空值，允许多个空值同时存在 NOT NULL 约束写法： 123456789CREATE TABLE Diagnosis( DGno VARCHAR(10) PRIMARY KEY, Pno VARCHAR(10) NOT NULL, Dno VARCHAR(10) NOT NULL, Symptom VARCHAR(100), Diagnosis VARCHAR(100), DGtime DATETIME, Rfee DECIMAL(18,2) NOT NULL) Check 约束Check 约束即可自定义约束。 Check 表级约束： 123456789101112CREATE TABLE Doctor( Dno VARCHAR(10), Dname VARCHAR(50) NOT NULL, Dsex VARCHAR(2), Dage INT, Ddeptno VARCHAR(10), Dlevel VARCHAR(50), Dsalary DECIMAL(18,2), PRIMARY KEY(Dno), CHECK (Dsex IN (‘男’, ‘女’)), CHECK (Dage &gt; 0 AND Dage &lt; 60)) FK 约束Foreign Key 的值必须为： 空值，或 等于对应某个 Primary Key 中某个主码值 FK 列级约束： 12345678910CREATE TABLE Doctor( Dno VARCHAR(10), Dname VARCHAR(50) NOT NULL, Dsex VARCHAR(2), Dage INT, Ddeptno VARCHAR(10) REFERENCES Dept(DeptNo), Dlevel VARCHAR(50), Dsalary DECIMAL(18,2), PRIMARY KEY(Dno),) 或表级约束： 1234567891011CREATE TABLE Doctor( Dno VARCHAR(10), Dname VARCHAR(50) NOT NULL, Dsex VARCHAR(2), Dage INT, Ddeptno VARCHAR(10), Dlevel VARCHAR(50), Dsalary DECIMAL(18,2), PRIMARY KEY(Dno), FOREIGN KEY(Mno) REFERENCES Dept(DeptNo)) 完整性策略即检查完整性，以及违反完整性时的操作。 违反完整性时，一般会有如下情况： 违反实体完整性规则、用户定义的完整性规则的操作，一般拒绝执行 违反参照完整性的操作，可以拒绝执行；或者接受这个操作，同时执行一些附加的操作，以保证数据库的状态正确 受限策略（RESTRICTED）当出现违背参照完整性规则的更新操作请求时，系统拒绝执行该操作。 这是系统的默认操作。 1234567CREATE TABLE RecipeDetail( Rno VARCHAR(10), Mno VARCHAR(10) NOT NULL, Mamount DECIMAL(18,0), PRIMARY KEY(Rno, Mno), FOREIGN KEY(Mno) REFERENCES Medicine(Mno)) 如上代码，如果删除了被上表引用的 Medicine.Mno 属性，则系统会阻止此次修改。 置空策略（SET-NULL）如果删除了被上表引用的 Medicine.Mno 属性，则对应的 RecipeDetail.Mno值将被置为 0。 12345678CREATE TABLE RecipeDetail( Rno VARCHAR(10), Mno VARCHAR(10) NOT NULL, Mamount DECIMAL(18,0), PRIMARY KEY(Rno, Mno), FOREIGN KEY(Mno) REFERENCES Medicine(Mno) ON DELETE SET NULL) 级联策略（CASCADE）不拒绝用户操作请求，而是连带处理参照数据。 如果删除/修改了被上表引用的 Medicine.Mno 属性，则对应的 RecipeDetail.Mno值所在行将被删除/修改。 123456789CREATE TABLE RecipeDetail( Rno VARCHAR(10), Mno VARCHAR(10) NOT NULL, Mamount DECIMAL(18,0), PRIMARY KEY(Rno, Mno), FOREIGN KEY(Mno) REFERENCES Medicine(Mno) ON DELETE CASCADE ON UPDATE CASCADE) 域约束看起来就是定义自己的数据类型，可以进行 CHECK。 1234567891011121314-- 定义域CREATE DOMAIN SexVal CHAR(2) CHECK (VALUE IN('男', '女'));--使用域CREATE TABLE Patient( Pno VARCHAR(10), Pname VARCHAR(50) NOT NULL, Psex SexVal, -- 自己定义的域 Page INT, Pino VARCHAR(50), Pid VARCHAR(18), PRIMARY KEY(Pno)) 上述代码等价于如下代码： 12345678910CREATE TABLE Patient( Pno VARCHAR(10), Pname VARCHAR(50) NOT NULL, Psex CHAR(2), Page INT, Pino VARCHAR(50), Pid VARCHAR(18), PRIMARY KEY(Pno), CHECK (Psex IN('男', '女'))) 但是使用域有统一约束、便于修改的好处。 断言断言可以理解为全局范围的 CHECK()，相比于上述的 CHECK() 只能在但表中。 但需要注意的是： 当创建断言时，系统要检测其有效性。如果断言有效，则以后只有不破坏断言的数据库修改才被允许。 如果断言比较复杂，则检测会带来相当大的开销。因此，使用断言应该特别小心。 代码： 12345678910111213141516CREATE ASSERTION salarycheck CHECK( NOT EXISTS( SELECT * FROM Doctor AS x WHERE Dsalary &gt;= ANY ( SELECT Dsalary FROM Doctor AS y WHERE x.Deptno = y.Deptno AND y.Dno = ( SELECT Manager FROM Dept WHERE x.Deptno = Dept.Deptno ) ) )) 上述代码涉及了三层嵌套，大致含义是，CHECK 不存在有医生（取自 x 表）的薪水高于医生（取自 y 表），其中二者同部门（Dept），且后者是前者部门的经理（Manager）。 修改完整性约束任何时候都可以添加、修改、删除约束。 因此，为了对约束进行修改、删除，有必要对约束进行命名（虽然不命名也是能运行的，但是不推荐）。 1234567891011121314151617-- 删除约束ALTER TABLE RecipeDetail DROP CONSTRAINT pkRecipeDetailRnoMno;-- 增加约束ALTER TABLE RecipeDetail ADD CONSTRAINT pkRecipeDetailRnoMno PRIMARY KEY(Rno,Mno);ALTER TABLE RecipeDetail ADD CONSTRAINT fkRecipeDetailMnoMedicine FOREIGN KEY(Mno) REFERENCES Medicine (Mno);ALTER TABLE Doctor ADD CONSTRAINT checkPsex CHECK( Psex IN ('男', '女'));ALTER DOMAIN rfee DECIMAL(18,2) DROP CONSTRAINT rfee_test;--删除断言DROP ASSERTION salarycheck; 自主访问控制（DAC）需要考虑以下三个部分： 主体，如某张三用户 客体，如某张表，或某数据的所有表 控制策略，也就是权限，如 SELECT、UPDATE 权限等 其中 SQL Server 的权限分为以下 15 种： 访问数据的权限： SELECT（读取权限）：读数据，但不能修改数据 INSERT（插入权限）：插入新的数据，但不能修改已有数据 UPDATE（修改权限）：修改数据，但不能删除数据 DELETE（删除权限）：删除数据 修改数据库模式（SQL 92标准）的权限： INDEX（索引权限）：建立或删除索引 CREATE（创建权限）：建立新的关系表 ALTER（修改权限）：对关系表中的属性进行增加、删除 DROP（删除权限）：删除关系表。 其它权限 REFERENCE 权限：允许用户在建立关系的完整性约束中引用一个参照关系 USAGE 权限：授权用户使用一个指定的域 TRIGGER 权限：授权用户定义关系表中触发器的权利 EXECUTE 权限：授予用户执行一个函数或过程的权利 UNDER 权限：授权用户建立一给定类的子类 授权授权，就是将对客体操作的权限授予主体。其语法如下： 1234GRANT &#123;all privileges|privilege&#123;. privilege….&#125;&#125; ON [TABLE] tablename|viewname TO [PUBLIC|user_name&#123;,user_name…&#125;] [WITH GRANT OPTION] ALL PRIVILEGES ：所有权限的总称 数据对象可以是基本表，也可以是视图 用户名可以代表单一用户也可以代表一个角色（见后） PUBLIC 是所有数据库用户的总称 WITH GRANT OPTION：受权者可以将此权限转授给其他用户 一个用户如果是表的创建者，他就自动拥有了对所创建表的所有权利以及将该表权利授予其他用户的权利，而且不能取消 示例： 12345GRANT SELECT ON RecipeDetail TO LiXia;GRANT SELECT ON RecipeMaster TO LiXia WITH GRANT OPTION;GRANT UPDATE(Mprice) ON Medicine TO WangHao;GRANT REFERENCE(Mno)ON Medicine TO ZhangYang;GRANT INSERT，DELETE ON RecipeDetail TO MengFan WITH GRANT OPTION; 收回权限格式： 1234REVOKE [WITH GRANT OPTION FOR] &#123;ALL PRIVILEGES|privilege&#123;. Privilege….&#125;&#125; ON [TABLE] tablename|viewname FROM [PUBLIC|user_name&#123;,user_name…&#125;] [RESTRICT|CASCADE] 示例： 123REVOKE SELECT ON RecipeDetail FROM LiXia;REVOKE UPDATE(Mprice) ON Medicine FROM WangHao;REVOKE GRANT OPTION FOR SELECT ON RecipeMaster FROM LiXia; RESTRICT 和 CASCADE 详细介绍可见 受限策略（RESTRICTED） 和 级联策略（CASCADE）。在权限部分也是类似的概念。 从一个用户那里收回权限可能导致其他用户也失去该权限。这一行为称为级联回收 CASCADE。在大多数数据库系统中，级联回收是默认行为。 示例： 12-- 指定为受限策略REVOKE SELECT ON RecipeMaster FROM LiXia RESTRICT; 角色对于角色有如下理解： 角色可以看作是一组操作的集合（“老师”这个角色可修改成绩表、修改名次表）； 角色是授权模板（可按“老师”的模板给张老师、王老师授权） 一个用户可经授权而拥有多个角色，一个角色也可有多个用户 代码如下： 12345678910111213-- 创建角色CRETAE ROLE Administrators;-- 角色授权GRANT SELECT ON RecipeMaster TO Administrators;-- 角色授予用户或其他角色GRANT Administrators TO LiXia;CREATE ROLE Manager;GRANT Administrators to Manager;GRANT Manager TO WangHao;-- 角色 Manager 除具有直接赋予它的权限外，还继承了角色 Administrators 具有的权限。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"SQL","slug":"SQL","permalink":"https://blog.lyh543.cn/tags/SQL/"}]},{"title":"HTML（萌新向）","date":"2020-03-06T08:52:32.000Z","path":"front-end/html/","text":"一个 HTML 在线测试网站 注释1&lt;!-- this is a comment --&gt; 显示一张图片将一行代码保存为 index.html： 1&lt;img src=\"maomao.gif\"&gt; 既可以使用（服务器的）本地图片，也可以使用网上的图片。 调整图片显示尺寸可以按照像素进行放缩，如下面调整宽度为 320 像素，高度为 240 像素： 1&lt;img src=\"maomao.gif\" width=320px height=240px&gt; 也可以按照浏览器窗口的比例显示，如下面是宽度调整为浏览器的 50%，高度调整为浏览器窗口的 30%： 1&lt;img src=\"maomao.gif\" width=50% height=30%&gt; 如果只填写 width 或 height， 图片会按比例缩放。 从列表随机选择一张图片显示 参考：https://ouuan.github.io/post/html实现随机图片/ 用 HTML 5 控件播放视频12345&lt;video width=\"320\" height=\"240\" controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt;您的浏览器不支持 Video 标签。&lt;/video&gt; 打开网页时，网页会由上往下依次检索是否支持这种 video。如果都不支持，就会显示 您的浏览器不支持 Video 标签。 不过感觉大多数浏览器都支持在线播放 mp4 格式吧，只提供一个 mp4 应该也可以了。","tags":[{"name":"编程语言入门","slug":"编程语言入门","permalink":"https://blog.lyh543.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"},{"name":"前端","slug":"前端","permalink":"https://blog.lyh543.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"HTML","permalink":"https://blog.lyh543.cn/tags/HTML/"}]},{"title":"Nginx（萌新向）","date":"2020-03-01T12:46:22.000Z","path":"linux/nginx/","text":"下面记录 Nginx 在使用过程中遇到的“基本”操作。 修改配置文件、测试重启Nginx 首先检查的配置文件在 /etc/nginx/nginx.conf。在这个文件中如果有如下内容： 1include /etc/nginx/conf.d/*.conf; 那么也会检查 /etc/nginx/conf.d/ 下的所有 conf 文件。本着干净的原则，我们推荐在 nginx.conf 加入 include 语句，然后在 conf.d 下按域名创建自己的 conf 配置文件。 修改配置文件以后，Nginx 并不是即时读取配置的，需要使用 reload 命令才能加载配置。 1nginx -s reload 也可以直接重启 Nginx 服务。 1systemctl restart nginx 如果配置有错误，Nginx 就会启动失败，宕机。为了保证 Nginx 服务器能平稳运行，不宕机，我们推荐使用以下命令而不是尝试重启的形式检查错误： 1nginx -t 给全站添加 SSL 证书请看另一篇博客。 网页转发隐性转发/反向代理这里的情形是：用户访问 https://cloud.example.com 时，服务器将其跳转到 127.0.0.1:8080，地址栏仍然显示 https://cloud.example.com。 首先要将域名 cloud.example.com 以 A 的形式指向你的服务器 ip（也就是 example.com 的服务器）。 然后在服务器上新建文件 \\etc\\nginx\\conf.d\\cloud.example.com（习惯用网站命名配置文件），然后加入以下内容： 12345678server &#123; listen 443 ssl http2; server_name cloud.example.com; location / &#123; proxy_pass http://127.0.0.1:8080; &#125;&#125; 这里默认你已经配置好了 https 以及 http 转发到 https 的操作。如果不想使用 https，将第二行修改为 listen 80; 即可。配置 https 请看另一篇博客。 第三行的 server_name 不限形式，可以使用通配符、正则表达式，还可以使用 .example.com 的形式匹配 example.com 及其所有子域名。更多细节可以看 [server_name 的官方文档] [server_name 的官方文档]:(http://nginx.org/en/docs/http/server_names.html) 也可以转发到别的网址，但是貌似不能转发到 https，并且有些网站可能限制转发。 显性转发这里的情形是：用户访问 https://cloud.example.com 时，服务器服务器将其跳转到 https://baidu.com/，地址栏显示 https://baidu.com/。 123456server &#123; listen 443 ssl http2; server_name cloud.example.com; return 301 https://baidu.com/;&#125; 这种方法也可以转发到别的网址，无限制。（顺便一说，这也可以在对应网页放一个 html 转发实现，可以不借助 nginx） 识别路径和参数并转发这里我们讨论更复杂的显性转发情况。方便起见，用表格进行说明： 用户输入的网址 转发后的网址 https://www.lyh543.cn/ https://blog.lyh543.cn/ https://www.lyh543.cn/git https://blog.lyh543.cn/Linux/Git/ https://www.lyh543.cn/linux https://blog.lyh543.cn/Linux/linux-daily-command/ https://www.lyh543.cn/&lt;其他参数&gt; https://blog.lyh543.cn/&lt;其他参数&gt; 我使用的配置文件如下： 1234567891011121314151617181920server&#123; listen 443 ssl http2; server_name www.lyh543.cn; location = / &#123; return 301 https://blog.lyh543.cn/; &#125; location = /git &#123; return 301 https://blog.lyh543.cn/Linux/Git/; &#125; location = /linux &#123; return 301 https://blog.lyh543.cn/Linux/linux-daily-command/; &#125; location / &#123; return 301 https://blog.lyh543.cn$request_uri; &#125;&#125; 注意到最后的 $request_uri 是个很好用的东西。除此之外，我们可以把任意一个 url 拆分为 $scheme://$host$request_uri。 具体地，对于访问链接 https://blog.lyh543.cn/nginx/，我们有： 参数名 实际意义 $scheme https $host blog.lyh543.cn $request_uri /nginx/ 按这种方法，很容易写出 http 强制跳 https 的配置文件： 1234567server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://$host$request_uri;&#125; 显示某路径下 index.html这里的情形是：用户访问 https://example.com/ 时，服务器显示 /path/to/index.html 的内容。 123456789server &#123; listen 443 ssl http2; server_name example.com; location /&#123; root /path/to; index index.html; &#125;&#125;","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.lyh543.cn/tags/Nginx/"}]},{"title":"全站添加 https","date":"2020-03-01T07:42:05.000Z","path":"linux/build-https-sites-with-nginx/","text":"参考链接： LET’S ENCRYPT 给网站加 HTTPS 完全指南 Docker 搭建私有云 Nextcloud nginx强制使用https访问(http跳转到https) 哪个男孩不想要自己的网站全站 https 呢 现在基本都要求各网站使用 HTTPS 、SSL 之类的。于是准备给自己的博客和网站也整一个。 这篇博客就简单说一下，如何在自己的网站上使用 https。 请把本文中出现的所有 example.com 替换为你的域名，将 yourip 替换为你的服务器的 ip。 本文假定你清楚哪些网站是架在服务器上，并且这些网址的域名解析记录已以 A 的形式指向你的服务器。 HTTPS、SSL、TLS 相关术语介绍参考这篇博客，可以知道 HTTPS、SSL、TLS 的定义和区别。 简单来说， SSL 是指安全套接字层，简而言之，它是一项标准技术，可确保互联网连接安全； TLS（传输层安全）是更为安全的升级版 SSL。由于 SSL 这一术语更为常用，因此我们仍然可以将我们的 TLS 安全证书称作 SSL。但当您从赛门铁克购买 SSL 时，您真正购买的是最新的 TLS 证书； TLS/SSL是一种加密通道的规范； HTTPS 实际上就是 HTTP over SSL 下面就开始正式内容。 关闭 ApacheApache 和 Nginx 都属于 Web 服务器。二者可以同时安装，但是（一般）不能同时运行，因为对于 http 的 80 端口只能由一个软件监听，而 https 的 443 同理。 由于本篇教材使用的是 Nginx，如果系统运行的是 Apache，则需要关闭。 如何查看自己的电脑是否运行的是 Apache 呢？ 1lsof -i:80 如果看到了 httpd 或 apache 等字样，就说明你的服务器正运行了 Apache。 如果运行了 Apache，则需要关闭 Apache。这里请读者自己百度完成。 安装 Nginx 可以采用直接在系统上安装和使用 Docker 安装在容器里。 在系统上安装 Nginx对于 CentOS 7，安装并运行 nginx 的命令为： 12yum install nginxsystemctl start nginx 停止 nginx 的命令为：systemctl stop nginx重启 nginx 的命令为：systemctl restart nginx 测试 Nginx在浏览器地址栏输入你的服务器 IP 并访问，如果看到了欢迎界面，则说明 Nginx 正常。 申请 SSL 证书参考：Docker 搭建私有云 Nextcloud – 申请 SSL 证书。 2020.4.28 更新：如果需要自动定期更新证书的，请使用 Certbot 自动脚本而不是以下讲的方法。自动脚本不适用于中文域名。 在服务器上下载 autocert 软件并给予可执行权限： 12wget https://dl.eff.org/certbot-autochmod a+x certbot-auto 然后一行命令（记得替换两个 example.com）： 1./certbot-auto certonly -d \"example.com\" -d \"*.example.com\" --manual --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory 这样可以申请到 example.com 及其下的所有子域名的证书。还可以继续增加域名（即使是别的域名）：-d &quot;another.xyz&quot;。 注意：可以对中文域名申请 HTTPS 证书，但是域名不能使用中文，而应该是使用 punycode 转码后的结果，以 xn-- 开头（也可以在 Chrome 中输入中文域名，复制出来的完整域名就是转码后的结果）。下文配置 Nginx 也应该使用 punycode 编码。 过程中需要： 输入你的邮箱（可选） 是否同意条款（那必须得同意） 是否加入邮件列表（看你） 是否同意 IP 被公示（同意） 往你的域名加入一段 TXT（需要到对应域名的解析页面添加 TXT 解析，照着做就可以了），然后回车继续。这是在验证这确实是你的网站。 之后如果看到了 Congratulations，就是成功了。 在完成这一步以后，文件夹 /etc/letsencrypt/live/example.com 会有以下文件 12# ls /etc/letsencrypt/live/example.comcert.pem chain.pem fullchain.pem privkey.pem README 这四个都是证书文件，请妥善保管。具体哪个是什么，可以先不追究这些细节。 域名解析添加 CAA 记录接下来是可选、但是推荐的步骤。 letsencrpyt.org 签发了你的证书，随后会公布到全网。 但是有个问题，如果别的人也伪造了你的网站的证书（HTTPS 劫持），该如何保证你的网站使用 letsencrypt.org 的而不是他的证书呢？ 我们可以在 DNS 解析中添加 CAA 记录，当别人访问你的网站时，你告诉他们，你的证书是 letsencrypt.org 签发的，就行了。 添加的方法可看 使用CAA记录防止域名证书劫持_最佳实践_云解析DNS-阿里云。 顺便，如果你想把你的某域名作为 GitHub Pages 的别名（如这篇博客），需要在 pages 的仓库设置 CNAME。如果需要 https，还需要添加 CAA 记录指向 letsencrypt.org，否则可能无法启用 https。 对全站加载 SSL 证书接下来我们要用 Nginx 做两件事： 将 https://*.example.com/ 加载 SSL 证书 将 http://*.example.com/ 转发到 https://*.example.com/ 我们要通过配置 nginx 服务来完成这一点。 如果你已经搭建过 nginx 服务，请直接参考修改 nginx 配置文件即可。 我们在 /etc/nginx/conf.d/ 新建一个 https.conf。 1nano /etc/nginx/conf.d/https.conf 然后添加以下内容）同样注意修改 3 个 example.com： 123456789101112131415161718192021server &#123; listen 80 default_server; server_name _; return 301 https://$host$request_uri;&#125;server &#123; listen 443 ssl http2 default_server; server_name _; ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; ssl_trusted_certificate /etc/letsencrypt/live/example.com/chain.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 30m; add_header Strict-Transport-Security \"max-age=63072000; includeSubdomains; preload\";&#125; 第三行的 .example.com 是 Nginx 官方给出的，可以同时匹配 *.example.com 和 example.com 的形式。好评！ 同时从官方链接可以看到 server_name 可以使用四种方式匹配，这里就提一笔，略过了。 读者需要自行修改第 3、10-13 行中的 example.com 保存并退出后，（根据自己安装 Nginx 的形式）重启 Nginx。 这之后，访问域名下的任意子域名都可以被强制跳转到 https 并且使用正确的加密。 自动定期更新证书方法请参考：https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au 由于更新证书也需要进行 DNS Challenge，即在自己的添加 TXT 解析，所以如果前文提到的纯手动添加 TXT 解析的方法，是不能自动定期更新证书的。 只有使用以上方法调用阿里云/腾讯云/华为云/GoDaddy 的 API 添加解析，才可以实现自动更新证书。 另外，经我测试，该方法似乎不支持中文域名（可能是 certbot 使用的是 punycode 编码，但阿里云 API 需要的是 GBK 编码，因此 API 对中文域名不能正常使用）。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.lyh543.cn/tags/Nginx/"}]},{"title":"搭建自己的 Owncloud 云盘","date":"2020-02-27T08:33:05.000Z","path":"linux/build-owncloud-on-server/","text":"2020.2.12 更新：相比 Owncloud，NextCloud 貌似更新。所以我转投 NextCloud 了。另外知乎上也有很多人安利 seafile。2020.2.27 更新：接触了 Docker 以后，发现使用 Docker 搭建更加方便（可从这篇博客中了解）。于是也花了一点时间钻研，搭建好了 NextCloud 和 Seafile，并把方法一并写在下面。 安装 Owncloud转载链接：https://zhuanlan.zhihu.com/p/28648363 官方教程：https://doc.owncloud.org/server/9.0/admin_manual/installation/linux_installation.html 按照上面无脑配就可以了。不多说。 配置 Owncloud按照知乎的链接装完以后 配置文件在 /etc/owncloud/config.php 云盘文件默认在 /var/lib/owncloud/data，可在开始使用，进入管理员账户的时候修改。 顺便一提，对于 NextCloud，配置文件在 ``，安装文件在 /var/www/html/nextcloud/。 如果需要进行配置，需要用 apache 用户运行 /var/www/html/nextcloud/occ 命令，还需要给可执行权限。 12chmod a+x /var/www/html/nextcloud/occ # 给可执行权限sudo -u apache /var/www/html/nextcloud/occ --help 安装基于 Docker 的 NextCloud为什么要用 Docker 呢？这是为了系统的干净吧。不过坏处是，Docker 的 NextCloud 访问宿主机的文件就没那么容易了。当然，两种方法各有所长。 顺便一提，如果使用 Docker 的话，甚至可以在一台 Windows 电脑上部署了，就可以在自己的 Windows 电脑上搭建一个，然后用 frp 等方式内网穿透到公网了（可参考博客）。 首先要安装 Docker 以及 Docker Compose，可参照这篇教程。 然后需要几个配置文件，我压缩好以后，放在我的网站上，链接在这里，当然也可以通过下面的命令直接从服务器下载： 1234wget https://blog.lyh543.cn/Linux/build-owncloud-on-server/nextcloud-docker-compose.tartar -xf nextcloud-docker-compose.tarcd nextcloud-docker-composecd nextcloud 然后一句 1docker-compose up -d 经过漫长的镜像下载以后，即可在 127.0.0.1:7070 看到 NextCloud 初始化页面。 配置 Nextcloud如果需要进入到 docker 的虚拟机中，可以使用一下命令进入容器的命令行： 12[root@iz2ze nextcloud]# docker exec -it nextcloud_web_1 /bin/sh/ # 其中 nextcloud_web_1 为你的容器名，一般来说就是这个，可以通过 docker ps 查看。 进入以后，就是 shell 的操作了。Nextcloud 文件的目录在 /var/www/html。 添加信任域名从别的域名访问的时候，NextCloud 会提示： 12通过不被信任的域名访问请联系您的管理员。如果您就是管理员，请参照 config.sample.php 中的示例编辑 config/config.php 中的 \"trusted_domains\" 设置。 我们需要在容器里配置文件添加自己的域名。 首先进入容器的命令行： 1# docker exec -it nextcloud_web_1 /bin/sh 然后用 vi 修改配置文件： 1# vi config/config.php 然后找到 trust_domain 部分，我的在 30 行附近。 1234'trusted_domains' =&gt;array ( 0 =&gt; 'example.com:8080',), 按 i 进入编辑模式，然后添加自己的域名。 12345'trusted_domains' =&gt;array ( 0 =&gt; 'example.com:8080', 1 =&gt; 'cloud.example.com',), 然后按 esc 退出编辑模式，再依次按 :wq 后回车，保存并退出。再输入 exit 退出 NextCloud 容器的命令行，刷新页面即可。 安装基于 Docker 的 Seafile这里我们基于 HumanBrainProject/seafile-compose 来配置 Seafile。 为什么要用 Docker 呢？这是为了系统的干净吧。不过坏处是，Docker 的 NextCloud 访问宿主机的文件就没那么容易了。当然，两种方法各有所长。 顺便一提，如果使用 Docker 的话，甚至可以在一台 Windows 电脑上部署了，就可以在自己的 Windows 电脑上搭建一个，然后用 frp 等方式内网穿透到公网了（可参考博客）。 首先要安装 Docker 以及 Docker Compose，可参照这篇教程。 然后我们下载前面提到的项目： 123# 如果还没有安装 git，记得安装git clone https://github.com/HumanBrainProject/seafile-composecd seafile-compose 但是！这个模板直接使用貌似会在一个过程中卡住。在修改一个地方以后，我才能够正常的进行部署。 1nano seafile_dev_docker/Dockerfile 在这里，我们修改第三行起的 RUN 语句，将其拆分为几个 RUN 语句，顺便也替换了中科大的镜像源。 123456789101112131415161718RUN sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list \\ &amp;&amp; apt updateRUN apt-get install -qq -y --no-install-recommends \\ vim \\ htop \\ net-tools \\ psmisc \\ git \\ wget \\ curl \\ build-essential \\ python-dev \\ python-pip \\ python-setuptools \\ python-wheel \\ libmysqlclient-devRUN apt-get cleanRUN rm -rf /var/lib/apt/lists/* 所以完整的 seafile_dev_docker/Dockerfile 应该如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556FROM ubuntu:16.04RUN sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list \\ &amp;&amp; apt updateRUN apt-get install -qq -y --no-install-recommends \\ vim \\ htop \\ net-tools \\ psmisc \\ git \\ wget \\ curl \\ build-essential \\ python-dev \\ python-pip \\ python-setuptools \\ python-wheel \\ libmysqlclient-devRUN apt-get cleanRUN rm -rf /var/lib/apt/lists/*ENV DOCKERIZE_VERSION v0.6.1RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ &amp;&amp; tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ &amp;&amp; rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gzENV SEAFILE_VERSION=6.3.3 SEAFILE_SERVER=seafile-serverRUN mkdir -p /opt/seafile/conf &amp;&amp; \\ mkdir -p /opt/seafile/data &amp;&amp; \\ mkdir -p /opt/seafile/pids &amp;&amp; \\ mkdir -p /opt/seafile/ccnet &amp;&amp; \\ mkdir -p /opt/seafile/sockets &amp;&amp; \\ mkdir -p /opt/seafile/logs &amp;&amp; \\ openssl genrsa -out /opt/seafile/ccnet/mykey.peer 4096 &amp;&amp; \\ touch /opt/seafile/logs/seafile.log &amp;&amp; \\ touch /opt/seafile/logs/ccnet.log &amp;&amp; \\ touch /opt/seafile/logs/seahub.logRUN mkdir -p /opt/seafile/ &amp;&amp; \\ curl -sSL -o - https://download.seadrive.org/seafile-server_$&#123;SEAFILE_VERSION&#125;_x86-64.tar.gz \\ | tar xzf - -C /opt/seafile/ &amp;&amp; \\ ln -s /opt/seafile/seafile-server-$&#123;SEAFILE_VERSION&#125; /opt/seafile/seafile-server-latestENV LD_LIBRARY_PATH=/opt/seafile/seafile-server-latest/seafile/lib:/opt/seafile/seafile-server-latest/seafile/lib64:$LD_LIBRARY_PATHENV SEAFILE_DATA_DIR=/opt/seafile/data CCNET_CONF_DIR=/opt/seafile/ccnet SEAFILE_CENTRAL_CONF_DIR=/opt/seafile/conf SEAFILE_CONF_DIR=/opt/seafile/seafile-dataENV PYTHONPATH=/opt/seafile/seafile-server-$&#123;SEAFILE_VERSION&#125;/seafile/lib64/python2.7/site-packages:/opt/seafile/seafile-server-6.3.3/seahub:/opt/seafile/seafile-server-6.3.3/seahub/thirdpart:$PYTHONPATHCOPY ./requirements.txt /tmp/requirements.txtRUN pip install --no-cache-dir --disable-pip-version-check \\ -r /tmp/requirements.txt \\ -r /opt/seafile/seafile-server-$&#123;SEAFILE_VERSION&#125;/seahub/requirements.txtCOPY config /opt/seafile/conf/COPY ccnet /opt/seafile/ccnet/COPY scripts /opt/seafile 然后使用该项目提供的命令进行构建： 123456docker-compose \\ -f docker-compose.yaml \\ up \\ --force-recreate \\ --renew-anon-volumes \\ --build 整个过程比较慢，最后如果看到了 seahub_1 开头的行，应该是配置完毕了。此时访问 yourip:8000，如果出现了 Seafile 登录页面，那么你就成功了 3/4 了。 接下来按 Ctrl+C 停止，然后重新让他以后台形式运行： 1docker-compose up -d 前面的 docker-compose 命令只用于第一个构建 Docker，之后就用常规的 docker-compose up -d 即可。运行完以后可以检查一下 8000 端口是否正常。 剩下的 1/4 就是注册新账户了。这里 Seafile 不像 NextCloud 在第一次登陆时创建管理员账户，而是需要调用容器内的 Python 脚本。 在宿主机执行以下命令： 1docker-compose exec seahub python /opt/seafile/seafile-server-latest/seahub/manage.py createsuperuser 如果正常，就会出现下面的情况： 1234567$ docker-compose exec seahub python /opt/seafile/seafile-server-latest/seahub/manage.py createsuperuser/opt/seafile/seafile-server-6.3.3/seahub/thirdpart/requests/__init__.py:80: RequestsDependencyWarning: urllib3 (1.19) or chardet (3.0.4) doesn't match a supported version! RequestsDependencyWarning)E-mail address: lxl361429916@live.comPassword:Password (again):Superuser created successfully. 前面的 Warning 可以忽略。注册完账户以后，就可以在 8000 端口登陆了。 可能报错及解决方案第一次配置时卡住如果第一次配置的时候卡住，出现了下面的内容： 12345678910111213141516171819202122232425262728293031323334353637# docker-compose \\&gt; -f docker-compose.yaml \\&gt; up \\&gt; --force-recreate \\&gt; --renew-anon-volumes \\&gt; --buildBuilding ccnetStep 1/15 : FROM ubuntu:16.04 ---&gt; 77be327e4b63Step 2/15 : RUN apt update &amp;&amp; apt-get install -qq -y --no-install-recommends vim htop net-tools psmisc git wget curl build-essential python-dev python-pip python-setuptools python-wheel libmysqlclient-dev &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* ---&gt; Running in 379f2d9271b1WARNING: apt does not have a stable CLI interface. Use with caution in scripts.Get:1 http://archive.ubuntu.com/ubuntu xenial InRelease [247 kB]Get:2 http://security.ubuntu.com/ubuntu xenial-security InRelease [109 kB]Get:3 http://archive.ubuntu.com/ubuntu xenial-updates InRelease [109 kB]Get:4 http://security.ubuntu.com/ubuntu xenial-security/main amd64 Packages [1063 kB]Get:5 http://archive.ubuntu.com/ubuntu xenial-backports InRelease [107 kB]Get:6 http://archive.ubuntu.com/ubuntu xenial/main amd64 Packages [1558 kB]Get:7 http://security.ubuntu.com/ubuntu xenial-security/restricted amd64 Packages [12.7 kB]Get:8 http://security.ubuntu.com/ubuntu xenial-security/universe amd64 Packages [620 kB]Get:9 http://security.ubuntu.com/ubuntu xenial-security/multiverse amd64 Packages [6280 B]Get:10 http://archive.ubuntu.com/ubuntu xenial/restricted amd64 Packages [14.1 kB]Get:11 http://archive.ubuntu.com/ubuntu xenial/universe amd64 Packages [9827 kB]Get:12 http://archive.ubuntu.com/ubuntu xenial/multiverse amd64 Packages [176 kB]Get:13 http://archive.ubuntu.com/ubuntu xenial-updates/main amd64 Packages [1432 kB]Get:14 http://archive.ubuntu.com/ubuntu xenial-updates/restricted amd64 Packages [13.1 kB]Get:15 http://archive.ubuntu.com/ubuntu xenial-updates/universe amd64 Packages [1021 kB]Get:16 http://archive.ubuntu.com/ubuntu xenial-updates/multiverse amd64 Packages [19.3 kB]Get:17 http://archive.ubuntu.com/ubuntu xenial-backports/main amd64 Packages [7942 B]Get:18 http://archive.ubuntu.com/ubuntu xenial-backports/universe amd64 Packages [8807 B]Fetched 16.4 MB in 1min 46s (153 kB/s)Reading package lists...Building dependency tree...Reading state information...All packages are up to date. 可能是你没有修改 Dockerfile，请按照上面的方法修改 Dockerfile，然后重新 docker-compose 设置密码时报错如果设置密码时报错： 1seahub.base.accounts.DoesNotExist: User matching query does not exits. 可能是数据库的容器自己退出了。可以用 docker ps --all，然后看 seafile-compose_db_1 的 STATUS 是 UP 还是 EXIT。 如果确实是 EXIT 退出了，那么 docker-compose up -d 即可重启。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.lyh543.cn/tags/Docker/"}]},{"title":"Docker 笔记","date":"2020-02-19T13:01:58.000Z","path":"linux/docker/","text":"Docker 像是一个容器一样，能够让应用运行在隔离的环境中。其实很像一个虚拟机，但是其本质和虚拟机是不同的，结构较虚拟机简单的多，因此速度也远快于虚拟机。Docker 还是跨平台的，可以在 Linux/Windows/MacOS 上运行。对于 Windows 的 Docker（准确的说是 Docker Desktop），它还提供了 Linux 和 Windows 两种子系统。（也就是说，在 Linux 下能运行的 Docker 容器，完全能够在 Windows 上运行） 而 Docker Compose 可以根据配置文件自动下载镜像、配置、运行 Docker 容器，一气呵成。下载网上写好的配置文件，然后一行代码 docker-compose 即可完成配置，搭建好自己的云服务。它同样是跨平台的。这也是 Docker 方便的原因之一。 Docker 文档：https://docs.docker.com/install/linux/docker-ce/centos/Docker Compose 文档：https://docs.docker.com/compose/install/ 我收集的基于 Docker 的好用的云服务可以见后面小节。 安装 DockerLinux 安装 Docker脚本安装1bash &lt;(curl -s https://get.docker.com) 手动安装由于项目是基于 Docker 的，所以要先安装 Docker。这篇文章安装的是稳定版的 Docker Engine - Community。 先卸载以前的 Docker 安装： 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 再安装所需的包： 123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 接下来添加 Docker 的库，并安装 Docker： 1234$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo$ sudo yum install -y docker-ce docker-ce-cli containerd.io 到这里，我们安装了 Docker 并建立了 Docker 用户组，但里面还没有成员。 接下来启动 Docker： 1$ sudo systemctl start docker 然后进行一个对 Docker 的 Hello-World 测试： 123456789101112131415161718192021222324252627$ sudo docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world1b930d010525: Pull completeDigest: sha256:9572f7cdcee8591948c2963463447a53466950b3fc15a247fcad1917ca215a2fStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 表示测试正常。 Windows 安装 DockerWindows 也是支持 Docker 的，他还支持 Windows 容器和 Linux 容器。 安装方法是去官网下载 Docker Desktop 并安装，然后就可以在命令行中使用 docker 和下面提到的 docker-compose 了，命令和 Linux 也是一样的。 在 WSL 1 中使用 docker-cliWSL 2 中集成了 docker-cli，可以直接管理 Windows 的 Docker。在 WSL 1 中输入 docker，可以看到 Docker 推荐你转换为 WSL 2。 12345The command 'docker' could not be found in this WSL 1 distro.We recommend to convert this distro to WSL 2 and activatethe WSL integration in Docker Desktop settings. See https://docs.docker.com/docker-for-windows/wsl/ for details. 然而我并不想转换，可参考 Windows 10 WSL1 的子系统下完美解决docker的命令问题_累积技术 沉淀经验-CSDN博客 在 WSL1 下安装 docker-cli。 安装 Docker ComposeDocker Compose，就可以使用配置文件，一行代码配置 Docker 了。 Docker Desktop 自带 Docker Compose，Linux 需要自行下载。 下载 Docker Compose 最新版，并给予可执行权限： 12sudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose 最后检查一下是否成功安装： 12$ docker-compose --versiondocker-compose version 1.25.4, build 8d51620a Docker 更换国内源 参考链接：https://www.cnblogs.com/wushuaishuai/p/9984228.html#_label0 和很多东西一样，Docker 镜像也有国内仓库。 国内的 Docker 镜像仓库有： 123456http://hub-mirror.c.163.comhttps://3laho3y3.mirror.aliyuncs.comhttp://f1361db2.m.daocloud.iohttps://mirror.ccs.tencentyun.comhttps://docker.mirrors.ustc.edu.cnhttps://registry.docker-cn.com 这里选 aliyun 的做示范。 创建一个 daemon.json： 1sudo vim /etc/docker/daemon.json 按 i 进入编辑模式，写入以下内容： 123&#123; \"registry-mirrors\": [\"https://3laho3y3.mirror.aliyuncs.com\"]&#125; 按 esc 退出编辑模式，按 :wq 保存。 然后重启 Docker 服务。 1sudo systemctl restart docker Windows 应到 Docker Desktop 的 Settings 中的 Docker Engine 栏中修改。下面是我修改后的内容。 123456&#123; \"registry-mirrors\": [\"https://3laho3y3.mirror.aliyuncs.com\"], \"insecure-registries\": [], \"debug\": true, \"experimental\": false&#125; 验证镜像源可以使用命令 docker info，如果看到有两行： 12Registry Mirrors: https://3laho3y3.mirror.aliyuncs.com/ 就表示成功。 下次拉取镜像的时候就快得多了。 常用 Docker 镜像个人收集的一些基于 Docker 的云服务。 镜像 创建命令或 docker-compose.yml 链接 Docker Web 管理 docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce 私人云 NextCloud nextcloud-docker-compose.tar 私人云 Seafile docker-compse.yaml morrisjobke/webdav docker run -d --name webdav -v D:/:/var/webdav -e USERNAME=test -e PASSWORD=test -p 8888:80 --restart always morrisjobke/webdav 在线 Markdown 编辑器 CodiMD docker-compse.yml 在线 LaTeX 编辑器 Overleaf docker-compose.yml Qbittorrent Enhanced Edition docker run -d --name qbittorrentee -e WEBUIPORT=8081 -e PUID=1026 -e PGID=100 -e TZ=Asia/Shanghai -p 6881:6881 6881:6881/udp -p 8081:8081 -v /media/Downloads:/downloads --restart always superng6/qbittorrentee 云 SSH WebSSH2 无 远程 Firefox firefox-enpass-novnc 无 shadowsocks docker run --name shadowsocks -d -p 54285:54285 --restart always oddrationale/docker-shadowsocks -s 0.0.0.0 -p 54285 -k yourpasswd -m aes-256-cfb v2ray+自定义dns docker run -d --name v2ray -p 443:443 -p 80:80 -v $HOME/.caddy:/root/.caddy pengchujin/v2ray_ws:0.10 YOURDOMAIN.COM V2RAY_WS &amp;&amp; sleep 3s &amp;&amp; sudo docker logs v2ray MySQL docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --restart always mysql Redis docker run -d --name redis -p 6379:6379 -e REDIS_PASSWORD=redis --restart always redis /bin/sh -c &#39;redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}&#39; Memcached docker run -d --name memcached -p 11211:11211 --restart always memcached Docker 基础命令初次接触 Docker，要记得两个概念：images（镜像） 和 containers（容器）。从网上获取一个镜像，然后每次可以由这个镜像创造一个容器（像是每次由一个系统镜像安装一个系统一样）。 下面是我最先接触到的几条命令，可能比较适合和我一样的新人。 命令 用途 常用参数 docker run -dit ubuntu 从 Ubuntu 镜像创造一个容器并运行 可用 --name 对容器命名，默认名是随机生成的；在最后可加 &lt;command&gt; docker start -i &lt;name&gt; 运行名为 &lt;name&gt;（也可以是容器的 container ID 值的前几位）的容器 docker images 查看本地的镜像 docker image prune -af 删除所有没有使用的镜像（如果有容器使用了某镜像，无论这个容器正在运行/已停止，这个镜像不会被删除） docker ps 查看正在运行的容器 加 --all 或 -a 查看所有的（包括已停止的镜像） docker container rm &lt;name&gt; 删除名为 &lt;name&gt;（也可以是容器的 container ID 值的前几位）的容器 docker container prune -af 删除所有已停止的容器 docker container rename &lt;old_name&gt; &lt;new_name&gt; 给容器改名 docker exec -it &lt;name&gt; /bin/bash 在正在运行的 &lt;name&gt; 容器中运行 bash 命令行 docker update --restart=always &lt;name&gt; 让 &lt;name&gt; 容器开机自启、自动重启 -v ~/downloads:/var/webdav 将容器外的 ~/downloads 映射到容器内的 /var/webdav Windows 下将路径中 \\ 改为 / 即可，如 d:/Downloads Docker Compose 基础命令 命令 用途 常用参数 docker-compose up 以当前文件夹下的 docker-compose.yml 作为配置文件，run 一个容器 -d可在后台运行 docker-compose down -v 删除当前文件夹下的 docker-compose.yml 所指的容器 Docker Compose 文件语法本人不会写 docker-compose.yml，只会做一些简单的修改，因此只记录自己用过的语法。 1234ports: - 7070:80 # 将 Docker 内的 80 端口映射到宿主机的 7070 端口 # 即可以通过访问 Docker 外部的 7070 端口访问到内部的 80 端口 常见错误及解决办法在 Docker 容器中如何安装软件不少 Docker 容器都是采用的 Alpine Linux，这个 linux 发行版没有 sudo，没有 bash，我猜是为了简洁吧，毕竟要做成镜像，所以把没用的功能尽量都砍了。 Alpine Linux 下安装软件的命令为： 1apk add &lt;package name&gt; 顺便中科大镜像源也有 Alpine Linux 的软件源，觉得国内网速慢的可以去更换，镜像站也有更换教程。 Read-only file system可能是 docker-compose.yml 中指定了目录为只读。这些可能出现在： 1234567891011version: '3.3' services: redis: image: redis:4.0.1-alpine networks: - myoverlay read_only: true # 指定为只读 networks: myoverlay: 12345678910web: build: ./web restart: always ports: - 7070:80 volumes: # - nextcloud:/var/www/html:ro # ro 为只读 (read-only) - nextcloud:/var/www/html # 可读写的版本 depends_on: - app Container is unhealty我在 Windows 下安装 overleaf 时，出现过下面的情况。 1234567&gt; docker-compose upCreating network \"overleaf_default\" with the default driverCreating overleaf_redis ... doneCreating overleaf_mongo ... doneERROR: for sharelatex Container \"233abaae4ea7\" is unhealthy.ERROR: Encountered errors while bringing up the project. 在配置文件 docker-compose.yml 中写到，sharelatex 基于 overleaf_redis 和 overleaf_mongo，并且要求 mongo 是 healthy 的。233abaae4ea7 正是我电脑上的 mongo 的 Container ID。 123456789101112sharelatex: depends_on: mongo: condition: service_healthy redis: condition: service_startedmongo: healthcheck: test: echo 'db.stats().ok' | mongo localhost:27017/test --quiet interval: 10s timeout: 10s retries: 5 healthy 可以理解为是正常运行。 这里出错就有两种情况了，一是 mongo 本身不正常了，另一种是 mongo 检查的太频繁了，导致还没完成启动，就被诊断为 unhealthy 了。 我们检查一下 mongo 的 log。 12&gt; docker ps | find \"233a\"233abaae4ea7 mongo \"docker-entrypoint.s鈥? About a minute ago Restarting (14) 47 seconds ago overleaf_mongo 显示 mongo 正在重启，我估计是在反复不正常-重启，因此就考虑在这方面进行 debug。最后的问题出在由于我是在 Windows 上运行，文件映射可能不正确，我把配置文件的 volumes 部分删掉就可以了。 当然，如果是正确的情况，上一行会显示： 12&gt; docker ps --all | find \"mongo\"194bafd8158f mongo \"docker-entrypoint.s鈥? 13 minutes ago Up 12 minutes (healthy) 27017/tcp overleaf_mongo 这种情况下，可以考虑把 mongo 的 healthcheck 部分的 inteval 和 timeout 调大。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.lyh543.cn/tags/Docker/"}]},{"title":"搭建在线 MarkDown 编辑器 -- CodiMD","date":"2020-02-19T08:58:37.000Z","path":"linux/build-online-markdown-editor/","text":"偶然在群里看到了在服务上搭建的 Markdown 编辑器，叫 CodiMD，也想自己整一个。于是就找官方文档来安装。 项目链接：https://github.com/hackmdio/codimdCodiMD 文档：https://hackmd.io/c/codimd-documentation/%2Fs%2Fcodimd-docker-deployment 安装 Docker 及 Docker Compose这两个部分已被迁移到一篇专门讲 Docker 的 博客 中。 安装 CodiMD现在准备工作做好了，就准备安装 CodiMD 了。 下面一份从 CodiMD 文档 获得的配置文件。复制下面的代码，并在任意处保存为 docker-compose.yml。 1234567891011121314151617181920212223242526version: \"3\"services: database: image: postgres:11.5 environment: - POSTGRES_USER=codimd - POSTGRES_PASSWORD=change_password - POSTGRES_DB=codimd volumes: - \"database-data:/var/lib/postgresql/data\" restart: always codimd: image: nabo.codimd.dev/hackmdio/hackmd:1.4.1 environment: - CMD_DB_URL=postgres://codimd:change_password@database/codimd - CMD_USECDN=false depends_on: - database ports: - \"3000:3000\" volumes: - upload-data:/home/hackmd/app/public/uploads restart: alwaysvolumes: database-data: &#123;&#125; upload-data: &#123;&#125; 这里的原理是建立了两个容器（container），分别名为 database 和 codimd。他们之后就是他们的设置。database 先通过 6-7 行建立数据库的账户，codimd 再通过 15 行 CMD_DB_URL=postgres://codimd:change_password@database/codimd 登录 database 进行数据交换。可以修改账户密码，但是记得 6-7 行和 15 行要同时改。 最后在文件所在目录下，一键下载配置： 1docker-compose up -d 然后要等待漫长的镜像下载。 可能错误password authentication failed for user首先检查 docker-compose.yml 的两个容器的 6-7、15 是否对应。 如果是对的，但是仍然报错，可能需要先删除容器，再重新建立容器： 12docker-compose down -vdocker-compose up -d","tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://blog.lyh543.cn/tags/Markdown/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.lyh543.cn/tags/Docker/"}]},{"title":"Python 基础","date":"2020-02-18T13:18:37.000Z","path":"python/python/","text":"学习链接：https://www.liaoxuefeng.com/wiki/1016959663602400参考链接：https://docs.python.org/zh-cn/3.7/tutorial/index.htmlGoogle 开源项目风格指南：https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/ 比较基础的部分，新的东西就记一笔过一下就行了，方便以后查阅。 由于讲的偏系统，而不是深入浅出，比如一上来就把所有的东西讲完，也不说清哪些常用哪些不常用，其实不是很适合新手学习。 学起来才会感觉到，C++ 从会用到入门以后，学其他语言也不会只关心它的语法，还会去查它的实现，如 Python list 的实现，int 的上限（不存在的）。 基础语法语句没有分号。 逗号不是用于分隔表达式，而是用于对多元组赋值： 1a, b = b, a+b 代码块不用大括号，完全靠缩进（约定俗成为 4 个空格） 注释用 # 号开头（和 shell 是一样的） 执行 python 脚本用 python 运行1python test.py 直接运行Windows 下不行，只能 Linux 或 MacOS X。 在脚本开头加： 1#!/usr/bin/env python3 通过命令给脚本权限 12chmod a+x hello.py./hello.py 基本 IO输出：print()123print(\"Hello world\") # 自带换行print(\"Hello\", \"world\") # 二句等效，print多个字符串，会在中间加空格print('100 + 200 =', 100 + 200) # 也可以输出计算结果 Python 也支持类似与 C 的格式化方式，但这部分内容属于字符串。 输入：input()123name = input() # 输入的是 str 而非 intname = input(\"Please input your name\") # 这里的输出不带换行age = int(input('Please input your age')) # 需要输入 int 时需转换 读文本文件123with open('input.txt', 'r') as f: for line in f: print(line) # 每一行的内容 如需读写 utf-8 文档，可在 open() 函数添加参数 encoding=&#39;utf-8&#39;。 如需跳过第一行，可以使用以下语法： 1234with open('input.txt', 'r') as f: next(f) for line in f: print(line) # 每一行的内容 写文本文件123with open('output.txt', 'w') as f: f.write('hello, world!\\n') f.write(\"I'm %s\" % \"lyh543\\n\") 关于写入、追加等方式的区别可见图（来源）： 读写文本的方法 基本数据类型有整数 int，浮点数、字符串 str、字节串 bytes 布尔值 bool、空值 None。 整数的上限知道怎么移位以后，我就尝试用 (-1)&gt;&gt;1 得知 Python 的上限。然而失败了。结果是 -1 是个什么意思？！ 查了一下资料，发现 Python 整型是没有上限的？！因为它的实现是类似于高精度的变长数组（牺牲效率获取方便，没毛病） 那这个大概负数移位以后，自动把空出来的符号位又用 1 补上了。最后的结果就是，无论正负数，右移的结果是向下取整。 实数间的除法Python 的 / 的结果是浮点数。 Python 的 // 和 % 是广义的整除和取模，可以在浮点数间使用。 字符串字符串可以理解为字符的 list，可以直接使用 list 的成员函数。 字符串常量 单双引号等价：&quot;a&quot; == &#39;a&#39;（Python 没有 char 的说法，只有 one-character string） 支持转义字符 \\：&quot;&#39;&quot; == &quot;\\&#39;&quot; == &#39;\\&#39;&#39;，&#39;\\n&#39; 类似于 C++ 的逐字字符串：r&#39;\\n&#39; == r&#39;&#39;&#39;\\n&#39;&#39;&#39; 还可以用 &#39;&#39;&#39; 括起表示换行的字符串（该语法支持与第三条搭配）： 12print('''helloworld''') 在命令行中使用该语法会出现用 ... 代替 &gt;&gt;&gt; 的提示符，如下： 12345&gt;&gt;&gt; print('''hello... world''')helloworld&gt;&gt;&gt; 字节串 bytes字符编码原理可以看这篇博客。 在 Python 3 中，字符串用 Unicode 编码。在内存中使用 Unicode，但是如果需要保存在磁盘上，就需要把 str 变为 bytes。 bytes 常量须在单/双引号前加前缀 b，如 b&#39;ABC&#39;。 Unicode（str）和 bytes 的转换Python 的 str 使用 Unicode 的，而若要用 ASCII 或 UTF-8 （如在网络或磁盘上存、取），就得使用 bytes。 str 可以通过成员函数 encode() 编码为指定编码（如&#39;ascii&#39;，&#39;utf-8&#39;）的 bytes。 12345678&gt;&gt;&gt; 'ABC'.encode('ascii');b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'&gt;&gt;&gt; '中文'.encode('ascii')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 中文编码为 ascii 会报错。而 utf-8 中无法显示为 ASCII 字符的字节，会用 \\x## 显示。 为避免乱码，应当坚持使用 UTF-8 对 str 和 bytes 进行转换。 而反过来，把指定编码的字节串编码为 Unicode 的函数叫 decode()。 12345678910&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')'中文'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8')Traceback (most recent call last): ...UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore')'中' 解码过程中可以传入 errors=&#39;ignore&#39; 忽略错误的字节。 字符串、字节串的长度对于字符串，len() 能返回字符数；对于字节串，len 返回的是字节数。 12len('中文') # == 2len('中文'.encode('utf-8')) # == 6 Python 源文件的编码 文本编辑器应使用 UTF-8 without BOM 在源代码前加： 12#!/usr/bin/env python3#-*- coding:utf-8 -*- 或者使用 ANSI 编码，然后加上 #-*- coding:ansi -*-。默认为 UTF-8。 格式化字符串和 C 的 printf() 一样，Python 也支持格式化字符串，也是使用 %，用法也差不多。但是格式略有不同。 123456&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.'&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)'Age: 25. Gender: True' 格式化字符串和参数中间由 % 隔开。和记一下就行。有意思的是，如果你不太确定应该用什么，%s 永远起作用，它会把任何数据类型转换为字符串。 另一种形式是用字符串的成员函数 format()，把一个字符串的 {0}、{1}等，用参数来一一替换得到一个新的字符串。 12&gt;&gt;&gt; 'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%' 除此之外，还支持以下类似 shell 的形式： 123name = 'World'message = f'Hello, &#123;name&#125;.'print(message) # Hello, World 还能支持居中、左对齐、右对齐： 123456value = 'hi'print(f'.&#123;value:&lt;25&#125;.')print(f'.&#123;value:&gt;25&#125;.')print(f'.&#123;value:^25&#125;.')print(f'.&#123;value:-^25&#125;.') 输出如下： 1234.hi .. hi.. hi ..-----------hi------------. 字符串函数函数名|作用-|-|-str.lower()|全大写str.upper()|全小写str.capitalize()|首字母大写str.title()|每个单词的首字母大写str.swapcase()|交换大小写len(str)|长度str.startswith(str)|返回 True 或 Falsestr.endswith(str)|返回 True 或 Falsestr.find(str)|返回出现的第一个位置，如不存在返回 0str.count(str)|计数出现次数str.strip()|去掉空白字符str.lstrip()|去掉左边的空白字符str.rstrip()|去掉右边的空白字符str.replace(str, str)|替换字符串str.rjust(int, str)|添加 str 以使右对齐至 int 个空格str.rjust(int, str)|添加 str 以使左对齐至 int 个空格 前面各类型的转换字符、数字（ASCII 码）间的转换单个字符和对应的 ASCII 码的转换可以使用 ord() 和 chr() 函数。 123ord('A') # == 65ord('中') # == 20013chr(66) # == 'B' 还可以直接用八进制、十六进制写 str： 12'\\u4e2d\\u6587' # =='中文''\\65' # == '5' 字符串、实数间的转换这种类型转换和 C++ 类似，把类型看作一个函数，如 int()，str()。 使用 str() 即可把 int 或 float 转为 str；使用 int() 可以把 float（和 C 一样，向 0 取整）和 str（要求是能转化为整数的字符串）转为 int。使用 float() 可以把 int 和 str（要求是能转化为实数的字符串）转化为 float。 1234str(123.0) # = '123.0'int('123') # = 123int('123.0') # 报错 ValueErrorfloat('123') # = 123.0 布尔值True, False 大小写敏感 print(True) 输出 True（而非 C 的 1）。 布尔运算：and，or，not 位运算位运算： &amp;，|，^，~，&gt;&gt;，&lt;&lt; 注意无论正负，进行右移 &gt;&gt; 操作都等价于除以 $2^n$ 后向下取整。参见整数的上限。 &amp;&amp;，||，!：不存在的 空值空值是 Python 里一个特殊的值，用 None 表示。None 不能理解为 0，因为 0 是有意义的，而 None 是一个特殊的空值。如输出没有返回值的函数的返回值，会输出 None： 1234def foo() returnprint(foo()) 其他数据类型此外，Python 还提供了列表、字典等多种数据类型，还允许创建自定义数据类型. 列表 list和 C++ STL 的 list 不同，Python 的 list 实际上不是链表，是可变长度的数组（元素是指针，类似于 C++ STL 的 vector&lt;void *&gt;，所以可以不同类型的变量混合存储）。因此，list.insert(index, elem) 和 list.pop(index) 是 O(n) 时间复杂度的。 list 定义list 内可存不同类型，可以嵌套 list。 12345&gt;&gt;&gt; classmates = ['Michael', 233 , \"Tracy\"]&gt;&gt;&gt; print(classmates)['Michael', 233, 'Tracy']&gt;&gt;&gt; nestedList = [[1, 2], [3, 4]] # 类似与二维数组&gt;&gt;&gt; emptyset = [] 如何初始化一个大小为 100，元素全为 0 的 list 呢？ 1&gt;&gt;&gt; newlist = [0] * 100 没错——Python 的列表居然支持乘法！！！！这也太香了！ 但是这种语法有陷阱——如果想要建立二维 list，以下语法是不行的： 1&gt;&gt;&gt; list2d = [[0] * 10] * 100 当你想要编辑第二行第二列个元素时，执行 list2d[1][1] = 1 后，会发现第二列的所有元素都变成了 1！ 究其本质，是上面所说的，元素是指针，[[0] * 10] * 100 的外层 list 的 100 个元素实际上是指向了同一个 list。 解决方案有三个： 一是在外层老老实实的迭代： 123list2d = []for i in range(100): list2d.append([0] * 10) 二是使用后面才会学到的列表生成式： 1list2d = [ [0 for i in range(10)] for j in range(100) ] 三是使用 numpy.zeros 12import numpy as nptest = np.zeros((m, n), dtype=np.int) list 成员函数 函数名 函数用法 len(classmates) 列表中元素个数 classmates[0] 第一个元素 ‘Michael’ classmates[3] 返回 IndexError classamte[-1] 返回最后一个元素（等价于classmate[2]） classmate[0:2] 返回子列表，其元素在 classmate 的下标范围为 [0,2)，详见切片 classmate[-3:0] 返回最后三个元素组成的子列表，详见切片 classmates.append(&#39;Adam&#39;) 向末尾追加元素（类似于 C++ std::vector::push_back()） classmates.insert(index, &#39;Jack&#39;) 在索引号为 index 的位置前插入元素（O(n) 时间复杂度） classmates.pop() 删除末尾的元素 classmates.pop(index) 删除索引号为 index 的元素（O(n) 时间复杂度） list 和 strC 中，字符串是字符数组 char[]。Python 中虽然二者是不同的类型，但是可以互通。 str 到 list 直接类型转换就好了。而 list 到 str 则需要使用 join 函数。 12345678&gt;&gt;&gt; list('abc')['a', 'b', 'c']&gt;&gt;&gt; ''.join(['a', 'b', 'c'])'abc''-'.join(['a', 'b', 'c'])'a-b-c' 元组 tuple元组这翻译怪怪的，可是谁叫 n-tuple 翻译过来是 n 元组呢 相当于是 list 的常量版本，一旦初始化就不能修改。但是可以使用 []。 123&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy')&gt;&gt;&gt; one_tuple = (1,)&gt;&gt;&gt; empty_tuple = () 一元组要在 ) 后加 , 以示和括号表达式的区分。 字典 dict Python 内置了字典：dict 的支持，dict 全称dictionary，在其他语言中也称为 map，使用键-值（key-value）存储，具有极快的查找速度。查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多。 看到这里，其实已经猜到 dict 的实现是 hashmap 了。查了一下，果然是的。 定义12d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;d['Adam'] = 67 对同一个键进行存入，会直接覆盖原先的值。 访问访问：d[&#39;Adam&#39;]，（返回 67）。如果不存在键，则返回 KeyError。 如果要查询是否存在，可以使用 if &#39;Adam&#39; in d。 dict 的 keydict 的 key 要求是不可变的量，如整数、字符串、tuple。而 list 则不可以。若强行作为 key， 会返回 TypeError: unhashable type: &#39;list&#39;。 变量和 C 一样，变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头。 赋值过程和 C 一样。 123a = 1t_007 = 'T007'a = True Python （基本数据类型？）变量不需要初始化，且同一个变量可以反复赋值，而且可以是不同类型的变量。这种被称为 动态语言，反之为静态语言，如 C，Java。 查询、判断变量类型查询类型使用 type()： 1234&gt;&gt;&gt; type(123)&lt;class 'int'&gt;&gt;&gt;&gt; type('c')&lt;class 'str'&gt; 判断类型使用 isinstance()： 12345678&gt;&gt;&gt; isinstance(123,int)True&gt;&gt;&gt; isinstance(123,str)False&gt;&gt;&gt; isinstance(123,lyh543)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'lyh543' is not defined 常量对基本数据类型，Python 没有常量。 习惯上，使用全大写命名来指代常量。 流程控制条件判断（if）if 中没有括号，判断条件后要加:。 貌似需要加缩进之前，前一个语句都需要加 :。这是个规律吧。 1234age = 20if age &gt;= 18: print('your age is', age) print('adult') if 后还可以加 else，elif。 1234elif age &lt; 0: print('input error')else: print('teenage') “三目运算符”C / Java 中有很好用的三目运算符： 1printf(\"%s\", value == true ? \"Yes\" : \"No\"); Python 没有三目运算符，但是 if 也可以用一行做到类似的功能： 1print(\"Yes\" if value == True else \"No\") 循环不精准的测试了一下，在我的 i7-6600U 下，以下代码大概要 10s： 123456n = 0sum = 0while n &lt; 1e7: sum += n n += 1print(sum) 可以粗略得出，python 的整数加法计算次数约为 1e6 左右，为 C++ 的 1/1000。（C++ 相关测试可见我的另一篇博客：C++ 基本计算的速度）。这只是一个没有感情的测试，不存在说 Python 慢就是垃圾的意思 for … in …在 list 用 for类似于 C++ 的 for(int : vector&lt;int&gt;)，Python 可以使用 for &lt;variable&gt; in &lt;list/tuple&gt;： 123names = ['Michael', 'Bob', 'Tracy']for name in names: print(name) 用 range 生成序列而如果是整数等差序列，可以使用 range(start, stop[, step]) 函数，然后转为 list。[start, stop) 左闭右开。左闭右开可以按 C++ 常用的 for (i = start; i &lt; stop; i += step) 来记。 如果是倒序的话，只要令 step 为负数即可。依旧是 start 闭，end 开（即 for (i = start; i &gt; stop; i += step)） 以下四种语法等价。 1234list(range(5))list(range(0,5))list(range(0,5,1))[0, 1, 2, 3, 4] 就可以愉快的 for i in list(range(5)): 了。 顺便一提，range 可以类型转换为 list。 在其他数据结构用 forstr，dict也是可迭代的。默认情况下，dict 迭代的是 key，但也可以迭代 key 和 value。 1234d = &#123;'a': 1, 'b': 2, 'c': 3&#125;for k in d:for v in d.values():for k, v in d.items(): 判断某对象是否可迭代，可使用 Iterable 类型。 12from collections import Iterableisinstance('abc', Iterable) # return true 如果想要实现下标循环，可以用 emumerate() 把 list 变为 索引-元素对。 1for i, v in enumerate(['A', 'B', 'C']): 同时引用两个变量是很常见的。 1for x, y in [(1, 1), (2, 4), (3, 9)]: while和 if 一样。 123456sum = 0i = 0while i &lt;= 100: sum += i i += 1print(sum) break 和 continue和 C 语言一样。 12345678n = 0while n &lt; 10: n = n + 1 if n == 8: break if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 函数调用函数简单，不多说。 123abs(100) # = 100abs(100,1) # TypeError: abs() takes exactly one argument (2 given)abs('abc') # TypeError: bad operand type for abs(): 'str' 定义函数函数前写 def，后面全部缩进。 12345def my_abs(x): if x &gt;= 0: return x else: return -x 如果函数保存在 abstest.py 中，需要使用 from ... import ... 来引入函数。 1from abstest import my_abs import 的更复杂用法会在模块一节中详细介绍。 空函数 pass如果函数定义留空会报错，此时可以使用 pass 来占位。（pass 和 return 是不一样滴！！！） 12def nop(): pass 在条件分支中也可以使用 pass： 12if age &gt;= 18: pass 函数类型检查Python 解释器只进行参数个数的检查，不进行参数类型的检查。需要自己使用 isinstance(variable, tuple of type) 手动检查。 注意 isinstance() 中 int 和 float 是不一样的（本来也是，str float int 之间随便转，他们也不是一个东西）。 1234def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') pass 还用到了 raise 返回错误。要多练习一下。 函数练习给定 $a,b,c$，解一元二次方程$ ax^2 + bx + c = 0$： 12345678910111213141516import mathdef isnum(x): return isinstance(x,(int,float))def quadratic(a, b, c): if not (isnum(a) or isnum(b) or isnum(c)): raise TypeError delta = b * b - 4 * a * c if (delta &lt; 0): print('delta &lt; 0, no real root') pass sqrt_delta = math.sqrt(delta) return (-b+sqrt_delta)/2, (-b-sqrt_delta)/2print(quadratic(1,1,1)); 函数参数其中 3.-5. 有点硬核，先不管。用到再学。 1. 必选参数即最普通的用法。 1234def pow(x, n): passpow(3, 2) 2. 默认参数和 C++ 一样，Python 也有默认参数。 1234def pow(x, n = 2): passpow(3) 声明参数时必选参数在前，默认参数在后，否则会导致编译错误。 调用函数时，默认参数可以不写，也可以按顺序给出。如无法按顺序给出（第一个默认参数为默认，但第二个不默认），可以指明变量名。 1enroll('Adam', 'M', city='Tianjin') 坑默认参数要指向不变对象！！ 如： 123456def add_end(L = []): L.append('END') return Ladd_end() # return ['END']add_end() # return ['END', 'END'] 究其本质，还是 [] 只是一个指针。 用 add_end(L = None) 即可解决。 12345678def add_end(L = None): if L is None L = [] L.append('END') return Ladd_end() # return ['END']add_end() # return ['END'] 3. 可变参数如果不使用可变参数，传入 list 或 tuple 时就需要先组装。 12345678def calc(numbers): sum = 0 for n in numbers: sum += n * n return sumcalc([1,2,3]) # = 14calc((4,5,6)) # = 77 如果使用可变参数，就不用组装了，也可以调用 0 个参数。在变量名前面加 * 即是可变参数。而调用 list 或 tuple 时也可以加一个 *。 123456def calc(*numbers): # ...calc(1,2,3) # = 14nums = (4,5,6)calc(*nums) # = 77 print() 也是使用这种形式。 4. 关键字参数上面是把所有参数变为 tuple，而这里是把额外的 0 个或 n 个参数变为 dict。 1234567def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)&gt;&gt;&gt; person('Michael', 30)name: Michael age: 30 other: &#123;&#125;&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125; 这有什么用呢？比如，在 person 函数里，我们保证能接收到 name 和 age 这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 123&gt;&gt;&gt; extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, **extra)name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; 而传 dict 进去也是，加 ** 就可以了。 但是请注意，这种用法中，不管是传很多组，还是直接传 dict，Keywords 必须为 string 名。诸如 1=one，&#39;one&#39;=1 都不能作为关键词参数传进函数。而传进去的 Keywords，会加引号。 5. 命名关键字参数关键字参数中，对参数名没有直接限制；如果需要限制名字，可以使用命名关键字参数。 12def person(name, age, *, city, job): print(name, age, city, job) 这样，我们只接受 city 和 job，其他参数会被忽略。 参数组合Python 定义函数，可以按顺序组合使用 必选参数、默认参数（y=1）、可变参数（*kw，组成 tuple）、命名关键字参数（*,x,y）、关键字参数（**kw，组成 dict）。 但是不要使用太多的组合否则代码就太难理解了。 高级特性这部分和 C 差异有点大，因此先水过去，等用到的时候再看。 切片 slice现在有一个 list L = list(range(20))。使用切片可以快速得到其子序列。 使用 L[begin:end] 可以得到 L 下标在 [begin, end) 范围内的数据。注意： begin 和 end 可以按规定使用负数。 begin 和 end 可以省略，缺省值为 begin = 0， end = 末尾下标+1。 若 end &gt; begin，则返回空 list []。 slice 也可以使用于 tuple，str 等支持切片的功能。 另外还可以用 L[start:end:step] 指定 step 大小。每隔五个取一个就是 arr[::5]。 123&gt;&gt;&gt; a=list(range(100))&gt;&gt;&gt; a[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] del 语句list 自带了 append 和 insert，分别是在 list 最后追加元素、在中间插入元素。也可以使用 del 删除元素。 12345678910&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a[1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[2:4]&gt;&gt;&gt; a[1, 66.25, 1234.5]&gt;&gt;&gt; del a[:]&gt;&gt;&gt; a[] 迭代 iteration其实就是前面讲了的 for … in … 语法。 列表生成式这个东西可以把 list（或可迭代的数据类型）中的元素通过自定义的映射函数生成新的 list 或 tuple。还可以配合 if、两层 for。 1234&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 另外还可以使用两个变量。 123&gt;&gt;&gt; d = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125;&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]['y=B', 'x=A', 'z=C'] 生成器 generator列表生成式是新建一个链表，而生成器是保存映射关系，需要时再进行计算。 第一种方法用法仅仅把列表生成式的 [] 改为 ()。 123&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 我们可以反复使用 next() 获得 generator 的下一个返回值。 123456789101112131415161718192021222324&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)25&gt;&gt;&gt; next(g)36&gt;&gt;&gt; next(g)49&gt;&gt;&gt; next(g)64&gt;&gt;&gt; next(g)81&gt;&gt;&gt; next(g)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;StopIteration 当然可以使用 for 循环。 第二种方法：yield输出 Fibonacci 数的前 max 位，可以使用一个函数： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return 'done' 上述程序会一次性计算完前 max 位。 把上面的程序改为 generator。 学不会学不会，感觉也不常用。留个坑吧。 https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128 函数式编程函数式编程就不仅仅是单纯的函数体、调用函数了了，还有更多的东西，比如类似于 C/C++ 函数指针的功能等等。 将函数赋给变量其实就是将函数指针赋给了变量。 12345678&gt;&gt;&gt; abs(-10)10&gt;&gt;&gt; f=abs&gt;&gt;&gt; f(10)10&gt;&gt;&gt; f&lt;built-in function abs&gt; 理所应当地，也可以把函数作为函数的参数。 123def add(x, y, f): return f(x) + f(y)print(add(5, -6, abs)) # 输出 11 下面是一些应用：map、reduce、filter、sorted。 mappython 的 map 其实类似于对一个 list/tuple 的每个元素使用函数 f，得到一个新的 list（实际上是把 map 类型转换为了 list），具体操作如下： 123&gt;&gt;&gt; r = map(f,list(range(10)))&gt;&gt;&gt; list(r)[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 显然该操作也可以使用循环，但是 python 追求的就是极致的简洁。 reduce reduce() 函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 –Python reduce() 函数| 菜鸟教程 reduce 和 map 一样，也接受两个参数，第一个是 f(x,y)，第二个是一个 list/tuple，作用类似于叠加： 1234567&gt;&gt;&gt; def f(x,y):... return x + y...&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; r = reduce(f,[1,2,3,4,5]);&gt;&gt;&gt; r15 也可以尝试手写一个将存有 digit 的 list 转为 int： 123456from functools import reducedef fn(x, y): return x * 10 + yprint(reduce(fn, [1, 2, 3, 5, 8, 3])) # 输出123583 函数式编程练习使用 reduce 和 map 手写一个 str2int 函数，将字符串转为整数。 这也说明，字符串可以当做字符的 list 来用。 123456789101112def str2int(_str): from functools import reduce def char2digit(x): return ord(x)-ord('0') def fn(x, y): return x * 10 + y return reduce(fn, map(char2digit, _str))print(str2int(\"123\") + 321) filter这个函数有两个参数，第一个是返回 True 或 False 的函数 f，第二个是一个 list。 filter 函数返回 list 中 f(x) 为真的所有 x。 12345def is_odd(n): return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果: [1, 5, 9, 15] sortedsorted 函数返回原 list/tuple 被排序以后的 list/tuple（而不是直接在 list/tuple 上修改）。 123&gt;&gt;&gt; arr=[3,1,8,4,5]&gt;&gt;&gt; sorted(arr)[1, 3, 4, 5, 8] 可以用一个函数作为 key 参数指定排序的依据。可以用 Reverse=True 参数使降序排列。 注意这个函数不是类似于 C++ sort 所需的返回两个元素的大小的 bool 值，而是返回一个元素的大小，如可使用 abs 函数： 12345&gt;&gt;&gt; '-'.join(['a', 'b', 'c'])'a-b-c'&gt;&gt;&gt; arr2=[-4, -2, 1, 3, 5]&gt;&gt;&gt; sorted(arr2, key=abs)[1, -2, 3, -4, 5] 对字符串 list 可以直接以字典序排序： 123&gt;&gt;&gt; arr3=['banana', 'anana', 'nana', 'ana', 'na', 'a']&gt;&gt;&gt; sorted(arr3)['a', 'ana', 'anana', 'banana', 'na', 'nana'] 注意在 Python 中，Z&lt;a，如果想要忽略大小写，可以把 key 设定为 str.tolower 函数。 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 函数作为返回值我们可以在函数内部创建一个函数（又名嵌套函数），然后返回。刚看到这里，说实话不知道这个有什么意义。 1234567def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 12345&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;&gt;&gt;&gt; f()25 多次调用 lazy_sum 时，会在不同位置创建多个函数，虽然他们本质是一样的。 1234&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f1==f2False 对于输入或输出是函数的函数，我们称为这种函数叫高阶函数。 闭包 closure廖雪峰的博客这一部分讲的有点糙，没看懂。后来又去看了 知乎，大概懂了。 首先说一句，CS 的闭包和数学的闭包完全没有关系！参考：https://www.zhihu.com/question/20504785，有人提到 SICP里第二章注释6 The use of the word “closure” here comes from abstract algebra, where a set of elements is said to be closed under an operation if applying the operation to elements in the set produces an element that is again an element of the set. The Lisp community also (unfortunately) uses the word “closure” to describe a totally unrelated concept: A closure is an implementation technique for representing procedures with free variables. 上面这个 unfortunately 笑死我了。 在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。 这段说的很对但是对于萌新来说可能讲的不像是人话 轮子哥 1234567891011def adder(x): def wrapper(y): return x + y return wrappertemp = 5adder5 = adder(temp)del tempadder5(10) # 输出 15adder5(6) # 输出 11 第二次还是没大看懂，以后再来看吧。 lambda 函数lambda 函数就是匿名函数。一般用于函数比较简短的情况。 12345def is_odd(x): return x % 2 == 1L=range(10)print(list(filter(is_odd, L))) # 输出 [1, 3, 5, 7, 9] 对于这个简短的的 is_odd 函数，写了不仅让代码多了两行（不考虑那种按代码行数计算工资的程序员），还多占用了一个 is_odd 名字。其实我们完全可以用匿名函数来解决： 12L=range(10)print(list(filter(lambda x : x % 2 == 1, L))) # 输出 [1, 3, 5, 7, 9] 也就是说，lambda x : x % 2 == 1 这是一个函数，完全等价于我们在第一段函数定义的 is_odd(x)。 当然，当 lambda 函数变复杂时，还是推荐使用 is_odd(x) 这样的常规函数。 装饰器 decorator装饰器是什么？在调试程序的时候，可能需要在函数的前后输出相关信息。此时，我们就可以对函数进行“装饰”，使得运行该函数时，会输出相关信息。 那么，如何实现呢？我们定义一个 wrapper 函数，他做的事情是在某函数开始时输出、在函数结束时再输出。 如果我们还想要写一个通用 wrapper 函数对于所有函数都生效，那么 wrapper 执行的函数应该作为一个参数。作为谁的参数呢？ 在 Python 的装饰器里，我们定义一个 wrapper 函数，其输入、输出和 func 完全一致，这个函数做的事，就是调用 func 函数，并在调用 func 前后做一些事情（输出、计时等等）。 而指定 func 的办法，是我们再定义一个 log 函数，这个函数输入 func，这个函数的操作是定义并返回调用了 func 的 wrapper。说了这么多大概晕了，那么直接上代码吧。 1234567891011def log(func): def wrapper(*args, **kw): print('starting executing function %s' % func.__name__) start_time = time.time() value = func(*args, **kw) end_time = time.time() print('function %s end in %d seconds' % (func.__name__, start_time - end_time)) return value return wrapper 有了上面的代码，我们可以在需要装饰的函数前（示例为 test）加上 @log。 1234@logdef test(x, y): time.sleep(2) return x + y 先不说 @log 的原理，我们先来调用一下 test 函数。把上面的两段代码整合在一起，然后调用 test。 123456789101112131415161718def log(func): def wrapper(*args, **kw): print('starting executing function %s' % func.__name__) start_time = time.time() value = func(*args, **kw) end_time = time.time() print('function %s end in %d seconds' % (func.__name__, end_time - start_time)) return value return wrapper@logdef test(x, y): time.sleep(2) return x + yprint(test(12,138)) 输出如下 123starting executing function testfunction test end in 2 seconds150 如果把 @log 去掉，那么程序只会输出 150。也就是说，我们成功地在 test 执行前后进行了计时、输出。 再回来说 @log 的原理：在定义 test 函数前加 @log，程序会在 test 定义完以后，执行 test=log(test)。配合 log 函数的定义就能做到前面所述的效果。具体过程如下： 定义原 test 把 test 作为参数给 log。 log 创造了 wrapper(*args, **kw) 函数，该 wrapper 函数执行 test(*args, **kw) 并返回 test 的返回值 test=log(test)。将创造的 wrapper 函数改名为 test。 以后调用 test，执行的实际上是在 log(test) 中定义的 wrapper。 大致原理如上。 但是还有一点问题，在以后我们调用 test.__name__ 时，由于此时的 test 实际上是 wrapper，所以返回就有点问题。 解决方法可以在 wrapper 定义中加一句 wrapper.__name__ = func.__name__。但是推荐直接调用 Python 自带的装饰器。 12345678910111213import functoolsdef log(func): @functools.wraps(func) def wrapper(*args, **kw): print('starting executing function %s' % func.__name__) start_time = time.time() value = func(*args, **kw) end_time = time.time() print('function %s end in %d seconds' % (func.__name__, start_time - end_time)) return value return wrapper 完整代码如下： 1234567891011121314151617181920212223import timeimport functoolsdef log(func): @functools.wraps(func) def wrapper(*args, **kw): print('starting executing function %s' % func.__name__) start_time = time.time() value = func(*args, **kw) end_time = time.time() print('function %s end in %d seconds' % (func.__name__, end_time - start_time)) return value return wrapper@logdef test(x, y): time.sleep(2) return x + yf = test(11, 22)print(f)print(test.__name__) 在面向对象（OOP）的设计模式中，decorator 被称为装饰模式。OOP 的装饰模式需要通过继承和组合来实现，而 Python 除了能支持 OOP 的 decorator 外，直接从语法层次支持 decorator。Python 的 decorator 可以用函数实现，也可以用类实现。decorator 可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。—— 廖雪峰的 Python 教程 模块在 Python 中，一个 .py 文件就称之为一个模块（Module）。 12import sysimport numpy as np 按第一行导入 sys 模块后，我们就有了变量 sys 指向该模块，利用访问 sys 这个变量的成员（如 sys.argv），就可以访问 sys 模块的所有功能。也可以使用别的变量名，比如后面一句，就用 np 指向了 numpy。 顺便，在 Python 环境中（即 &gt;&gt;&gt; 中）貌似没法直接运行脚本，如果需要调用脚本中的函数，应该当做模块一样，import filename 然后 filename.function_name() 来调用。 虚拟环境和包参考 应用程序有时需要特定版本的库，因此某些时候不能安装最新的包，甚至不同应用程序需要不同的 Python 安装程序。 因此，可以建立多个 Python 虚拟环境，每个虚拟环境用一套软件。 建立虚拟环境并激活的方法如下： 123python3 -m venv tutorial-env # 建立虚拟环境tutorial-env\\Scripts\\activate.bat # 激活虚拟环境 Windows# source tutorial-env/bin/activate # Linux, Mac 将该环境下安装的包导出为 requirements.txt、从导出文件建立环境； 12freeze &gt; requirements.txt # 导出为 requirements.txtpip install -r requirements.txt # 从 requirements.txt 导入 面向对象编程见 Python 面向对象编程。","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"编程语言入门","slug":"编程语言入门","permalink":"https://blog.lyh543.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"}]},{"title":"从网易云音乐获得 lrc 格式歌词","date":"2020-02-13T05:54:52.000Z","path":"others/get-lrc-lyrics-from-netease-cloudmusic/","text":"最近喜欢听各种冷门歌手的翻唱曲，经常遇到没有歌词的情况。由于是翻唱，理论上把原曲的 lrc 文件搬运过去提交就行了，但是，网易云貌似不提供 lrc 歌词的下载。 实际上，网易云音乐的歌词存储格式是类似于 lrc 的，只需要一定转换。 需要网易云音乐 PC / Android / UWP 客户端。 这里我们用《别看我只是一只羊》作为示范。（你问我为什么用这首？看我头像） 测试版本：网易云音乐 PC 版本 2.7.1网易云音乐安卓版 7.0.10网易云音乐 UWP 版早期是支持的，最近没有使用，应该也是支持的iOS 可能是不支持的，Mac OS X 可能支持，但由于没有设备，没有进行测试 找到歌曲 id我们要从歌曲的分享链接找到歌曲的 id。客户端通过分享链接/直接从网页复制音乐链接均可。 1http://music.163.com/song?id=5242612&amp;userid=xxxxxxxxx 不同客户端、不同版本获取的链接可能不同，但 songid 都是比较明显的。（这里我把个人的 userid 略去了） 于是我们得到这首歌的 songid 为 5242612。 得到原始歌词文件 注意：网易云 PC 7.2.1 必须要下载歌曲才可以获得歌词文件。可采用 Android 或 UWP 客户端。UWP 版本因很久没有使用过了，文件夹可能变化。 接下来，我们需要得到原始歌曲文件。我们在客户端播放这首歌，等其加载完歌词。（有的客户端可能需要下载歌曲才能获得歌词） 然后，我们找到网易云缓存歌词的文件夹： PC 7.2.1 版为：%USERPROFILE%\\AppData\\Local\\Netease\\CloudMusic\\webdata\\lyric，直接复制到地址栏即可。UWP 版（可能）为：%USERPROFILE%\\AppData\\Local\\Packages\\1F8B0F94.122165AE053F_j2p0p5q0044a6。Android 版（缓存歌词文件夹）为：内部存储器/netease/cloudmusic/Cache/Lyric。Android 版（已下载歌曲的歌词文件夹）为：内部存储器/netease/cloudmusic/Download/Lyric。 文件夹里为以 songid （无后缀） 命名的歌词文件。以 songid 5242612 搜索到该歌词文件（也可以在 cloudmusic 文件夹就直接搜索了）。 处理为 lrc 文件用文本编辑器打开该文件，即可看到类似于 lrc 格式的歌词。但是 lrc 歌词的换行全部被替换为了 \\n，需要替换回来。 可以进行手动替换，或者使用别的文本编辑器。这里我们使用 Windows 下的 notepad++。原文件如下： 1&#123;\"briefDesc\":\"\",\"kalaokLyric\":\"\",\"kalaokVersion\":0,\"lyric\":\"[by:RisingTank]\\n[by:E-Lyric]\\n[offset:-100]\\n[00:10.28][01:25.09][02:28.25]喜羊羊\\n[00:11.34][01:26.29][02:29.12]美羊羊\\n[00:12.38][01:27.10][02:30.11]懒羊羊\\n[00:13.26][01:28.01][02:30.99]沸羊羊\\n[00:14.37][01:29.22][02:32.09]慢羊羊\\n[00:15.40][01:30.13][02:33.10]软绵绵\\n[00:16.42][01:31.17][02:34.12]红太狼\\n[00:17.15][01:31.79][02:34.98]灰太狼\\n[00:18.43][00:50.75][01:24.10][01:33.28]\\n[00:20.36][00:35.91][01:35.16]别看我只是一只羊\\n[00:24.16][01:39.10]绿草因为我变的更香\\n[00:27.62][01:42.91]天空因为我变的更蓝\\n[00:32.05][01:46.72]白云因为我变的柔软\\n[00:39.76]羊儿的聪明难以想像\\n[00:43.74]天再高心情一样奔放\\n[00:47.75]每天都追赶太阳\\n[00:51.36][01:50.29]有什么难题去牵绊我都不会去心伤\\n[00:55.21][01:54.28]有什么危险在我面前也不会去慌乱\\n[00:59.11][01:58.18]就算有狼群把我追捕也当做游戏一场\\n[01:06.85][02:05.88]在什么时间都爱开心笑容都会飞翔\\n[01:11.02][02:09.94]就算会摔倒站得起来永远不会沮丧\\n[01:14.87][02:13.80]在所有天气拥有叫人大笑的力量\\n[01:21.27][02:20.55]虽然我只是羊\\n[02:36.31]wu da da\\n[02:38.25]wu lu lu\\n[02:38.86]wu wu lu lu\\n[02:40.08]de li de\\n[02:41.03]de da da\\n[02:42.30]de de de de de de de\\n\",\"lyricInfoType\":\"Lyric_Loaded_Or_Update\",\"lyricUserId\":5242612,\"lyricUserName\":\"RisingTank\",\"lyricUserOffset\":-1,\"lyricUserTime\":0,\"lyricVersion\":22,\"musicId\":5242612,\"qfy\":false,\"transUserId\":0,\"transUserTime\":0,\"translateLyric\":\"\",\"translateVersion\":0&#125; 在工具栏上找到替换按钮并单击，打开替换窗口，查找目标设为 \\\\n，替换为设为：\\n，下面的查找模式设为 扩展(\\n, \\r, \\t, \\0, \\x...)，然后点击 全部替换。歌词变为如下： 123456789101112131415161718192021222324252627282930313233&#123;\"briefDesc\":\"\",\"kalaokLyric\":\"\",\"kalaokVersion\":0,\"lyric\":\"[by:RisingTank][by:E-Lyric][offset:-100][00:10.28][01:25.09][02:28.25]喜羊羊[00:11.34][01:26.29][02:29.12]美羊羊[00:12.38][01:27.10][02:30.11]懒羊羊[00:13.26][01:28.01][02:30.99]沸羊羊[00:14.37][01:29.22][02:32.09]慢羊羊[00:15.40][01:30.13][02:33.10]软绵绵[00:16.42][01:31.17][02:34.12]红太狼[00:17.15][01:31.79][02:34.98]灰太狼[00:18.43][00:50.75][01:24.10][01:33.28][00:20.36][00:35.91][01:35.16]别看我只是一只羊[00:24.16][01:39.10]绿草因为我变的更香[00:27.62][01:42.91]天空因为我变的更蓝[00:32.05][01:46.72]白云因为我变的柔软[00:39.76]羊儿的聪明难以想像[00:43.74]天再高心情一样奔放[00:47.75]每天都追赶太阳[00:51.36][01:50.29]有什么难题去牵绊我都不会去心伤[00:55.21][01:54.28]有什么危险在我面前也不会去慌乱[00:59.11][01:58.18]就算有狼群把我追捕也当做游戏一场[01:06.85][02:05.88]在什么时间都爱开心笑容都会飞翔[01:11.02][02:09.94]就算会摔倒站得起来永远不会沮丧[01:14.87][02:13.80]在所有天气拥有叫人大笑的力量[01:21.27][02:20.55]虽然我只是羊[02:36.31]wu da da[02:38.25]wu lu lu[02:38.86]wu wu lu lu[02:40.08]de li de[02:41.03]de da da[02:42.30]de de de de de de de\",\"lyricInfoType\":\"Lyric_Loaded_Or_Update\",\"lyricUserId\":5242612,\"lyricUserName\":\"RisingTank\",\"lyricUserOffset\":-1,\"lyricUserTime\":0,\"lyricVersion\":22,\"musicId\":5242612,\"qfy\":false,\"transUserId\":0,\"transUserTime\":0,\"translateLyric\":\"\",\"translateVersion\":0&#125; 然后我们把lrc 格式的部分（中括号开头的部分）复制，粘贴到另一个文档并另存为 lrc 格式即可。","tags":[]},{"title":"数据结构与算法","date":"2020-02-04T04:59:19.000Z","path":"computer-science/data-structure-and-algorithm/","text":"这是我大二上修的《数据结构与算法》的笔记。 数据结构绪论数据相关术语数据：所有能被计算机识别的符号集合数据元素：是数据（结构）中的一个个体（一个人出生日期的年、月、日）数据项：是数据结构中讨论的最小单位（一个人的出生日期）数据对象：具有相同性质的数据元素的集合（迷宫的每一个点） 数据结构相关术语数据结构：带结构的数据元素的集合。全面的来说，$DS = (E, R, M)$，$E$、$R$、$M$ 分别为数据元素（Element）的集合、数据元素之间关系（Relation）的集合、存储（Memorizaion）数据元素单位的集合。逻辑结构：线性结构、树形结构、图形结构、集合结构。 存储结构：顺序存储、链式存储 操作：查找、插入、删除、遍历、排序…… 数据类型相关术语抽象数据类型（Abstract Data Type, ADT）：$ADT=(E,R,O)$。$O$ 指元素基本操作（Operation）的集合。 ADT 特点：抽象性（把定义和实现分开）、扩展性 算法相关术语算法：解决某一特定问题的具体步骤的描述，是指令的有限序列。 算法是有穷的，通过有限步以后一定能得到输出；程序可以是无穷的，比如操作系统的核心进程，再启动完成后将驻留后台一直运行。 算法的五大基本性质：有穷性、确定性、可行性（能被分解为基本操作）、输入、输出。 算法设计的一般规则：正确性、可读性、健壮性（鲁棒性）、高效率和低存储量。 线性结构及其查找和排序线性表相关术语线性表下标从 1 开始。 头元素、尾元素；前驱、后继、（直接）前驱、（直接）后继； KMP （坑）老师讲的 next[j] 指 p[0...j-1] s的（不包含自己）的 border 的长度。如： p[j] a b a a c a b a a next[j] -1 0 0 1 1 0 1 2 3 查找 Search一些概念： ASL：平均查找长度。 静态查找：只做查询 动态查找：查到了删/没查到就插 顺序查找 Linear Search网课的实现是在头插入所查找元素，然后从后往前查找。即带岗哨的顺序查找版本。这样的好处是 if 条件句能少一个条件。 等概率下：$ASL=\\frac{n+1}{2}$；不等概率下：可以把高概率的放在后面。 折半查找 Binary Search需要有序表，并且只使用与顺序存储结构。 11 个数，等概率下：$ASL_{成功} = \\frac{1}{11}(1 \\times 1 + 2 \\times 2 + 4 \\times 3 + 4 \\times 4) = 3$，$ASL_{失败} = \\frac{1}{12}(4 \\times 3 + 8 \\times 4) \\approx 4$ $n&gt;50$ 时，可认为 $ASL \\approx log_2(n+1)-1$。 索引查找 Index Search想一想字典的查找方法：有一个索引。 索引搜索的步骤： 分析数据，建立索引 (1) 对数据进行分块。须保证第 $R_k$ 块所有关键字 &lt; $R_{k+1}$ 块所有关键字（块间有序）。 (2) 然后建立索引线性表，每项存储了每块的首地址和最大关键字 （注意最后一块后面也要存一个结束的查找表结束的地址，方便判断查找失败） 查找 (1) 索引表的查找（顺序或二分） (2) 查找表的查找（顺序或二分） $\\begin{split}\\qquad ASL &amp;= L_b+L_s \\\\&amp;= \\frac{1}{b}\\sum_{j=1}^b j + \\frac{1}{s}\\sum_{i=1}^s i \\\\&amp;= \\frac{1}{2}(\\frac{n}{s}+s)+1\\end{split}$ 哈希查找 Hash Search哈希函数即是一个将任意一个东西映射到 $[0, n-1]$ 的整数区间上的一个函数。常用的映射规则有直接（对于整数）对 n 取模、（对于字符串）把字符串看做一个 26（或 32，加速乘法）进制的数，按转换为 10 进制的方法，转为数以后取模。 哈希查找即是把元素映射到 $[0, n]$ 后，把元素放在线性表对应下标的内存中，查找时，计算哈希函数，然后在对应内存的地方找。一般 $n$ 的选择是质数。 哈希函数是密码学相关的，所以这门课程没有讨论太多相关的内容，更多讨论的是哈希表解决冲突的方法。 定义装填因子为要存的元素个数/哈希表空间能存的元素个数。 $a = \\frac {L.length()}{n}$ 显然，装填因子小，冲突的可能性会变小。 做题时，给定 $a$，若计算的 $n$ 不是整数，应向上取整（保证 $a$ 变小）。 解决冲突的方法有： 线性探测再散列（即存入数据时，如果发生冲突，则尝试将数据存入后 $d_1=1$ 个位子，如下标超出 n 则模 n。仍然冲突，则尝试存入原数据后 $d_2=2$ 个位子……直至数据被存下） 平方探测再散列（${d_i} = {1^2, -1^2, 2^2, -2^2, …}$） 随机数探测再散列（${d_i} = {7, 14, 21,…}$） 链地址法（在哈希表的每一个内存外接链表） 常用方法 1 和 4。也有双哈希（即选择两个模数，然后建立两个一位数组作为哈希表，查找时若两表都查到了，就认为查找成功）等方法。 ASL 的计算需要计算每个数的查找次数（或冲突次数+1）。若查找失败，需要按 $d_i$ 一直找，直到该内存没有数据。 另外，删除数据时，需要注意，不能将该格还原为初始状态（如标记为 -1），否则某些后面的冲突项也会被忽略。正确的是，进行特殊标记（如标记为 -2）。 排序 Sort排序的稳定性如果排序过程中，相同的数字的相对顺序可能变化，则称这个排序是不稳定的。 如快排，对于序列 $(3, \\underline{3}, 2)$，排序以后是 $(2, \\underline{3}, 3)$，两个 3 的相对位置，因此快排是不稳定的。 稳定的好处：一是交换的过程不会很混乱，在前面的依旧在前面；二是可以应用于基数排序；三是（感觉上）减少了交换的次数（因为两个一样大的数，把后面的数放到前面去，感觉做了无用功；实际也是稳定的更优秀）。 稳定的排序有：简单插入、冒泡排序、归并排序 不稳定的排序有：希尔排序、简单选择、快速排序 简单插入排序 Simple Insertion Sort就是第 $i$ 趟保证前 $i$ 个数之间有序；为此，每次把第 $i$ 个元素插入到前 $i-1$ 个元素之间（慢在插入的过程需要移位）。如下序列跑三趟的结果是： 4 2 1 32 4 1 31 2 4 31 2 3 4 一般会使用第 0 位作为岗哨。 简单插入排序简单好写，并且在基本有序的表上表现很好：在有序表上只需要 $n-1$ 次比较和 0 次交换数据。交换数据的次数完全等于逆序对的个数。 希尔排序 Shell Sort希尔排序是改进的简单插入排序。他将数据进行分组，然后进行排序，再把小组合为大组继续排序，以此类推。 如果把数据按分块的方式进行分组，对复杂度影响其实不大；有意思的是，如果是隔几个数分为一组（如123123123……），就会有神奇的效果：一趟排序完成以后，每组基本都是有序的，整体来看也是小的在前，大的在后，这样，每趟就是基本有序的插入排序了，复杂度接近 $O(n)$。平均复杂度就得到了降低。 然而，希尔排序的最坏复杂度可以为 $\\Theta(n^2)$，如构造以下数列： 11 9 2 10 3 11 4 12 5 13 6 14 7 15 8 16 按间隔 $d_i=\\{8,4,2,1\\}$ 的话，前三趟做的都是无用功，最后一趟实际等同于简单插入排序，复杂度为 $\\Theta(n^2)$。（实际上 $\\{8,2,4,1\\}$ 就是 Shell 本人提出的序列） 上述的原因是，增量间不互质，于是小的增量可能没有效果。 接下来，就是讨论希尔排序的增量序列（和哈希函数一样，想在一个核心上做文章，取得整体的复杂度的改善）。 在说序列之前，贴一份希尔排序的参考代码（也可下载 sort.cpp） 123456789101112131415161718192021222324252627282930313233343536//简单插入排序，但是带有 dist 参数，可以被希尔排序调用template &lt;class T&gt;void simple_insertion_sort(vector&lt;T&gt;&amp; Arr, int l, int r, int dist)&#123; for (int i = l; i &lt; r; i += dist) //现在开始移动原来位置为 i 的元素 &#123; for (int j = i; j - dist &gt;= l; j -= dist) &#123; if (Arr[j - dist] &gt; Arr[j]) swap(Arr[j - dist], Arr[j]); else break; &#125; &#125;&#125;//希尔排序template &lt;class T&gt;void shell_sort(vector&lt;T&gt;&amp; Arr, int l, int r)&#123; //希尔序列选择 Hibbard 序列 2^i-1 vector&lt;int&gt; distArr; for (int i = log2(Arr.size()); i &gt;= 1; i--) &#123; distArr.push_back((1 &lt;&lt; i) - 1); &#125; for (int i = 0; i &lt; distArr.size(); i++) &#123; int dist = distArr[i]; for (int j = 0; j &lt; dist; j++) &#123; simple_insertion_sort(Arr, j, r, dist); &#125; &#125;&#125; 各种增量序列（了解）此后，很多数学大牛都来提出了自己的序列。可参考英文维基百科。 希尔伯特（Hibbard）核心：增量序列 $h_k=2^k-1$。其最坏复杂度为 $\\Theta(n^\\frac{3}{2})$，平均复杂度为 $O(n^\\frac{5}{4})$。 目前最新提出的有理论复杂度证明的是 1986 年提出的 Sedwick 序列，他的前几项为 $\\{1, 5, 19, 41, 109, …\\}$。其递推式在很多国内网站都是错的，正确的如下： ${\\begin{cases}9\\left(2^{k}-2^{\\frac {k}{2}}\\right)+1 &amp; k{\\text{is even}} \\\\8\\cdot 2^{k}-6\\cdot 2^{(k+1)/2}+1 &amp; k{\\text{is odd}}\\end{cases}}$ 按该数列进行希尔排序的最坏复杂度为 $O(n^\\frac{3}{4})$，平均复杂度为 $O(n^\\frac{7}{6})$。 这么看来希尔排序也不差，$O(n^\\frac{7}{6})$ 的复杂度在小数据范围内基本可以和 $O(n \\log n)$ 抗衡了（在 $n &lt; 6 \\times 10 ^ 8$ 下，$O(n^\\frac{7}{6}) &lt; O(n \\log_2n)$）。 更新的几个研究成果都是给出了数列和递推式，但是没有给出理论最坏复杂度，大概是没有理论推进的，但是实测表现良好的方法吧。 简单选择排序 Selection Sort就是扫一遍得到最小的数的下标，与 $a_0$ 交换；再扫一遍得到第二小的数的下标，与 $a_1$ 交换。与冒泡不同的是，他每趟只交换一次数据。 4 2 1 31 2 4 31 2 4 31 2 3 4 简单选择也可以选最大的数的下标。 冒泡排序 Bubble Sort最形象的算法之一。目的和简单选择一样：每次把没处理的序列的最小者放到最前面（或最大的放到最后面）。但是他的实现是多次交换。 注意，冒泡有两个优化（以下针对“每次把最大的放到最后”的算法）： 算法结束条件改为当前一趟没有交换任何数据。这样，对于有序表，进行 n-1 次比较即可完成排序。 算法需要指定冒泡的最后一个位置 m for(int m = n; m &gt; 0; m--)。但是并不是每个 m 的值都需要执行循环。要是这一趟的交换只交换到了 k(k&lt;n)，下一次可令 m=k-1; 即跳过很多趟无用功。可以看到优化 2 是包含了优化 1 的。 优化后的算法如下： 1234567891011121314151617void BubbleSort(Elem R[]，int n)&#123; m=n; while(m&gt;1) &#123; lastExchangelndex=1; for(j=1;j&lt;m;j++) &#123; if（R[j].key&gt;R[j+1].key) &#123; Swap（R[j]，R[j+1]); lastExchangelndex=j;/*记下进行交换的记录位置*/ &#125; &#125; m=lastExchangelndex;/*本趟最后一次交换的位置*/ &#125;&#125; 简单选择排序和冒泡排序的每趟结果应该是一样的吧。 快速排序 Quick Sort快速排序思想就不说了，网上有很多。 空间的支出主要是递归的栈消耗，空间复杂度最好情况是 $O(logn)$ 的，最坏（若原数组基本有序）是 $O(n)$ 的。时间复杂度最好情况是 $O(nlogn)$ 的，最坏是 $O(n^2)$ 的。 选择枢纽也非常重要， 如果选择 a[0] 为枢纽，原数组基本有序，则是 $O(n^2)$ 的复杂度； 可以使用 a[rand()] 为枢纽。但是 rand() 比较慢； 还可以使用三者取中法：取a[0]、a[n]、a[mid] 的中间值作为枢纽。一般采用这种。 快速排序是不稳定的。 我写的超级丑的代码（完整代码可下载 sort.cpp）： 1234567891011121314151617181920void quick_sort(vector&lt;int&gt;&amp; Arr, int l, int r)&#123; if (r &lt;= l + 1) return; int pivot = Arr[l]; int i = l + 1, j = r - 1; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; Arr[i] &lt;= pivot) i++; while (i &lt; j &amp;&amp; Arr[j] &gt;= pivot) j--; swap(Arr[i], Arr[j]); &#125; if (Arr[i] &lt;= pivot) i++; swap(Arr[i - 1ll], Arr[l]); //要让 pivot 即 Arr[l] 与一个小于他的数交换，于是需要判断 Arr[i] 是大于它还是小于它 quick_sort(Arr, l, i - 1); quick_sort(Arr, i, r);&#125; 如果每次 pivot 取第一个，而数组原本有序，会进行 $O(n^2)$ 次比较和 0 次交换。 枢纽取 l，r，(l+r)/2 位元素的中间大小者，可以优化约 5%。 归并排序 Merge Sort归并排序是先分解、递归，再进行排序、合并。 归并排序分为 二路归并排序，和多路（k 路）归并排序。 空间主要消耗在新建的数组，复杂度是 $O(n)$ 的。 时间复杂度是 $O(nlogn)$ 的。 归并排序是稳定的。 二路归并的参考代码（完整代码可下载 sort.cpp）： 1234567891011121314151617181920212223242526272829303132333435363738template &lt;class T&gt;void merge_sort(vector&lt;T&gt;&amp; Arr, int l, int r)&#123; if (l + 1 &gt;= r) return; int mid = (l + r) / 2; merge_sort(Arr, l, mid); merge_sort(Arr, mid, r); vector&lt;T&gt; tempArr; for (int i = l; i &lt; mid; i++) &#123; tempArr.push_back(Arr[i]); &#125; int i = 0, j = mid, cur = l; while (i != tempArr.size() &amp;&amp; j != r) &#123; assert(cur &lt; r); if (tempArr[i] &gt;= Arr[j]) &#123; Arr[cur] = Arr[j]; cur++, j++; &#125; else &#123; Arr[cur] = tempArr[i]; cur++, i++; &#125; &#125; while (i != tempArr.size()) &#123; Arr[cur] = tempArr[i]; cur++, i++; &#125; assert(cur &lt;= r); return;&#125; 基数排序基数排序就是多关键字（如 n 进制的第一位、第二位、第三位）排序的一个方法：定好按哪个进行排序，然后就只按照这个关键字排序。 基数排序分为高位优先排序和低位优先排序。 高位优先排序非常直观，先把所有元素按高位排序，然后再把相同高位的元素按次高位排序……以此类推。但是，高位优先排序的问题是麻烦：第一趟按把所有元素进行排序，第二趟按次高位排序时，需要确定高位相同的每一段的范围。 反而，按低位优先排序会有神奇的特效： 第一趟按最低位对所有数进行排序， 第二趟按次低位对所有数进行排序， … 最后一趟按最高位对所有数进行排序。 只要上述的每一趟排序使用的是稳定的排序方法，排完高位以后，相同高位的元素的低位也是有序的。 外部排序以上学的几种方法都是直接在内存中进行操作的内部排序。 而当数据量太大，无法全部从磁盘读入内存时，就只能把部分数据读入内存，多趟排序，这便是外部排序。 由于 I/O 的速度非常慢，外部排序中，我们主要考虑的是如何减少存储器的读写。归并排序就很适合外排序，因为他只需要访问被归并序列中的第一个元素。 外部排序的两个阶段： 预处理：根据内存大小读取文件记录入内存，用内排序算法排序形成有序片段； 归并排序（二路、多路、多阶段）：将有序片段归并为一个有序文件。 下面的例子是以磁带做存储器，因为它的读写过程比较形象。在实际应用中，可以把一个文件看作是一个磁带。 预处理：置换算法置换算法能在只能容纳 p 个记录的内存内生成平均长度为 2p 的已排序片段。 事实上，只要第一个元素被写入到输出磁带上，他用的内存空间就可以给别的元素使用。当然，这样的前提是，输入磁带的下一个元素比刚输出的元素大。 可以使用优先队列实现这个置换算法+内排序过程。 算法中，如果输入的元素小于等于刚输出的元素，则将其加入优先队列；如果大于刚输出的元素，就可以把它放进优先队列的空余位置（刚空出来的位置）。反复执行这个过程直至优先队列大小为 0。此时，空余位置也满了，可以对这些数重新构建优先队列。 归并排序：二路归并 把 A1 的数据预处理得到的片段被轮流写到文件 B1 和 B2 上。 然后每次在 B1，B2 磁带上各取一个有序片段，进行二路归并，第一次写到 A1，第二次写到 A2，第三次写到 A1…… 下次交换 A1，A2 和 B1，B2 的地位，每次在 A1，A2 磁带上各取一个有序片段，进行二路归并，第一次写到 B1，第二次写到 B2，第三次写到 A3…… 重复步骤 2、3 直至只剩一个有序片段，即所有数据经过排序以后的数据。 归并排序：多路归并多路归并和二路归并的思想基本相同，只有一个细节地方需要处理： 在进行 k 路归并的时候，找到当前 k 路中的最小值，对于二路归并是 $O(1)$ 的复杂度；对于 k 路归并，暴力比较是 $O(k)$ 的复杂度，可以引进优先队列，则每次的复杂度为 $O(\\log k)$。 运用多路归并虽然增加了一个树结构，但是复杂度竟然没有变化（二路归并为 $O(n\\log_2n)$，k 路归并为 $O(n\\log_kn\\log_2k)=O(n\\log_2n)$），还可以减少磁带读写次数。 归并排序：多阶段归并多阶段归并是多路归并的优化版本。 显然，k 路归并需要共 2k 条磁带，而多阶段归并可以仅用 k+1 条磁带实现 k 路归并。 过程有点复杂，虽然思想不是很复杂。就是要充分利用空出来的磁带，进行轮流合并。 如果一开始，每条磁带上的有序数列的数量取斐波那契数列时，多阶段归并会有非常好的效果。 （斐波那契数列在最优化中也有应用，真就从小学学到大学啊） 递归与分治分治的适用情况抄ppt 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质； 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 能否利用分治法完全取决于问题是否具有第三条特征，如果具备了前两条特征，而不具备第三条特征，则可以考虑贪心算法或动态规划。 而第四特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作：重复地解公共的子问题。此时虽然也可用分治法，但一般用动态规划较好。 分治算法的时间复杂度戴波的书是参考《算法导论》写的，该节见另一篇博客。 树和二叉树node 是 结点 不是 节点！！！ 于是一口气把之前写的几十个错别字全改了当然是用的查找与替换改的 树中结点的度数是直接儿子的个数，不是图中度数的定义。数学中就把树二叉树看做从根往叶子结点的有向图，然后讨论的时候点明是出度 二叉树满二叉树（Full Binary Tree，更加严格）一定是完全二叉树（Complete Binary Tree），反之不一定。搞清定义啊 $n_0=n_2+1$ 结点的深度：根结点的深度为 1，往下依次加大。可从字面理解“深度”。树的深度：即是根结点的深度。 存储结构分为： 顺序 链式：又分为二叉链式、三叉链式（指加了一个父结点的指针） 遍历方法： 递归遍历（递归） 先中后序遍历中的先、中、后指的是根结点的访问的次序，左右结点都是先左后右。 先中/后中可以还原子树，貌似给任意两种遍历方式都能指出父子关系。 层次遍历（队列） 非递归遍历 层次遍历的示例代码： 123456789101112131415queue&lt;Node*&gt; q;q.push(root);while(!q.empty())&#123; int sz = q.size(); // 一层一层地遍历，避免分不清层次 for (int i = 0; i &lt; sz; i++) &#123; Node* cur = q.front(); q.pop(); if (cur-&gt;left) q.push(cur-&gt;left); if (cur-&gt;right) q.push(cur-&gt;right); &#125;&#125; 二叉排序树 左&lt;父&lt;右 的二叉树，又叫二叉搜索树 Binary Search Tree。树中不存在相同的元素。 查找、插入都无脑。 删除的时候讨论一下就行，画画图的事情。注意对于待删除结点左右子树结点都存在的情况，有两种做法，分别是让其左子树顶上去和让其右子树顶上去，都可以。 注意二叉排序树复杂度也可能爆炸，原因是没有控制树高为 $\\log n$。下面几种算法就会通过不同的限制，来控制树高。 平衡二叉树（AVL Tree）平衡二叉树是一种二叉排序树，但是其左右结点数会较为平衡，使得树高能控制在 $\\log n$。 课程这里提到的实际上是平衡二叉树的一种——AVL 树。平衡二叉树的实现方法还有红黑树、伸展树、B树（B树不是二叉树，但是树高能控制在 $\\log n$）等。 AVL 控制树高的方法是强制要求 每个结点的左右子树高度差不超过 1。 在插入、删除的时候涉及到了左旋、右旋等。多处需要旋转的时候，是从靠向叶子的地方开始旋转进行平衡。 旋转具体分为 LL（单向左旋）、RR（单向右旋）、LR（先左后右）、RL（先右后左）。下面直接贴 ppt 了。 单向左旋 单向右旋 先左后右 先右后左 还是有一点迷。 Huffman 树 和 Huffman 编码维基百科对 Huffman 编码的定义： 在计算机数据处理中，霍夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现几率的方法得到的，出现几率高的字母使用较短的编码，反之出现几率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。 例如，在英文中，e的出现几率最高，而z的出现概率则最低。当利用霍夫曼编码对一篇英文进行压缩时，e极有可能用一个比特来表示，而z则可能花去25个比特（不是26）。用普通的表示方法时，每个英文字母均占用一个字节，即8个比特。二者相比，e使用了一般编码的1/8的长度，z则使用了3倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。 Huffman 编码的（一种）计算方法是构造 Huffman 树。 维基百科对 Huffman 树的定义： 霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1L1+W2L2+W3L3+…+WnLn），N个权值Wi（i=1,2,…n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,…n）。可以证明霍夫曼树的WPL是最小的。 由定义可以看出，把所有需要编码的源符号作为二叉树的结点，如果构造出的二叉树 WPL 越小，压缩比例就越高。 如何将 Huffman 树转化为 Huffman 编码呢？将 Huffman 树的每个结点的左右孩子命名为 0 和 1（也可以交换），某符号的编码就是从根结点往下遍历到该符号代表的叶子结点过程中，经过的所有结点组成的 01 字符串。 上面是将 Huffman 树转化为编码，那如何通过给定概率（给定权重）构造出 Huffman 树呢？ 简单的来说，就是每一步： 构造一个新的结点； 每次优先将权值最小的两个结点，通过作为新构造的结点的左右孩子，合并为一棵二叉树； 新结点的权值为两个结点的权值之和； 将刚才讨论的两个结点从集合中删除，然后将新结点加入。 如此反复，直至 n 个字符代表的 n 个叶子结点变为一个结点。 构造的过程容易懂。实现需要堆。证明需要贪心。 Huffman 可以应用于压缩文件，压缩率在 20%~90% 之间。 Huffman 编码贪心选择性质分析这部分参考了《算法导论（第三版）》。 符号 说明 $f_x$ $x$ 出现的频度 $d_T(x)$ $x$ 在 $T$ 树的深度 $WPL(T)$ $T$ 树的 WPL（带权路径长度） $WPL(T)=\\sum_{x \\in T} f_x \\cdot d_T(x)$ 我们即要证明，一个序列 $S$ 的 Huffman 树是具有最小 WPL（带权路径长度）的二叉树。 我们的证明思路是： 证明引理 1（贪心选择）：对于一个序列，$y$ 和 $z$ 是其最小频度的字母。由这个序列中组成的 WPL 最小的二叉树中，一定存在一棵树，其中 $y$ 和 $z$ 是具有最大深度的兄弟子结点。证明引理 2（最优子结构）：对于一棵二叉树 $T$，设 $y$、$z$ 为其两个叶子且互为兄弟，他们的父亲是 $\\omega$。若将 $\\omega$ 看做具有权重（频率）$f_\\omega = f_y + f_z$ 的叶子结点，按此法得到的树 $T’$ 具有最小 WPL，则 $T$ 也具有最优子结构。 首先证明引理 1：对于一个序列，$y$ 和 $z$ 是其最小频度的字母。由这个序列中组成的 WPL 最小的二叉树中，一定存在一棵树，其中 $y$ 和 $z$ 是具有最大深度的兄弟子结点。 我们使用交换论证：设 $T$ 为 WPL 最小的二叉树，其最大深度兄弟子结点为 $a$, $b$。不失一般性地假设 $f_y \\leq f_z$，$f_a \\leq f_b$。由于 $y$、$z$ 频度最小，显然有 $f_y \\leq f_a$，$f_z \\leq f_b$。在此前提下，设将 $T$ 的 $a$、$y$ 结点交换得到的树为 $T’$，将 $T’$ 的 $b$、$z$ 结点交换得到的树为 $T’’$。 树 $T$ 和 $T’$ 的 WPL 之差为： $$\\begin{aligned}WPL(T)-WPL(T’) &amp;= \\sum_{x \\in T} f_x \\cdot d_T(x) - \\sum_{x \\in T’} f_x \\cdot d_T’(x) \\\\&amp;= f_a \\cdot d_T(a) + f_y \\cdot d_T(y) - f_a \\cdot d_{T’}(a) - f_y \\cdot d_{T’}(y) \\\\&amp;= f_a \\cdot d_T(a) + f_y \\cdot d_T(y) - f_a \\cdot d_T(y) - f_y \\cdot d_T(a) \\qquad \\left( d_{T’}(a)=d_T(y) \\right) \\\\&amp;= (f_a - f_y) \\cdot (d_T(a) - d_T(y)) \\geq 0 \\qquad \\left(两项都非负\\right)\\end{aligned}$$ 所以 $WPL(T) \\geq WPL(T’)$。同理 $WPL(T’) \\geq WPL(T’’)$。又因为 $T$ 为最下 WPL，故有 $WPL(T) \\leq WPL(T’’)$。由三个不等式可得，$WPL(T) = WPL(T’’)$，即 $T’’$ 的 WPL 也是最小。引理 1 得证。 在证明引理 2 之前，我们先证明引理 3：对于一棵二叉树 $T$，设 $y$、$z$ 为其两个叶子且互为兄弟，他们的父亲是 $\\omega$。若将 $\\omega$ 看做具有权重（频率）$f_\\omega = f_y + f_z$ 的叶子结点，按此法得到了树 $T’$，则有： $$WPL(T’)=WPL(T)-f_y-f_z$$ 证明如下： $$\\begin{aligned}WPL(T) &amp;= \\sum_{x \\in T} f_x \\cdot d_T(x) \\\\&amp;= f_y \\cdot d_T(y) + f_z \\cdot d_T(z) + \\sum_{x \\in T, x \\neq y, x \\neq z} f_x \\cdot d_T(x) \\\\&amp;= (f_y + f_z) \\cdot (1 + d_{T’}(\\omega)) + \\sum_{x \\in T, x \\neq y, x \\neq z} f_x \\cdot d_T(x) \\\\&amp;= f_y + f_z + \\left[ f_{T’}(\\omega) \\cdot d_{T’}(\\omega) + \\sum_{x \\in T’, x \\neq \\omega} f_x \\cdot d_{T’}(x) \\right] \\\\&amp;= f_y + f_z + WPL(T’)\\end{aligned}$$ 有了这个性质，这样贪心的思路基本就清楚了。剩下的就是按照贪心的套路证明。数学归纳法 + 反证法： 证明引理 2：如果按上面方法构造的 $T’$ 是序列 $S’=S - \\{y, z\\} + \\{\\omega\\}$ 的最优树，则 $T$ 是序列 $S$ 的最优树。 令 $n = |S|$。 当 $n = 2$ 时，显然一个根结点和两个叶子结点的结构具有最小 WPL； 当 $n \\geq 2$ 时，假设存在大小为 $n$ 的更优编码的树 $Z$，其最深的兄弟子结点为 $a$ 和 $b$。 按引理 1 的方式将 $Z$ 树中 $a$、$b$ 和 $y$、$z$ 互换，得到 $Z’$。由引理 1 有 $WPL(Z) = WPL(Z’)$； 按引理 3 的方式将 $Z’$ 树中 $y$、$z$ 替换为 $\\omega$，得到 $Z’’$。由引理 3 有 $WPL(Z’’) = WPL(Z’) - f_y - f_z$； 此时的 $Z’’$ 为 $T’$ 树的另一个排序方式，由于 $T’$ 的 WPL 最优，有 $WPL(T’) \\leq WPL(Z’’)$。 由引理 3 有：$WPL(T’)=WPL(T)-f_y-f_z$ 综上有：$WPL(Z) = WPL(Z’) = WPL(Z’’) + f_y + f_z \\geq WPL(T’) + f_y + f_z = WPL(T)$，即 $WPL(Z) \\geq WPL(T)$，证毕。 有了引理 2，由数学归纳法可得：一个序列 $S$ 的 Huffman 树是具有最小 WPL（带权路径长度）的二叉树。证明完毕。 堆 Heap这部分参考了《算法导论（第三版）》。 就是 C++ 的 priority_queue 的实现过程啦。 堆是完全二叉树，同时（小根堆/小顶堆）要求根结点小于两个结点，大根堆同理。（因此堆不是二叉排序树） 完全二叉树，一可以保证 $\\lfloor \\log n \\rfloor$ 的树高，二可以用线性表实现。 以上是堆的性质，下面一步一步的说（大根）堆的实现和应用： max_heapify(Array, index)，作用是在以 index 的左右儿子为根的完全二叉树符合堆性质的前提下，通过调整使得以 index 为根的二叉树符合堆性质，时间复杂度 $O(\\log n)$； build_max_heap(Array)，将任意数组调整为堆，时间复杂度 $O(n)$； heap_sort(Array)，将任意数组使用堆结构进行排序，时间复杂度 $O(n \\log n)$； heap_insert(value)、heap_pop_max()、heap_max()，将堆作为优先队列使用，每一步的时间复杂度都是 $O(\\log n)$。 完整的代码因为较长，不在这里贴出，可下载 sort.cpp。 max_heapifymax_heapify(Array, index)，作用是在以 index 的左右儿子为根的完全二叉树符合堆性质的前提下，通过调整使得以 index 为根的二叉树符合堆性质，时间复杂度 $O(\\log n)$。 实现上，就是只考虑 index 为根的二叉树，将小的根一直向下沉，将左右结点中较小的一个往上冒，然后再处理这边的子树。 这里的 $O(\\log n)$ 的时间复杂度是指，操作的复杂度与以该结点为根结点的子树的深度成正比（也就是说，叶子结点的复杂度最小，根结点最大）。至于如何由这句话严格地推出 $O(\\log n)$，这里不加赘述。 参考代码： 12345678910111213141516171819202122template &lt;class T&gt;void max_heapify(vector&lt;T&gt;&amp; Arr, int i, int size) //size 参数是堆的大小，在堆排序过程中，堆的大小不一直等于数组的大小&#123; while (i &lt; size) &#123; int l = leftson(i), r = rightson(i), largest; if (l &lt; size &amp;&amp; Arr[i] &lt; Arr[l]) largest = l; else largest = i; if (r &lt; size &amp;&amp; Arr[largest] &lt; Arr[r]) largest = r; if (largest == i) break; else &#123; swap(Arr[i], Arr[largest]); i = largest; &#125; &#125;&#125; build_max_heap堆的实现中，不是像 priority_queue 一样，一个一个加进来，而是将一个数组逐步调整为堆。调整的具体方法，是从最后一个非叶子结点往根结点方向调整，使得调整的结点以下部分都满足堆的性质。 代码非常简洁，就是 max_heapify 外面套一个 for。 12345678template &lt;class T&gt;void build_max_heap(vector&lt;T&gt;&amp; Arr)&#123; for (int i = Arr.size() - 1; i &gt;= 0; i--) &#123; max_heapify(Arr, i, Arr.size()); &#125;&#125; 但是正确性的证明需要用到循环不变式，这也是《算法导论》一直在强调的东西。此处略去详细的证明。 时间复杂度的一个上界 $O(n \\log n)$ 是显然的。 但是实际上它是 $O(n)$ 的！ 证明如下： 为简洁起见，我们设树高为 $h$。显然有 $h = O(\\log n)$。 由 max_heapify 的复杂度分析，我们可以知道，该函数的复杂度是和以结点为根结点的树的深度成正比的。即根结点的复杂度为 $O(h)$，叶子结点为 $O(1)$。build_max_heap 对所有结点进行了 max_heapify，所以时间复杂度为： $$O(\\sum_{i=1}^h (h+1-i)\\cdot 2^i) = O(4 \\cdot 2^h - 2h - 4) = O(2^h) = O(n)$$ 其中可能需要用到等比数列求和或级数求和的技巧。 heap_sort用堆实现排序的方法是， 首先 build_max_heap 将数组调整成（大根）堆，此时最大的数一定在堆顶。 将其取出（实际上是和堆的最后一个元素交换，然后堆的大小 –），再重新 max_heapify 调整为堆。如此反复，直至堆大小为 0，此时原数组正好就是升序排列的。 （值得一提的是，实现升序排序，推荐的反而是大根堆，因为取走堆顶元素以后丢到线性表末尾，堆的大小为 0 时，得到的序列就是升序的） 因此 pop 过程不需要重新写删除元素的函数（所以也就只能删除堆顶的元素了好歹人家也是完全二叉树，删了中间的结点就不是完全二叉树了）。 所以，堆排序实际分为两个步骤：先将数组调整为堆 build_max_heap，时间复杂度 $O(n)$，再反复 pop 堆顶元素再调整，时间复杂度 $O(n\\log n)$，总时间复杂度也为 $O(n\\log n)$。 代码如下： 12345678910111213template &lt;class T&gt;void heap_sort(vector&lt;T&gt;&amp; Arr, int l, int r)//非递归排序，不需要 l, r 参数，但为了统一，还是设定了这个参数&#123; using namespace heap; //先将数组调整为堆 build_max_heap(Arr); for (int i = Arr.size() - 1; i &gt; 0; i--) &#123; swap(Arr[i], Arr[0]); max_heapify(Arr, 0, i); &#125;&#125; 这里是对根结点进行了 $n$ 次 max_heapify，所以时间复杂度是 $O(n\\log n)$。 heap_insert这里的 heap_insert 和《算法导论》上的实现思想略微有点不同，但是算法复杂度数量级是相同的。 这里的思想是在最后插入一个结点（使用 C++ 的 std::vector 的 push_back 函数），然后对新结点往上的结点都使用一次 max_heapify。 注意到在原来已经是一个堆的前提下，这样的每次 max_heapify 都只会进行一次循环就结束，其实是 $O(1)$ 的，因此可以也保证时间复杂度是 $O(\\log n)$。 具体实现上，对于优先队列我创建了类 priority_queue。函数名为了与 std::priority_queue 保持一致，这里的 heap_insert 用的是 push。 123456789101112131415template &lt;class T&gt;class priority_queue //为突出算法核心并保持代码简洁，不进行异常情的检查&#123;private: vector&lt;T&gt; Arr;public: void push(const T val) &#123; Arr.push_back(val); for (int i = Arr.size() - 1; i &gt;= 0; i = father(i)) &#123; max_heapify(Arr, i, Arr.size()); &#125; &#125;&#125; heap_heap_pop_maxpop 过程和 heap_sort 的 10、11 行内容接近。就是将根结点和最后一个结点进行交换（方便 vector::pop_back 去掉最后一个元素），然后 max_heapify。 123456void pop()&#123; swap(Arr[0], Arr[Arr.size() - 1]); Arr.pop_back(); max_heapify(Arr, 0, Arr.size());&#125; heap_max一行，返回根结点就行。 1234T top()&#123; return Arr[0];&#125; 完整的结构体代码和其他堆的代码都可以参见 sort.cpp。 树森林就是一堆树。将森林的每棵树的根结点加上一个父结点以后，又变成了一棵树。 存储结构 双亲表示法：每个结点只存值和父结点。 孩子表示法：每个结点的一堆儿子结点指针拉成链表来存。 兄弟表示法：每个结点存儿子结点和右边的兄弟结点。这个挺有意思的，可以直接由二叉树的结构改过来。 兄弟表示法与二叉树的转换（指的是同一个存储结构用二叉树和兄弟表示法两种形式解释的结果）：森林结点的儿子存储在二叉树的左结点，森林结点的兄弟存在二叉树的右结点。二叉树根结点的右结点一定为空。 最后这个特性很有意思，就可以把森林的每个根结点用根结点的右节点串起来，即实现了森林和二叉树的转换。 遍历方法非二叉树没有中序遍历废话 森林有先序、中序，没有后序。后序没有意义（先把别人的树访问完了再来访问自己的根结点？？？） 引用：计算表达式 后缀表达式天下第一 中缀表达式不唯一 前缀表达式的实现需要两个栈 图论和贪心算法贪心算法贪心算法就是每一步寻求局部最优解。证明全局最优，可以通过修改最优解得到贪心解，然后将问题划归为最优子结构，最后用数学归纳法证明。 另外的证明方式可以看算法设计 最小生成树 朴素 Prim 在稠密图中优于 Kruskal，在稀疏图中劣于 Kruskal。 堆优化 Prim 在任何时候的时间复杂度都优于朴素 Prim 和 Kruskal，代价是空间消耗极大。 后记由于课程紧张，后期笔记就比较水了。 这是中国大学 MOOC 的学习链接。 2019.12.29 更新：明天考数据结构，今天看了下笔记，发现做笔记还是很香的，虽然前期很花时间，但是复习起来不要太舒服，特别是排序章节。","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"图论","permalink":"https://blog.lyh543.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.lyh543.cn/tags/%E6%90%9C%E7%B4%A2/"},{"name":"坑","slug":"坑","permalink":"https://blog.lyh543.cn/tags/%E5%9D%91/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.lyh543.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.lyh543.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Git笔记","date":"2020-01-31T14:02:19.000Z","path":"linux/git/","text":"常用链接常用命令可查表：Git-CheatSheet 官方文档 也是很好的学习的手段。 GitHub 词汇表GitHub 备忘清单 本博客参考链接：https://www.liaoxuefeng.com/wiki/896043488029600 前言先说一个概念：Git 是目前最流行的版本管理系统，学会 Git 几乎成了开发者的必备技能。 如果你看不懂这句话，你可以从字面意思理解“版本管理系统”：多个开发者在同一个软件的基础上，开发了不同的版本，他们可以通过 Git 方便、严谨的实现上传、下载、比对、合并代码间的冲突等操作。 而我们最常用的把代码放到 GitHub（或其他 Git 服务器）上的操作，可以把远程服务器也看做一个开发者（虽然他什么也不会修改），我们每次开发完以后，就会将代码上传给他。 Git 入门在本地 Git 新建仓库入门，首先就是新建一个仓库了。对于这第一个概念，仓库，可以从字面理解为存代码的仓库，往往将一个项目的完整代码放在一个仓库。 有两种方法：一是在本地新建一个 Git 仓库，另一种是在 GitHub 上新建库，然后下载到本地。 如果你打算将代码放到 GitHub 上，这里推荐第二种方法。因为在 GitHub 新建了库以后，可能会有一些初始文件、初始设置，可能和本地不同。如果使用使问题更复杂，在初学阶段，可以先跳过这些麻烦的东西。 首先假设你已经在 GitHub 网站上建立了库（或者你想把别人的库下载到本机），链接为 https://github.com/lyh543/lyh543.github.io/。现在想要在当前文件夹中，新建 lyh543.github.io 文件夹，并将仓库下载到本地： 1git clone https://github.com/lyh543/lyh543.github.io/ 本地就多了一个文件夹 lyh543.github.io，内容和网站上的一致。 你也可以使用不同于 HTTPS 协议的 SSH 协议（如果你明白这是什么），将上面 clone 的 HTTPS 链接修改为 SSH 链接即可。 顺便提一下，在本地新建仓库的方法如下： 123mkdir lyh543.github.iocd lyh543.github.iogit init Git 上传三连在建立好库以后，每次写完代码，就可以按照下面的上传三连了。如果该项目只有你的一台设备进行开发（即不会出现不同步的情况），在 99% 的情况，你只会用到以下三条语句。 123456789# 如果本地、服务器端不一致，需要先 git pull，将服务器的内容拉取下来git add --all # 单文件是 git add &lt;file&gt;# git status # 这句可以看到到底 add 了哪些东西git commit -m \"upload 2 files.\" # 用文字说明这一次更新了什么东西，推荐写git push 上传完以后，你就可以看到 GitHub 上的代码已经更新。 一键三连在很熟悉三连操作以后，就会感到有点麻烦了。于是用 alias 实现了一个命令缩写。 1alias commit='git_commit() &#123; git add --all &amp;&amp; git commit -m \"$1\" &amp;&amp; git push;&#125;; git_commit'` 但是因为 alias 不是开机自启的，要想开机自启，可以看 另一篇博客，此略。 Git 使用 SSH 协议Git for Linux 如果操作 HTTPS 协议链接的仓库，是不能保存密码的，每次 push 都需要输入账号密码，很烦。（Git for Windows 貌似可以走网页认证，好像可以保存） 一个选择是 ssh 协议，使用这个协议可以保存用户信息，很方便。第二个方案是走 https，不过让 Git 明文保存密码（不推荐） 多 ssh 秘钥部署可以看链接：https://www.awaimai.com/2200.html 在 Linux 下 Git 使用 ssh 密钥大概分为三步走： 本地生成密钥对； 设置 GitHub 上的公钥； 修改 Git 的 remote url 为 SSH 协议。 Linux 下本地生成密钥对$ ssh-keygen -t rsa -C &quot;lyh543@github.com&quot; passphrase 可留空因为太懒，不然以后每次 push 都要输这个 passphrase The key fingerprint is: SHA256:QtXXXXXXXXXXXXXXXXXXXXXXXXXXXXlk lyh543@github.com 设置 github 上的公钥 查看你的公钥 12$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXmp lyh543@github.com 登陆你的github帐户。然后 Account Settings -&gt; 左栏点击 SSH Keys -&gt; 点击 Add SSH key 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，你随便填一个都行。 完了，点击 Add key。 测试一下这个key。 123456$ ssh -T git@github.comThe authenticity of host 'github.com (52.74.223.119)' can't be established.RSA key fingerprint is SHA256:nTXXXXXXXXXXXXXXXXXXXXXXX8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,52.74.223.119' (RSA) to the list of known hosts.Hi lyh543! You've successfully authenticated, but GitHub does not provide shell access. 看到最后一句就是OK了。 修改 Git 的 remote url 从 https 改为 ssh查看当前（git仓库下的）的remote url 1234# 需要到仓库根目录下$ git remote -vorigin https://github.com/lyh543/lyh543.github.io.git (fetch)origin https://github.com/lyh543/lyh543.github.io.git (push) 修改 remote url 1git remote set-url origin git@github.com:lyh543/lyh543.github.io.git 题外话：把 ssh 密钥给服务器使用 ssh 远程登录服务器的时候，每次都要输入密钥。其实也可以使用 ssh 密钥进行登录。而且甚至没有 git 这么麻烦，还要去官网上加入公钥。 直接一句： 12ssh-keygenssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.x.xxx -p22 即可。 Windows 下 git 使用 ssh 密钥Windows 下也可以生成 ssh 密钥对，但是需要使用第三方软件：PuTTYgen，在 Tortoise Git 中自带。由于方法不同，可以在 Windows 和 Linux 使用不同的 ssh Key。 本地生成密钥对； 设置github上的公钥； 设置本地git使用的密钥。 Windows 下本地生成密钥对进入软件，点Generate，然后就开始生成。由于生成时的随机数据是采集鼠标指针的移动，因此务必在生成过程中移动鼠标。 PuTTYgen_1 大约1分钟以后，生成完成，如图2。 PuTTYgen_2 然后 Save Private Key 把密钥文件存下来。文本框中的内容是公钥，按照上面的方法设置github上的密钥。 设置本地 git 使用的密钥由于笔者使用 Tortoise Git，在一个 reporisitory 中 push 的时候选中自动加载 PuTTY密钥即可。 命令行 Git 另有实现方法。 (Linux) Git 保存密码 参考博客：https://blog.csdn.net/xx326664162/article/details/49686241https://www.crifan.com/git_remember_record_user_and_password_no_need_input_again/ Git的凭据存储有 cache、store、manager 三种方式。可以通过 1git config --global credential.helper store 切换。 其中，如果使用 store，密码将被会明文保存在 ~/.git-credentials。感觉不大好。 如果使用 cache 密码会在内存中保存一段时间。密码永远不会被存储在磁盘中，并且默认在15分钟后从内存中清除。不过时间是可以修改的。 于是，就有人想到把这个时间设置为一个月 2592000 。 注销以后密码也会被清除，毕竟是存在内存里的。不过每次开机输一次密码也能接受。 12git config --global credential.helper cachegit config credential.helper 'cache --timeout=1000000000' 还有一种在 remote.url 中加入自己的用户名和密码，更危险，就不表了。 Git 代理经常会有挂上代理，浏览器访问 Github 快到飞起的，但是 Git Clone 却慢死的经历。awsl。 以下方法收集自知乎的同一问题：git clone一个github上的仓库，太慢，经常连接失败，但是github官网流畅访问，为什么？ Shadowsocks 对 Github 进行 HTTPS 代理12git config --global http.https://github.com.proxy socks5://127.0.0.1:1080git config --global https.https://github.com.proxy socks5://127.0.0.1:1080 也要注意 1080 是 Shadowsocks 代理的端口，可能需要根据自己的代理配置进行修改。另外使用该方法以后，需要用 HTTPS 协议（而不是 SSH）进行传输。 ssh 代理Linux/WSL 1Linux 的 ssh 代理可以通过macOS 给 Git(Github) 设置代理（HTTP/SSH）的方法。 WSL 2注意如果是 wsl 2，因为 wsl 2 实际上是一个 Hyper-V 虚拟机，因此 Windows 上的代理如果想要被 Linux 使用，上面填 ip 的地方应该填 Windows 在 wsl 网络下的 ip（命令行输入 ipconfig，看到 以太网适配器 vEthernet (WSL) 的就是）。另外还需要代理软件“允许局域网的连接”。 而且目前 wsl 2 由于是由 Hyper-V 实现的，每次重启 windows，windows 和 wsl 的 ip 都会变，目前没有方法改为静态 ip，只能每次改 ip 了。（ Windows如果是 Windows 下的 Git，可以参考：git clone一个github上的仓库，太慢，经常连接失败，但是github官网流畅访问，为什么？ - 戈登走過去的回答 - 知乎 不过注意，如果你的 OpenSSH 是通过 Windows 10 设置 - 应用与功能 - 可选功能 安装的，此法可能会使 Windows 下 ssh 出现如下错误： 123C:\\Tools\\Git\\&gt;ssh -T git@github.comCreateProcessW failed error:87posix_spawn: Unknown error 这个 bug 不影响 Git 的使用，并且可以通过卸载后从此处安装解决：https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH bug 相关可参见：https://github.com/microsoft/vscode-remote-release/issues/1887 改 hosts还有一个方法是修改 Hosts 文件。对于没有代理的开发者，会有一点帮助（都是开发者了为什么还没有代理）。 12151.101.72.249 github.http://global.ssl.fastly.net192.30.253.112 github.com Git 基础对于刚入门 Git 的萌新，clone pull add commit push 已经够用了。然而，如果要发挥 Git 全部的功能，还需要了解更多的东西。 回溯版本git status/diff/checkout 查看当前状态 学习链接：https://www.liaoxuefeng.com/wiki/896043488029600/896954074659008#0 下面只是对上述博客的一些简短的笔记。 使用 git status 可查看目前 Git 的状态（什么文件被修改过之类的……） 使用 git diff readme.txt 可查看 readme.txt 的还没有被 commit 的修改。 对于只是修改了 readme.txt 文件，还没有进行任何 Git 操作的，可以 git checkout -- readme.txt 恢复为之前 add 过的文件。 更多的情况可看Git 之 恢复修改的文件 git log/reflog/reset 版本回退使用 git log 可查看当前分支的所有 commit 日志。可搭配 --pretty=oneline 简略显示。 12345$ git log --pretty=onelinea4a32854a37319561d16f1618cd9c20e0b3290bf (HEAD -&gt; master, origin/master) append GPLf4d84ec5d20e8be8f7ef70802b1ba6e654986197 add distributedd5fd90e99d8a1d91a34d7aef9e615d122d2a2904 new readme.txt65a146ab6bc8b27dbaaed4d0c200d7d0ee8b6b65 add Hello world 前面的一串是 SHA1 值。 回退到上一个版本：git reset --hard HEAD^回退到上两个版本：git reset --hard HEAD^^ 或 HEAD~2回退/前进到指定版本：git reset --hard a4a3（到 append GPL 版本） 如果回退以后想再前进，却忘了 SHA1 值，可以使用 git reflog。 注意至少要写四位，否则会报错： 1234$ git reset --hard 65afatal: ambiguous argument '65a': unknown revision or path not in the working tree.Use '--' to separate paths from revisions, like this:'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]' 相关概念浅析：工作区、暂存区 工作区 working tree：（对于 test 项目）test 文件夹（tree 翻译成目录比较好） 版本库 Repository：test/.git 文件夹 暂存区 stage/index：在版本库中（Git 文档中凡是出现 stage 和 index 都是暂存区的意思） master：第一个分支，也在版本库中 HEAD：指向 master 的指针 其逻辑关系如下： 1234567891011test 文件夹 │ ├─工作区 working tree │ └─版本库 .git 文件夹 │ ├─ 暂存区 │ ├─ master 分支 │ └─ 其他分支 git add：将文件修改添加进暂存区 git commit：将暂存区的东西 commit 到当前分支。（在这之后用 git status 会显示 working tree clean） git diff/checkout/reset 笔记diff 只能比较两份文件，如果是操作中是新建文件/删除文件，git diff 会提示“没有差异”。 各 diff 的区别： git diff：显示工作区和暂存区的差异（即未 add 的内容） git diff --cached：显示暂存区和 HEAD 的差异（即未 commit 的内容） git diff HEAD：显示工作区和 HEAD 的差异（即未 add 或 commit 的内容） 在命令后可加文件名，指定比对某文件。 git checkout -- &lt;file&gt; 可以认为是反向 add，是将暂存区的文档修改覆盖工作区的文档； 使用不带参数的 git checkout 可以查看工作区和暂存区的文件差异。 -- 表示这条命令要无视 -- 后的所有参数（实战中貌似也是可以去掉的） git reset HEAD &lt;file&gt; 可以认为是反向 commit，是用当前分支的文档覆盖暂存区。（并不会覆盖工作区） 加上 --hard 参数，git reset --hard HEAD &lt;file&gt; 就会覆盖工作区了 Git checkout/reset/diff 对比 远程库操作在本地 git init 了一个库以后，如果需要上传到远程库，就需要设置远程库的地址（地址可以在 GitHub 网页上获取）： 1git remote add origin git@github.com:lyh543/test.git Git 规定，要给每一台远程主机命名。这里的 origin 就是 Git 给远程库的默认名字。虽然可以用别的名字，但是推荐 origin。 然后，进行 push： 1git push -u origin master push 命令将本地的当前分支上传到 origin 的 master 分支（简写 origin/master）。-u（或 --set-upstream）参数，还顺便将本地的 master 分支和 origin/master 分支进行关联（track），以后就不用指定。 branch 分支管理学习链接 分支管理 其他版本控制系统如 SVN 等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但 Git 的分支 branch 是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。 创建和合并分支相关概念复习一下，master 是 Git 默认创建的分支，HEAD 是指向 master 的一个指针。 其实，分支，是一条 commit 线。 也就是说，Git 中的每一个状态，其实指的是每一次 commit，而分支就是将 commit 串起来了（然后 HEAD 又指向了当前分支的头）。 分支 所以创建分支的本质就是添加一条线，更改一下 HEAD，很快的。而删除分支，就是删一条线（并不删除 commit），也很快。 代码新建 dev 分支并切换到该分支： 12git branch dev # 从当前分支新建 dev 分支git checkout dev # 切换到 dev 分支 上述两个过程也可以用一行替代： 1git checkout -b dev 实现的效果如图： 新建 dev 分支并切换到该分支 顺便一提， git checkout 的确是有两个功能，一是切换分支，二是将暂存区的某文件修改覆盖工作区的对应文件，不过二需要使用 git branch --。 这之后，就可以在 dev 分支上修改，然后三连了。 123echo \"We are working on a new branch\" &gt;&gt; readme.txtgit add readme.txtgit commit -m \"commit on dev branch\" 这之后，我们的仓库状态如下图： 在 dev 上三连后的仓库 接下来，将 dev 上的 commit merge 进 master。 由上图可以看到，直接将 master 分支线延长至 dev 即可，所以 Git 能够轻松完成 merge 操作。 这种 merge 又叫 fast-forward merge： A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch.Instead of “actually” merging the branches, all Git has to do to integrate the histories is move (i.e., “fast forward”) the current branch tip up to the target branch tip. – Git Merge | Atlassian Git Tutorial When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. This is the default behavior. – git merge --help 12git checkout master # 从 dev 切回 master 分支git merge dev # 将 dev 分支的内容合并到当前分支 提一句，merge 本质也是一次 commit，其也可以使用 -m &lt;msg&gt; 来设定 commit 信息，而不是在弹出的文本编辑器中。 最后删除 dev 分支： 1git branch -d dev # 删除已经完成合并的 dev 分支 no-fast-forward mergefast-forward merge 的好处是相当快，并且 commit 线简洁，但是简洁的坏处就是丢失了一些信息。 在这种模式下，删除分支后，会丢掉分支信息。 git merge 默认使用 fast-forward 模式。如果要强制禁用 fast-forward 模式，Git就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。 使用方法很简单，就是在 git merge 时增加一个参数： 1git merge --no-ff dev 2020.8.26 更新：在团队合作时，将自己写的代码 merge 到合作的分支（如 master 或 dev）上时，推荐使用 --no-ff，这样 commit 线上会出现分叉，不同人的 commit 会更加明显。 删除分支有三种情况：在本地删除某分支；在远端删除某分支（即将本地删除分支的操作 push 到远端）；在本地删除远端分支（即远端的已经被其他小伙伴删除，需要删除之前拉取到本地的远端分支）。 12345678# 在本地删除分支git branch -d lyh543# 在 origin 远端删除分支git push -d origin lyh543# 在本地删除远端的分支git branch -d -r origin/lyh543 解决冲突上面的分支图都是很简单的(linear)，如果复杂一点，比如两个分支都有自己的提交，git merge 就不能进行 fast-forward merge 了。 两个分支都有新的提交 对于简单的情况（两个分支只有文件增添，没有文件修改的冲突），Git 仍然可以实现自动合并，如： 在 feature1 删除了 a.txt 在 master 新增了 b.txt 将 feature1 合并进 master 后，master 分支会呈现删除 a.txt，新增 b.txt 的状态。 但是，也会有复杂的情况。如两个分支的某文件内容不同： 在 master 分支的 branch.txt 如下： 12branch:master 在 dev 分支的 branch.txt 如下： 12branch:dev 在 master 分支下进行 git merge dev 会报失败： 1234$ git merge devAuto-merging branch.txtCONFLICT (content): Merge conflict in branch.txtAutomatic merge failed; fix conflicts and then commit the result. 这时查看 branch.txt，会是这样： 123456branch:&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADmaster=======dev&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev 上面标注了两个版本的区别。 现在我们有两个方案：一是放弃合并操作；二是进行合并。 如果想放弃合并操作，只需一句 git merge --abort，就可以回到 git merge dev 之前的状态（一切都没发生过.jpg）； 如果想进行合并，只需要在当前状态下，修改 branch.txt 到想要的样子，然后 add 和 commit： 12git add branch.txtgit commit -m \"fix merge confict\" 就完成了 merge 和解决冲突。如何验证呢？可以用带图的 git log 1git log --graph --pretty=oneline 分支管理策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在 dev 分支上，也就是说，dev 分支是不稳定的，到某个时候，比如 1.0 版本发布时，再把 dev 分支合并到 master 上，在 master 分支发布 1.0 版本； 你和你的小伙伴们每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev分支上合并就可以了（向 dev 合并自己的代码的时候推荐 --no-ff，从 dev 分支将小伙伴的代码合并到自己的代码时推荐默认的 --ff）。 所以，团队合作的分支看起来就像这样： 团队合作的分支 而对于一个小 bug 或者一个 issue-101，也可以通过开一个 issue-101 临时分支，写完、merge 以后，再将临时分支删掉。 git stash 工作区暂存在当前分支的修改还有没 commit 的情况下，切换到其他分支后，这些修改会依然存在。 git checkout [&lt;branch&gt;]To prepare for working on &lt;branch&gt;, switch to it by updating the index and the files in the working tree, and by pointing HEAD at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the &lt;branch&gt;.– git checkout 如果我们既不想 commit（当前工作还没做完），也不想将当前分支的修改带到别的分支里，应该怎么做呢？ 1git stash 使用这句命令，我们就可以把工作区的修改暂存起来，然后让工作区呈现修改前的状态。这之后，使用 git status 会显示 working tree clean。 然后我们就可以用 git checkout 切换分支，在别的分支进行工作了。 在别的分支工作完，并切回该分区以后，如何找回来呢？ 1234567git stash list # 列出当前的 stashgit stash apply # 将最近的 stash 找回git stash drop # 将最近的 stash 删除git stash pop # 将最近的 stash 找回并删除git stash pop stash@&#123;0&#125; # 还可以指定 stash remote 远端管理这一节的内容其实和分支管理有一些交集，毕竟远端管理其本质也是在管理远端的分支。 git remote 查看远程库的信息查看远程库的信息： 123456$ git remoteorigin$ git remote -v # 详细信息origin git@github.com:lyh543/test.git (fetch)origin git@github.com:lyh543/test.git (push) 上面显示了可以抓取 fetch 和推送 push 的 origin 的地址。如果没有推送权限，就看不到 push 的地址。 git push 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。 推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上： 1git push origin master 如果要推送其他分支，比如 dev，就改成： 1git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master 分支是主分支，因此要时刻与远程同步； dev 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug 分支只用于在本地修复 bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个 bug； feature 分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在 Git 中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ git fetch 从远端拉取git clone 只会获取远程的 master 分支，如果要获取 dev 分支，我们应该从 origin/dev 新建 dev 分支： 123git checkout dev# 等价于 git checkout -b dev origin/dev，见下 git checkout [&lt;branch&gt;]If &lt;branch&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;remote&gt;) with a matching name and –no-guess is not specified, treat as equivalent to$ git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;– git-checkout Documentation - Git 这也太贴心了吧~ 那就不用记麻烦的了。 然后就可以愉快的在 dev 分支上进行修改了。 如果远端的内容更新了（比如你的小伙伴向远端 commit 了），但本地还没有更新，可以使用 123456git fetchgit merge# 或git pull # 两句的等价形式 来进行拉取（fetch）。 如果 merge 或 pull 中有冲突，需要按照 解决冲突 的套路来合并冲突。 git rebase 变基git rebase 通过修改 commit 的顺序使得某些情况下的分支图更简洁。 比如以下场景： 小伙伴 A 和 B 在合作开发同一个项目。 小伙伴 A 添加了 a.txt，并进行了 commit 和 push； 小伙伴 B 在没有 fetch 的情况下添加了 b.txt，并进行了 commit 和 push。当然，这里 push 会失败，提示需要 fetch。 小伙伴 B fetch 并 merge，完成了 merge 的过程，可以进行 pull 了。但是…… 此时的 git log --graph --pretty=oneline 出现了分叉！ 1234567$ git log --graph --pretty=oneline* d2232e76aad5009a86a66399b0d4a1e3feb9e6ef (HEAD -&gt; master) Merge branch 'master' of github.com:lyh543/test|\\| * 98946ab30bbaf2fbc60531450731a8e840bdf62a (origin/master, origin/HEAD) add a.txt* | 2eb60148822f268aa3510304fa409c1bdd2ec9b4 add b.txt|/* 591c9b045b7b84e75710fa96b1f77cb92ee82a85 remove dev.txt 这也没什么问题。但是，从理论上，这个分叉完全可以避免：只要 B 能在 commit 前进行 fetch 就可以少一次 merge 了。 于是，这时 B 拍出了 git rebase： 123$ git rebaseFirst, rewinding head to replay your work on top of it...Applying: add b.txt （这里的 rebase 过程比较简单，如果 A B 对同一文件进行了修改，rebase 过程会稍微复杂，但同样能达到效果） 之后，工作区和暂存区都没有什么变化，但是 git log --graph --pretty=oneline 发生变化了： 1234$ git log --graph --pretty=oneline* 3b3769ddfea3f6ddc0a36e3d5784bd676386030e (HEAD -&gt; master) add b.txt* 98946ab30bbaf2fbc60531450731a8e840bdf62a (origin/master, origin/HEAD) add a.txt* 591c9b045b7b84e75710fa96b1f77cb92ee82a85 remove dev.txt 分支线的分叉消失了！ 也就是说，git rebase 能通过修改 commit 顺序，使得分支线简单，但是会减少一个 merge 的 commit。 接下来就可以 push 了。 tag 标签管理学习链接 Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 标签也是一个指针，指向 commit 的。 标签有 轻量标签 lightweight 和 附注标签 annotated。 一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。 添加轻量标签： 12git tag v1.0 # 为 HEAD 添加 v1.0 的标签git tag v1.0 366e # 为 commit 366e 添加 v1.0 的标签 添加附注标签，加一个 -a 开关就可以。 1git tag -a v1.4 -m \"my version 1.4\" 列出已有标签：git tag 查看标签对应的 commit：git show v1.0 注意，标签默认不会被 push 至远程服务器（clone 和 fetch 时是会获得的）。 需要显式地 push 标签：git push origin v1.0或 push 时带上 --tags：git push origin --tags 删除标签可以使用 git tag -d v1.0。 但是，将删除标签推送至远端就有点复杂了： git push origin :refs/tags/v1.0。 查看标签所指的文件版本： git checkout v1.0 注意这之后会进入 detached HEAD 的状态，不再有 HEAD 的概念。在这个状态下会进行 commit 有一定副作用（具体见手册），推荐新开一个 branch 来进行操作。 看完了？如果看完了，推荐去看看 git-scm.com 的教程和手册，这里有官方对命令的解释，你对命令和概念的理解会更加精确。如 git checkout Git 小技巧git rm以下三种命令等价，都是从工作区删除并提交到暂存区 rm readme.txt git add readme.txt rm readme.txt git rm readme.txt git rm readme.txt 而从工作区删除，但是想恢复，只能在使用 rm readme.txt 的前提下 git checkout -- readme.txt。 –amend 修改上次 commit可以使用 git commit --amend -m &quot;xxx&quot; 以修改上次的 commit。 如果已经 push 了，下次就需要 git push -f 强制推送。如果还没有 push，就相当于之前的 commit 没发生过，直接 git push 就行。 git 修改设置12git config [--local] --list # 查看设置；--local 用于本地库git config --local remote.origin.url git@github.com:lyh543/lyh543.github.io.git # 修改设置，项和名用空格间隔 git 修改远端12git remote -v # 查看所有远端git remote set-url origin git@github.com:lyh543/lyh543.github.io.git # 修改远端 更多的命令，可以随便敲一个不存在的命令，如 git remote hhh 来查看所有命令。 当你在 branch 外 commit 后如果你在 branch 外 commit，然后立即切回 branch，你的 commit 就会掉。 有两个解决方案： 将 commit 的内容变为一个新的 branch，然后在原来的 branch 中 merge 新的 branch； 用下面的 cherry-pick 命令在 branch 中把对应的 commit 捡回来。 cherry-pick 捡 commitgit cherry-pick 是一个“捡” commit 的命令。可以把任意（非当前 branch 的） commit 拉到本 branch 来。 非当前 branch 的 commit 可以通过 git reflog 查看。 Git 大文件版本管理：git-lfsgit-lfs 官网GitHub 中文帮助页面 Git LFS 是 Github 开发的一个 Git 的扩展，他能够处理 Git 仓库里的大文件（如图片、视频等等），其原理是将 Git 仓库中的大文件替换为一个指针，然后将大文件存在另一个服务器上。这样做的好处有： 可让您存储最大 2 GB 的文件 使得 Git 仓库的容量更大 更快的 Cloning 和 Fetching（大概用的服务器更快） 操作和工作流等和原来完全一样 以上是官方的，个人感觉可能还会使得每次更新大文件时，他不会再保存在 .git 文件夹，占取大量硬盘空间了。 git-lfs 安装Windows 上官网就行。Ubuntu 下： 1sudo apt install git-lfs git-lfs 配置对于每个仓库下，第一次需要配置一下（如需要用 git-lfs 管理 psd 和 mp4 文件） 1234git lfs installgit lfs track \"*.psd\"git lfs track \"*.mp4\"git add .gitattributes 以后就和常规 git 上传三连 相同了。 123git add file.psdgit commit -m \"Add design file\"git push origin master GitHub 使用技巧下载最新的 release阅读他人的教程博客时，经常会看到给出 GitHub Release 的某版本的下载链接（下面第一行），但该版本可能已经过时。实际上，GitHub 提供了能重定向到最新版的链接（下面第二行）： 12https://github.com/canton7/SyncTrayzor/releases/download/v1.1.24/SyncTrayzorSetup-x64.exehttps://github.com/canton7/SyncTrayzor/releases/latest/download/SyncTrayzorSetup-x64.exe 在写下这篇博客时，第二行链接能正确地被重定向到第一行： 12345678$ curl -I https://github.com/canton7/SyncTrayzor/releases/latest/download/SyncTrayzorSetup-x64.exeHTTP/1.1 302 Founddate: Wed, 07 Oct 2020 10:22:26 GMTcontent-type: text/html; charset=utf-8server: GitHub.comstatus: 302 Foundvary: X-PJAX, Accept-Encoding, Accept, X-Requested-With, Accept-Encodinglocation: https://github.com/canton7/SyncTrayzor/releases/download/v1.1.24/SyncTrayzorSetup-x64.exe","tags":[{"name":"Git","slug":"Git","permalink":"https://blog.lyh543.cn/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"ssh","slug":"ssh","permalink":"https://blog.lyh543.cn/tags/ssh/"}]},{"title":"Django 测试那些事","date":"2020-01-08T10:20:23.000Z","path":"python/django-test/","text":"Django 测试的教程：https://docs.djangoproject.com/zh-hans/3.1/intro/tutorial06/ Django 测试的文档：https://docs.djangoproject.com/zh-hans/3.1/topics/testing/ 在后端开发中，自己写测试样例还是非常重要的，不然每次修改程序以后手动测试，工作量又大，还很难测完整。 Django 项目中用到的测试主要是集成测试。 同作为 Web 框架的 Spring Boot 可以单元测试和集成测试，因为 Spring Boot 项目的分层很明显 (Controller, Service, DAO)，可以对其中一层进行单元测试。 而 Django 框架本身已经实现了大部分功能 (DAO 由 Django Models 实现、Controller 由 Django Router 实现)，只剩下 Service 业务逻辑部分需要做测试，所以直接集成测试就可以了。 Django runserver 时测试 APIDRF 教程提到，在 runserver 时手动测试看效果时可以使用 httpie 或者其他工具。但是 POST 数据似乎有点麻烦。我更常使用 Python 的 requests 库。 1pip install requests 12345from requests import get, post, put, deletepost(\"http://localhost:8000/login/\", &#123; \"username\": \"lyh543\", \"password\": \"password\"&#125;) 语法和 django.test.client.Client 几乎一模一样。 Django test 环境初始化和清理在编写一个 django.test.TestCase 类的每个函数时，可能涉及到某些重复步骤。如对活动内容进行测试前都需要创建一个活动。文档里提到，可以把相同的准备工作写为这个测试类的 setUp 方法，这个方法在每个测试函数之前都会被调用一次。 而与 setUp 对应的就是 tearDown 方法，它可以完成每个测试函数以后的清理工作（如清空邮箱、删除测试文件）。需要注意的是，一般来说不需要清理数据库，因为 Django 的每个测试函数都是一个事务，测试完成后会回滚。所以如果测试函数只修改了数据库，就不需要单独编写 tearDown 函数了。 1234567891011121314151617# 重置密码相关测试class ResetPasswordTest(TestCase): email = \"admin@example.com\" password = \"adminadmin\" def setUp(self): tester_signup(self.email, self.password, 'Admin', '20210101') self.user = User.objects.first() def tearDown(self): mail.outbox.clear() # Django test 中不会真的发送邮件 # 文档：https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/#email-services def test_forget_password_whole_process(self): # ... pass setUp 和 tearDown 在每个函数执行前/后都会执行，而 setUpClass 和 tearDownClass 就是在测试类执行前/后执行。（注意 Django 也编写了 setUpClass 和 tearDownClass，因此重写的时候，不要忘了 super().setUpClass()） Django test 测试邮件服务Django test 还会替换掉默认的 SMTP 服务器，改为一个虚拟的、不会真正发送邮件的服务器。 文档：https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/#email-services 官方也给了一个读取发件箱的方法，这样每次测试的时候就不用人工查询邮件，而是直接在测试代码里读取邮件信息，再配合正则表达式就可以提取出需要的信息了。下面是一个示例： 12345678910111213from django.core import maildef pop_token_from_virtual_mailbox(test_function): \"\"\" 测试时从虚拟的邮箱中找到验证码，并清空测试发件箱 虚拟邮箱：https://docs.djangoproject.com/zh-hans/3.1/topics/testing/tools/#email-services 调用示例：https://github.com/uestc-msc/uestcmsc_webapp_backend/blob/5ca6316e6de8c42f28e3b7e9f0866b5cba4280c8/users/tests.py#L188 \"\"\" test_function.assertEqual(len(mail.outbox), 1) message = mail.outbox[0].message().as_string() mail.outbox = [] token = re.findall('token=.+', message)[0][6:] return token 上面这个函数自动抓取发送邮件中的 token=XXXXX 字段中的 XXXXX，保存到 token 变量然后返回。 Django test mock 当前时间我在写签到的 TestCase 的时候，想要修改 now() 时间来进行测试。Google 了一下找到了 mock 的几种写法，这里演示一种（源代码）： 123456789101112131415161718from unittest import mockclass ActivityCheckInTest(TestCase): @mock.patch('activities.views.now') def test_check_in_anytime(self, mocked_now): # 需要在 test 函数的参数部分增加一个参数 for day in [1, 2, 3]: is_today = day == 2 for hour in range(24): mocked_now.return_value = datetime(2020, 1, day, hour, 15, tzinfo=pytz.timezone('Asia/Shanghai')) # 可任意修改 activities.views.now 的参数 client = Client() client.force_login(self.user) response = client.post(activity_check_in_url(self.activity.id), &#123; # 此处测试的 activities.views.now 会返回上面的 return_value \"check_in_code\": self.activity.check_in_code &#125;) self.assertEqual(response.status_code, 200 if is_today else 403, f'date=&#123;mocked_now.return_value&#125;') self.activity.refresh_from_db() self.assertEqual(self.activity.attender.count(), 1 if is_today else 0) self.activity.attender.clear() 对于整个类的每个测试函数都需要 mock 的情况，可以参考 Applying the same patch to every test method - unittest.mock。 mock 的对象是类和函数，如果想修改变量，直接赋值修改就可以了，不需要 mock。 Django test 和 Integration Error？我在写登录的 TestCase 时出现了很奇怪的现象：正常运行时 API 貌似没有问题，在一个 Test 函数中调用一次 login 函数也没有问题，但如果调用两次 login 函数，Python解释器会不报错而停止，错误码为 -1073741819 (0xC0000005)。login() 函数如下： 12345678910def login(request): try: username = request.data['username'] password = request.data['password'] with transaction.atomic(): user = authenticate(request, username=username, password=password) django_login(request, user) return Response(status=status.HTTP_200_OK) except IntegrityError or KeyError: return Response(status=status.HTTP_401_UNAUTHORIZED) test 函数如下： 1234567class LogInTest(TestCase): def test_log_in_with_less_argument(self): r = Client().post('/users/login/') self.assertEqual(r.status_code, 401) r = Client().post('/users/login/') self.assertEqual(r.status_code, 401) 我参考了 Django 文档的 事务 部分，按照官方推荐的方法编写这段代码，但是出了问题。 个人猜测可能是 TestCase 中涉及的数据库回滚和 IntegrityError 触发回滚的冲突？ 最终我只能按照 if 的方法替代掉 try-catch 的方法。尽量不要触发 IntegrityError 吧。 Django test 时，POST 和 PATCH 记得添加 content_type=’application/json’笔者已经两次被这个坑了。第一次是在测试 PATCH 时，使用 django.test.client.Client.patch(path, data)，返回的 HTTP 状态码为 415 Unsupported media type &quot;application/octet-stream&quot; in request.&#39;： 添加参数 Client.patch(path, data, content_type=&#39;application/json&#39;) 就好了。 Getting 415 code with django.test.Client’s patch method 后来，在 POST 的时候莫名其妙发现我写的下面这段 JSON，手动 POST 时能正常工作，但使用 Client.post(path, data) 时，嵌套的 {&quot;id&quot;:1} 部分不能被正确识别到。 123456&#123; \"title\": \"test\", \"datetime\": \"2021-01-20T10:29:26+08:00\", \"location\": \"test\", \"presenter\": [&#123;\"id\":1&#125;]&#125; DEBUG 的时候注意到，response 中包含的 wsgi_request 里面，{&quot;id&quot;:1} 就没有被正确提交。猜测可能是 Django Client 没有以 JSON 的形式解析这段代码，于是加上 content_type=&#39;application/json&#39;，就返回 201 Created 了。","tags":[{"name":"后端","slug":"后端","permalink":"https://blog.lyh543.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"RESTful","slug":"RESTful","permalink":"https://blog.lyh543.cn/tags/RESTful/"},{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Django","slug":"Django","permalink":"https://blog.lyh543.cn/tags/Django/"}]},{"title":"C++ 异常处理","date":"2019-12-26T14:10:56.000Z","path":"cpp/cpp-grammar/cpp-exception-handling/","text":"参考 https://www.runoob.com/cplusplus/cpp-exceptions-handling.html C++ 自带的异常处理，可以用来处理 除数为 0、加法溢出 等一些情况。虽然我们可以使用普通的 if 来判断，但是也可以使用 C++ 提供的一些异常。 这样的好处，是用标准统一了异常处理，方便了一些操作，也“提高了代码的复用性”。 三个关键字：try throw catchtry catch throw 是 C++ 为异常处理设定的关键字。从字面上来理解： throw: 当问题出现时，程序会抛出 throw 一个异常。 catch: 用于捕获 catch 异常。 try: 尝试 try 触发异常。它后面通常跟着一个或多个 catch 块。 从代码上来看： 1234567891011try&#123; // try 块 //如果出错，就进行 throw&#125;catch( ExceptionType e1 )&#123; // catch 块&#125;catch( ExceptionType e2 )&#123; // catch 块&#125; 异常处理的机制看到这里可能还是一脸懵逼。我们需要 throw 什么？catch 什么？ 我看到的教程中很少明确指出了这一点：C++ 中，我们需要 throw 的是一个对象，在 catch 中通过判断对象的类来判断是否执行。 比如，我们在 try 块中 throw 了一个字符串 &quot;divided by zero&quot;，在 catch 中，我们就需要判断是不是 const char *： 12345678910111213141516int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; try &#123; if (b == 0) throw \"divided by zero\"; cout &lt;&lt; a / b; &#125; catch (const char* errorString) &#123; cout &lt;&lt; errorString; &#125; cout &lt;&lt; a / b;&#125; 输入 2 0 时，会输出 divided by zero，然而还是运行错误，执行到了 15 行 a / b。这说明： 异常被 catch 后，会跳过 try 剩下的语句，执行对应的 catch 代码块，然后按顺序向下继续执行 catch 代码块后的第一句。 看到这里，你可能觉得这功能还是很蠢：当你想要 catch 两种错误时，throw 一个字符串是行不通的（因为 catch 识别的是类型），这又怎么办呢？ 异常类和 C++ 标准异常上文说道，一个字符串不好用。于是： C++ 提供了一个异常类 std::exception（定义在 &lt;exception&gt;），他是所有的异常的父类。 除了构造函数、复制构造函数、析构函数以外，他只有一个 const char * what() 成员函数，还是个虚函数（简单的说，即父类声明、子类实现的函数）。这个函数是用来读取异常的字符串。 除此之外，C++ 还提供了 C++ 标准异常，定义在 &lt;stdexcept&gt; 中，他们都是继承于 std::exception 类。他们除了实现 what() 以外，还在 &lt;exception&gt; 上加了两个构造函数，参数分别为 const string &amp; 和 const char *。这就起到了传递字符串的效果：由字符串构造，由 what() 输出字符串。 这也是为什么这篇异常处理会被插上面向对象的标签 C++ 标准异常 cppreference 上也提到了所有 C++ 标准异常。 既然有了异常类，那么传递一个对象，判断类的类型，就是水到渠成的想法了。 定义新的异常类：我们通过公有继承 std::exception 来定义自己的 MyException 类。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std; struct MyException : public exception&#123; //what() 是异常类提供的一个公共方法，它已被所有子异常类重载。 const char * what () const throw () &#123; return \"C++ Exception\"; &#125;&#125;; int main()&#123; try &#123; throw MyException(); &#125; catch(MyException&amp; e) &#123; std::cout &lt;&lt; \"MyException caught\" &lt;&lt; std::endl; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; &#125; catch(std::exception&amp; e) &#123; //其他的错误 &#125;&#125; 上面的代码会返回如下的结果： 12MyException caughtC++ Exception Which one: 断言、异常处理和 return false当程序遇到预期可能的错误时，可以进行断言 assert、异常处理和返回一个错误返回值表示执行错误。那么到底该选择哪个呢？ 知乎上有这个问题。结论基本是： 三个词可以分为两类：一类是 assert，另一类是异常处理和返回错误值。因为 assert 应当是程序出了 bug 才会触发（程序应当“留下证据然后立即自爆”），另两个可能是用户输入了错误的内容触发的。应当修改错误或者引导用户进行正确输入。 针对采用return value 还是 exception，没有一定的结论。Stack Overflow 有一个针对这个问题的讨论，不过基本上没有结论，我比较喜欢的是抛出异常会强迫调用者处理，返回值则不会。无论那种，基本上都要有一堆的处理语句。来源 坑这篇博客对异常处理讲的很草率马上期末考试了没时间深究了啊啊啊啊有空再更。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"坑","slug":"坑","permalink":"https://blog.lyh543.cn/tags/%E5%9D%91/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"C++ 命名空间","date":"2019-12-26T14:10:03.000Z","path":"cpp/cpp-grammar/cpp-namespace/","text":"命名空间是表达多个变量和多个函数组合成一个组的方法。主要是为了解决名字（类型、变量、函数名）冲突的问题。 定义命名空间用一个例子来说明：在 MyStudent.h 和 YourStudent.h 中都定义了 Student 类，并在 main 函数中包含这两个文件。 1234567891011121314151617181920212223//MyStudent.cppclass Student&#123;public: void Show() &#123;cout &lt;&lt; \"MyStudent\"; &#125;;&#125;;//YourStudent.cppclass Student&#123;public: void Show() &#123;cout &lt;&lt; \"YourStudent\"; &#125;;&#125;;//main.cpp#include\"MyStudent.cpp\"#include\"YourStudent.cpp\"int main()&#123; Student s; s.Show(); return 0;&#125; 以上代码会报错：Student 不明确。 所以用 namespace 将两个代码分开： 1234567891011121314151617181920212223242526272829//MyStudent.cppnamespace MyStudent&#123; class Student &#123; public: void Show() &#123;cout &lt;&lt; \"MyStudent\"; &#125;; &#125;;&#125;//YourStudent.cppnamespace MyStudent&#123; class Student &#123; public: void Show() &#123;cout &lt;&lt; \"YourStudent\"; &#125;; &#125;;&#125;//main.cpp#include\"MyStudent.cpp\"#include\"YourStudent.cpp\"int main()&#123; Student s; s.Show(); return 0;&#125; 应该可以了。（注意 namespace 没有分号） 然而还是不行。因为没有指明用的是哪一个 namespace 的。 修改上一段的 main.cpp： 1234567891011//main.cpp#include\"MyStudent.cpp\"#include\"YourStudent.cpp\"int main()&#123; MyStudent::Student ms; YourStudent::Student ys; ms.Show(); ys.Show(); return 0;&#125; 总算能正常使用了。 注意这个 :: 符号，和类的也是一样，都是表明域运算符。 关于定义命名空间，再多说几句，namespace： 可以在全局范围定义 可以在另一个 namespace 中定义（形成嵌套 namespace） 不可以在函数、类的内部定义 定义可以不连续、分段定义（和类一样） 甚至可以没有名字，但是就不能跨文件调用，起到了类似 static 的效果 using 语句还可以使用 using namespace 语句，使得 using 作用域里的代码使用该 namespace 时可以省略 namespace 的名称。 （这里的 作用域 遵循正常的范围规则：从使用 using 开始，直到范围结束） 继续修改上一例的 main.cpp： 123456789101112//main.cpp#include\"MyStudent.cpp\"#include\"YourStudent.cpp\"using namespace MyStudent;int main()&#123; Student ms; YourStudent::Student ys; ms.Show(); ys.Show(); return 0;&#125; 注意，如果在本例中对 MyStudent 和 YourStudent 都进行 using，会报最开始就提到的 不明确 的错。 也可以使用名称空间的部分内容： 1using std::cout; namespace stdC++ 标准语法库的所有代码都被包含在了 std 名称空间中。 这意味着，如果不指明名称空间，形如 string sort cout 的东西都无法使用。 所以，我们一般会在代码最开始，或 main 函数开头加一个 using namespace std，或者将所有需要的代码加上 std::。 另外，值得一提的是，如果在类中定义了和 C++ std 的同名成员函数，其他成员函数想调用 C++ std 函数的话，就可以加上 std::。如以下代码： 1234567891011121314class BigInteger&#123;// ...public: void rand() &#123; int n = std::rand(); //调用的是 cstdlib 中的 rand，而不是 BigIntegr::rand rand(); //调用的是 BigInteger::rand()，会发生递归 &#125; void foo() &#123; rand(); //调用的是 BigInteger::rand(); &#125;&#125; 作用域分解背景是这样的：在 ctype.h 中定义了 isspace，而在 locale 中定义了 std::isspace。 如果我们在前面定义了 using namespace std;，isspace 会指向 std::isspace。如果我们想调用 ctype.h 的 isspace 呢？就需要进行作用域分解： 1::isspace 对，在作用域分辨符 :: 前什么都不加，就起到了分解作用域的作用。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"C++ 模板","date":"2019-12-26T14:07:45.000Z","path":"cpp/cpp-grammar/cpp-template/","text":"C++ 最重要的特征之一就是 代码重用。 所以有了这么一个东西，可以 不受数据类型的影响。可以将数据类型也参数化（又叫参数化程序设计）。 于是就产生了了模板。从模板的字面义来看，有了模板应该就可以自动“产生”一堆类似的东西。 函数模板比如我们要写最大值的函数，可能要写： 123int max(int a, int b)&#123;return a &gt; b ? a : b&#125;;float max(float a, float b)&#123;return a &gt; b ? a : b&#125;;//更多的类型对应的函数。。。。 但是很麻烦，而且加大代码维护难度。 一个替代方案是宏定义，但是宏定义很容易出锅。 因此，C++ 把数据类型也作为一个参数： 12template &lt;class T&gt; T max(T a, T b)&#123;return a &gt; b ? a : b&#125;; 我好了。 这样，对于需要调用 max 函数的任意类，只要定义了类间的 &gt; 符号，即可直接运行。 对于比较 int 和 char 类型的，就不能调用上面的模板了。 其实，还可以以下写： 12template &lt;class X, class Y&gt; X max(X a, Y b)&#123;return a &gt; b ? a : b&#125;; 函数模板的匹配当一个函数有多个模板可以使用的时候，该使用哪个呢？ 比如以下代码： 123int max(int a, int b)&#123;cout &lt;&lt; \"Template Function Used!\\n\"; return a &gt; b ? a : b&#125;;template &lt;class T&gt; T max(T a, T b)&#123;cout &lt;&lt; \"Simple Function Used!\\n\"; return a &gt; b ? a : b&#125;; 对于 max(1, 2)，该调用谁呢？ 重载函数的最下匹配遵循以下优先原则： 完全匹配时，普通函数优于模板函数； 提升转换（如 char to int、short to int、float to double） 标准转换（如 int to char、long to double） 用户定义的类型转换 对于这部分，书上讲的貌似不是特别清楚但是期末了没时间深究了，先挖个坑 类模板由于 C++ 的 vector 是用类模板实现的，我们从 vector 入手讲讲模板。 定义过程应如下： 12345678template &lt;class T&gt; class vector&#123;private: T * beginPointer;public: T * begin(); //...&#125; 在类外定义 begin() 函数，应为： 12345//template &lt;模板形参列表&gt; 返回值 类名&lt;模板形参&gt; :: 函数名()template &lt;class T&gt; T * vector&lt;T&gt;::begin()&#123; return beginPointer;&#125;","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"Verilog HDL 速成手册","date":"2019-12-02T13:37:29.000Z","path":"others/verilog-hdl/","text":"数字逻辑要学这个，于是整理了一篇笔记。顺便说一下，如果打算写代码，我们使用的是 Xilinx ISE Design Suite 14.7。（安装下来占了 20G，我只是想入个 Verilog 的门。。。。） 先说一句，Verilog 是一门把电路板和程序结合在一起的语言，因此，学 Verilog，一定要把语法和实际电路联系起来！！！！这会很帮助理解的。 另外，和学习其他编程语言一样，如果在 Xilinx 写代码时出了问题，同样可以利用搜索引擎找到不少的答案。好用的网站有 Stack Overflow（被墙），Xilinx 论坛、知乎、CSDN（虽然很不想提他，但是在某些问题上确实还行）等。 Xilinx ISE Design Suite 14.7 安装这里是针对 Xilinx ISE 的安装过程。当然也可以使用更先进的 Vivado 进行开发，这里为了保持和学校机房统一，故安装 Xilinx ISE Design Suite 14.7。 到 Xilinx ISE 下载页面下载 14.7 的四个安装包，每个各 2 GB（注意不用下载 Windows 10 版的，我没有测试过能否成功破解）。官网可能需要注册账号，完善信息等。 （Windows 7 及以下电脑可忽略这一步）安装完成后，复制文件 X:\\Xilinx\\14.7\\ISE_DS\\ISE\\lib\\nt64\\libPortabilityNOSH.dll 并分别替换 X:\\Xilinx\\14.7\\ISE_DS\\ISE\\lib\\nt64\\libPortability.dll 和 X:\\Xilinx\\14.7\\ISE_DS\\common\\lib\\nt64\\libPortabilityNOSH.dll（参考百度知道） 在开始菜单启动 Manage Xilinx Lisenses，然后在 Manage Lisense 选项卡中点击 Load Lisense...，选择 license12x.lic，完成激活。（参考脚本之家） 概述（以下抄 PPT） Verilog HDL（以下简称 Verilog）是一种硬件描述语言，用于从算法级、门级到开关级的多种抽象设计层次的数字系统建模。 Verilog硬件描述语言的主要功能包括： 基本逻辑门，例如 and、or 和 nand 等都内在语言中。 用户定义原语（UDP）创建的灵活性。用户定义的原语既可以是组合逻辑原语，也可以是时序逻辑原语。（UDP太难，应该不考） 提供显式语言结构指定设计中的端口到端口的时延及路径时延和设计的时序检查。 可采用三种不同方式或混合方式对设计建模。这些方式包括： 行为描述方式——使用过程化结构建模； 数据流方式——使用连续赋值语句方式建模； 结构化方式——使用门和模块实例语句描述建模。 Verilog HDL 中有两类数据类型：网络数据类型和寄存器数据类型。网络类型表示构件间的物理连线，而寄存器类型表示抽象的数据存储元件。 等我学完这一章以后再来看看哪些不重要，可以删。 2019.12.4 更新：从八点删到四点（不算 UDP），不愧是我。 程序基础Verilog 由模块构成 一个复杂电路系统的完整 Verilog HDL 模型是由若干个 Verilog HDL 模块构成的，每一个模块又可以由若干个子模块构成。 （划重点，模块 module 思想） 模块是什么？ 用 Verilog HDL 描述的电路设计就是该电路的 Verilog HDL 模型，也称为模块，是 Verilog 的基本描述单位。一般来说一个模块可以是一个元件或者是一个更低层设计模块的集合。模块是并行运行的，通常需要一个高层模块通过调用其他模块的实例来定义一个封闭的系统，包括测试数据和硬件描述。 老师连 PPT 都不分行的吗，还得我手动分行。。。 代码结构Verilog 程序结构： 123456789101112131415161718192021// 模块声明module 模块名（端口列表） // 端口定义 input 输入端口 output 输出端口 inout 输入/输出端口 // 数据类型说明 wire reg parameter // 逻辑功能定义 assign always function task // ....endmodule 以上各部分解释： &lt;模块名&gt; 是模块唯一的标识符； &lt;端口列表&gt; 是由模块各个输入、输出和双向端口组成的一张端口列表，这些端口用来与其他模块进行通信； 数据类型说明部分：用来指定模块内用到的数据对象为寄存器型、存储器型还是连线型； 逻辑功能定义部分：通过使用逻辑功能语句来实现具体的逻辑功能。 语言要素 每个 Verilog HDL 程序源文件都以 .v 作为文件扩展名。 Verilog HDL 区分大小写。 Verilog HDL 程序的书写与 C 语言类似 一行可以写多条语句，也可以一条语句分成多行书写 每条语句以分号结束（注意是语句，begin end initial endmodule 语句后不加分号,module 要加分号！！！） 新行、制表符和空格没有特殊意义 间隔符包括空格字符 \\b、制表符 \\t、换行符 \\n 以及换页符。 注释和 C 语言完全相同，有两种风格： 12/*第一种形式：可以扩展至多行* ///第二种形式：在本行结束。 关于标识符： Verilog HDL 中的标识符 identifier可以是任意一组字母、数字、$ 符号和 _ (下划线)符号的组合，是赋予一个对象唯一的名字。标识符的第一个字符必须是字母或者下划线。标识符是区分大小写的。 关于关键字，类似于 C 语言的关键字概念，如 if int 等： Verilog HDL 语言内部使用的词称为关键字或保留字，保留字不能随便使用。所有的关键字都使用小写字母。 运算符部分见后。 程序结构模块声明123456module &lt;module_name&gt;(port_name1,…,port_namen);// ...// ...endmodule; module_name 为模块名（类似于 C 语言的函数名）。 port_name 为端口名（类似于函数的输入输出）， 端口定义123input &lt;input_port_name&gt;, ...&lt;other_inputs&gt;...; //输入output &lt;output_port_name&gt;,...&lt;other_outputs&gt;...; //输出inout &lt;inout_port_name&gt;,...&lt;other_inouts&gt;...; //双向端口 双向端口类似于输入以后被修改了，然后输出？ 注意： 在声明输入/输出时，要声明其数据类型是 net （网络）型还是 reg （寄存器）型；如果省略，默认为 net 类型中的 wire 类型。 无论是在网络说明还是寄存器说明中，网络或寄存器必须与端口说明中指定的宽度相同。 输入和双向端口只能为网络型。 也可以使用 C 语言风格的端口声明。 如果看不懂网络和寄存器的概念，请跳转到数据类型部分，看一眼概念，然后再回到这里来。 两种风格的声明示例： 1234567module addr(cout,sum,ina,inb,cin); input cin; input[7:0] ina,inb; output[7:0] sum; output cout; //...endmodule 123456module fulladd4(output reg [3:0] sum, output reg c_out, input [3:0] a,b,input c_in); //...endmodule [7:0] 是什么，请看向量。 变量声明见数据类型部分的变量声明。 数值和数据类型逻辑值为什么他 PPT 不写这个啊啊啊，很重要的啊 逻辑值有四种： 逻辑值 硬件电路中的条件 0 逻辑 0，条件为假 1 逻辑 1，条件为真 x 逻辑值不确定 z 高阻，浮动状态 注意 x 和 z 不分大小写。 常量 在程序运行过程中，不能改变的量称为常量 constants。Verilog HDL中有三类常量： 整型； 实数型；（不重要） 字符串型。（不重要） 整数常量整数型常量可以按如下两种方式描述： 1．简单的十进制格式（不重要） 这种形式的整数定义为带有一个 + （可省略）或 - 的数字序列。如： 描述 值 32 十进制数 32 -15 十进制数 -15 注意这样描述的整数是 32bit 的，在函数传参时如果将整数 0 传给了一个 1bit 的位会报错。因此我们更喜欢使用 1&#39;b0。 2．基数表示法（重要） 预警：这部分可能会有一点点无聊。 这种形式的整数格式为：&lt;size&gt;&lt;&#39;base_format&gt;&lt;number&gt;； &lt;size&gt;：常量的位的长度。 &lt;&#39;base_format&gt;：&#39; 加字母指明基数，如十进制 d、二进制 b、八进制 o、十六进制 h。 &lt;number&gt;：是基于基数的值的数字序列，可以出现 0123456789abcdefxz。 注意：三个部分都不区分大小写。 示例： 描述 值 5&#39;O37 用 5 位二进制存储的 八进制数 37（即十进制的 31） 4&#39;D2 用 4 位二进制存储的 十进制数 2 4&#39;d-4 非法，数值不能为负 -4&#39;d4 合法 8 &#39;h 2A 合法，在位长和 &#39; 之间、基数和数值之间允许出现空格 3&#39; b001 非法，&#39; 和基数之间不允许出现空格 (2+3)&#39;b10 非法，位长不能够为表达式 9&#39;o721 9位二进制显示的八进制数 8&#39;hAF 8位二进制显示的十六进制数 对于一个 x 和 z，在不同基数的长度也不同：在二进制中长度为 1，八进制中长度为 3，十六进制中长度为 4。 描述 值 4&#39;b100x 即二进制的 100x 8&#39;h1x 即二进制的 0001xxxx 当数字序列 &lt;number&gt; 的长度小于 &lt;size&gt; 时，就会用 0、x、或z 来填充。具体用谁填充，取决于最高位是 x、z、还是其他。 描述 值 7&#39;Hx 7位 x，即 xxxxxxx 4&#39;hZ 4位 z，即 zzzz 10&#39;b10 左边添 0 占位，即0000000010 10&#39;bx0x1 左边添 x 占位，即 xxxxxxx0x1 当数字序列 &lt;number&gt; 的长度大于 &lt;size&gt; 时，就会取 &lt;size&gt; 的位宽而把 &lt;number&gt; 的高位截断。 3&#39;b10010011 == 3&#39;b0115&#39;H0FFF == 5&#39;H1F 无聊的部分结束。 还有实数、字符串类型，但是不考，故删掉了。 数据类型理解 Verilog 数据类型非常重要！！！因为这是它和 C 等编程语言的区别中最大的一点。 数据类型上，分为 net（线网型）和 reg（寄存器型）。 reg 类型，是使用寄存器实现，用于存储数据，类似于电脑 CPU 的寄存器、内存等等。 寄存器型变量与网络型数据的区别主要在于：寄存器型变量保持最后一次的赋值，而 wire 型数据需要有连续的驱动。寄存器型变量只能在 initial 或 always 内部被赋值。 而 net 分为 wire、wand、wor 等等，由于 wire 类型的线网声明最常用，所以 net 和 wire 概念经常互换使用。就是说 wand 和 wor 都不重要 而 wire 是什么呢？翻译成 连线 非常抽象，让人难以理解。其实呢，wire 是个很常见的东西： 想象一个“与门”，它有两个输入 A 和 B，输出 F。在这里 A、B、F 都是电线，他们也就是所谓的 线网 或 wire。 合理猜测，对于线网型和寄存器型，将是两种风格的编程；前者是描述各种“门”，后者是类似于 C 语言的赋值、赋值、再赋值的编程。 确实如此。概述的第 5 点提到， 行为描述方式——使用过程化结构建模；数据流方式——使用连续赋值语句方式建模；结构化方式——使用门和模块实例语句描述建模。 行为描述方式即是使用赋值、寄存器、if、for 等流程的 C 语言风格。（面向过程编程） 结构化即是描述各个门，使用线网类型的结构化风格（面向门结构编程）。 至于数据流，是使用 out=~(A&amp;B) 这种赋值形式替代了门结构的描述（面向数据编程），也是使用线网类型编程 当然也可以混合编程。 等我学完这一章以后再来看看是不是这样。 2019.12.4 更新：改掉了不对的地方。。。顺便总结了面向xx编程。 最后稍微提一下整数 integer 类型。 在算术运算中被视为二进制补码形式的有符号数。整型数据与 32 位的寄存器型数据在实际意义上相同，只是寄存器型数据被当做无符号数来处理。需要注意的是虽然 interger 有位宽度的声明，但是 integer 型变量不能作为位向量访问。D[6] 和 D[16:0] 的声明都是非法的。在综合时，integer 型变量的初始值是 x 其实用的不多，毕竟只是很简略的讲一下 Verilog，寄存器已经够入门使用了。 另外还有实数型、时间型变量，用的不多，就这么提一笔就了了。 变量声明用到变量前需要声明。 顺便再提一遍，要是没有写类型，默认为 wire。 示例： 12345678integer i,j;integer[31:0] D;reg cout; //定义信号 cout 的数据类型为 regreg[7:0] out; //定义信号 out 的数据类型为8位 regwire A,B,C,D,F; //定义信号 A,B,C,D,F 为 wire（连线）型wire [7:0] data; //声明一个 8bit 宽的网络型 示例：寄存器变量的声明及使用 123456789101112131415module mult(clk, rst, A_IN, B_OUT);input clk,rst,A_IN; output B_OUT;reg arb_onebit = 1'b0;always @(posedge clk or posedge rst)begin if (rst) arb_onebit &lt;= 1'b1; else arb_onebit &lt;= A_IN;end B_OUT &lt;= arb_onebit;endmodule 看不懂代码的更多细节，可以暂时放一下。 参数类似于 C 语言的 #define 宏定义。 参数不是变量，而是常量。用参数声明一个可变常量，常用于定义延时及宽度等参数。 参数定义的例子： 12parameter BUS_WIDTH=8;reg [BUS_WIDTH-1:0] my_reg; 示例：参数的声明及使用 12345678910111213141516module lpm_reg (out, in, en, reset, clk); parameter SIZE=1; input in, en, reset, clk; output out; wire [SIZE-1:0] in; reg [SIZE-1:0] out; always @(posedge clk or negedge reset) begin if (!reset) out&lt;=1’b0; else if(en) out&lt;=in; else out &lt;= out; endendmodule 向量向量 (vector) 就是数组。 向量的声明示例： 1wire [7:0] data; 该声明表示一个位宽为 8 的 wire 型数据，名为 data。 1reg [63:0] array1 [255:0][7:0] 该声明表示一个 256*8 的 reg 型数组，其中的每个数据是 64 位宽度。 1wire [7:0] array2 [0:15][0:255][0:15] 该声明表示一个三维的数组，表示 16 个 256*16 的 wire 型数据，每个数据 8 位宽度。 1wire [2:0] a, b; 声明的 a b 都是 3bit 的。不过对于入门，建议分行写 wire [2:0] a; wire [2:0] b;，而不用一些易混淆的语法。 看了几个例子，应该比较懂了。数组用的不多，倒是变量的位数用的比较多。 声明变量位数是从高到0！！！ 向量的赋值的两个示例： 123data[7:0] = input[7:0]data[7:0] = 0; 注意一定要指明对应位。 Verilog 表达式操作符 Verilog HDL 中的操作符按功能可以分为下述类型：算术操作符、关系操作符、相等操作符、逻辑操作符、按位操作符、归约操作符、移位操作符、条件操作符、连接和复制操作符；按运算符所带操作数的个数可分为三类：单目操作符、双目操作符和三目操作符。 太长不看。 操作符从高到低的优先级（太长不看）： 操作符 名字 +、- 一元加、减 ! 一元逻辑非 ~ 一元按位求反 *、/、% 乘、除、取模 +、- 二元加、二元减 &lt;&lt;、&gt;&gt; 左移、右移 &lt;、&lt;=、&gt;、&gt;= 小于、小于等于、大于、大于等于 ==、!= 逻辑相等、逻辑不等 ===、!== 全等、非全等 &amp;、^、^~ (或~^)、| 按位与、异或、异或非、或 &amp;&amp;、|| 逻辑与、逻辑或 ? : 条件操作符 注意，wire 和 reg 之间不能做任何操作（加减、逻辑运算、相等……）。如果需要进行操作，可以新建一个 always 语句，将 wire 赋给另一个 reg。如下： 123456789//尝试比较 reg1 和 wire1reg reg1, reg2, T;wire wire1;always @(*) reg2 = wire1;initial T= (reg1 == reg2); //需要比较的地方 延迟表达式 Verilog HDL 中，延迟表达式的格式为用圆括号括起来的三个表达式，这三个表达式之间用冒号分隔开。三个表达式一次代表最小、典型、最大延迟时间值。如(a:b:c)+(d:e:f)表示最小延迟值为 a+d 的和，典型延迟值为 b+e 的和，最大延迟值为 c+f 的和。 讲完了。有什么用？不知道。 Verilog 语言模块描述方式前面是一堆非常无聊的基础。下面开始重点。 Verilog 分为三大流派：行为级建模、结构级建模，数据流级建模。 模块大致可以按以下三类抽象级别来进行描述。 行为级或算法级的描述方式（行为级建模）； 数据流描述方式（数据流级建模）； 门级描述方式（门级建模）； 怎么又回到概述第五点了。。。 行为描述方式——使用过程化结构建模；数据流方式——使用连续赋值语句方式建模；结构化方式——使用门和模块实例语句描述建模。 行为描述方式即是使用过程语句、赋值、寄存器、if、for 等流程的 C 语言风格。（面向过程编程） 结构化即是描述各个门，使用线网类型的结构化风格（面向（门）结构编程）。 至于数据流，是使用 out=~(A&amp;B) 这种连续赋值形式替代了门结构的描述（面向数据编程），也是使用线网类型编程 这便是 Verilog 三种不同流派的语法。下面，我们就用三个大标题，分别来聊这三种不同的模块。 模块的结构级描述结构级就相当于把每个元件描述好，具体仿真以后会发生什么，得看元件的搭配。如下面的直接以逻辑门为单位描述。 门级赋值语句门单元赋值的 Verilog HDL 描述像下面这样： 1nand(y,a,b,c,d); 该语句实现了与非门 y=(a·b·c·d)&#39;。 注意Verilog 门级赋值语句的输出在前面，输入在后面 Verilog HDL中提供下列内置基本门： 多输入门：and,nand,or,nor,xor,xnor 多输出门：buf,not（略） 三态门：bufif0,bufif1,notif0,notif1（略） 上拉、下拉电阻：pullup,pulldown（略） 语法格式如下： 123gate_type [instance_name1] (term11,term12,...,term1N)类型 [命名](参数) 其中 命名 是可省的。 多输入门顾名思义，多输入、一个输出的门。 有 and,nand,or,nor,xor,xnor。 注意，参数的输出在前，输入在后！！！ 一堆示例： 1and RBX (Sty,Rib,Bro,Qit,Fi); 该门实例语句是四输入与门，单元名为 RBX（可省），输出为 Sty，4 个输入为 Rib、Bro、Qit 和 Fix。 1xor (Bar,Bud[0],Bud[1],Bud[2]); 该门实例语句是异或门的具体实例，没有单元名。它的输出是 Bar，三个输入分别为 Bud[0]、Bud[1] 和 Bud[2]。 多输出门一堆示例： 1buf B1 (Fan[0],Fan[1],Fan[2],Fan[3],Clk); 该门实例语句中，Clk是缓冲门的输入，门B1有4个输出：Fan[0]到Fan[3]。 1not N1 (PhA,PhB,Ready); 该门实例语句中，Ready是非门的唯一输入端口。门N1有两个输出：PhA和PhB。 示例123456789101112`include \"full_add_1.v\"module add4_1(sum,cout,a,b,cin); input cin; input[3:0] a,b; output[3:0] sum; output cout; full_add1 f0(a[0],b[0],cin,sum[0],cin1); full_add2 f1(a[1],b[1],cin1,sum[1],cin2); full_add3 f2(a[2],b[2],cin2,sum[2],cin3); full_add4 f3(a[3],b[3],cin3,sum[3],cout);endmodule 示例：一位半加器： 1234567891011module halfadd (X, Y, C, S); input X, Y; output C, S; wire S1, S2, S3; nand NANDA(S3,X,Y); nand NANDB(S1,X,S3); nand NANDC(S2,S3,Y); nand NANDD(S,S1,S2); assign C=S3;endmodule 模块的数据流级描述 数据流描述方式，也称为RTL（寄存器传输级）描述方式。数据流描述方式类似于布尔方程，它能够比较直观地表达低层逻辑行为。用数据流描述方式对一个设计建模的最基本的机制就是使用连续赋值语句。在连续赋值语句中，某个值被指派给网络变量。 连续赋值语句也可以使用连续赋值语句实现相同的与非功能： 123assign [delay] LHS_net=RHS_expression;assign y = ~(a&amp;b&amp;c&amp;d); // y 必须是 wire 型变量 为什么叫连续赋值语句？ 该连续赋值语句表示，输出 y 的变化跟随输入 a、b、c、d 的变化而变化，反映了信号变化的连续性。右边表达式使用的操作数无论何时发生变化, 左边表达式都重新计算, 并且在指定的时延后被赋予左边的网络变量。时延定义了右边表达式操作数变化与赋值给左边表达式之间的持续时间。如果没有定义时延值, 默认时延为 0。 不要手滑把 assign 放在 initial 或 always 里。assign 是门级描述的等价形式。 示例： 2-4 解码器的 Verilog HDL 数据流描述 12345678910111213`timescale 1ns/1nsmodule Decoder2x4(A,B,EN,Z); input A,B,EN; output [0:3] Z; wire Abar,Bbar; assign #1 Abar =~A; assign #1 Bbar =~B; assign #2 Z[0]=~(Abar &amp; Bbar &amp; EN); assign #2 Z[1]=~(Abar &amp; B &amp; EN); assign #2 Z[2]=~(A &amp; Bbar &amp; EN); assign #2 Z[3]=~(A &amp; B &amp; EN);endmodule 以反引号 ` 开始的第一条语句是编译器指令。编译器指令`timescale将模块中所有时延的单位设置为 1ns，时间精度为 1ns。例如，在连续赋值语句中时延值 #1 和 #2 分别对应时延 1ns 和 2ns。 模块 Decoder2x4 有 3 个输入端口和 1 个 4 位输出端口。网络类型说明了两个连线型变量 Abar 和 Bbar 。此外，模块包含 6 个连续赋值语句。 示例的详细说明（太长不看）： 当EN在第5ns变化时,语句3、4、5和6执行。这是因为EN是这些连续赋值语句中右边表达式的操作数。Z[0]在第7ns时被赋予新值0。当A在第15ns变化时, 语句1、5和6执行。执行语句5和6不影响Z[0]和Z[1]的取值。执行语句5导致Z[2]值在第17ns变为0。执行语句1导致Abar在第16ns被重新赋值。由于Abar的改变，反过来又导致Z[0]值在第18ns变为1。 更多的关于 #t 的解释，请看initial 语句的时延控制部分。 模块的行为级描述先给一个示例：8 位计数器的 Verilog HDL 行为级描述 123456789module counter8(clk,clr,out); input clk,clr; output reg[7:0] out; always @(posedge clk or posedge clr) begin if(clr) out&lt;=0; else out&lt;=out+1; endendmodule 语句块 语句块提供将两条或更多条语句组合成语法结构上相当于一条语句的机制。在 Verilog HDL 中有两类语句块，即： 顺序语句块 begin…end：语句块中的语句按给定次序顺序执行。 并行语句块 fork…join：语句块中的语句并行执行。（不常用） 注意，begin…end 或 fork…join 相当于 C 语言的 {…}（毕竟都是叫代码块），他们俩一个是顺序、一个是并行。 示例：顺序语句块的 Verilog HDL 描述 12345678begin#2 Stream=1;#5 Stream=0;#3 Stream=1;#4 Stream=0;#2 Stream=1;#5 Stream=0;end 假定顺序语句块在第 10 个时间单位开始执行。两个时间单位后第 1 条语句执行，即第 12 个时间单位。此执行完成后，下 1 条语句在第 17 个时间单位执行（延迟 5 个时间单位）。然后下 1 条语句在第 20 个时间单位执行，以此类推。 示例： 12345begin Pat=Mask|Mat; @ (negedge Clk) FF=&amp; Pat;end 在该例中，第 1 条语句首先执行，然后执行第 2 条语句。当然，第 2 条语句中的赋值只有在 Clk 上出现负沿时才执行。 这么说来 negedge Clk 就是在 Clk 上出现负沿时才执行。相对应的 posedge Clk 就是在 Clk 上出现正沿时才执行。 过程语句 Verilog HDL 中的多数过程模块都从属于以下两种过程语句： initial 语句 always 语句一个模块中可以包含任意多个 initial或 always 语句。这些语句相互并行执行，即这些语句的执行顺序与其在模块中的顺序无关。一个 initial 语句或 always 语句的执行产生一个单独的控制流，所有的 initial 和 always 语句在 0 时刻开始并行执行。 所有语句（除一开始的声明）都必须包含在 initial 或 always 里。 initial 语句从英文上看也知道，initial（初始化）语句只在最开始执行一次，即在0时刻开始执行。 initial 语句的语法如下： 123456initial begin statement1; //描述语句1 statement2; //描述语句2 //...end 即使像下面这么写， a 在 0 时刻会被赋值为 2。 1234a;//...initial a=2; 当然，initial 语句也可以带有时延控制： 1234reg Curt;...initial #2 a = 1; 寄存器变量 a 在时刻 2 被赋值为 1。initial 语句在 0 时刻开始执行，在时刻 2 完成执行。 顺便提一句，这里的 2 可以用变量替代，还可以用延迟表达式。 #t 的含义应为：等待 t 个单位时间以后执行（而不是在 t 时刻执行）。也就是说，如果有两个 # 叠加，后者语句的执行时间应是二者时间的叠加。在语句块里会有一个例子说明。在连续赋值语句有一个更详细的例子说明。 initial 语句通常用于仿真模块对激励向量的描述，或用于给寄存器变量赋初值，它是面向模拟仿真过程的语句，不能被综合。 顺便一提，顺序过程 begin、end 最常使用在进程语句中。 下面是更复杂的、带有顺序过程的 initial 语句： 123456789101112parameter SIZE = 1024;reg [7:0] RAM [ 0:SIZE- 1 ];reg RibReg;initialbegin: SEQ_BLK_A integer Index; RibReg = 0; for (Index = 0; Index &lt; SIZE; Index = Index + 1) RAM [Index] = 0;end 这一 initial语句在执行时将所有的内存初始化为 0。 SEQ_BLK_A 是顺序过程的标记；如果过程中没有局部说明部分，不要求这一标记。 always 语句 与 initial 语句相反，always 语句重复执行。 与 initial 语句类似，always 语句语法如下： 1234567always @(敏感信号表达式)begin //过程赋值 //if-else,case语句 //while,repeat,for循环语句 //task,function调用end always@(*) 在功能上类似于无条件的 while(true)，而 always @() ；类似于有条件的 while。 注意，在 testbench （仿真）的过程中，always(*) 是错误的写法，只能写 always；而在编程文件中，只能写 always(*)，always 这样是错误的 always 本身只影响到下面的一句话，配合 begin…end （即代码块）才能够实现装很多句话。 示例：always 过程实现计数器的过程 12345always @(posedge clk)begin if(reset) out&lt;=0; else out&lt;=out+1;end 示例：always 实现时钟信号（源代码链接） 123456789101112module clock(output reg clock)//在零时刻把clock变量初始化initial clock = 1'b0;//每半个周期把clock信号翻转一次always #10 clock=~clock;initial #1000 $finish; //1000个时间单位后，停止仿真endmodule always 语句有一个过程性赋值。因为 always 语句重复执行，并且在此例中没有时延控制，过程语句将在 0 时刻无限循环。因此，always 语句的执行必须带有某种时序控制。 示例：always 语句用于 4 选 1 开关 123456789101112131415module mux4 (sel, a, b, c, d, outmux);input [1:0] sel;input [1:0] a, b, c, d;output [1:0] outmux;reg [1:0] outmux;always @(sel or a or b or c or d)begin case (sel) 2'b00: outmux = a; 2'b01: outmux = b; 2'b10: outmux = c; default: outmux = d; endcaseendendmodule 这里涉及到了 case 语句。也是和 C 语言比较类似。 示例：敏感信号为时钟沿的 always 语句的 Verilog HDL 描述 1234567891011module EXAMPLE (DI, CLK, RST, DO);input [7:0] DI;input CLK, RST;output [7:0] DO;reg [7:0] DO;always @(posedge CLK or posedge RST) if (RST==1'b1) DO&lt;=8'b00000000; else DO&lt;=DI;endmodule 过程赋值语句（行为级）一段话分了五页 ppt 预警 过程赋值语句的硬件实现是：从赋值语句右边提取出的逻辑，用于驱动赋值语句左边的变量（必须是 reg型）。有两种类型的过程赋值语句： 阻塞赋值语句（Blocking Assignment Statement） 非阻塞赋值语句（Non-blocking Assignment Statement） 阻塞赋值语句 以赋值操作符 = 来标识的赋值的操作称为阻塞型过程赋值语句，阻塞赋值语句可以简述为：在一个 always 块中，语句是按从上到下顺序执行的。它具有如下特点： 顺序块内的各条阻塞语句以它们在顺序块中的排列先后次序依次得到执行；而并行块中的各条阻塞赋值语句则是同时得到执行。 阻塞赋值语句的执行过程是：首先计算右端赋值表达式的取值，然后立即将计算结果赋值给 = 左端的被赋值变量。 这种语句更多的用在行为仿真和时序仿真的过程中。 非阻塞赋值语句 以赋值操作符 &lt;= 来标识的赋值操作的也是出现在 initial 和 always 块语句中，在非阻塞赋值语句中，赋值号 &lt;= 左边的赋值变量也必须是 reg 型变量，其值不像在过程赋值语句那样，语句结束时即刻得到，而在该块语句结束才可得到。 非阻塞赋值语句的特点如下： 在 begin-end 顺序语句块中，一条非阻塞赋值语句块的执行不会阻塞下一条语句的执行，即在本条非阻塞赋值语句对应的赋值操作执行完毕之前，下一条语句才可以开始执行。 仿真过程在遇到非阻塞型赋值语句后，首先计算其右端赋值表达式的值，然后要等到当前仿真时间结束时再将该计算结果赋值给被赋值变量，即非阻塞赋值操作时在同一仿真时刻上的其他普通操作结束之后才得到执行的。因此非阻塞赋值语句的这个特点是不同于阻塞型赋值语句的执行时序特点的。 这写的什么玩意。看不懂看不懂。 例子：非阻塞赋值的 Verilog HDL 描述 12345678module block(a3,a2,a1,clk);input clk,a1; output reg a3,a2;always @(posedge clk)begin a2&lt;=a1; a3&lt;=a2;end endmodule 例子：阻塞赋值的 Verilog HDL 描述 12345678module block(a3,a2,a1,clk);input clk,a1; output reg a3,a2;always @(posedge clk)begin a2=a1; a3=a2;end endmodule 只有赋值符号不同。 在这里第一次使用了 Xilinx 编程测试 将上面两段代码分别进行仿真测试，测试代码如下： 1234567initial begin a1 = 1; clk = 0; #100; clk = 1;end 测试的结果显示： 对于非阻塞型的 &lt;=，100ns 后 a2 变为 1，而 a3 仍为 x。阻塞型的 =，100ns 后 a2 和 a3 都变为 1。 这很好的解释了二者的区别，简单的来说就是： &lt;= 是并行执行的，= 是顺序执行的。 并行的那个是非阻塞，顺序执行的是阻塞。记一下就行。 顺便，&lt;= 和 = 这些赋值都是 reg 的玩意。wire 没有赋值的概念，只能把他接到某一个门的输出。 wire 可以使用门，或者数据流 assign a = 1&#39;b0;。 流程控制if-else写法和 C++ 一样，只是判断执行标准时，如果是 0zx 之一，就不执行。 注意，reg 和 wire 不能直接作比较。解决方案参考 操作符。 示例：使用 if-else 实现 D 触发器 12345678910module v_registers_2 (C,D,CLR,Q); input C, D, CLR; output Q; reg Q; always @(negedge C or posedge CLR) begin if (CLR) Q&lt;=1'b0; else Q&lt;=D; endendmodule case和 C 语言的写法稍微有点不同，用法一样。不需要 break，有 default。 示例：case 语句实现多路选择器的 Verilog HDL 语句 12345678910111213module mux4 (sel, a, b, c, d, outmux); input [1:0] sel,a,b.c,d; output reg [1:0] outmux; always @(sel or a or b or c or d) begin case (sel) 2'b00: outmux=a; 2'b01: outmux=b; 2'b10: outmux=c; default: outmux=d; endcase endendmodule 示例：case 语句实现 3-8 译码器的 Verilog HDL 语句 12345678910111213141516171819module v_decoders_1 (sel, res); input [2:0] sel; output [7:0] res; reg [7:0] res; always @(sel or res) begin case (sel) 3'b000 : res=8'b00000001; 3'b001 : res=8'b00000010; 3'b010 : res=8'b00000100; 3'b011 : res=8'b00001000; 3'b100 : res=8'b00010000; 3'b101 : res=8'b00100000; 3'b110 : res=8'b01000000; default : res=8'b10000000; endcase endendmodule 居然是枚举。。。 单篇笔记 1000 行纪念。 对于 z 和 x，还有 casex 和 casez。用法和上面一样。示例： 123456casez(Mask) 4'b1??? : Dbus[4] = 0; 4'b01?? : Dbus[3] = 0; 4'b001? : Dbus[2] = 0; 4'b0001 : Dbus[1] = 0;endcase casez 语句表示： 如果 Mask 的第 1 位是 1（忽略其它位），那么将 Dbus[4] 赋值为0； 如果 Mask 的第 1 位是 0 ，并且第 2 位是 1（忽略其它位），那么 Dbus[3] 被赋值为 0； 依此类推。 casex 和 casez的区别在于： casez treats all the z values in the case expression as don’t cares while casex treats all the x and z values in the case expression as don’t cares. forever字如其人。 示例：forever 实现时钟 12345initial begin Clock=0; #5 forever #10 Clock = ~Clock;end 这一实例产生时钟波形：时钟首先初始化为 0 ，并一直保持到第 5 个时间单位。此后每隔 10 个时间单位，Clock 反相一次。 注意，在过程语句中必须使用某种形式的时序控制（如 #10），否则， forever 循环将在 0 时后永远死循环下去。 它和 always 的区别是，always 的级别更高，但功能上貌似可以互相替代。 repeat循环的时候直接指定了重复次数。xz 被视为 0。 示例： 1234repeat (Count) Sum=Sum+10;repeat (Shift By) P_Reg=P_Reg &lt;&lt; 1; forever 相当于 repeat(infinity)（当然，是没有这种写法的） while和 C 语言一样。另外，xz 被视为 0。 示例：（顺序查找 0？） 123456789101112131415parameter P = 4;always @(ID_complete)begin : UNIDENTIFIED integer i; reg found; unidentified=0; i=0; found = 0; while (!found &amp;&amp; (i &lt; P)) begin found = !ID_complete[i]; unidentified[i] = !ID_complete[i]; i=i+1; endend for和 C 语言一样。 示例： 12345678910111213141516module countzeros (a, Count); input [7:0] a; output reg[2:0] Count; reg [2:0] Count_Aux; integer i; always @(a) begin Count_Aux = 3'b0; for (i = 0; i &lt; 8; i = i+1) begin if (!a[i]) Count_Aux = Count_Aux+1; end Count = Count_Aux; endendmodule 示例：输入 8bit wire 类型数据，判断其是否为质数 12345678910111213141516171819202122232425`timescale 1ns / 1psmodule hw36(N, F);input [7:0] N;output reg F;reg [7:0]N_reg;reg [7:0]i; always @(N) begin N_reg[7:0] = N[7:0]; if (N_reg &lt;= 1) F = 0; else begin F = 1; for (i = 2; i &lt; N_reg &amp;&amp; F == 1; i = i + 1) if (N_reg % i == 0) F = 0; end end endmodule 用户自定义基本元件PPT 第 128-144 页。感觉不会考这么难。 Verilog 系统任务和函数PPT 第 145-147 页。感觉不会考这么难。 Verilog 用户定义任务和函数PPT 第 148-163 页。感觉不会考这么难。 完结撒花。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Verilog","slug":"Verilog","permalink":"https://blog.lyh543.cn/tags/Verilog/"}]},{"title":"迭代法求解线性方程组","date":"2019-11-30T01:31:22.000Z","path":"mcm/iterative-method-in-solving-system-of-linear-equations/","text":"大一线代学的高斯消元法不适合高阶线性方程组。因此发展新的方法——迭代法。 迭代法的基本概念设方程组 $Ax=f$ 有唯一解 $x^*$。可将方程组变形为： $$x=Bx+f$$ 由此建立迭代公式： $$x^{(k+1)}=Bx^{(k)}+f \\quad (k=0,1,2,…)$$ 再给定 $x^{(0)}$，即可得到近似解序列 ${x^{(k)}}$。 若 $\\lim\\limits_{k\\to\\infty}x^{(k)}=x^*$，有 $x^*=Bx^*+f$（$x^*$为不动点），则称迭代法是收敛的，否则是发散的。 $B$ 称为迭代矩阵，$B$ 的取法不同，就是各种迭代法的区别。各种方法是否收敛？速度如何？如何进行误差估计？这就是我们要研究的问题。 迭代法适用于解大型稀疏方程组。 雅可比迭代法最简单的方法是将每个方程组左边留一个变量，其他全部丢到右边，这就是一个最简单的迭代矩阵。 具体的来说，对于方程组中第 $i$ 个方程， $$\\sum_{j=1}^n a_{ij}x_j = b_i \\quad (i=1,2,…,n)$$ 我们把 $a_{ii} x_i$ 留在左边，其他丢到右边，再两边同时除以 $a_{ii}$，得到迭代公式为： $$x_i^{(k+1)} = \\frac{1}{a_{ii}} [b_i - \\sum_{j = 1}^{i-1}a_{ij}x_j^{(k)} - \\sum_{j = i+1}^{n}a_{ij}x_j^{(k)}]$$ （迭代公式中后面两项其实可以合并为一个求和符号，但是这里分开写，是为了给后面做铺垫） 初始点任取，进行迭代即可。 不过呢，这玩意不一定收敛。 高斯——赛德尔迭代法注意到，如果上面如果收敛，一般来说，新值比旧值优秀。所以我们尽可能使用新的值，把第 $k+1$ 次迭代前面算出来的数用到该次迭代中（迭代表达式中只改了一个上标）： $$x_i^{(k+1)} = \\frac{1}{a_{ii}} [b_i - \\sum_{j = 1}^{i-1}a_{ij}x_j^{(k+1)} - \\sum_{j = i+1}^{n}a_{ij}x_j^{(k)}]$$ 理论上，如果使用两个方法都收敛，高斯——赛德尔方法会略快于雅可比迭代。 雅可比迭代法的矩阵表示（这一段的公式也太长了叭） 将 $Ax=b$ 的 $A$ 分裂 $$ A= D - U -L $$$$ D = \\left[\\begin{matrix}a_{11} \\\\&amp; a_{22} \\\\&amp; &amp; \\ddots \\\\&amp; &amp; &amp; a_{nn}\\end{matrix}\\right]\\quadL = -\\left[\\begin{matrix}0 \\\\a_{21} &amp; 0 \\\\\\vdots &amp; \\ddots &amp; \\ddots \\\\a_{n1} &amp; \\cdots &amp; a_{n,n-1} &amp; 0\\end{matrix}\\right]\\quadU = -\\left[\\begin{matrix}0 &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\&amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\&amp; &amp; 0 &amp; a_{n-1,n} \\\\&amp; &amp; &amp; 0\\end{matrix}\\right]$$ 有： $$ AX = b \\Rightarrow DX^{(k+1)} = (U+L)X^{(k)} + b \\\\X^{(k+1)} = D^{-1}(U+L)X^{k} + D^{-1}b \\\\$$ 记 $$B_J=D^{-1}(U+L) \\qquad f_J=D^{-1}b \\\\X^{(k+1)}=B_JX^{(k)}+f_J$$ 进一步计算 $B_J$ 和 $f_J$： $$\\begin{aligned}B_J &amp;=\\begin{bmatrix}a_{11} &amp; &amp; &amp; \\\\&amp; a_{22} &amp; &amp; \\\\&amp; &amp; {\\ddots} &amp; \\\\&amp; &amp; &amp; {a_{n n}}\\end{bmatrix}^{-1}\\begin{bmatrix}{0} &amp; {-a_{12}} &amp; \\cdots &amp; {-a_{1 n}} \\\\{-a_{21}} &amp; {0} &amp; \\cdots &amp; {-a_{2 n}} \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\{-a_{n 1}} &amp; {-a_{n 2}} &amp; \\cdots &amp; {0}\\end{bmatrix} \\\\&amp;=\\begin{bmatrix}0 &amp; -a_{12}/a_{11} &amp; \\cdots &amp; -a_{1n}/a_{11} \\\\-a_{21}/a_{22} &amp; 0 &amp; \\cdots &amp; -a_{2n}/a_{22} \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\-a_{n1}/a_{nn} &amp; -a_{n2}/a_{nn} &amp; \\cdots &amp; 0\\end{bmatrix}\\end{aligned}$$ $$f_J=D^{-1}b=\\begin{bmatrix}b_1/a_{11} \\\\b_2/a_{22} \\\\\\vdots \\\\b_n/a_{nn}\\end{bmatrix}$$ 高斯-赛德尔迭代法的矩阵表示高斯-赛德尔的矩阵会复杂一点，因为上面方法被求逆的矩阵是一个对角矩阵，而这里是一个下三角矩阵。 $$(D-L)X^{(k+1)} = UX^{(k)} + b \\\\X^{(k+1)} = (D-L)^{-1}UX^{k} + (D-L)^{-1}b$$ 记 $$B_{G-S}=(D-L)^{-1}U \\qquad f_{G-S}=(D-L)^{-1}b \\\\X^{(k+1)}=B_{G-S}X^{(k)}+f_{G-S}$$ 进一步计算 $B_{G-S}$ 和 $f_{G-S}$ 有（其实没有必要往下写了）： $$B_{G-S} =\\begin{bmatrix}a_{11} &amp; &amp; &amp; \\\\a_{21} &amp; a_{22} &amp; &amp; \\\\{\\vdots} &amp; {\\vdots} &amp; {\\ddots} &amp; \\\\a_{n1} &amp; a_{n2} &amp; {\\cdots} &amp; {a_{n n}}\\end{bmatrix}^{-1}\\begin{bmatrix}{0} &amp; {a_{12}} &amp; \\cdots &amp; {a_{1 n}} \\\\&amp; {0} &amp; \\ddots &amp; {a_{2 n}} \\\\&amp; &amp; \\ddots &amp; \\vdots \\\\&amp; &amp; &amp; {0}\\end{bmatrix}$$ $$f_J=D^{-1}b=\\begin{bmatrix}a_{11} &amp; &amp; &amp; \\\\a_{21} &amp; a_{22} &amp; &amp; \\\\{\\vdots} &amp; {\\vdots} &amp; {\\ddots} &amp; \\\\a_{n1} &amp; a_{n2} &amp; {\\cdots} &amp; {a_{n n}}\\end{bmatrix}^{-1}\\begin{bmatrix}b_1 \\\\b_2 \\\\\\vdots \\\\b_n\\end{bmatrix}$$ 向量的收敛性范数知识请看范数简介 迭代的收敛性在基本概念中提到，迭代即是 $$\\lim_{k \\to \\infty}X^{(k)} = X^*\\Leftrightarrow\\lim_{k \\to \\infty}\\| X^{(k)} - X^* \\|_2 = 0$$ 令 $\\varepsilon^{(k)} = X^{(k)} - X^*$，则上述结论可以写为 $$\\lim_{k \\to \\infty}X^{(k)} = X^*\\Leftrightarrow\\lim_{k \\to \\infty}\\| \\varepsilon^{(k)} \\|_2 = 0$$ （利用向量范数的等价性，我们还可以进一步推出上述结论对任意范数同样成立） 接下来，我么换一个角度，看从迭代法的定义还能推出什么关于 $\\varepsilon^{(k)}$ 的结论： $$X^{(k+1)}=BX^{(k)}+f \\quad (k=0,1,2,…) \\\\X^* = BX^* + f \\\\X^{(k+1)} - X^* = B(X^{(k)}-X^*)$$ 则有： $$\\varepsilon^{(k)} = B \\varepsilon^{(k-1)} \\quad (k=1,2,3,…)$$ 递推一下， $$\\varepsilon^{(k)} = B \\varepsilon^{(k-1)} = B^2 \\varepsilon^{(k-2)} = \\cdots = B^k \\varepsilon^{(0)}$$ 得出结论： $$ \\lim_{k\\to\\infty}\\varepsilon^{(k)} = \\mathbf{0} \\Leftrightarrow \\lim_{k\\to\\infty} B^k = \\mathbf{0}$$ 结论非常漂亮，就是没法用（逃 于是出现了范数： $$ \\lim_{k\\to\\infty}\\varepsilon^{(k)} = \\mathbf{0} \\Leftarrow \\|B\\| &lt; 1 $$ 证明如下： 由 $\\varepsilon^{(k)} = B \\varepsilon^{(k-1)}$ 和范数的相容性，有 $$\\| \\varepsilon^{(k)} \\| \\leq \\|B \\| \\| \\varepsilon^{(k-1)} \\| \\\\\\| \\varepsilon^{(k)} \\| \\leq \\|B \\|^k \\| \\varepsilon^{(0)} \\|$$ 由于 $\\|B \\| &lt; 1$， $$\\lim_{k \\to \\infty} \\| \\varepsilon^{(k)} \\|\\leq\\lim_{k \\to \\infty} \\|B \\|^k \\| \\varepsilon^{(0)} \\|= 0$$ 所以有 $\\lim_{k\\to\\infty}\\varepsilon^{(k)} = \\mathbf{0}$。 然而我们还是不知道当 $\\|B\\| \\geq 1$ 时会发生什么。因此我们要进行推广： 矩阵的谱 定义 矩阵的谱 $\\rm{ch}\\;B$ （或$\\sigma(B)$）就是矩阵特征值的集合 $\\{\\lambda_1, \\lambda_2, …, \\lambda_n\\}$。 定义 矩阵 $B$ 的谱半径 $\\rho(B) = \\max\\limits_{1\\leq k\\leq n}|\\lambda_k|$ 那么，关于在 范数的相容性 中提到的最大特征值的结论都可以套过来： 结论 1：当 $B$ 是对称矩阵时，$\\|B\\|_2 = \\rho(B)$结论 2：对于任意范数都有：$\\rho(B) \\leq \\|B\\|_2$ 定理： $$\\lim_{k\\to\\infty}\\varepsilon^{(k)} = \\mathbf{0} \\Leftrightarrow \\rho(B) &lt; 1 $$ 这里就是充要条件了。 对于有些问题，雅可比不收敛、高斯——赛德尔收敛；也有前者收敛，后者不收敛。 套用雅可比和高斯——赛德尔方法中的 $B$ 的结果，可以得到判断该方法是否收敛的算法： 1234% 雅可比迭代法 B=D\\(U+L)D=diag(diag(A1));B=D\\(D-A);max(abs(eig(B1))); % 值小于 1 则收敛，大于 1 则不收敛 1234% 高斯——赛德尔迭代法 B=(D-L)\\UDL=tril(A1);B1=DL\\(DL-A1);max(abs(eig(B1))); % 值小于 1 则收敛，大于 1 则不收敛 定理：设 $X^*$ 是方程组 $AX=b$ 的解，迭代形式为：$X^{(k+1)}=BX^{(k)}+f$。若 $\\|B\\| &lt; 1$，则有： $$\\| X^{(k)} - X^* \\| \\leq \\frac{\\|B\\|}{1-\\|B\\|} \\|X^{(k)} - X^{(k-1)}\\|$$ $$\\| X^{(k)} - X^* \\| \\leq \\frac{\\|B\\|^k}{1-\\|B\\|} \\|X^{(1)} - X^{(0)}\\|$$ PPT 上给了第一条的证明，但是太硬核了（给刚接触范数的同学看这些真的看得懂吗），如果需要的话，再来翻 PPT 重学吧。 至于第二条，真的不懂了（逃","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"最优化","slug":"最优化","permalink":"https://blog.lyh543.cn/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"},{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"在 Windows 上安装 Anaconda 和 Jupyter Notebook","date":"2019-11-28T13:28:59.000Z","path":"python/anaconda-and-jupyter-notebook-on-windows/","text":"诚然，在 Linux 上使用 Anaconda、Jupyter Notebook 的体验远远高于 Windows，但我由于自身因素，只能在台式机上使用 Windows 系统，而微软的 wsl 暂时还不能连接到显卡，后期如果要考虑用 Python 进行深度学习方面的学习，不能使用显卡加速是一个很麻烦的地方。 综上，我想要尝试在 Windows 上安装 Anaconda 和 Jupyter Notebook。 Anaconda 简介 摘抄自：https://blog.csdn.net/ITLearnHall/article/details/81708148 Anaconda 指的是一个开源的 Python 发行版本，其包含了 conda、Python 等 180 多个科学包及其依赖项。 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 531 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版（仅包含 conda 和 Python）。 Conda 是一个开源的包、环境管理器（类似于 Debian 的 apt，Python 的 pip？），可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换 Anaconda 包括 Conda、Python 以及一大堆安装好的工具包，比如：numpy、pandas 等 Miniconda 包括 Conda、Python Anaconda 安装直接丢链接吧：https://blog.csdn.net/ITLearnHall/article/details/81708148 （还是上面那个） 包括安装、添加环境变量及其他常见使用方法。 Anaconda Windows 环境变量为方便使用，我个人添加了一些其他的 PATH 环境变量（添加 PATH 环境变量的方式请自行百度）。如下： 1234C:\\Program Files\\Anaconda\\C:\\Program Files\\Anaconda\\ScriptsC:\\Program Files\\Anaconda\\condabinC:\\Program Files\\Anaconda\\Library\\bin conda 包管理命令列举已安装的包：conda list 安装 requests 包（以下命令二选一）： 12conda install requestspip install requests 卸载： 12conda uninstall requestspip uninstall requests 更新： 1conda upgrade --all 配置 Jupyter Notebook安装完 Anaconda 以后，就自带了 Jupyter Notebook。双击或者运行 jupyter notebook 就可以用了。 配置方面，可以先运行 jupyter notebook --generate-config 生成默认配置，路径在 ~/.jupyter/jupyter_notebook_config.py 或 %userprofile%/.jupyter/jupyter_notebook_config.py（Windows）。 如果想要支持在公网访问 Jupyter Notebook，需要关注文件里的以下配置： 12345678910111213141516## The IP address the notebook server will listen on.# Default: 'localhost'c.NotebookApp.ip = '*'## Whether to open in a browser after starting. The specific browser used is# platform dependent and determined by the python standard library `webbrowser`# module, unless it is overridden using the --browser (NotebookApp.browser)# configuration option.# Default: Truec.NotebookApp.open_browser = False## The base URL for the notebook server.# # Leading and trailing slashes can be omitted, and will automatically be added.# Default: '/'c.NotebookApp.base_url = '/nb/' Jupyter Notebook 支持 C++、MATLAB、MathematicaJupyter Notebook 对 Linux 和 Mac 平台支持很好，可以在上面使用 C++、MATLAB、Mathematica，只要安装了对应内核就行。然而现在这些还不支持 Windows。目前全平台支持 Python。 部分报错及解决办法conda list 报错 conda 不是可运行的程序将 Anaconda 安装目录的 Anaconda3\\Scripts 文件夹加入 PATH 环境变量。参考conda list 报错 conda list 报错 LoadLibrary() …错误提示 TypeError LoadLibrary() argument 1 must be str, not None。 不是很清楚具体的原因，倒是找到了三篇 CSDN 博客解决这个的问题： 环境变量和（单独安装的） Python 的 Scripts 冲突？—— 将 Anaconda 的 PATH 置顶（或者考虑直接将单独安装的 Python 卸载）。参考链接 将 Anaconda3\\condabin 文件夹加入 PATH 环境变量。参考链接 每次使用 conda.bat activate 进入 Anaconda 环境；或者 conda init bash 激活基础环境。参考链接 最后都没好，但重启以后就好了，到底哪一条是对的，我也不知道 conda upgrade 报错 SSL is not available具体报错是 Can&#39;t connect to HTTPS URL because the SSL module is not available。更有意思的是，在 Anaconda Prompt 命令行中不会报错，而在 cmd 中 conda install 就会报错。 解决办法一：将默认源换为清华的镜像源，并将 https 改为 http。（参考链接，不推荐） 解决办法二：将 \\Anaconda3\\Library\\bin 包含进 PATH 环境变量。（亲测有效） 解决办法三（没有试过）：安装 OpenSSL。参考链接 conda upgrade 报错 EnvironmentNotWritableError1EnvironmentNotWritableError: The current user does not have write permissions to the target environment. 使用管理员权限运行命令行窗口即可。","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.lyh543.cn/tags/Windows/"}]},{"title":"数值分析中的数据处理方法","date":"2019-11-25T11:47:54.000Z","path":"matlab/data-process-in-data-analysis/","text":"这是在数模课上做的随堂笔记，插值和拟合更详细的自学笔记请看数模自学笔记——插值和拟合。 插值变量之中存在的函数关系，有时不能确定，而是通过获得的数据来找出两个变量间可能存在的连续。 这东西和拟合有点像。 未知 $f(x)$，但已知 $f(x)$ 的很多观测点 $(x_i, y_i)$，要找一个（可以分段的）函数 $\\varphi(x) \\approx f(x)$，并且强制要求 $\\varphi(x)$ 经过所有观测点。 这里使用的是多段分段函数进行近似。 常用的方法有：线性插值 linear、三次样条插值 spline、三次插值 cubic。推荐使用三次样条插值。 MATLAB 函数：y_new = interp1(x,y,x_new,option) 1234567x = linspace(0,2*pi,10);y = sin(x);x_new = linspace(0,2*pi,1000);y_new = interp1(x,y,x_new,'spline');plot(x,y,'o',x_new,y_new,'r-'); 二维插值。这里不能使用 interp2 而需要使用 griddata，Google 了一下： 二者均是常用的二维差值方法，两者的区别是，interp2 的插值数据必须是矩形域，即已知数据点 (x,y) 组成规则的矩阵，或称之为栅格，可使用 meshgrid 生成。而 griddata 函数的已知数据点 (x,y) 不要求规则排列，特别是对试验中随机没有规律采取的数据进行插值具有很好的效果。griddata(X,Y,XI,YI,&#39;v4&#39;) v4是一种插值算法，没有具体的名字，原文称为“MATLAB 4 griddatamethod”，是一种很圆滑的插值算法，效果不错。X 和 Y 提供的已知数据点，XI 和 YI是需要插值的数据点，一般使用 meshgrid 生成，当然也可以其他数据，但是那样绘图的时候就比较麻烦，不能使用 mesh 等，只能使用 trimesh。 1234567891011121314151617X=[129.0 140.5 103.5 88.0 185.5 195.0 105.5 ... 157.5 107.5 77.0 81.0 162.0 162.0 117.5];Y=[ 7.5 141.5 23.0 147.0 22.5 137.5 85.5 ... -6.5 -81.0 3.0 56.5 -66.5 84.0 -33.5];Z=[ 4 8 6 8 6 8 8 ... 9 9 8 8 9 4 9 ];% 船的吃水深度为5英尺。%在矩形区域（75，200）×（-50，150）% 内的哪些地方船要避免进入。xp = linspace(75,200,50);yp = linspace(-50,150,50);[xq,yq]=meshgrid(xp,yp);vq = griddata(X,Y,Z,xq,yq,'cubic')mesh(xq,yq,vq)hold onplot3(X,Y,Z,'O','markersize',14) 拟合数值微分微分其实用的不多。常用于解微分方程。 前面两个差商比较垃圾，但是处理端点好用： 一阶前向差商（左端点） $f’(a)=\\frac{f(a+h)-f(a)}{h}+O(h)$ 一阶后向差商（右端点） $f’(a)=\\frac{f(a)-f(a-h)}{h}+O(h)$ 一阶中心差商（中间部分） $f’(a)=\\frac{f(a+h)-f(a-h)}{2h}+O(h^2)$ 二阶中心差商 $f’’(a) =\\frac{f(a+h)+f(a-h)-2f(a)}{h^2}+O(h^2)$ 证明都是通过泰勒展式，略。 实际使用时，令 $h$ 为一个较小的数（如 $h=10^{-5}$）即可求 $f$ 在 $a$ 点的微分。 数值方法求梯度 参考链接：https://www.bilibili.com/video/av59319786 梯度的定义： $$\\nabla f(\\boldsymbol{x}) = \\left[\\begin{matrix}\\frac{\\partial f}{\\partial x_1} \\\\\\frac{\\partial f}{\\partial x_2} \\\\\\vdots \\\\\\frac{\\partial f}{\\partial x_n}\\end{matrix}\\right]$$ 数值方法求梯度，其实就是上面的微分方法用来求 n 遍偏导。每次求偏导的方法如下： $$\\frac{\\partial f}{\\partial x_i} = \\frac{ f(\\boldsymbol{x};x_i+\\Delta x_i) - f(\\boldsymbol{x};x_i-\\Delta x_i)}{2x_i} + O \\left((\\Delta x_i)^2 \\right)$$ 数值方法求黑塞矩阵黑塞矩阵： $$\\nabla^2f(\\boldsymbol{x})=\\left[\\begin{array}{cccc}{\\frac{\\partial^2 f}{\\partial x_1^2}} &amp; {\\frac{\\partial^2 f}{\\partial x_1 \\partial x_2}} &amp; {\\cdots} &amp; {\\frac{\\partial^2 f}{\\partial x_1 \\partial x_n}} \\\\{\\frac{\\partial^2 f}{\\partial x_2 \\partial x_1}} &amp; {\\frac{\\partial^2 f}{\\partial x_2^2}} &amp; {\\cdots} &amp; {\\frac{\\partial^2 f}{\\partial x_2 \\partial x_n}} \\\\{\\vdots} &amp; {\\vdots} &amp; {\\ddots} &amp; {\\vdots} \\\\{\\frac{\\partial^2 f}{\\partial x_n \\partial x_1}} &amp; {\\frac{\\partial^2 f}{\\partial x_n \\partial x_2}} &amp; {\\cdots} &amp; {\\frac{\\partial^2 f}{\\partial x_n^2}}\\end{array}\\right]$$ 其实和上面本质是一样的，只是二阶导要求两次。推导过程就略了（可以看上面参考链接的视频），最后的每一项的结果如下： $$\\begin{aligned}\\frac{\\partial^2 f}{\\partial x_i \\partial x_j} = &amp;\\frac{1}{4\\Delta x_i\\Delta x_j} \\bigg[ \\\\&amp;f(\\boldsymbol{x};x_i+\\Delta x_i,x_j+\\Delta x_j) + f(\\boldsymbol{x};x_i-\\Delta x_i,x_j-\\Delta x_j)\\\\&amp;-f(\\boldsymbol{x};x_i-\\Delta x_i,x_j+\\Delta x_j) - f(\\boldsymbol{x};x_i+\\Delta x_i,x_j-\\Delta x_j)\\bigg] \\\\&amp;+ O((\\Delta x_i)^2)\\end{aligned}$$ 看起来麻烦，其实就是如下图，需要找得到 A 点的二阶偏导时，将 A 的 $x_i, x_j$ 各增加/减少 $\\Delta x_i, \\Delta x_j$ 的量，得到 B、C、D、E，用 (B+D)-(C+E) （的函数值加减以后的结果）除以 $4\\Delta x_i\\Delta x_j$ 即可。 数值方法求二阶偏导 注意这个方法不能用在对角线上。求对角线上的二阶导仍需要用上面数值微分提到的求二阶导方法。 $$\\frac{\\partial^2 f}{\\partial x_i^2} =\\frac{ f(\\boldsymbol{x};x_i+\\Delta x_i) + f(\\boldsymbol{x};x_i-\\Delta x_i) - 2f(\\boldsymbol{x}) } {(\\Delta x_i)^2}+O((\\Delta x_i)^2)$$ 数值积分按积分定义有： $$\\int_a^bf(x)dx=\\lim_{h\\to0}\\sum_{i=1}^nf(x_j)h$$ 当 $h$ 足够小时，数值积分结果即可近似实际结果。 数值积分分为左矩形法（积分的高度按左端点的函数值计算）、右矩形法。 效率不高（即使是一重积分中，$h$ 的精度就必须要相当高） 构造思路：想构造 $A_k$ 使得 $$\\int_a^b f(x)dx=\\sum_{k=0}^nA_kf(x_k)+R[f]$$ $R[f] = \\int_a^b f(x)dx - \\sum_{k=0}^nA_kf(x_k)$ 表示残差。不同算法的残差不同。 求积公式的代数精度对于每个求积公式，我们用对多项式进行求积，来定义 $m$ 阶代数精度公式： 对于不高于 $m$ 次的任意多项式 $P(x)$，求积公式若恒等于 0，即$$R[f] = \\int_a^b P(x)dx - \\sum_{k=0}^nA_kP(x_k) \\equiv 0$$且对于 $m+1$ 次多项式，不具有这么的性质，则称：$$\\int_a^b f(x)dx \\approx \\sum_{k=0}^nA_kf(x_k)$$具有 $m$ 阶的代数精度。 插值型求和公式Lagrange 插值求积公式这是基于 Lagrange 插值法的一个方法。 从思想上来说，Lagrange 插值法是通过函数 $f(x)$ 的已知的 $n+1$ 个点 $(x_j, y_j)$，构造出一个多项式 $p(x)$ 来近似 $f(x)$。（这个多项式最高为 $n$ 次，经过全部 $n+1$ 个点）而 Lagrange 插值求积分，其思想就是用 $f(x)$ 算出 $n+1$ 个点，构造出 $p(x)$，再用 $p(x)$ 的积分（多项式积分很容易）来近似 $f(x)$ 的积分。 在 Lagrange 插值中，已知 $n+1$ 个点 $(x_j, y_j)$，则应用 Lagrange 插值公式得到的 Lagrange 插值多项式 为： $$p(x) \\approx \\sum_{j=0}^k y_j l_j(x)$$ 其中 $$l_j(x) = \\prod_{i=0, i \\neq j}^n\\frac{x-x_i}{x_j-x_i}=\\frac{(x-x_0)}{(x_j-x_0)} \\cdots \\frac{(x-x_{j-1})}{(x_j-x_{j-1})} \\frac{(x-x_{j+1})}{(x_j-x_{j+1})} \\cdots \\frac{(x-x_{k})}{(x_j-x_{k})}$$ 公式的正确性略，请读者自行查阅资料。注意，这个 $l_j(x)$ 将会被用到积分过程中。 下面我们利用 Lagrange 插值公式进行求积的推导： $$\\begin{split}f(x) &amp;\\approx p(x) \\\\\\int_a^b f(x) &amp;\\approx \\int_a^b \\sum_{j=0}^k l_j(x) \\cdot y_j \\\\&amp;\\approx \\sum_{j=0}^k \\left[ \\int_a^b l_j(x) \\right] f(x_j)\\end{split}$$ 令 $A_j = \\int_a^b l_j(x)$，则推出了 前面 所提到的公式： $$\\int_a^b f(x) = \\sum_{j=0}^k A_j f(x_j) + R[f]$$ 可以证明此法的 $$R[f] = \\sum_a^b \\frac{f^{(n+1)}(\\xi)}{(n+1)!} \\omega(x)dx$$ 其中 $\\omega(x)=\\prod_{i=0}^n (x-x_i)$。 进一步推进，对于 $n+1$ 点（即 $n$ 次） Lagrange 插值求积公式，其代数精度至少为 $n$ 阶。 应用 1 梯形公式我们可以把整段区间的积分，分割为数个小区间的积分再求和。在求小区间的积分的时候，我们对小区间的两个端点进行拉格朗日插值积分。 对于两点 $(a,f(a)), (b,f(b))$ 的线性插值，有 $$l_0(x)=\\frac{x_1-x}{x_1-x_0}\\quad l_1(x)=\\frac{x-x_0}{x_1-x_0} \\\\A_0=\\int_a^b \\frac{b-x}{b-a}dx=\\frac{1}{2}(b-a) \\quad A_1=\\int_a^b \\frac{x-a}{b-a}dx=\\frac{1}{2}(b-a) \\\\\\int_a^b f(x)dx \\approx \\frac{b-a}{2}[f(a) + f(b)]$$ 误差 $$\\begin{split}R &amp;=\\int_a^b \\frac{f’’(\\xi)}{2}(x-a)(x-b)dx = \\frac{f’’(\\eta)}{2}\\int_a^b (x-a)(x-b)dx \\\\&amp;=-\\frac{(b-a)^3}{12}f’’(\\eta)\\end{split}$$ 要使误差小：一是区间取小，二是二阶导数小（曲线更趋近于直线，几何上看也比较明显） 梯形公式具有 1 阶代数精度。 MATLAB 梯形法数值积分 trapz 另外梯形公式还能够推出另外一个公式： 来自数学建模实验的笔记： 这是积分中值定理：$$\\exists \\xi, \\quad \\int_a^bf(x) = (b-a)f(\\xi)$$ 在数值积分时，可以在 $[a, b]$ 中等间距地取 10000 个点，$f(x)$ 的平均值就可以近似 $f(\\xi)$。 貌似是数值积分的套路操作，但是微积分 I 没有讲。2020.2.22 更新：确实，这是梯形公式，可见维基百科 应用 2 Simpson 公式（三点积分公式）依旧是把整段区间的积分，分割为的积分再求和。不过，在求小区间的积分的时候，我们改用二次函数近似，在一个区间上取三个点（两个端点+中点）。 计算过程仍然是类似于梯形公式，算 $l_j(x)$，对每一个进行积分得到 $A_j$，然后和每段的 $y_j$ 相乘再相加，最后得到 $$\\int_a^b f(x)dx \\approx \\frac{b-a}{6} \\left[ f(a)+4f(\\frac{a+b}{2})+f(b) \\right]$$ 近似效果会好些。 Simpson 公式竟然具有 3 阶代数精度。 当然，还可以用高次函数来跑 Lagrange 插值积分，但是高次函数有震荡性，一般就使用线性或二次即可。 Newton-Cotes 公式使用 Lagrange 插值求积时，如果取的点为等距的（即 $x_j = a + jh$ 时），求积公式称为 Newton-Cotes 公式。 Newton-Cotes 公式代数精度至少为 $n$。且有定理：当 $n$ 为偶数时， $n$ 阶 Newton-Cotes 公式至少有 $(n+1)$ 阶代数精度。 复合梯形求积公式将积分区间先拆为 $n$ 等分。按照前面的某一种方法来计算。 然后分的更细，使区间变为上一次的 $\\frac{1}{2}$。是迭代法！ 迭代的时候要重复使用之前的结果，只需要补上新增的点的 $f(x_{j_1})$ 值。 这样迭代的好处是，我不知道这个算法算到哪种程度才能算特别精确，所以就一直算。但是这样算的本质和直接算其实都是一样的。 由于我一直在利用之前迭代的结果，所以直接算的算法时间复杂度其实和迭代的时间复杂度是一样的。 复合梯形法可以套用前面的所有插值法。 蒙特卡罗方法求积分很显然的方法就是在每一维上取一些点，计算 $10^n$ 个点，但是复杂度与维数是成指数级的。 于是使用随机投点法，用矩形框起来，然后随机投点，计算概率，即可估算积分大小。 优点：算法复杂度和函数无关，和维数无关缺点：不能保证精确度 高斯型数值积分公式震惊！选取好的求积结点，就可以用两个点能得到线性插值的代数精度为 3？ 以下是插值型求积公式（我们讨论在 $[-1,1]$ 积分的特例） $$\\int_{-1}^1f(x)dx \\approx A_0f(x_0) + A_1f(x_1)$$ 为保证代数精度为 3，令 $f(x) = 1, x, x^2, x^3$，代入上式，得到参数需要满足以下条件： $$\\left\\{ \\begin{matrix}A_0+A_1 &amp;=2 &amp; (1) \\\\A_0x_0+A_1x_1 &amp;=0 &amp; (2) \\\\A_0x_0^2+A_1x_1^2 &amp;=2/3 &amp; (3) \\\\A_0x_0^3+A_1x_1^3 &amp;=0 &amp; (4)\\end{matrix}\\right.$$ 虽然是非线性不好解，但是可以解得： $$A_0=A_1=1,\\quad x_0=-\\frac{1}{\\sqrt{3}},\\quad x_1=\\frac{1}{\\sqrt{3}}$$ 也就是说，如果我们按照 $x_0, x_1$ 的比例取点来计算，所得的线性插值求积的代数精度就可以达到 3。 定义 如果求积结点 $x_0, x_1, …, x_n$，使得$$\\int_{-1}^1f(x)dx \\approx \\sum_{k=0}^nA_kf(x_k)$$的代数精度为 $2n+1$,则称该求积公式为 Gauss 型求积公式。这些求积结点称为 Gauss点。 定理 如果多项式 $w_{n+1}(x)=(x-x_0)(x-x_1)\\cdots(x-x_n)$ 与任意不超过 $n$ 次的多项式 $P(x)$ 正交，即$$\\int_{-1}^1 w_{n+1}(x)P(x)dx = 0$$则 $w_{n+1}(x)$ 的所有零点 $x_i$ 是 Gauss 点。 对于别的区间，可以进行伸缩变换： quad Legendre多项式递推式真心看不懂辣","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"},{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"使用 iperf3 测速","date":"2019-11-19T12:04:49.000Z","path":"linux/iperf3-speedtest/","text":"Iperf3 是一个开源的多平台跨架构的命令行测速软件，只要在两个设备上同时运行这个软件，就可以进行测速。 iperf3 下载、使用官网下载链接如下：https://iperf.fr/iperf-download.php 其中 Windows 是一个 exe 和一个 dll，而 Debian 推荐使用他的命令行下载，红帽系的 Linux 可以直接使用 xxx install iperf3。 使用方法直接看说明就行，服务端直接 iperf -sD 即可后台运行； 客户端进行 iperf -c &lt;server port&gt; 即可测试上传至服务端的速度。测试下载，需要使用 iperf -c &lt;server port&gt; -R。 局域网测试我进行了一个简单的局域网网速的测试。 终端设备： 台式电脑，使用 Tenda U12 1300Mbps ( 2.4GHz 下 400Mbps + 5Ghz 下 867 Mbps) USB 无线网卡 Surface Book 小米 Mix2s 路由设备 TP-Link TL-WDR5620 1200Mbps ( 2.4GHz 下 300Mbps + 5Ghz 下 867 Mbps) 路由器，在 5GHz 下工作 小米 Mix2s 的移动热点，分别在 5GHz 和 2.4GHz 下工作 测试结果的 Excel 简要结论： 终端设备上，台式和 Mix2s 表现较好（毕竟 Surface Book 已经是 3 年前的产品了） 路由设备上，Mix2s 的热点甚至比路由器还强。 测试不同距离的 Wifi 速度，两个终端距离路由器 3m 时，速度会较距离 30cm 时下降 10% 左右。反正平时也跑不满电信的带宽 5GHz 网速明显快于 2.4Ghz","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"LaTeX 基础","date":"2019-11-18T16:00:00.000Z","path":"latex/latex/","text":"LaTeX 简介课上抄的 LaTeX 是： 一个以排版文章以及数学公式为目标的计算机程序 充当了文档设计者和排版者 与 Word 等所见即所得的方式有着巨大区别 强制使用者声明文档的逻辑结构，避免版式错误 LaTeX 与 Word 区别 Word 所遵循的思想是“所见即所得”，输出的文档效果与屏幕上显示一致， LateX 所遵循的思想是“所想即所得”，它有非常强大的功能，但入门学习要难于 Word，用 LaTeX 编写页面与最终得到的 pdf 有着较大的区别 从美学观点来看，由于 LaTeX 强大的排版功能，尤其是强大的数学公式编辑功能，使得 LaTeX 排版出来的文档美观性一般强于 Word，这点在科技文档中尤为明显。此外，在编辑一份含大量公式的文档时，LaTeX 的稳定性高于 Word。 完成一篇篇幅较长，含有很多插图，表格和公式的论文后，一旦论文需要修改，Word 在排版上会发生巨大的工作量，而 LaTeX 的工作量则要小得多。 大部分国内外杂志，要求寄去的文章按 LateX 格式排版，国内越来越多的学校开始鼓励毕业论文采用 LaTeX 编写。 编译器、IDE 及 参考书重度使用推荐 TeX Live 和 TeXStudio。轻度使用可以使用在线编辑器 Overleaf。 参考书推荐：一份不太简短的LaTeX教程.pdf。 另外推荐我编写的：LaTeX常见语法，去掉了该文中复杂的部分，推荐快速入门。 配置环境可见 配置 LaTeX 开发环境。 在 tex 代码的开头使用如下注释可指定 xelatex 进行编译。 1% !TEX program = xelatex Hello, world1234\\documentclass&#123;article&#125; % 源文件第一行必须是介个\\begin&#123;document&#125; hello, LaTeX\\end&#123;document&#125; 更多 documentclass 可以自己查询。 在接下来的学习中，可以使用 Bing/Google 到的模板。 你好，LaTeX原生 LaTeX 不支持中文。需要引入包。课程使用的是 CJK。但是在我的 TeXstudio 编译不过？？？？？？ 引入包的格式是在 begin{document} 后使用 \\usepackage[option]{packagename} 12345678\\documentclass&#123;article&#125;\\usepackage&#123;CJK&#125;\\begin&#123;document&#125; \\begin&#123;CJK&#125;&#123;GBK&#125;&#123;song&#125; hello, LaTeX 你好 \\end&#123;CJK&#125;\\end&#123;document&#125; 于是我采用了另一个 ctex 包。ctex 用法可见官方文档。 12345\\documentclass&#123;article&#125;\\usepackage[UTF8]&#123;ctex&#125;\\begin&#123;document&#125; \\youyuan 你好，\\LaTeX！\\end&#123;document&#125; 自带的六种字体见下表： 命令 字体 \\songti 宋体 \\heiti 黑体 \\fangsong 仿宋 \\kaishu 楷书 \\lishu 隶书 \\youyuan 幼圆 字号 \\zihao、字距 \\ziju 等特殊格式请查阅 ctex 官方文档。 文档基本符号空格、回车转义的字词后，空格不起作用，除了使用 \\space，还可以使用&quot;\\ &quot;（不含引号，最常用）、\\,、\\;、\\:。MathJax 的写法：\\space、\\\\;、&quot;\\\\ &quot;（不含引号）。 换行使用 \\endline、\\\\ ，也可以使用两个回车。一个回车没有用。（MathJax 中得 \\\\\\\\） 连续换行使用 \\\\ \\\\ 会编译不过，需要使用一个 ~ 以占位：\\\\~\\\\。 注释 单行注释：直接加入 % 即可； 多行注释： 12\\usepackage&#123;verbatim&#125;\\begin&#123;comment&#125; ... \\end&#123;comment&#125; 特殊符号 \\LaTeX 即能打出 $\\rm\\LaTeX$ 的官方图标。 ~ 在 LaTeX 为空白符，如果想要显示这个字符，请使用\\textasciitilde（非数学环境中）或 \\sim（数学环境中） % 注释 _ 为下标，如果想要显示这个字符，请使用 \\_ 进行转义。如果你有很多的 _ 需要打，可以使用 \\usepackage{underscore}，在非数学模式下使用 _ 时就无需转义啦。 文档格式文字格式 粗体：\\textbf{}； 斜体：\\emph{}； 下划线：\\underline{}（这是唯一一个数学公式外能用的数学公式功能）。 可以进行叠加： \\textbf{\\emph{\\underline{Hello}}}。 下划线处理大段文字时，不能自动换行（大概是数学公式并不需要换行）。 需要引入 ulem 宏包，并将 \\underline 改为 \\ulem。如果中文包使用的是 CJK，需要将引入的宏包改为 CJKulem。 段落格式分页：\\newpage、\\clearpage； 使用 \\noindent 以去掉首行缩进，使用 \\indent 以加入首行缩进。 左对齐：\\begin{flushleft}（默认，所以不常用）右对齐：\\begin{flushright}居中：\\begin{center} 章节格式 通用：\\part{}、\\paragraph{}、\\subparagraph{}、 \\section{}、\\subsection{}、\\subsubsection{} 关联编号（即 1.1.1）。 在 book 类中，\\section 以上还有一级更高的 ：\\chapter{} 。 \\section*{} 不参与自动编号。 页面间距格式12\\usepackage&#123;geometry&#125;\\geometry&#123;left=5.0cm, right=2.0cm, top=2.0cm, bottom=2.0cm&#125; % 全局设置 分栏 此部分源码及 PDF 见：https://github.com/lyh543/UESTC_LaTeX_Template/blob/master/Course_Thesis_others/心理学漫谈 1234567\\begin&#123;multicols&#125;&#123;2&#125; % 双栏控制\\section&#123;第一段&#125;这里是正文。\\lipsum[1]\\section&#123;第二段&#125;这里是正文 \\lipsum[2]\\end&#123;multicols&#125; 文档信息及标题 \\title{}：标题。 \\author{}：作者信息，以及邮件信息等等。如需换行，可在大括号中使用换行。 \\date{2017\\\\December}：日期 以上命令可放全局变量位置或文档正文位置。 然后在正文里调用一句 \\maketitle 产生标题及以上信息。 引用参考文献LaTeX 的引用原理是给每个文献写一个好记的名字，然后引用的时候直接引用名字。编译的时候自动对文献进行标号，并将引用处和文献根据名字绑定，然后标号。最后名字是不会呈现在文档里的。好评。 了解了原理以后，基本也是无脑抄板子。不需要额外的库。 12345678910111213141516171819\\documentclass&#123;article&#125; % 源文件第一行必须是介个\\usepackage[UTF8]&#123;ctex&#125;\\begin&#123;document&#125;xxx说的对。\\cite&#123;Zhang10&#125;yyy说的也对。\\cite&#123;Li10&#125;\\begin&#123;thebibliography&#125;&#123;&#125; \\bibitem&#123;Li10&#125; L. Ming, Y. Shucheng, R. Kui, and L. Wenjing, Securing Personal Health Records in Cloud Computing: Patient-Centric and Fine-Grained Data Access Control in Multi-owner Settings, in: Processing of SecureComm 2010, LNICST 50, pp. 89-106, 2010. \\bibitem&#123;Zhang10&#125; R. Zhang, and L. Liu, Security Models and Requirements for Healthcare Application Clouds, in: Processing of Cloud 2010, pp. 268-275, 2010.\\end&#123;thebibliography&#125;\\end&#123;document&#125; 引用参考文献 示例 摘要和关键字摘要可以用自带的，但是关键字需要自己写。 12345\\begin&#123;abstract&#125; This is an example of abstract. \\textbf&#123;Keywords&#125;: Abstract, Exmaple\\end&#123;abstract&#125; 如果你正在中文环境上写英文文章，你就会遇到啼笑皆非的情况和我一样：英文摘要上方写着大大的汉字“摘要”！ 遇到这种情况，你只需要在摘要前加一行代码： 1\\renewcommand&#123;\\abstractname&#125;&#123;Your Abstract Name&#125; 就可以把你的摘要标题变为 Your Abstract Name 了。 数学公式正式学 LaTeX 之前我就开始写数学公式了，所有内容我就放在另外一篇博客了。 表格创建表格，除了自己编辑，还可以使用生成工具，如： https://tablesgenerator.com/https://github.com/krlmlr/Excel2LaTeX 创建表格使用 \\begin{tabular} \\end{tabular} 和 &amp; \\\\ 即可创建表格。 和数学矩阵一样，在 \\begin{tabular} 后加入 {clcr} 即可说明每一列的对齐方式（c 居中，l 左对齐、r 右对齐）。 1234\\begin&#123;tabular&#125;&#123;cl&#125;1 &amp; 2 \\\\3 &amp; 4\\end&#123;tabular&#125; 表格 给表格加边框可以看到，如不加说明，LaTeX 表格是不带边框的。 如果要对一整行添加水平边框，在行间（或第一行前，最后一行后，下同）使用 \\hline 命令即可。 注意最后一行加边框时，最后一行必须换行 \\\\。 如需部分列添加水平边框（如想在第 i 列到第 j 列加入边框），将 \\hline 换为 \\cline{i-j} 的形式即可。如果只有一列，则需使用 \\cline{i-i}。如果需要添加多个间断的水平边框，连续使用多个命令（如 \\cline{1-2}\\cline{4-4} 即可。 对于竖直边框，在表格 \\begin 的 clr 部分加入 | 即可，如 \\begin{tabular}{|c|l|rr|}。 如果需要间断的数值边框，书上说的 \\vline，但是貌似不可用，会歪的。 123456789\\begin&#123;tabular&#125;&#123;|c|lr|&#125; \\hline ab &amp; cd &amp; ef \\\\ \\cline&#123;1-1&#125;\\cline&#123;3-3&#125; cd &amp; ef &amp; ab \\\\ \\cline&#123;1-2&#125; ef &amp; ab &amp; cd \\\\ \\hline\\end&#123;tabular&#125; 边框 示例 合并单元格这一段会比较硬核，于是再分三个小段讲。 合并水平单元格这是最简单的。格式为 \\multicolumn{2}{|c|}{ef}。 第一个 {2} 为要合并的水平单元格数量； 第二个 {|c|} 表示该单元格的对齐方式和列边框（会覆盖掉上面的列边框设置）； 第三个 {ef} 为文本格式。 注意合并单元格以后，该行的 &amp; 数较其他行会少一些。 测试的时候不要把每一行的同两列都合并了，不然合并了还是没效果。（逃 合并竖直单元格合并竖直单元格还需要调宏包 \\usepackage{multirow}。 调用格式为（在合并的第一行写） \\multirow{2}{*}{ab}。 {2} 和 {ab} 和上述的意思相近，注意这里的 {*} 是需要无脑抄的参数，没有会报错。 另外，\\cline 和 \\hline 设置不会被覆盖，需要自己调整（要不就会出现单元格被穿过去的情况）。 同时合并行和列虽然理论实现非常简单，就是上述两个语句的嵌套，但是因为细节太多太多，这才是最硬核的部分。 仍然需要在合并的第一行调用。 必须 \\multicolumn 在外，\\multirow 在内，如 \\multicolumn{2}{c|}{ \\multirow{2}{*}{gh} }。不然会报错。 合并的后面几行需要写 \\multicolumn，数量和列对齐格式和第一行的 \\multicolumn 相同，内容留空 {}。 最后是以上几个例子的综合实例。 1234567891011\\begin&#123;tabular&#125;&#123;|c|c|c|c|&#125; \\hline \\multirow&#123;2&#125;&#123;*&#125;&#123;ab&#125; &amp; \\multicolumn&#123;2&#125;&#123;|c|&#125;&#123;ef&#125; &amp; cd\\\\ \\cline&#123;2-4&#125; &amp; ef &amp; \\multicolumn&#123;2&#125;&#123;c|&#125;&#123;\\multirow&#123;2&#125;&#123;*&#125;&#123;gh&#125;&#125; \\\\ \\cline&#123;1-2&#125; ef &amp; gh &amp; \\multicolumn&#123;2&#125;&#123;c|&#125;&#123;&#125; \\\\ \\hline 1 &amp; 2 &amp; 3 &amp; 4 \\\\ \\hline\\end&#123;tabular&#125; 合并单元格 示例 美观地插入表格上面是“如何创建一个表格”，这一部分是“如何将表格美观的插入文档”。 如下是无脑抄板子： 12345678910111213\\begin&#123;table&#125;[!hbp] % 有关[!hbp]，详见：插入浮动体 \\centering % 表格居中 \\begin&#123;tabular&#125;&#123;|c|c|c|c|c|&#125; \\hline lable 1-1 &amp; label 1-2 &amp; label 1-3 &amp; label 1 -4 &amp; label 1-5 \\\\ \\hline label 2-1 &amp; label 2-2 &amp; label 3-3 &amp; label 4-4 &amp; label 5-5 \\\\ \\hline \\end&#123;tabular&#125; \\caption&#123;表格标题&#125; % 表格标题\\end&#123;table&#125; 有关 [!hbp] 等，详见：插入浮动体。 对表格进行缩放 防止超宽遇到超宽的表格，我们可以使用 \\begin{adjustbox}...\\end{adjustbox} 对其进行缩放。 1234567891011121314151617181920212223\\documentclass&#123;article&#125;\\usepackage&#123;adjustbox&#125;\\begin&#123;document&#125;\\begin&#123;table&#125;[h!] \\centering \\begin&#123;adjustbox&#125;&#123;max width=\\textwidth&#125; \\begin&#123;tabular&#125;&#123;*&#123;14&#125;&#123;|c&#125;|&#125;%%&#123;|c|c|c|c|c|c|c|c|c|c|c|c|c|c|&#125; \\hline One &amp; Two &amp;Three &amp; Four &amp; Five &amp; Six &amp; Seven &amp; Eight &amp; Nine &amp; Ten &amp; Eleven &amp; Twelve &amp; Thirteen &amp; Fourteen\\\\ \\hline \\hline $1.111$ &amp; $2.222$ &amp; $3.333$ &amp; $4.444$ &amp; $5.555$ &amp; $6.666$ &amp; $7.777$ &amp; $8.888$ &amp; $9.999$ &amp; $0.000$ &amp; $1.111$ &amp; $2.222$ &amp; $3.333$ &amp; $4.444$\\\\ \\hline \\end&#123;tabular&#125; \\end&#123;adjustbox&#125; \\caption&#123;Test Table&#125; \\label&#123;tab:label_test&#125;\\end&#123;table&#125;\\end&#123;document&#125; adjustbox 效果 标准三线表格123456789101112\\begin&#123;table&#125;[!htbp] \\caption&#123;标准三线表格&#125;\\label&#123;tab:001&#125; \\centering \\begin&#123;tabular&#125;&#123;ccccc&#125; \\toprule[1.5pt] $D$(in) &amp; $P_u$(lbs) &amp; $u_u$(in) &amp; $\\beta$ &amp; $G_f$(psi.in)\\\\ \\midrule[1pt] 5 &amp; 269.8 &amp; 0.000674 &amp; 1.79 &amp; 0.04089\\\\ 10 &amp; 421.0 &amp; 0.001035 &amp; 3.59 &amp; 0.04089\\\\ 20 &amp; 640.2 &amp; 0.001565 &amp; 7.18 &amp; 0.04089\\\\ \\bottomrule[1.5pt] \\end&#123;tabular&#125;\\end&#123;table&#125; 标准三线表格 另外，[Table Generator] 也支持标准三线表格，只需将 Default Table Style 改为 Booktabs Table Style。 tabular* 表格tabular* 在兼容 tabular 的语法上，又增加了功能。 一是必须指定表格的总宽度，二是可以将所有列在设定的表格宽度中均匀展开（即让表格横向均匀展开，不留横向空位）。 不需要新的宏包。 12345678\\begin&#123;tabular*&#125;&#123;10cm&#125;&#123;lll&#125; \\hline Start &amp; End &amp; Character Block Name \\\\ \\hline 3400 &amp; 4DB5 &amp; CJK Unified Ideographs Extension A \\\\ 4E00 &amp; 9FFF &amp; CJK Unified Ideographs \\\\ \\hline\\end&#123;tabular*&#125; 这是没有横向展开的。把第一行的 {lll} 改为 {@{\\extracolsep{\\fill}}lll} 即可横向展开。下面是两个对比图。 不使用 extracolsep 使用 extracolsep tabularx 表格tabularx 也可以实现对表格总宽度的设定。 12345678\\begin&#123;tabularx&#125;&#123;8cm&#125;&#123;llX&#125; \\hline Start &amp; End &amp; Character Block Name \\\\ \\hline 3400 &amp; 4DB5 &amp; CJK Unified Ideographs Extension A \\\\ 4E00 &amp; 9FFF &amp; CJK Unified Ideographs \\\\ \\hline\\end&#123;tabularx&#125; tabularx 文档内容元素这部分的内容，Markdown 也有，但是 LaTeX 可以调各种参数，功能强大。相对应的，命令也会比较长。 Markdown 真香 水平横线Markdown 里的预览： LaTeX 版本： 12\\rule[raise-height]&#123;width&#125;&#123;thickness&#125;\\rule[4pt]&#123;18cm&#125;&#123;0.5pt&#125; % 参考配置 分条目命令无标号Markdown 里的预览： a b LaTeX 版本： 1234\\begin&#123;itemize&#125; \\item[*] a \\item[*] b\\end&#123;itemize&#125; [*] 可以不要（即默认使用黑点），或者换成其他的符号 + - 等。 数字标号Markdown 里的预览： a b LaTeX 版本： 12345\\usepackage&#123;enumerate&#125;\\begin&#123;enumerate&#125;[1.] \\item a \\item b\\end&#123;enumerate&#125; 也可以使用其他的标号，修改 [1.] 部分即可。 文字描述12345\\begin&#123;description&#125; \\item[研究生课程：] 数据挖掘等； \\item[本科课程：] 高等代数等； \\item[自学课程：] Stanford:编程方法。\\end&#123;description&#125; 文字描述 插入图片1\\includegraphics&#123;file.pdf&#125; % 按图片原尺寸插入图片 file.pdf 插入的图片可以是 pdf、png 等格式。对于矢量图，不能插入 svg，推荐打印成 pdf 后剪裁成图片，就可以插入了。 美观的插入图片依旧是抄板子。 123456\\begin&#123;figure&#125;[H] \\centering \\includegraphics[width=0.7\\textwidth]&#123;图片文件&#125; \\caption&#123;标题名称&#125; \\label&#123;fig1&#125;\\end&#123;figure&#125; 有关这段代码的详细解释，详见：插入浮动体。 插入子图可自行排列。由于情况较复杂，可见 https://blog.csdn.net/a6822342/article/details/80533135 插入浮动体表格的 \\table 和图片的 \\figure 等都算是浮动体，他们有类似的语法体系。 下面以插入图片为例： 123456\\begin&#123;figure&#125;[H] \\centering % 居中 \\includegraphics[width=0.7\\textwidth]&#123;图片文件&#125; \\caption&#123;标题名称&#125; \\label&#123;fig1&#125;\\end&#123;figure&#125; 关于 [!hbp] 的解释如下（默认为 [tbp]）： ! 严格按照说明放置，即使看起来不好。（请谨慎的使用） h (here) 浮动体尽量放在代码对应的位置上。这主要用于小浮动体 t (top) 尽量放在页面顶部 b (bottom) 尽量放在页面底部 p (page) 放在一专门页面，仅含一个浮动体 H (Here) 使得浮动体严格地放在代码对应的位置上 需要 \\usepackage{float} H 的好处是照片不会和下面的文字错位，但坏处是如果页面放不下，图片会放在在下一页开头，但当前页会有大量空白。 上述字母的顺序不重要（$LaTeX$ 用固定的算法摆放浮动体，中括号的内容仅决定 $LaTeX$ 是否跳过该方法。参考） 如果把 \\caption{标题名称} 写在 \\includegraphics 之前，则得到的图片的标题在图片的上面。 \\label{fig1} 是这个图片的标签，在别的地方那个引用这个图片的话，用 \\ref{fig1} 就可以了。（注意：\\label 必须放在 \\caption 命令的后面，如果放在其他的地方，则插图的计数器就会出错） 插入代码LaTeX 支持的语言 123456\\begin&#123;lstlisting&#125;[caption=&#123;一段C代码&#125;, label=&#123;lst:code-example&#125;, captionpos=t, language=c]#include &lt;stdio.h&gt;int main (int argc, char *argv[])&#123; printf(\"Hello world!\");&#125;\\end&#123;lstlisting&#125; 使用 LaTeX 制作幻灯片什么是 beamer？ beamer 是 LaTeX 的一个文档类，和 article、 book 一样；beamer 主要是写幻灯片用的，目前表现最好的书写幻灯片的宏包之一；采用 LaTeX 命令来组织幻灯片，用 frame 命令生成单页幻灯片（Slide）。 Hello, World!先跑一下，看下什么效果。 如果编译不过，请参照文末解决。 123456789101112131415161718\\documentclass[red]&#123;beamer&#125;\\usepackage[UTF8]&#123;ctex&#125;\\usetheme&#123;Warsaw&#125;\\begin&#123;document&#125; %%------------------------------------------ \\title&#123;beamer~测试&#125; \\author&#123;XXX&#125; \\institute&#123;lyh543&#125; \\date&#123;\\today&#125; \\frame&#123;\\titlepage&#125; %%------------------------------------------ \\begin&#123;frame&#125; \\frametitle&#123;test&#125; Hello, world! \\end&#123;frame&#125; %%------------------------------------------\\end&#123;document&#125; 需要说明的几点： \\usetheme{} 显然是用来换主题的。可供选择的有：Madrid、Warsaw、CambridgeUS； \\begin{frame} \\end{frame} 是 beamer 里面重要的概念，每一个 frame 定义了一张 Page。 bug 及可能的解决方法无法编译/更新宏包这里仅列举 beamer 编译不成功的例子，其他宏包是类似的。 使用 beamer 编译不能成功, 可能是使用的 beamer, pgf, xcolor 宏包需要更新，更新地址为：当然也可以使用 LaTeX 发行版提供的宏包管理工具 beamer 更新地址: http://sourceforge.net/projects/latex-beamer/pgf 更新地址: http://sourceforge.net/projects/pgf/xcolor 更新地址: http://www.ctan.org/tex-archive/macros/latex/contrib/xcolor/ 具体更新步骤如下: (1) 下载: 下载最新的 beamer, pgf, xcolor 包;(2) 安装: 找到 TeX 的安装目录 texmf, 放到下面的地方即可： texmf/tex/latex/beamer, texmf/tex/latex/pgf, texmf/tex/latex/xcolor这里有一个细节要注意一下: 如果 texmf/tex/latex/ 目录下原来有 beamer, pgf 等文件夹, 宜先删除原有的旧文件夹, 再粘贴新文件。(直接覆盖的话，可能会因为文件名不同，使旧文件没有被删除。)","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://blog.lyh543.cn/tags/LaTeX/"}]},{"title":"配置 LaTeX 开发环境 (TeX Live / CTeX + TeXstudio)","date":"2019-11-12T12:58:41.000Z","path":"latex/setting-up-latex-developing-environmnent/","text":"相比于 C++、Python 等开发环境的配置，LaTeX 的开发环境就要麻烦的多了。因此也准备水一篇博客，来讲讲我的配置环境的过程。 TeX Live 和 CTeX 都是编译器。其中 CTeX 据说是根据国人优化过的（但是很久没更新了，还会出 bug，有点麻烦，不推荐）。而 TeXstudio 是编辑器。 看网上说，CTeX 和 Tex Live 是二选一的关系。我本来是全装了的，但是发现经常遇到 bug，而在只装了 TeX Live 的笔记本上却没有这样的 bug，后来就卸载了 CTeX。 安装 TeX LiveTeX Live 是跨平台（Win/Linux/Mac OS）的。不过由于 NTFS 分区格式和其他系统有区别，Windows 的编译过程会较慢，一篇 20 页的论文使用 xelatex 编译，同配置的电脑 Linux 下编译不到 3 秒，Win 下需要 12 秒。当然，Win 也不是不能用。 TeX Live 的官网可谓是相当简洁。。。。 TeX Live 官网 不过根据一般的大软件都会以光盘（iso）的形式提供离线安装包（如 Windows、Office），看到官网上的 DVD 就直接点进去。 点进去好像也没有什么下载的地方，不过下面有一行小字 downloading the TeX Live ISO image and burning your own DVD，点进去，再经几番周折就能找到链接。 很不错的是，网站会根据你的 ip 跳转到最快的服务器，点击链接前把代理关掉，在国内就能跳转到中科大的源，下载最新的 .iso 文件（带年月日和只有年份的均可），轻松跑满速。 安装的过程不难，不多说了，不会的话可以自行百度。 更改 TeX Live 远程仓库及更新稍对 LaTeX 工作原理有所了解的人都知道，LaTeX 体系由无数的小的宏包组成，而这些宏包可能并没有默认安装在电脑，而是需要的时候会自动下载。 说到下载，一个不得不提的就是下载的源，某些外国的源到中国的下载速度非常慢，甚至下载不了。因此，切换到镜像站就非常重要。 下面是通过 GUI 等方法（较麻烦），最后还有直接命令行的方法。 安装好 TeX Live 以后，在开始菜单打开 TeX Live Manager。 找到 选项 - Repositoties...，选择下面的 specific mirror 中的中国的任意一个镜像站（个人喜好中科大 ustc），保存。 更换 TeX Live 仓库源 还可以更新 tlmgr 之类的，都是非常容易的，自己琢磨一下能弄懂了。 顺便一提，上面的所有操作都可以用命令行（管理员权限）完成： 123tlmgr option repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnettlmgr update --selftlmgr update --all TeX Live 默认会安装所有包。如果只安装了 tlmgr，并没有安装其他的包，可以使用以下命令行安装所有包： 1tlmgr install scheme-full 更新 TeX LiveTeX Live 每年会更新一次大版本，之前的版本会无法再使用 tlmgr install 和 tlmgr update，需要进行更新。 然而，在官方的Upgrade页面上，官方推荐的更新方式是重新安装。这也可以从文件夹名字包含年份看出。 Upgrade页面 官方给出了 Unix 下的更新方法，不过我发现，似乎也可以仅运行 http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.sh 以完成更新（尚未清楚有什么副作用）。 对于 Windows，官方说没有类似的升级方法，但是，将上述链接的 sh 后缀改为 exe （即 http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.exe ）后能下载到一个 exe，运行后，可发现 TeX Live 升级完成。 完成上述升级后，即可 tlmgr update --self --all 对包进行升级。 安装 CTeX 2019.11.16 更新：我在安装了 CTeX 和 TeX Live 的电脑上编译 beamer 幻灯片文件，死活编译不过，也手动下载了安装包，还是无解。后来偶然发现只安装了 TeX Live 的电脑竟然能编译通过。于是删掉了电脑上的 CTeX，再次编译，通过。因此，我不推荐安装 CTeX。 CTeX 的安装也不难，甚至比上面简单。、 问题就在于 CTeX 太老了，最后一次更新是在 2016 年。导致他自带的 MiKTeX 不能链接服务器进行更新，手动更新就会报错 Data: Get host by name failed in tcp_connect().。 解决方法可以见 替换CTeX套装中的MiKTeX、WinEdt和Sumatra PDF组件 ，这里不再多说。 顺便提一下，文中还提到了替换 CTeX 的另外两个组件。有需求的可以按照上面博客做。 安装 TeXstudio这货的官网貌似被墙了。。。 不过他有 GitHub 仓库，去 releases 页就能看到下载链接了。（顺便说一句，官网的下载链接也是重定向到 GitHub 的。。。） 我使用的是 2.12.16 版本。 安装也是非常简单，不过安装以后需要配置一下。 首先，TeXstudio 是支持中文的，但他就是不默认使用。在 Option 选项卡 - Configure TeXstudio - General 侧边栏 - Apprearance - Language 调成 zh_CN。 调完以后，标题的宋体就非常引人注目了。（逃 还好这也是可以调的。在刚才的 语言 上面有字体、字号。我使用的是 微软雅黑，字号为 9。 如果你使用的是 2K 以上的屏幕，工具栏的图标还是很小。这玩意不适配高分屏吗？？ 后来发现还是可以改。。。在刚才的设置的最下面有一个高级设置的复选框，勾上以后，就出现了 GUI 缩放的功能。 调整 GUI 选项还是靠拖动的，拖到一个比较好看的地方就可以了。 之后 TeXstudio 也不需要怎么配置了，直接就能调用 CTeX / TeX Live 编译了/","tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"https://blog.lyh543.cn/tags/LaTeX/"}]},{"title":"MATLAB 解常微分方程","date":"2019-11-11T11:44:18.000Z","path":"matlab/differential-equation/","text":"常微分方程常微分方程就是解 $\\frac{dN}{dt}=rN, N(0)=N_0$ 这一类的方程。 上式中，若 $r$ 为常量，则常微分方程的解为 $N_0 e^{rt}$。 建立常微分模型的过程略。 MATLAB 解常微分方程的函数解运用 desolve 命令。 如果使用字符串，方法如下： 1desolve('') 如果运用符号编程，方法如下： 123syms N(t) K N0 r0;dsolve(diff(N,t,1)==r0*(1-N/K)*N, N(0)==N0)pretty(ans) 求解一元一阶常微分方程数值解有些常微分方程能够解得显式函数，但是也有不能的。于是我们退而求其次，只需要求其数值解。 更一般的是： $$\\frac{dy}{dt} = f(t,y) \\\\y(t_0) = y_0$$ 误差分析局部截断误差思想：假设 $y_n$ 准确，计算 $y_{n+1}$ 的误差。 设 $y_n=y(x_n)$，称 $R_{n+1} = y(x_{n+1}) - y_{n+1}$ 为局部截断误差。若局部误差为 $O(h^{n+1})$，则称该方法有 $n$ 阶精度。 欧拉法解法：（欧拉法，又名左矩形法）积分。 显式快，但是不稳定，h需要很小；隐式慢，但是稳定，h可以很大。 显式的如下： $$\\begin{aligned}\\int_{t_0}^{t_1}y’(t)dt &amp;= \\int_{t_0}^{t_1}f(t,y)dt \\\\y(t_1) - y(t_0) &amp;\\approx (t_1 - t_0)f(t_0,y_0) \\\\y(t_1) &amp;\\approx y(t_0) + (t_1 - t_0)f(t_0,y_0) \\qquad\\cdots(1)\\end{aligned}$$ 由 (1) 式可解出 $y(t_1)$ 的近似值，并继续用 $y(t_1)$ 解出 $y(t_2),…$ 隐式的方法： $$\\begin{aligned}\\int_{t_0}^{t_1}y’(t)dt &amp;= \\int_{t_0}^{t_1}f(t,y)dt \\\\y(t_1) - y(t_0) &amp;\\approx (t_1 - t_0)f(t_1,y_1) \\\\y(t_1) &amp;\\approx y(t_0) + (t_1 - t_0)f(t_1,y_1) \\qquad\\cdots(2)\\end{aligned}$$ 同样可由 (2) 式解出 $y(t_1)$ 的近似值，并继续用 $y(t_1)$ 解出 $y(t_2),…$但问题在于对于 (2) 式右边的部分是未知的，也就是说，还要解一下 (2) 这个非线性方程。 以上方法还可以解多元的情况。 例题：预测战争模型 $\\left\\{ \\begin{aligned}\\frac{dx}{dt} &amp;= -0.15y \\\\\\frac{dy}{dt} &amp;= -0.1x \\\\x_0 &amp;= 10000 \\\\y_0 &amp;= 5000\\end{aligned} \\right.$ 计算 t 为何值时， x 或 y 变为 0。 12345678910111213141516171819202122dt=1/3600;N=10;size = fix(N/dt);a = 0.15;b = 0.1;y = zeros(1,size);x = zeros(1,size);x(1) = 10000;y(1) = 5000;for i = 2:size+1 x(i) = x(i-1) - a * y(i-1) * dt; y(i) = y(i-1) - b * x(i-1) * dt; if (x(i) &lt; 0 || y(i) &lt; 0) break; endendfprintf( 't=%d, x=%d, y=%d',double(i-1)*dt,x(i), y(i))t = 1:i;t = t * dt;h = plot(t, x(1:i),'r-', t, y(1:i), 'k-') % r 红色， k 黑色set(h, 'linewidth' ,2);legend('x', 'y'); 梯形法但是不想解非线性方程。 于是搞了一个近似的方法——预估——校正法（修正的欧拉法）。是二阶误差的。 $$y(t_1) - y(t_0) = \\frac{h}{2}[f(t_0,y_0)+f(t_1, y_1)] \\\\\\Rightarrow \\begin{cases}\\tilde{y_1} = y_0 + hf(x_0, y_0) \\qquad(由 1 式) \\\\y_1 = y_0 + \\frac{h}{2}[f(t_0,y_0)+f(t_1, \\tilde{y_1})]\\end{cases}$$ Range-Kutta 公式简单介绍一下就行。不需要记。 MATLAB 命令解常微分方程数值解：二阶 ode23，四阶 ode45。 ode45题目是上面的预测战争模型。 123456789101112function testmain[T,Y]=ode45(@rigid,[0 6],[10000 5000]);plot(T,Y(:,1),'-',T,Y(:,2),'*')% T的每一行表示时间，Y的每一行表示两边的兵力function dy=rigid(t,y)a=0.15;b=0.1;dy=zeros(2,1);dy(1)= -a*y(2);dy(2)= -b*y(1); 求解多元常微分方程将 $y1,y2$ 用向量 $\\vec{y}$ 来写，$f$ 用向量 $F$ 来写，数值解法和一元一阶常微分方法相同。 解高阶微分方程就是降阶。 123456function dy=odefun(t,y)n=length(y); dy=zeros(n,1);dy(1)=y(2)dy(2)=y(3)% ...dy(n)=f(t,y(2),y(3),...,y(n-1));","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"}]},{"title":"Windows 使用 ssh","date":"2019-11-06T03:18:51.000Z","path":"microsoft/windows/setup-ssh-windows/","text":"和 Linux 一样，Windows 10 （我为 Win 10 1909）上也可以使用 ssh 客户端和服务器。对 Windows 进行 ssh 的效果就是 cmd，当然你也可以在里面输入 powershell 或 wsl 使用其他的命令行。 这就是这篇文章归类于 Linux 的原因吗 Windows 安装 ssh 客户端其实可以直接使用 wsl 的 ssh 客户端的。 但是既然 Windows 提供了这个功能，那就还是提一笔。 在 Windows 设置(按 Windows徽标键+I) 直接搜索 添加可选功能 并进入。 添加功能，找到 OpenSSH 客户端 并安装。 安装好以后就可以使用 ssh ssh-keygen ssh-agent ssh-add scp 等功能了。 Windows 安装并配置 ssh 服务器同样是在上面的 添加可选功能 找到 OpenSSH 服务器 并安装。 以管理员权限的 Powershell 执行 net start sshd 即可。 本地测试：在 cmd 执行 ssh 微软账户@127.0.0.1(我的是 ssh lxl361429916@live.com@127.0.0.1，虽然两个 @ 确实有点蠢)，密码是微软账户的密码。被问及是否要信任的时候选 yes。 如果需要外网链接该服务器，需要有一个公网 ip 或进行内网穿透，可参考 利用内网穿透进行远程桌面访问。这里就不多说了。 Windows 设置 ssh 公钥这个地方倒挺麻烦，如果直接使用 Linux 向 Linux 加入公钥的方式 ssh-copy-id，在 Windows 服务器上是行不通的，会显示没有 cat 等命令。 直接把客户端的公钥复制到服务器的 %USERPROFILE%\\.ssh\\authorized_keys 也不能使用。因为权限不对。 参考链接：Setting up OpenSSH for Windows using public key authentication - Stack Overflow 首先通过 scp 或其他方式（随便瞎搞，鼠标复制粘贴都行），把客户端的公钥复制到服务器的 %USERPROFILE%\\.ssh\\authorized_keys。 用文件资源管理器打开 %USERPROFILE%\\.ssh\\。 右键单击 authorized_keys，打开 属性 - 安全 -高级。 点击 禁用继承，并选择 将已继承的权限转换为此对象的显式权限。 最重要的一步，是删除除了 SYSTEM 和当前账户以外的所有账户的权限（也就是说，最后只能剩这两个账户，Administrators 什么的都得删）。回答中专门提到，某些使用 Repair-AuthorizedKeyPermission $env:USERPROFILE\\.ssh\\authorized_keys 的方法会导致增加 sshd 的权限，最后导致失败，所有不建议这么做。 如果 Windows 版本在 1809 及以后，还要打开 C:\\ProgramData\\ssh\\sshd_config 并注释掉以下两行： 12# Match Group administrators # AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys 最后以管理员权限重启 sshd： 12net stop sshdnet start sshd 即可。 配置文件目录 %USERPROFILE%/.ssh/ 对应 ~/.ssh/ %PROGRAMDATA%/ssh/ 对应 /etc/ssh/","tags":[{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"ssh","slug":"ssh","permalink":"https://blog.lyh543.cn/tags/ssh/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.lyh543.cn/tags/Windows/"},{"name":"frp","slug":"frp","permalink":"https://blog.lyh543.cn/tags/frp/"}]},{"title":"非线性方程求根","date":"2019-11-01T16:00:00.000Z","path":"mcm/non-linear-equation/","text":"多元函数误差分析基本概念：绝对误差 $\\varepsilon(x)$ 和相对误差 $\\varepsilon_r(x) = \\frac{\\varepsilon(x)}{x*}$ 对于 $z=f(x_0,x_1,…x_n)$，有 $$\\varepsilon(z) \\approx \\sum_{k=1}^{n}|\\frac{\\partial f}{\\partial x_{k}}| \\varepsilon(x_{k})$$ 对于特例： $$\\begin{aligned}\\varepsilon(x_1+x_2) &amp;=\\varepsilon(x_1)+\\varepsilon(x_2) \\\\\\varepsilon(x_1 \\cdot x_2) &amp; \\approx|x_1| \\varepsilon(x_2)+|x_2| \\varepsilon(x_1) \\\\ \\varepsilon(x_1 / x_2) &amp; \\approx \\frac{|x_1| \\varepsilon(x_2)+|x_2| \\varepsilon(x_1)}{x_2^2}\\end{aligned}$$ 比如 $z=xy$ 误差为 $|x|y’+x’|y|$。 应用：对于除法的情况，避免绝对值小的量当分母。 安利秦九韶算法来计算多项式。在不同数据下误差小的算法就叫 稳定的算法。 例题：稳定的算法看一个例子：利用递推式计算 $I_n$ 的估计值 $S_n$。 $$I_n = e^{-1} \\int_0^1 x^n*e^x dx \\quad (n = 0, 1, …,20)$$ 对积分值可以放缩：由于 $1 \\leq e^x \\leq e \\quad(0&lt;x&lt;1)$，有 $$\\frac{e^{-1}}{n+1} \\leq e^{-1} \\int_0^1 x^n*e^x dx \\leq \\frac{1}{n+1}$$ 方法一：利用分部积分求得递推式 $$\\begin{cases}I_0 &amp;= 1-e^{-1} \\\\I_n &amp;= 1-n I_{n-1},(n=1,2, \\cdots)\\end{cases}$$ 如果推出递推式用迭代法从小往大，$n&gt;=20$ 的时候误差值就会变得非常大，甚至超出了预估值的范围（$S_{20} = -30.19$）.。理由是初值有误差，每次迭代都会放大误差。那么能不能把放大误差变成缩小误差呢？ ——把递推式中的 *n 换为 /n，从后往前推。 方法二：先算 $S_{30}$ 再往前推，最后误差极小，这时候这就是一个稳定的算法。 由 $I_n$ 的估计式，令 $S_n = \\frac{1}{31}$。反解上面的递推式，得 $I_{n-1} = \\frac{1}{n}(1-S_n)$。 然后反过来跑递推，得到的 $S_1$ 能保证 $10^{-14}$ 的精确度。 数值方法前人：$n \\geq 5$ 时无显式求根公式 基本思想：迭代法逼近 第一步：对 $f(x)=0$ 的根进行隔离 第二步：利用迭代法计算一定精度的根近似值 从给定的一个出发值 $x_0$，产生一个序列 $x_0, x_1,…$ 详见迭代法解线性方程组 二分法二分夹逼，简单无脑，要求单调。 定理 误差满足 $|x_n-x^*|&lt;\\frac{|b-a|}{2^{n+1}}$ 不动点迭代偏理论的方法，略。 另外提到了收敛阶数 $r$： $$\\lim\\limits_{n\\to\\infty}\\frac{|x_{n+1}-x^*|}{|x_n-x^*|^r} = a$$ 按 $r$ 大小分为线性收敛、超收敛、平方收敛等等。 迭代误差： 线性收敛：每次迭代误差放大 k 倍 超收敛 ($r&gt;1$) 每次迭代误差是上一次误差的 $r$ 次方的 $k$ 倍数，在这个含义下，如果第一次误差 $1\\%$，$r=2$，那么迭代一次后误差为 $0.01\\% \\times k$ 牛顿迭代法（正确性根据引理，从略）基本思想：泰勒公式将非线性函数线性化设函数 $f(x)$ 在有根空间 $[a,b]$ 二次连续可微，泰勒后只取线性部分。 用切线方程的根近似原 $f(x)$ 的根，然后多次牛顿迭代近似 $$x_{n+1} = x_n - \\frac{f(x_n)}{f’(x_n)}$$ 牛顿迭代法的几何意义： 上一次得到根 $x_1$，再在 $x_1$ 的地方做泰勒近似（做切线），在 $x$ 轴截到 $x_2$… 用上一个根迭代下一个根，nb所以单变量牛顿迭代法也被称为切线法 一个例题，实际使用估计还得工具箱 有缺陷的牛顿迭代法 12345678f=inline('x*exp(x)-1');f1=inline('(x+1)*exp(x)');x0=0.5;er=1;k=0;while er&gt;0.00001 x=x0-f(x0)/f1(x0); er=abs(x-x0) x0=x; k=k+1end 缺陷： 被 0 除错误，根使得原函数和导函数都为 0 的情况，称为二重根可以考虑加一个 eps？ 死循环：对于特殊函数(如 $\\arctan x$）无法使用多次迭代无进展的话跳出，换个算法 牛顿迭代法改进：弦截法$$x_{n+1} = x_n - \\frac{(x_n - x_{n-1})f(x_n)}{f(x_n) - f(x_{n-1})}$$ 不使用切线，而是使用上两次迭代的点的线（也就是割线、弦），依旧是看其与 $x$ 轴的交点。 看看两个解之间的距离是不是逐渐变小且函数值是不是逐渐变小来判断是否收敛、是否适用于牛顿迭代法 范数简介向量范数向量范数公理化的定义：如果一种映射 $f: R^n \\to R$ 的结果，映射出来的 $\\| x \\|$ 满足正定性、齐次性、三角不等式，则被称为范数。 范数是对长度的推广，三角不等式需要根据柯西不等式证明得到。 1-范数：${\\|x\\|}_1 = \\sum\\limits_{i=1}^n|x_i|$ 2-范数：$\\|x\\|_2 = \\left(\\sum\\limits_{i=1}^n|x_i|^2\\right)^{1/2}$ 无穷范数：$\\|x\\|_\\infty = \\max\\limits_{1 \\leq i \\leq n}|x_i|$ 一般向量而言，无穷范数 &lt; 1-范数 &lt; $n*$无穷范数。 性质：向量空间的任何范数均等价 1-范数、无穷范数随便选，算起来都简单 矩阵范数公理化定义依旧是：正定性、齐次性、三角不等式。 对于向量的 1-、2-、无穷范数，是对向量的每一个元素进行处理、加和，矩阵中引申到矩阵的每一个元素进行处理、加和，最后将和进行开 n 次根。 $$\\begin{aligned}\\| A \\|_{m_1} &amp;= \\sum_{j=1}^n\\sum_{i=1}^m|a_{ij}| \\\\\\| A \\|_{m_2} &amp;= \\left( \\sum_{j=1}^n\\sum_{i=1}^m|a_{ij}|^2 \\right) ^ \\frac{1}{2} \\\\\\| A \\|_{m_\\infty} &amp;= \\max_{i,j}{|a_{ij}|} \\quad 1 \\leq i \\leq m,1 \\leq j \\leq n \\\\\\| A \\|_F &amp;= \\left( \\sum_{j=1}^n\\sum_{i=1}^n a_{ij}^2 \\right) ^ \\frac{1}{2}\\end{aligned}$$ 注意 F-范数 只适用于实矩阵。 这种定义不好用，所以有了另一种矩阵范数：矩阵算子范数。 矩阵算子范数逐渐晕掉 对于矩阵 $A \\in R^{n \\times n}$，其算子范数的定义为 $$\\| A \\| = \\max_{x \\neq 0} \\frac{\\| Ax \\|}{\\|x\\|} $$ 其定义是基于向量范数的。对于二阶有： $$\\| A \\|_2 = \\max_{x \\neq 0} \\frac{\\| Ax \\|_2}{\\|x\\|_2} $$ 或 $$\\| A \\|_2 = \\max_{\\|x\\|=1} \\| Ax \\| _2$$ 算子的英文是 Operator。 矩阵范数的相容性如果三种矩阵范数满足：$$\\|AB\\|_c \\leq \\|A\\|_a \\cdot \\|B\\|_b$$则称这三种矩阵范数相容。 如果$$\\|AB\\| \\leq \\|A\\| \\cdot \\|B\\|$$则称这种矩阵范数是自相容范数。 $\\| A \\|_{m_\\infty}$ 是不相容范数。 定理： $$\\| A \\|_2 = \\max_{x \\neq 0} \\frac{\\| Ax \\|_2}{\\|x\\|_2} =\\sqrt{\\lambda_{max}(A^TA)}$$ 不仅如此，若 $A$ 为对称矩阵，$\\sqrt{\\lambda_{max}(A^TA)} = \\lambda(A)$。之所以这么定义，是为了把任意矩阵 $A$ 变成对称矩阵 $A^TA$，而对称矩阵一定有实特征值，从而保证了范数的非负性。 这个公式告诉我们，2-算子范数不仅好用（相容），而且好算23333目前其他的算子范数不好算。 定理：矩阵所有特征值小于等于矩阵的任意范数。而二范数又等于最大的特征值，则有： $$\\| A \\|_2 \\leq \\| A \\|_c$$ 矩阵的条件数$Ax=b$，右端有一点扰动量 $\\delta b$，引起了方程解的扰动 $\\delta x$： $$A(x+\\delta x) = b + \\delta b$$ $A\\delta x = \\delta b, \\delta x = A^{-1}\\delta b$，由矩阵的相容性（假设我们只使用相容的矩阵范数）有 $$\\left\\| \\delta x \\right\\| = \\left\\| A^{-1} \\right\\| \\left\\| \\delta b \\right\\|$$ 又由 $Ax=b$，有 $\\left\\| b \\right\\| = \\left\\| A \\right\\| \\left\\| x \\right\\|$ 以上两式整理得： $$\\frac{\\left\\| \\delta x \\right\\|}{\\left\\| x \\right\\|} \\left( \\left\\| A \\right\\| \\cdot \\left\\| A^{-1} \\right\\| \\right)\\frac{\\left\\| \\delta b \\right\\|}{\\left\\| b \\right\\|} $$ $\\|A\\| \\cdot \\|A^{-1}\\|$ 越大，即使 $\\delta b$ 小，$\\delta x$ 也会很大 因此，定义条件数： $$Cond(A) = \\|A\\| \\cdot \\|A^{-1}|$$ 条件数很大时，$Ax=b$ 是病态问题；条件数很小时（几百、几千、几万），$Ax=b$ 是良态问题。 15 阶希尔伯特矩阵的条件数为 $10^{10^{16}}$，因此，与希尔伯特矩阵的数值计算是十分困难的。 MATLAB 对范数的支持norm 求范数，cond 求条件数。 非线性方程组牛顿法，就是最优化嘛。由于我学过最优化，这部分就略了。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"数学归纳法的七种变式及其应用（转载）","date":"2019-10-31T06:13:11.000Z","path":"maths/mathematical-induction/","text":"分享深度好文。数学归纳法的七种变式及其应用","tags":[{"name":"转载","slug":"转载","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"数学","slug":"数学","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"差分方程","date":"2019-10-28T11:35:27.000Z","path":"maths/difference-equation/","text":"例：熟悉的汉诺塔游戏（略）。 $\\begin{cases}a_n = 2a_{n-1}+1 \\\\a_1 = 1\\end{cases}$ 又例：两个海军交战，两边的火力 $a_n, b_n$。 差分方程是研究/刻画元素之间的规律。 定义差分方程：有一数列 ${a_n}$，把数列中的 $a_n$ 和前面的 $a_i\\; (i=0,1,2,…)$ 关联起来的方程叫做差分方程（也叫做递推关系）。数列中的一些已知数称为初始值。 一阶差分：$\\Delta a_i = a_{i+1} - a_i \\; (i=0,1,2,…)$ 解差分方程数模貌似没有太高要求。用到了就现学.jpg 时间训练模型前面貌似都挺水，这个才开始硬核起来。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"算法设计","date":"2019-10-27T16:00:00.000Z","path":"computer-science/design-and-analysis-of-algorithms/","text":"该篇博客为肖鸣宇老师所开的 Design and Analysis of Algorithms 课程的笔记。 绪论算法解决的三种问题 Desicion Problem（判断是否） Optimal（最优化的结果/解） Numeric Calculation（数字计算、解方程） 问题的分类（按复杂度） P: a solutuon can be solved in polynimoal time. NP: a solution can be checked in polynomial time. NPC: problems that may not have a polynomial-time algorithm. P NP NP-Complete NP-Hard PTAS: Polynomial-time approximation scheme 和上面不同的是，上面的词描述的都是问题，而 PTAS 是解决问题的方法。也就是说，可以说某个 NP-Hard 问题有 PTAS 算法。 PTAS 要求对于给定的任意近似率 1+ε，都能给出一个多项式算法，虽然这个多项式在 ε 趋于 0 时会变为指数级或更高。一般来说 PTAS 算法的复杂度都可以写为 $O(n^{(1/ε)})$ 或 $O(n^{exp(1/ε)})$。如 TSP 问题和背包问题都存在 PTAS 算法。 NPC 问题的求解 启发式算法（Heuristic algorithm）：我觉得怎么好，就怎么做。不知道对不对，但是跑的确实快。例如：人工智能方面。 近似算法（Approximation Algorithm）：在多项式时间内得到一个近似解。（难点在于证明近似） 快速算法：高效的指数运行时间的精确算法。 参数算法：参数小的时候，能高效解决问题。近年来兴起。 稳定婚姻问题 Stable Match / Stable marriage problem给定 n 男 n 女，以及每个人对异性对象的喜好程度（按 1 至 n 排列）。安排男女结婚，使得不出现以下不稳定情形： 在 n 男 n 女中的存在两对夫妇 (M, W) 和 (m, w)，M 男对 w 女喜好度大于现任妻子 W 女，并且 w 女对 M 男喜好度也大于现任丈夫 m 男。 找到解、证明其符合题意、证明是否存在最优解都不是很显然。 稳定室友问题 可能无解若给 2n 个人，可以随意选择其他 2n-1 人。可能无解。如下图： stable roommate match Gale-Shapley 算法Gale-Shapley 算法，1962 123456789101112Initialize each person to be free.while (some man is free and hasn't proposed to every woman)&#123; Choose such a man m w = 1st woman on m's list to whom m has not yet proposed if (w is free) assign m and w to be engaged else if (w prefers m to her fiancé m') assign m and w to be engaged, and m' to be free else w rejects m&#125; Demo 正确性证明：终止注意到： (1) 男生从高到低求婚，且对同一个女生只会求一次婚；(2) 女生一脱单，不会重返单身； 因此，由 (1)，最多进行 $n^2$ 次匹配后，程序会终止。 正确性证明：所有人都被匹配数学三大证明方法：反证、归纳、构造。 反证（By Contradiction）：不妨设（Suppose, for sake of contradiction, that）结束时 Zeus 没有被匹配，由 (1)，他向所有女生求过婚。 则一定有女生没有被匹配，不妨设为 Amy； 由 (2)，Amy 从来没有被求过婚； 则 Amy 没有被 Zeus 求过婚； 由假设和上一条，推出矛盾。 正确性证明：稳定性反证：假设 A-Z 是不稳定对。则分情况讨论： 情况 1：Z 没有向 A 求过婚。则 Z 更喜欢当前的对象，与假设矛盾； 证明 2：Z 向 A 求过婚，而 A-Z 没有在一起，则 A 更喜欢当前的对象，与假设矛盾； 综上，假设不成立。 思考 如何用算法实现？时间复杂度？（用数组即可，时间复杂度 $O(n^2)$） 如果有多种稳定匹配，GS 算法得到的是哪一种？ 多种稳定匹配情况——GS 男生最优，女生最劣定义：如果存在一组稳定匹配，其中男生 m 为女生 w 配对，则定义他们为彼此的合法伴侣。结论：GS 算法得到的是男生的最优解，女生的最劣解（男生匹配到的伴侣是最优的合法伴侣，女生匹配到的伴侣是最劣的合法伴侣）。 证明 GS 算法得到的匹配 S* 是男生最优的（男生匹配到的伴侣是最优的合法伴侣）：（反证） 假设某男在 S* 中匹配到了不是最佳合法伴侣的伴侣。由于男生是以降序求婚，有男生被其最佳合法伴侣拒绝过。设第一个被最佳合法伴侣拒绝的男生为 Y，其最佳合法伴侣为 A。 设在另一个稳定匹配 S 中，女生 A 和男生 Y 在一起。 在 S* 中，女生 A 拒绝过男生 Y，则女生 A 一定和某男生（设为 Z）在一起了（女生拒绝男生的充要条件是女生和她更喜欢的男生在一起）。则可得女生 A 对男生的好感度中，Z &gt; Y (3)。 设在 S 中，男生 Z 和某女生 B 在一起。 由于在 S* 中，男生 Y 是第一个被拒绝的，所以此时男生 Z 还没有被拒绝过。此时男生 Z 和女生 A 在一起了，所以男生 Z 还没有向女生 B 求过婚（否则 Z 需要先被 B 拒绝，才能和 A 在一起）。则男生 Z 的好感度中，A &gt; B (4)。 在稳定匹配 S 中，A-Y 在一起，B-Z 在一起。而由 (3)(4)，A-Z 对彼此的好感度高于他们的当前伴侣 B(Y)，因此，推出匹配 S 是不稳定的，矛盾。 问题得证。 有意思的是，男生的最优是以女生的最劣为代价（在 GS 算法中，女生匹配到的伴侣是最劣的合法伴侣），这可以由男生最优这一结论简单的推出： 假设在稳定匹配 S* 中，女生 A 和 男生 Z 在一起。而女生 A 的最劣合法伴侣是某男生 Y。则女生 A 对男生的好感度中，Z &gt; Y (5)。 设在稳定匹配 S 中，女生 A 和某男生 Y 在一起，男生 Z 和 女生 B 在一起。 S* 中 A-Z 在一起。由 S* 中男生最优的结论，男生 Z 对女生的好感中，A &gt; B (6)。 在稳定匹配 S 中，A-Y 在一起，B-Z 在一起。而由 (5)(6)，A-Z 对彼此的好感度高于他们的当前伴侣 B(Y)，因此，推出匹配 S 是不稳定的，矛盾。 问题得证。 问题拓展：将病人安排在医院没有做过多研究，仅作摘抄。 Men ≈ hospitals, Women ≈ med school residents Variant 1. Some participants declare others as unacceptable. (resident A unwilling to work in Cleveland)Variant 2. Unequal number of men and women.Variant 3. Limited polygamy. (hospital X wants to hire 3 residents) Def. Matching S unstable if there is a hospital h and resident r such that: h and r are acceptable to each other; and either r is unmatched, or r prefers h to her assigned hospital; and either h does not have all its places filled, or h prefers r to at least one of its assigned residents. 算法复杂度分析渐进复杂度分析。 渐近分析（asymptotic analysis、asymptotics），在数学分析中是一种描述函数在极限附近的行为的方法。 有多个科学领域应用此方法。 例子如下： 在计算机科学中，算法分析考虑给定算法在输入非常大的数据集时候的性能。——维基百科 $O(g(n)), \\Omega(g(n)), \\Theta(g(n))$ 这些都是函数的集合。为什么用 “$=$”而不用 “$\\in$”，只能说是习惯。 主要是想说说另外两个非紧上界、下界。 $O(g(n)) = \\{ f(n) |$对于任何正常数 $c&gt;0$，存在正数 $n_0&gt;0$ 使得对所有 $n \\geq n_0$ 有：$0 \\leq f(n) &lt; cg(n) \\}$ $ \\Omega (g(n)) = \\{ f(n) |$对于任何正常数 $c&gt;0$，存在正数 $n_0&gt;0$ 使得对所有 $n \\geq n_0$ 有：$0 \\leq cg(n) &lt; f(n) \\}$ 和上面的区别就是这是对于任何 $c$ 都满足，因此必须要在数量级上非紧，才能使得对于任何 $c$ 都满足。 这还很像极限的定义： $$ f(n) = O(g(n)) \\space \\Leftarrow \\space \\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = 0 \\space \\Rightarrow \\space g(n) = \\Omega (f(n))$$ 但是不完全一样。如果拿极限定义，$f(n)$ 就不满足 $O(f(n))$ 了。 传递性、对称性、反身性、互对称性、算术运算。 贪心算法实例：线段覆盖。 证明贪心的正确性的几种方法： 试图说明在每一步以后，贪心算法至少和别的算法一样好。 如果每一个解都有值，找到一个界，并证明贪心能够达到这个界。 交换论证。证明每一个解通过一步步的交换，在不变差的前提下，逐渐变为贪心的解。 分治算法分治复杂度计算： 若 $T(n) = k \\cdot O(\\frac{n}{2}) + \\Theta(n)$，且 则 $T(n) = O(n^{\\log_2 k})\\cdot T(1) + O(n\\log n)$。（构造等比数列或列出递归树证明） 还有更通用的（但是好复杂）： 若 $T(n) = \\begin{cases}1 &amp; \\text{n=1} \\ kT(\\frac{n}{m})+f(n) &amp; \\text{n&gt;1} \\end{cases}$， 则 $T(n)=n^{log_mk}+\\sum_{j=0}^{log_mn-1}k^j f(\\frac{n}{m^j})$ 不如使用主方法。 注意分治递推表达式里面的常数 $k$ 推出来和 $n$ 的次数是有关系的。 递归表达式处理可参考《算法导论》或其他书籍的递归理论。 Substitution method（代换法，猜结论，然后用第二数学归纳法证明） Recursion-tree method（递归树法） Master method（主方法即套公式法） 主方法主方法看起来复杂，其实也不复杂。 对于表达式 $T(n)=aT(\\frac{n}{b})+f(n)$， 其中 $a≥1$ 和 $b&gt;1$ 是常数，$T(1)=\\Theta(1)$，$f(n)$ 是一个渐进正的函数（渐进函数，并且是增函数），其中 $\\frac{n}{b}$ 指 $\\lfloor \\frac{n}{b} \\rfloor$ 或 $\\lceil \\frac{n}{b} \\rceil$： 若对于某常数 $\\varepsilon&gt;0$，有 $f((n)=O(n^{\\log_b{a-\\varepsilon}})$，则 $T(n)=\\Theta(n^{\\log_b a})$ 若 $f(n)= \\Theta(n^{\\log_ba})$，则 $T(n)=\\Theta(n^{\\log_ba}\\log n)$ 若对于某常数 $\\varepsilon&gt;0$，有 $f(n)=\\Omega(n^{\\log_b{a+\\varepsilon}})$，且对常数 $c&lt;1$ 与所有足够大的 $n$，有 $a\\cdot f(\\frac{n}{b}) \\leq c \\cdot f(n)$，则 $T(n)=\\Theta(f(n))$ 主方法其实是在说这个事情： 对于 $T(n)=aT(\\frac{n}{b})+f(n)$，其最终算出来的复杂度为某两项之和，并且前一项化出来肯定是 $\\Theta(n^{\\log_b a})$。 主方法做的事情，就是为了在某些条件下，就可以直接判断哪一项的复杂度更高（然后忽略掉另一项）。 而第一、三条的奇奇怪怪的形式是为了表示一句话：“如果后一项的复杂度低于/高于 $\\Theta(n^{\\log_b a})$”。在渐进复杂度中没有“复杂度低于”的这种表示法，只能引入 $\\varepsilon&gt;0$ 来表示复杂度的高于、低于。于是看起来才这么复杂，为了严谨性不得不牺牲可读性。 剩下具体的内容就不再展开了，因为涉及到了主方法的证明了。 分治实例用分治加速大数乘法：将大数分为前半段和后半段计算。注意要尽量在代数上减少乘法的次数，不能直接跑。 Karatsuba Multiplication 用分治加速矩阵乘法：对矩阵分块，再经过一波玄学操作，能把 8 次乘法（$O(n^{log_2 k}) = O(n^3)$）减少到 7 次，从而把复杂度降到 $O(n^{log_2 7}) = O(n^{2.81})$。 Matrix Multiplication 动态规划DP 是为了解决递归算法中的重复计算。 DP 可以写为递归形式，也可以写为自底向上的循环形式。 0-1 背包问题时间复杂度：$\\Theta(nW)$，不是对于输入量的多项式复杂度，而是输入数值的多项式复杂度（输入量是输入数值取 $log$）。可称为伪多项式时间复杂度，Pseudo-polynomial）。是 NP 问题。 0-1 背包有多项式复杂度的近似算法，解的误差在 0.01% 以内。 序列比对把两个长度为 m 和 n 的字符串通过 mismatch 和 gap 使得两个字符串匹配。每个 mismatch 和 gap 的代价已知。求总代价的最小值。 String Similarity 跑一个 $T(n,m) = S(n,m) = \\Theta(mn)$ 的 DP 即可。 这是目前最快的算法，但是对于计算生物学来说，两个 10GB 的字符串会很难受。 网络流见另一篇博客。 NP 和难以计算的问题讲 NP 之前，我们得先来聊聊什么是归约。 归约，是把看起来不相关的两个问题的解决方法联系起来。这样，就能用一个已知为（公认为） NP 的问题，证明一堆问题是 NP 的。 多项式归约问题 $X$ 被多项式归约（polynomial reduces to）问题 $Y$，定义为，对于问题 $X$ 的任意一种情形，都能通过进行以下操作完成： 多项式次标准操作 和， 多项式次解决问题 $Y$ 的方法。 记作：$X \\leq _p Y$。 这么做的目的，是将问题按（在多项式时间内解决的）难度分类。以下是分类的技巧： 如果 $X \\leq _p Y$，而 $Y$ 能在多项式时间内解决，则 $X$ 也能在多项式时间内解决。 （1 的逆否命题）如果 $X \\leq _p Y$，而 $X$ 不能在多项式时间内解决，则 $Y$ 也不能在多项式时间内解决。 $(X \\leq _p Y) \\wedge (Y \\leq _p X) \\Leftrightarrow X \\equiv _p Y $。 归约的技巧 Reduction by simple equivalence.(简单恒等) Reduction from special case to general case.(从特殊到一般) Reduction by encoding with gadgets.(利用一些小技巧进行归约) 简单恒等：独立集 与 顶点覆盖独立集：给定一个图，在图中找到一个点的集合，使得集合中任意两点之间都没有线段。下图的最大独立集大小为 6。 最大独立集 点覆盖：给定一个图，在图中找到一个点的集合，使得图中的所有边的两个顶点至少有一个在集合里。下图的最小点覆盖是 4。 最小点覆盖 看两个描述就觉得有互补的关系，而看这两张图，就更明显了。最大独立集问题和最小点覆盖问题是否是互补的呢？ 是的！最大独立集问题 $\\equiv _p$ 最小点覆盖问题。 证明： 只需要证明 $S$ 是独立集的充要条件是 $V-S$ 是点覆盖。 必要：设 $S$ 为独立集。$\\forall \\ edge \\ (u, v), u \\notin S \\ or \\ v \\notin S \\Rightarrow u \\in V - S \\ or \\ v \\in V - S \\Rightarrow V - S$ 是点覆盖； 充分：设 $G-S$ 为点覆盖。对于 $S$ 中的任意两点 $v, u$，二点之间必没有边，否则至少有一点必须被加入点覆盖 $G-S$。所以 $S$ 是独立集。 从一般到特殊：集合覆盖 与 顶点覆盖集合覆盖：给定全集 $U$、它的一些子集 $S_1, S_2, …, S_m \\subseteq U$ 和一个整数 $k$，问能否从所有子集 $S_i$中选取不多于 $k$ 个，使得它们的并集为 $U$。 可以证明，顶点覆盖问题 $\\leq _p$ 集合覆盖问题。证明思路是，顶点覆盖问题和一类特殊的集合覆盖问题是可以互相等价的。 让顶点覆盖中的点是集合覆盖中的集合。 让顶点覆盖中的线段是集合覆盖中的元素。 让上述线段的两端的顶点是包含了对应元素所存在的集合。（特殊就出现在了这里，要求集合覆盖中的每个元素最多只能出现在两个集合 $S_i$ 中） 这样，我们构造出的特殊的最小集合覆盖即等价于最小顶点覆盖。如下图： 集合覆盖和顶点覆盖 因此，顶点覆盖 $\\leq _p$ 集合覆盖。 构造的小技巧：3-SAT 与 独立集先介绍一下析取范式。 简单合取式（Clause）：$C_j = {x_1} \\vee \\overline \\vee {x_3}$；析取范式（CNF）：$\\Phi = C_1 \\wedge C_2 \\wedge C_3 \\wedge C_4$。 SAT 问题（Satisfiability）是给定一个析取范式（CNF），判定是否存在一种赋值，使得该范式值为真。 3-SAT 即是，每个 Clause 的变量数不超过 3（不是整个 CNF 涉及到的变量数不超过 3）。如上述的 CNF。 我们可以归约：3-SAT $\\leq _p$ 独立集 构造：（假设问题的 CNF 有 $k$ 个 Clause） 对于每个 Clause 的三个变量，构造三个点，并连接起来构成 $k$ 个三角形； 将所有变量和它的所有否定形式一一连接。 此时，3-SAT 有解，当且仅当该图的最大独立集大小为 $k$。 3_SAT_to_Independent_Set 证明：显然 $k$ 是图的独立集大小的上界。若该图的最大独立集大小为 $k$，则每个三角形必有一个顶点在该独立集中，且这些点不会同时出现 $x$ 和 $\\overline{x}$ 的情况（否则这两点会被相连，与独立集定义矛盾），则可使取的点（$x$ 或 $\\overline{y}$）的值为真，没有被赋值的变量任取真或假，即是 3-SAT 的解。 若 3-SAT 有解，则独立集可取解中所有值为真的点，以及值为假的点的取反（即若 $x$ 为假，取所有 $\\overline{x}$），对于同一三角形中的点，可在取到的集合去掉任一，即可得到一个大小为 k 的独立集。 总结我们已经证明了： 3-SAT $\\leq _p$ 独立集 $\\equiv _p$ 顶点覆盖 $\\leq _p$ 集合覆盖 自身归约每个问题两个研究方向：决定问题（Decision Problem）和优化问题（Search Problem）。 举个栗子，对于顶点覆盖问题：决定问题是，是否存在一个小于等于 $k$ 的顶点覆盖。优化问题是，找到最小的点覆盖的集合的大小。 显然，对于所有问题，决定问题能被归约到优化问题。有趣的地方就在于，貌似优化问题也可以归约（指多项式归约）到决定问题，这样，决定问题和归约问题就互相归约了。这种归约叫做自身归约。 如果对于一个问题，如果它能自身归约，于是对于这种问题，我们要想证明 NP，只需要证明决定问题是 NP 的，这样就简化了问题。 而对于目前的所有问题，都可以证明有自身归约的性质（但不代表所有问题一定都有自身归约的性质）。 例子：最小点覆盖下面证明最小点覆盖的优化问题可以归约到决定问题。 二分搜索找到最小点覆盖的大小，并设为 k； 在图中找到一个点 v 使得删掉 v （及其邻边）的图的有大小为 k-1 的点覆盖； 在图中删去点 v，并返回 2 继续执行。 不同的问题证明自身归约有不同的方法，但其实也是有套路可循的。 P 与 NP决定性问题决定性问题的严格定义： $X$ 是一个字符串（当然也可以是数字）的集合，$s$ 是一个字符串，决定问题是需要判断 $s$ 是否在 $X$ 中。 多项式时间复杂度： 指对于每个字符串 $s$，判断 $s$ 是否在 $X$ 中的算法所需时间是 $s$ 长度 $|s|$ 的多项式次数。 如判断数字 t 是不是质数的朴素算法，就不是多项式时间复杂度的（是 $10^{|t|}$ 的）。在 2002 年出现了多项式复杂度的 AKS 算法，$p(|s|)=|s|^8$。它的 $X$ 集合是 $\\{2,3,5,…\\}$。 验证（Certification &amp; Certifier）算法验证算法同样是要判断 $s$ 是否在 $X$ 内。不同的是，它可以用到更多的信息 $t$，以加速判断。如，判断合数的验证算法需要的 $t$ 是它的一个因数，这样就能很快判断了。 验证算法的严格定义：对于算法 $C(s,t)$，如果对于 $X$ 中的任意一个解 $s$，都存在一个 $t$，使得 $C(s,t) = yes$，则称 $C(s,t)$ 算法是问题 $X$ 的一个验证算法。 NP 的严格定义先声明一下，NP 不是 P 的反义词！！！！这是新人（包括我）在第一次接触 P 和 NP 时，容易产生的一个很大的误区。 扯完验证算法，就可以说 NP 了，因为 NP 的严格定义是和验证算法有关的。 NP：存在多项式时间的验证算法的决定问题（即能在多项式时间内验证的问题）。 听完这个，可能你会有一万个黑人问号，NP 不就是不能在多项式解决的问题吗？？？？ 其实不是，说不定一万年以后就有人证出了某个 NP 问题是多项式可解的呢？所以呢，NP 的严格定义是存在多项式时间的验证算法，它并没有提及问题本身能否在多项式内是可解的。 不过呢，在平时，一般很多人说的 NP 指的就是目前多项式不可解的问题。这种说法是错误的。 那 NP 为什么叫 NP 啊？它定义里面就没有一个 N 开头的单词啊。NP 是 nondetermistic (turing machine) polynomial-time，即非确定性图灵机能在多项式时间内解决的问题。啊看不懂看不懂。 好了，那我们如何证明一个问题是 NP 的呢？ 。。。。。。。。。。 只需证明能在多项式时间内验证就行了。（不是说要证明他多项式不可解喔别被坑了哈哈哈哈） 验证合数显然是多项式可解的，那验证质数是 NP 呢？只能调用 AKS 跑一遍了，甚至不需要验证算法可以额外提供的 $t$。 NP-Complete NP-Complete（NPC、NP完全）：所有 NP 问题都能归约到这个问题，并且这个问题也是 NP 的。 顺便说一句，满足第一点的问题也被称为 NP-Hard。这里并不需要证明它不是 NP 的，因为你几乎不能证明一个问题不是 NP 的（毕竟证伪难）。所以 NP-Hard 包含了 NP-Complete 问题。如上一点的图。 NPC 的意义是，他们是 NP 中最难的问题，因为如果证明其中一个在多项式内有解，则直接证明了 P=NP！因此，我们不需要花太多精力来找是否存在多项式复杂度的问题。 问题是，第一个 NP-Complete 问题是如何产生的呢？ P、NP 和 EXP在讲第一个 NP-Complete 问题之前，这几个概念再理一遍： P： 使用图灵机能在多项式时间内解决的问题；NP： 存在多项式时间的验证算法的决定问题；EXP：使用图灵机能在 $O(2^{p(n)})$ 的时间内解决的问题（$p(n)$ 代表 $n$ 的多项式）。NP-Complete：所有 NP 问题都能归约到这个问题，并且这个问题也是 NP 的。NP-Hard：所有 NP 问题都能归约到这个问题。 有 P $\\subseteq$ NP $\\subseteq$ EXP，NP $\\wedge$ NP-Hard = NP-Complete。 其中 NP $\\subseteq$ EXP，可由 NP 的定义，解的集合 $X$ 肯定是有限的，因此能够在指数时间完成枚举即可。 P NP NP-Complete NP-Hard 第一个 NP-Complete 问题：Circuit Satisfiablity Circuit SAT 证明 Circuit SAT 是 NPC 证明的大概思路就是，对于任意 NP 问题，都可以把他的有限的解和验证算法的 t 构成一个逻辑电路，就把所有问题归约为了这个问题。 更多的 NP-Complete 问题我们证明 NP-Complete 的，如果按定义，证明所有 NP 问题都能被归约到这个问题，这也太难了。但是—— 有了第一个 NP-Complete 问题，我们就可以通过把已知的 NP-Complete 问题归约到其他问题，（根据归约的传递性）从而证明更多的问题也是 NP-Complete。 以下就是一个 NP-Complete 问题的拓扑图。 NP-Complete 拓扑图 这些问题又分为六个基本大类： Packing problems(装箱问题): SET-PACKING, INDEPENDENT SET. Covering problems: SET-COVER, VERTEX-COVER. Constraint satisfaction problems(约束满足问题): SAT, 3-SAT. Sequencing problems: HAMILTONIAN-CYCLE, TSP(旅行商问题). Partitioning problems: 3D-MATCHING 3-COLOR. Numerical problems: SUBSET-SUM, KNAPSACK. 大多数 NP 问题，要么已知是 P 的，要么已经被证明是 NP-Complete 的了。（也有例外：质因数分解、判断图的同构、纳什均衡等） 看到这里，你大概已经明白了，我们一般说一个问题已被证明多项式不可解，其实不是说的 NP，而是 NP-Complete（准确的说，是 NP-Hard。 虽然 NP-Complete 的定义里面也没有直接提到”多项式不可解”，但是，可以注意到的是，NP-Complete 问题多项式可解的充要条件是：P=NP。 接下来，我们要分别阐述六个基本大类里的 NPC 问题。 39-49??????? NP 问题归约例子近似算法","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"坑","slug":"坑","permalink":"https://blog.lyh543.cn/tags/%E5%9D%91/"}]},{"title":"最优化算法在数学建模中的应用","date":"2019-10-26T06:35:16.000Z","path":"mcm/optimization-in-mcm/","text":"最优化设计了以下方面： 最优化方法及其应用（含计算机模拟） 最优化模拟、最优化建模案例、最优化方法、 典型算法（穷举法、贪心、爆搜、蒙特卡罗法、模拟退火法、粒子群算法、蚁群算法）、随机系统模拟 数模一般使用 MATLAB 进行编程，MATLAB 自带的函数可在 MATLAB 函数 中查看。 如何学习？ 听课、了解、练习 借阅书籍 1：最优化方法（线性规划——单纯形，非线性规划——一维方法、无约束、有约束）、运筹学（线性规划、非线性规划、图论等）、随机系统模拟/离散系统仿真/系统仿真/系统模拟/计算机模拟 借阅书籍 2：数学模型、建模案例、建模优秀论文集 需要欣赏： 写法、风格、文法 论文框架：理解模型的思想，体会模型的建立过程、步骤 三个人都要对论文优秀论文有研究。 了解一些算法（如上的典型算法：穷举法等），变成的同学要熟悉，体现我们的工作量 经典算法比较简单的就一笔带过。 直接搜索法：用两个变量存储 f(x) 最小值和对应的 x 取值，并初始化最小值为无限大 inf。规定上下界和步长，枚举所有 x 值，如果 x 在范围内且 f(x) 值小于目前的最小值，则更新 f(x) 最小值及对应 x 取值。 蒙特卡罗法：与上述大体相同，只是取值的过程从“按上下界和步长枚举所有点”改为“在上下界内随机投大量点”，投点数量可由运行效率调整。 最优化相关基础概念 极大值、极小值、充要条件 blah blah 向量范数：即（二维上）两点距离在高维上的叫法。 p - 范数： $$||x||_p=(|x_1|^p+|x_2|^p+ \\cdots + |x_p|^p)^{1/p}$$ 更多向量范数知识见链接 等值线及其性质 全微分、方向导数、梯度 例题一：1996 全国赛 B 题 洗衣机节水问题 保证洗衣机的洗涤效果，如何减少用水。 建模前期分析报告模板： 明确建模目标 抓关键词 抓条件 列建模方向 建模难点 … 对于这个题来说，其实是一个化学题，建立了多次加水时，每次加水量和最后剩余污渍量的函数关系，建立了非线性最优化模型，使用 fmincon 求解。 例题二：2005 全国赛 B 题 DVD 租赁问题略。主要看建模过程（列最优化模型）的过程。 线性规划后面部分是 2019.11.2 的讲座，笔记作者为 OrangeRain. 问题一：无脑题，三原料两产品，高中数学 问题二也挺无脑的 线性规划模型中，约束条件为不等式时，可以 $f(x)+yi=0, yi \\geq 0$ 化为等式约束一般会直接丢到 matlab 中求解。 一类切割问题，一类指派问题对于切割钢条问题我们先分析一根钢条切完。一通分析上 intlinprog 整数约束一道课后思考题：先用 linprog 找到一个近似解 + 蒙特卡洛法 背包ccc，究极傻逼背包，正解不讲的 遗传算法模仿遗传的过程蚁群算法代码量少，模拟蚁群找食物，完事了，基本上不考。模拟退火代码量少，很好写的，简单介绍。就是个建模，把决策变量取值当做个体，要用约束条件限制变异，但这里讲的遗传算法不用约束（有约束也可以带进去处理）交叉之后可能发生变异， 准备工作：概念：基因、染色体进制转换：二进制转十进制、十进制转二进制 生物遗传学 最优化模型 种群 可行集的一些元素 个体 可行集的一个元素 染色体 同上 基因 同上 二进制编码 同上 在这个模型中，后四个其实在同一个层面上 先进行模块化设计，设计出一个较为通用的遗传算法的 MATLAB 语言实现 可是不是有工具箱吗 有约束优化$$\\min f(x) \\\\s.t.\\begin{cases}g_i(x) \\geq 0 &amp; i = 1,2,…,m \\\\h_j(x) = 0 &amp; j = 1,2,…,l\\end{cases}$$ 有约束优化常用罚函数法转化为无约束优化：当函数即将达到可行域边界/超出边界时，急剧增加其函数值作为“惩罚”，对可行域内的点不予惩罚。前者是内点法，后者是外点法。 外点罚函数法可构造以下函数，将对 $f(x)$ 的有约束优化转为对 $F(x,\\sigma)$ 的无约束优化： $$F(x,\\sigma) = f(x) + \\sigma P(x)$$ 其中惩罚因子 $\\sigma$ 是很大的正数， $P(x)$是连续函数。 $$P(x)=\\sum_{j=1}^l\\phi(h_j(x)) + \\sum_{i=1}^m\\psi(g_i(x))$$ 其中 $\\phi$ 和 $\\psi$ 是满足以下条件的连续函数： $$\\phi(y)\\begin{cases}=0 &amp; y=0 \\\\&gt;0 &amp; y \\neq 0\\end{cases} \\qquad\\psi(y)\\begin{cases}=0 &amp; y \\geq 0 \\\\&gt;0 &amp; y&lt;0\\end{cases}$$ 一个可行的取法为： $$\\phi(h_j(x))=|h_j(x)|^\\beta \\qquad \\psi(g_i(x))=[\\max\\{0,-g_i(x)\\}]^\\alpha$$ 常取 $\\alpha = \\beta = 2$。显然在可行域内，$P(x)=0$，否则 $P(x)&gt;0$。 $\\sigma P(x)$ 被称为罚项，$F(x,\\sigma)$ 被称为罚函数。 注意，惩罚因子 $\\sigma$ 越大，找到的点就越接近极值点；但并不是 $\\sigma$ 越大就越好，因为 $\\sigma$ 越大会使得求导和 Hesse 矩阵趋向病态。 外点罚函数法要求 $f(x)$ 在可行域外也有定义，如没有定义，需要考虑内点罚函数法。 算法算法实现上，常使用 $\\sigma$ 从小取到大的方法： 初始化： 选定初始点 $x^{(0)}$ 初始罚因子 $\\sigma$ 设置罚因子的放大系数 $c&gt;1$（如 $c=10$） 置 $k=1$ 以 $x^{(k-1)}$ 为起始点，求解无约束问题 $$\\min F(x,\\sigma)$$得到极小点 $x^{(k)}$。 若 $\\sigma P(x) &lt; \\varepsilon$，则输出 $x^{(k)}$ 并终止，否则转 4。 置 $\\sigma = \\sigma * c, k=k+1$，并返回 2。 这种通过求解一系列无约束问题来获得约束问题最优解的方法称作序列无约束极小化SUMT。 例题下面是运用外点法求解 $$ \\min f(x) = x_1^2+2x_2^2 \\\\s.t. \\; x_1 + x_2 &gt;= 1$$ 的 MATLAB 程序。 1234567891011121314151617181920212223global sigma f P;f=@(x)x(1)^2+2*x(2)^2;g=@(x)x(1)+x(2)-1;P=@(x)max(0,-g(x))^2;x=[0,0]sigma=1;c=10;epsilon=1e-5;for k = 1:20 x = fminunc(@F,x) disp(sigma*P(x)) if (sigma*P(x) &lt; epsilon) disp('answer successfully found') break; end sigma=sigma*c;endfunction y=F(x)global sigma f P; y=f(x)+sigma*P(x);end 最值为： 12x(1) = 0.6666x(2) = 0.3334 内点罚函数法外点罚函数法要求 $f(x)$ 在可行域外也有定义，如没有定义，需要考虑内点罚函数法。 这次，当迭代点靠近边界点时，就迅速增加目标函数值（而不是当迭代点在可行域外时才动手），保证迭代点在可行域内。 由于内点罚函数总是从内点出发，于是不适用于有等式约束的问题。 $$\\min f(x) \\\\s.t. \\; g_i(x) \\geq 0 \\quad i = 1,2,…,m$$ 类似于外点法，我们定义障碍函数： $$F(x,\\mu)=f(x)+\\mu B(x)$$ 不同的时，当 $x$ 趋向可行域边界时，让 $B(x) \\to \\infty$。$B(x)$ 的设定一般如下： $$\\begin{aligned}B(x) &amp;= \\sum_{i=1}^m \\frac{1}{g_i(x)} \\\\B(x) &amp;= -\\sum_{i=1}^m \\ln g_i(x) \\\\B(x) &amp;= \\sum_{i=1}^m \\frac{1}{g_i^2(x)} \\\\\\end{aligned}$$ 对于 $\\mu$，如果 $\\mu$ 越小，无约束问题的最优解越接近原问题的最优解。因此要求 $\\{\\mu\\}$ 是单调下降序列。 实际应用中，还可以对不同的 $g_i(x)$ 施加不同的 $\\mu_i$： $$F(x,\\mu)=f(x)+\\sum_{i=1}^n \\mu_i\\frac{1}{g_i(x)}$$ 算法与外点法大致相同，故略。参数选择上，可选 $r_1 = 10, C = 0.1$。 例题$$\\min f(x)=(x_1-1)^2+x_2^2 \\\\s.t. \\begin{cases}x_1 \\geq 0 \\\\x_2 \\geq 0\\end{cases}$$ 1234567891011121314151617181920global mu f Bf=@(x)(x(1)-1)^2+x(2)^2;B=@(x)log(x(1))+log(x(2));x=[1,1];mu=10;c=0.1;epsilon=1e-9;for k = 1:20 x = fminunc(@F,x) disp(mu*B(x)) if (abs(mu*B(x)) &lt; epsilon) break; end mu=mu*c;endfunction y=F(x)global mu f B; y=f(x)-mu*B(x);end 最值为： 12x(1) = 1.000x(2) = 0.000 多目标优化多目标优化，即需要求最优的目标函数有两个或多个。 显然不是任意问题都可以使得目标函数值全为最优。于是产生了一个词叫“非劣解”。 非劣解就是几个解，这几个解无法确定谁好谁劣。其余的解就是劣解。 ~~个人感觉就是把几个目标用一个新的函数 Z 连立起来，就可以当做一个单目标优化来解了。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"最优化","slug":"最优化","permalink":"https://blog.lyh543.cn/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"},{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"数学建模入门","date":"2019-10-25T16:00:00.000Z","path":"mcm/getting-started-mcm/","text":"无生活，不建模。——覃思义 课程及比赛安排泥电开展的课程 《漫话数学建模》（大一下，核心通识课） 《数学建模实验》《数学建模方法》（即现在的集训，面向大二，素质选修课） 《数学建模实验》《高级程序设计方法（进行科学计算的）》（面向大二及以上，素质选修课） 本课程的开展过程 学分在下学期，本学期无 本学期上到 16 周左右、不考试，不与主课考试冲突 下学期除上课之外，在老师指导下以组为单位自学数模 比赛 秋季 11 月中旬（2019 年为 2019.11.27）：美国模拟赛（大面积，主要面向大三） 春季 5 月中旬（2020 年为 2020.5.14）：校内赛（主要面向大二） 校队选拔标准 课程结业考核（很随意的，满分 150 分） 校内比赛 平时活动中老师的评价 选拔面试表现（三人为单位） 选拔人数不定。 美赛和国赛风格区别 如果你参加的是国赛，应该尽量完成所有问题，并保证结果的正确性，创新但要评委能看懂是最好的；如果你参加的是美赛，重点把主要问题做的很出彩就够了，其他问题可以在主要问题的应用下能完成就行。 数学建模方法和规律 适当的假设和简化 找出问题中最关键的量，找出支配问题的内在规律 用数学的语言（即公式、图表或算法等）描述这些俩之间的数学关系，即数学模型 用数学的方法进行编译、推断、求解、数值解 用各种方法进行验证 改进模型 学习资料校内讲义《数学方法与实践》《数学建模方法与编程培训》《数学建模竞赛优秀论文》 参考书籍： 姜启源、谢金星、叶俊《数学建模（第三版）》，高等教育出版社 杨启帆《数学建模》，高等教育出版社 徐全智、杨晋浩《数学建模》，高等教出版社 韩中庚《数学建模方法及其应用》，高等教育出版社 分工准备建模方面熟悉并掌握一些常见的模型。 分析类——机理分析、微分方程、差分方程、动力系统… 概率统计类——概率、统计、抽样、多元统计、回归、聚类、判别分析、时间序列… 优化类——优化、规划、运筹线性规划、非线性规划、目标规划、动态规划… 组合、离散类——排列、组合、递归等，图、路、匹配、网络等… 常见模型中的数值计算的方法 关于写作竞赛结果的唯一体现形式是论文，所以也有必要多看一下往年的优秀竞赛论文（国一论文）。学习他们的行文语言、论文格式、一些习惯。以及如何从实际问题，进行简化假设，一步步导出最终的数学模型。 关于编程好好学 Matlab 就够了。基础编程一定要会，工具箱函数可以现查。学有余力，可以学 SPSS/R 等统计专用软件，Visio 绘图软件。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"数学建模集训课程笔记目录","date":"2019-10-25T16:00:00.000Z","path":"mcm/mcm-training-note/","text":"2019 秋季集训 2020.3.14 更新：由于个人感觉泥电的数模培训班太偏向理论，因此在后期就不打算听课，也不打算更新了。改为看网课、做笔记的形式来学习数学建模。所有自学笔记的链接：Tags: 数模自学笔记 周次 上午 下午 第一周 10.26 数学建模入门 最优化算法 第二周 11.2 非线性方程求根 最优化算法——线性规划、背包、遗传算法 第三周 11.30 非线性方程求根——范数、非线性方程组迭代法解线性方程组 最优化算法——有约束优化、多维优化2013 国赛 B 题 碎纸片的拼接复原 第四周 12.7 数值分析——插值、模拟 例题讲解 第五周 12.21 数值分析——数值微分、积分 最优化算法——动态规划 第六周 2.29 图论 最优化算法——多目标规划 第七周 3.7 图论——子图、树 最优化算法——随机模拟 第八周 3.14 图论 最优化算法——随机模拟，元胞自动机模型","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"服务器下载文件","date":"2019-10-23T04:39:17.000Z","path":"linux/download-file-on-server/","text":"前言某些国外网站，虽然没有被墙，但是下载个东西，几十 KB 的网速很难顶。 于是想把东西下载服务器上，然后本地从服务器满速下载。这也就是离线下载的原理。 基础知识后台运行也是非常重要的，我就一笔带过，将原本的命令改为 nohup &lt;命令&gt; &amp; 即可后台执行（此时可以按 Ctrl+C 关掉 nohup 的前端）。 另外，如果服务器显示了“可以通过 127.0.0.1:8080 访问……”，表示的是服务器本机的 8080 端口，就可以在你的电脑访问 [服务器ip]:8080（如 39.1.2.3:8080）来访问对应的网站。后文不再赘述。 服务器下载文件服务器下载 http(s) 直链，最常用、也是最无脑的就是 wget &lt;Link&gt; 了。对付非直链的情况，我们有非直链的解决方案；对于种子/磁力链，我们可以使用 wget 下载 Google Drive 文件在时断时续的梯子上，Google Drive 的下载不是很方便，特别是需要下载一个大文件的时候。 但是 Google Drive 是可以获取直链的。很香。 服务器用 wget 从 Google Drive 下载小文件的命令为（需要替换链接中的 FILEID）： 1wget --no-check-certificate ‘https://docs.google.com/uc?export=download&amp;id=FILEID’ 对于大文件，无法通过安全查杀，所以要用别的命令（注意 FILEID 有两处）： 12wget --load-cookies /tmp/cookies.txt \"https://docs.google.com/uc?export=download&amp;confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://docs.google.com/uc?export=download&amp;id=FILEID' -O- | sed -rn 's/.*confirm=([0-9A-Za-z_]+).*/\\1\\n/p')&amp;id=FILEID\" &amp;&amp; rm -rf /tmp/cookies.txt1 其中，需要替换其中的 FILEID 为公开分享的文件 ID，下面是实例： 12https://drive.google.com/open?id=FILEIDhttps://drive.google.com/file/d/1_wnCdMKB4_GQM9dtA4AOHxZ21NCGFNm9/edit 第二条的 1_wnCdMKB4_GQM9dtA4AOHxZ21NCGFNm9 即为 FILEID。 就可以感受国外连服务器的 60M/s 的网速了。 wget 下载 mediafire.com 的文件 参考链接：https://moeclub.org/2018/04/11/609/?spm=23.8 这个网站就属于一开始说那种的网站，没有被墙，但是国内访问速度平均不到 100 K/s。 不过这个网站又不像 Google Drive，可以直接找到直链，而是需要你访问网站，然后生成一个直链网页中（这些网站都挺良心，直接把直链放网站上，不像国内某云）。但是不同端登录给的直链时不一样的，所以我们要在服务器访问网站。 具体来说，就是在服务器用 wget 下载他分享的链接对应的 html，然后从 html 里面找到链接即可用 wget 下载。 假设我们的直链如下（注意统一用 https）： 1https://www.mediafire.com/file/yrd1py7od5911zt/Catalina_Virtual_Disk_Image_by_Techsviewer.rar/file 可以用以下命令： 1234LINE=https://www.mediafire.com/file/yrd1py7od5911zt/Catalina_Virtual_Disk_Image_by_Techsviewer.rar/fileIndex_data=\"$(wget --no-check-certificate -qO- \"$LINE\" | grep -o 'https://download.*.mediafire.com/.*/.*\"' | cut -d'\"' -f1# 通过分享的链接获取页面 html，并通过正则表达式抓到下载链接 得到类似下面的 Index_data。其中 download 后的 2331 就是每个直链不同的地方。 1https://download2331.mediafire.com/chmg33d4airg/yrd1py7od5911zt/Catalina+Virtual+Disk+Image+by+Techsviewer.rar 然后就可以 wget &quot;$Index_data&quot; 或手动 wget &lt;网址&gt; 进行下载。 如果需要后台下载，当然是用 nohup 了。这样，即使是几十 kb 的下载速度，服务器下个三天三夜，然后就可以以满速下到本地了。 1nohup wget \"$Index_data\" &amp; 下载的进度可以 tail nohup.out 查看输出文件的最后几行。 qbittorrent 下载磁力链/种子12apt install qbittorrentqbittorent-nox 安装 qbittorrent 以后，提供了两条命令 qbittorrent 和 qbittorrent-nox 的。前者是提供 GUI 的，后者是给命令行使用的（所谓 no X）。 输入 qbittorent-nox 以后，就可以在本地通过访问对应的网站来管理服务器的 qbittorent 下载种子了。 如果需要后台执行，可以使用 qbittorrent-nox -d。 服务器、本机互传文件如果想要知道最方便的方法，请跳到 webdav 部分。 scp 命令：通过 ssh 在服务器和本地互传文件12345678910111213scp /home/work/source.txt work@192.168.0.10:/home/work/#把本地的source.txt文件拷贝到192.168.0.10机器上的/home/work目录下scp work@192.168.0.10:/home/work/source.txt /home/work/#把192.168.0.10机器上的source.txt文件拷贝到本地的/home/work目录下scp work@192.168.0.10:/home/work/source.txt work@192.168.0.11:/home/work/#把192.168.0.10机器上的source.txt文件拷贝到192.168.0.11机器的/home/work目录下scp -r /home/work/sourcedir work@192.168.0.10:/home/work/#拷贝文件夹，加-r参数# 更改端口用 -P 参数 python3 http.server 一行建立 http 文件服务器（不支持断点续传、密码验证）123sudo apt-get install python3python3 -m http.server 8000 需要更多的选项，可以使用 python3 -m http.server --help 看到 Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 以后即可。 就可以在互联网上通过打开访问到当前文件夹了。后台运行同样是 nohup。 注意这是没有密码验证的，也不支持断点续传（毕竟 simple ），所以不要长期开放！！！ npm http-server 一行建立 http 文件服务器（支持断点续传，不支持密码验证）1234apt install npmnpm install http-server -ghttp-server 其中 http-server 的常用参数为 http-server [path] [-p port]。port 默认为 8080。 如果想要在后台运行，可以配合 nohup 使用： 1nohup http-server &amp; 如果想要守护进程（如果被 kill 就立刻重启），可以使用： 12345apt install npmnpm install pm2 -gpm2 --name s1 -f start http-server # 配置 pm2pm2 save # 可选命令，作用是保存当前的 pm2 状态，下次开机的时候可以使用 pm2 startup 恢复到当前状态pm2 ls # 可选命令，列出当前 pm2 的任务 另外，实现同样功能的还有：https://github.com/lwsjs/local-web-server 不过，需要注意的是，如果连接线程太多，会消耗大量服务器内存。在我的测试中： 单线程下载一个文件，内存占用 36 MB 16 线程下载一个文件，内存占用 40 MB 下载三个文件，每个文件 128 线程，内存占用高达 250MB（不要问我为什么这么高，问就是某线程破解版下载软件默认） 给不支持密码验证的 http server 增加密码验证这个方法是借助于 Nginx 的密码验证。实现思路是： 使用 Nginx 服务器，将 file.lyh543.cn 反向代理到 lyh543.cn:8080，其中 8080 为上述 http-server 的访问端口。方法可参考Nginx （萌新向）。 同时在 file.lyh543.cn 的配置文件中加入密码验证功能，可参考nginx配置访问密码。 最后为安全起见，可在防火墙中关掉 8080 端口，避免直接从端口访问服务器。可参考Linux 日常命令–防火墙。 webdav（支持断点续传、密码验证） 参考博客：https://blog.devzeng.com/blog/build-webdav-server-in-docker.html 我在 2020.6.14 发现了 webdav，最方便的应该就是 webdav 了。 首先安装 Docker，可参照这篇教程。 然后运行一行命令： 1docker run -d --name webdav -v /path/to/directory:/var/webdav -e USERNAME=test -e PASSWORD=test -p 8888:80 morrisjobke/webdav 运行前修改上面的 /path/to/directory 为你的文件夹名；修改用户名和密码；修改端口为你想要的端口。 然后就可以在浏览器中访问 http://yourip:8888/webdav（注意有个 webdav），再进行账户密码验证即可进行下载。 对于支持 WebDAV 的应用，就可以用这个方法上传、下载了。 SMB如果能使用 SMB，就可以把服务器的某个文件夹当做（Windows）本机的一个硬盘，上传下载都是非常的方便。 然而，SMB 配置起来比较麻烦，一是 SMB 通常用于局域网内，在外网使用会麻烦一点；二是 SMB 的默认端口 445 被阿里云、腾讯云等封禁了，需要使用别的端口。但是确实有人实现过。还是使用 scp 或 webdav 吧。 Syncthing如果需要两个设备的某些文件夹保持完全同步，可以考虑使用 Syncthing。 这个软件可以让两个设备的文件夹保持完全同步，并且跨平台（Linux/Windows/macOS/FreeBSD/OpenBSD/NetBSD/Dragonfly BSD/Illumos/Solaris）。通过网页进行管理，非常方便。 给链接添加 HTTPS上面都是通过 HTTP 协议 + 端口访问服务，如果需要 HTTPS，需要用 Nginx 做一次反向代理，参见 Nginx。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"修改 ssh 的端口","date":"2019-10-18T02:01:34.000Z","path":"linux/change-ssh-port/","text":"修改 ssh 端口的前因后果今天用安卓手机 ssh 连接我的服务器的时候，出现了 kex_exchange_identification。又要修 bug 了。 百度了一下，按照 ssh连接失败，排错经验 的步骤做了一下，发现 ssh 有时连得上，有时连不上。迷惑行为。 按照他的方法，关闭 ssh 服务，并开始 ssh 的调试模式： 12service sshd stop/usr/sbin/sshd -d 打开以后，貌似一切正常。 几秒以后，发现 ssh 显示了很多，然后就直接退出了？？？ 粗略看了一下，有一个未知 ip （最后查出来是法国的）在尝试 ssh 连接我的服务器。大概是来搞我的。 于是我就把他放进 ssh 的黑名单了。 1echo x.x.x.x &gt;&gt; /etc/hosts.allow 重新开启调试模式，发现几秒以后他又关掉了。 这次是江苏的。 重复了一次，发现又有一个北京的。 ？？？？ 大家都来搞我？？？ ssh 没有仅允许白名单访问的方法，那咋办嘛。 后来突然想到，不应该用默认端口的，否则他发现端口可用就可以暴力破解了！ 于是下面才是正题：如何更改 ssh 的端口。 修改方法1vi /etc/ssh/sshd_config 12345678910111213# The strategy used for options in the default sshd_config shipped with# OpenSSH is to specify options with their default value where# possible, but leave them commented. Uncommented options override the# default value.#Port 22#AddressFamily any#ListenAddress 0.0.0.0#ListenAddress ::#HostKey /etc/ssh/ssh_host_rsa_key#HostKey /etc/ssh/ssh_host_ecdsa_key#HostKey /etc/ssh/ssh_host_ed25519_key 现在的端口 Port 是默认的 22，我们要修改，先要把 Port 前注释的 # 去掉，然后把 22 改为自己想要的数字（0-65535 都可，只要不跟自己其他的端口重合）。 12Port 2333#AddressFamily any 然后再开调试模式，发现一切都和平了。 以后要 ssh 远程的时候，就要带一个端口参数了。对于 39.1.2.3 的服务器的 2333 端口，应该使用 1ssh -p2333 root@39.1.2.3 即可。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"ssh","slug":"ssh","permalink":"https://blog.lyh543.cn/tags/ssh/"}]},{"title":"利用内网穿透进行远程桌面访问","date":"2019-10-16T12:07:27.000Z","path":"microsoft/windows/use-remote-desktop-with-frp/","text":"2019.12.5 更新：内网穿透还有更简单、更好的实现方法，具体看文末 前言平时带一台轻薄的笔记本，打开远程家里/寝室里的台式，进行远程桌面，在有网速保证的前提下，既能获得笔记本的轻便型，也能获得台式电脑的强大性能，更能最大化笔记本的续航，更重要的是可以在同一台机器上进行办公、开发，无需资料同步。是很不错的选择。 我体验过的几款远程桌面软件里， Teamviewer 是一个很优秀的选择； 向日葵免费版有 300kbps 的限速，几乎等于不能用； Anydesk 国内网速太慢，不可用； 应急的话，还可以用 QQ 的远程协助。（用 QQ 的远程协助启动 Teamviewer 的远程协助） 除了以上选择以外，其实微软自带了远程桌面 mstsc。在局域网内你就可以通过远程 *.*.*.*:3389 （你的电脑 ip）体验到远程桌面，体验同样是相当不错的，几乎和 Teamviewer 是一样的（所以一般的同学就可以直接选 Teamviewer 了）。 但是，如果在外网体验的话，就不大好了。原因是，你在外网里找不到被远程端的 ip 地址（未经强调，本文所有 ip 指 ipv4，此处是因为 ipv6 在中国还没普及）。 NAT 及内网穿透的原理ip 是一台机器在互联网上的唯一地址，可以通过你的机器 ip，从互联网的任何一端找到你的机器。 然而， ipv4 的数量是极其有限的，只有 256*256*256*256=4294967296 四十亿个（想想现在地球多少人口）。而且还有很多 ip 是保留的，不能作为互联网里的 ip。现在的 ip 地址已经快要用完了。 因此，聪明的运营商们想了一个办法，可以用一个设备，把他的一个 ip，下发为一万个 ip（当然，远不止这么多）。这种方法叫 NAT（Network Address Translation，网络地址转换）。好处是 ip 够用了，另外还具有防火墙的功能；坏处是，转换过的 ip 是不能在互联网上直接访问到的，而且还是动态变化的。你就不能直接靠输入 ip 来实现远程内网 ip。（所以互联网上能直接访问到的 ip 又叫公网 ip） 但是，你想想，肯定是会有方法的，要是你的电脑和一个有公网 ip 的电脑建立了联系，要想访问你的电脑，就可以通过找到这个 ip，让公网 ip 电脑转发一下数据到你的电脑上，你就可以内网以外的地方访问到内网设备了（实现的这个结果叫内网穿透）！这便是转发/反向代理，内网穿透的一种实现。 2019.12.5 更新：另一种实现是 P2P，你的内网电脑和想要访问内网的电脑同时连接一台公网服务器，这台公网服务器就在你的两台电脑之间建立了一个 P2P 的联系，接下来，你的电脑就不需要再经过公网服务器的中转，直接访问内网电脑了。但这种方法只适用于 UDP 协议，不适用于 TCP 协议。ZeroTier 即是用这种方法实现的。 内网穿透需要一台有公网的电脑，最简单的办法，就是去租一个服务器。而实现转发数据、内网穿透的软件也有不少，如 frp、ngrok 等等。 （以下两段复制自 使用 Shadowsocks 搭建回国代理） 租服务器首先，去租一个阿里云或腾讯云的服务器。 推荐的服务器有： 服务器名 规格 配置 价格 备注 阿里云服务器 ECS 突发性能实例 t6 2核2G40G，流量按量付费0.8元/G 54元/月，550元/年，1033元/3年，1375元/5年 偶尔用一下frp、博客访问，推荐突发性能实例 腾讯云服务器 CVM 标准型SA2 1核2G50G，200M，流量按量付费0.8元/G 45元/月，453元/年，819元/3年，1365元/5年 带A的是AMD CPU，性能差不多但会便宜很多 AMD YES 阿里云学生机 轻量应用服务器 2核2G60G，带宽5M，1T流量包 30元/3月，100元/年 仅限学生新用户 腾讯云学生机 轻量应用服务器 1核2G50G，带宽5M，1T流量包 27元/3月，108元/年 仅限学生（25岁以下免认证） 如果搭建服务器是用来反向代理+远程桌面的，对带宽就会有需求，最好在 5M 以上。这里推荐的两个非学生机都是流量按量付费，好处是带宽可以拉到100兆或更高，偶尔使用反向代理也不会消耗太多流量，算下来可能比固定带宽还便宜；如果不需要大带宽的，可以考虑阿里云/腾讯云的轻量应用服务器和上面两款的固定带宽版。 系统推荐使用 Debian 或 Ubuntu。 然后租了服务器会给 ip 地址（下面为方便叙述，设为 39.1.2.3）和密码。 ssh 远程登录注意阿里云的服务器要开放防火墙的端口，不然连不上！！！！！！！！作者就是被这个坑了一下午还没弄好。上面需要开放 22 端口，协议选 tcp。 在本地 wsl（或自行百度 ssh 的方法）使用 ssh -p22 root@39.1.2.3 登录远程服务器。 下载并配置 frp 参考链接：https://www.hostloc.com/thread-463360-1-1.html 本地和远程下载 frp 的压缩包，然后解压。 注意下对应系统的最新的包，而不是复制粘贴下面的命令（我遇到 i/o deadline reached 什么的奇奇怪怪的错误就是因为下的 0.9.0 版本的）。 服务器端的命令： 1234wget https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_amd64.tar.gztar -zxvf frp_0.29.0_linux_amd64.tar.gzcp -r frp_0.29.0_linux_amd64 /etc/frpsrm -f frpc frpc_full.ini frpc.ini frp 的压缩包中同时包含了 server 服务器版本 frps 和 client 客户端版本 frpc。服务器可以删除 frpc 相关文件，客户端（被远程的电脑）可以删除 frps 相关文件。 然后配置服务器的 frps.ini 和客户端的 frpc.ini。 服务端 frps.ini 一行即可，指明客户端连入的端口： 1bind_port = 7000 客户端 frpc.ini 要复杂一点。 12345678[common]server_addr = 39.1.2.3 # 这里是 vps 的 ipserver_port = 7000[rdp]type = tcplocal_ip = 127.0.0.1local_port = 3389 # 本地的 Remote Desktop 对应端口remote_port = 5200 # 服务器接收 Remote Desktop 信息的端口，可以改 几个端口解释一下： 首先，服务器启动 客户端启动访问服务器的 7000 端口，建立内网穿透 远程的设备访问服务器的 5200 端口，服务器即把数据转发给客户端的 3389 端口，即可远程桌面 注意开放服务器防火墙 tcp 7000 和 5200 端口！！！！ 我被这后面这个坑了一个小时。明明配置好了，就是连不上，原来是服务器没开端口。 另外还需要配置一下客户端的远程桌面方面的设置，这个比较常见，在 控制面板-系统-(侧边栏)远程设置-(单选框)允许远程连接到此计算机。 启动 frp 及守护进程服务器 /etc/frp/frps -c /etc/frp/frp.ini，客户端 frpc.exe -c frpc.ini。 启动以后，要是有什么问题，建议检查端口开放和 frp 版本是否为最新，然后再百度。（对我各被坑了一个小时） 如果没什么问题，就可以测试远程桌面了。 注意，远程桌面连接的时候可能会提示密码错误（即使你密码输入正确了）。这大概是个 bug，原因是你远程那边登录使用的不是密码（而是 PIN）。说不定是个为了安全的 feature 呢解决方法是，远程端那边需要想办法注销账户，然后用密码登录，这边再远程就没有说明问题了。 要是可以正常使用，就可以准备守护进程了。 服务端后台运行服务端使用 nohup /etc/frp/frps -c /etc/frp/frps.ini &amp; &amp;&gt; /dev/null 使 frp 后台运行。 可能会看到 ignore input 之类的警告，不用管，Ctrl+C 退出前台即可，此时 ssserver 正在后台运行。 客户端开机运行下面的方法二选一。 客户端需要开机后台启动 frpc，可以把 vbs 脚本放在 Startup 目录。 新建一个文本文档，加入下面两行脚本代码，并改名为 startup-frpc.vbs，复制到 C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 下。 （假设 frpc.exe 和 frpc.ini 都在 c:\\frp\\ 目录） 12set ws=WScript.CreateObject(\"WScript.Shell\")ws.Run \"c:\\frp\\frpc.exe -c c:\\frp\\frpc.ini\",0 也可以用 任务计划，用 GUI 设定一下就行。具体百度吧，不难。 额外说一句，在设置任务计划时，需要注意的是， 在属性-常规-安全选项，中，选择不管用户是否登录都要运行，同时可以选择使用最高权限运行。（保存的时候需要输入账户的密码） 触发器选在系统启动时 操作选启动程序，命令为 wscript，参数为 &quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\startup-frpc.vbs&quot;。（你也可以把这个 vbs 放在别的目录，然后把这个目录修改为对应的目录） 为了防止意外，可以在远程的电脑上安装额外的临时的远程桌面解决方案如 Teamviewer 或 QQ 以应急。 客户端守护进程 2019.12.5 更新：如果正确的配置启动命令以后，应该不会出现问题。所以也可以选择上面的配置。不过我还是选择的下面的配置。 但是有些时候还是会有蜜汁启动不了。即使我设了启动命令 + 任务计划，仍然必须要登录以后才会启动 frpc（而不是在开机后登陆前就启动了）。因此我并不推荐开机自启的方法，而是用这种进程守护的功能。 于是我打算搞一个进程守护，任务计划每一分钟启动一次，检测 frpc 是否正在运行，否则后台启动 frpc。 为此我需要以下文件（都放在 D:\\Documents\\Tools\\frp\\）： vbs 脚本，让命令行程序在后台运行的最简单的实现方法。内容如下： 12set ws=createobject(\"wscript.shell\")ws.run\"D:\\Documents\\Tools\\frp\\frpc-daemon.bat\",0,ture frpc-daemon.bat 脚本，因为 bat 检测进程最为方便。vbs 也可以检测进程，但是按网上 Google 到的方法都只能检测会话名为 Console 的进程，对于任务计划启动的 Services 进程是检测不到的，再加上我不会 vbs，于是采用的是 vbs+bat 的方法。bat 内容如下： 12set frppath=D:\\Documents\\Tools\\frptasklist | find \"frpc\" || %frppath%\\frpc.exe -c %frppath%\\frpc.ini 任务计划。 常规部分，选择“不管用户是否登录都要运行”，不要勾选“不存储密码”。触发器部分，选择 一次，时间默认，然后勾上 重复任务间隔 设为 1 分钟。操作部分，启动程序 wscript，添加参数为 &quot;D:\\Documents\\Tools\\frp\\frpc-daemon.vbs&quot;（你的 frpc-daemon.vbs 路径，带引号）。 虽然这种方法会占用一点点 CPU（实际上占用的很少很少），但是真的非常推荐，配置好以后，要是哪天手滑关了 frpc，问题也不大，几分钟以后就会启动。并且配置好以后，也会开机自启，非常好用，推荐。 番外：为 RDP 使用 UDP 协议远程桌面应该使用 TCP 还是 UDP 协议呢？ 抛去网上的一堆 TCP/UDP 枯燥难懂的定义，我找到了这个问答。 大概意思就是，UDP 只传输数据，不执行校验等命令。也就是说，较 TCP， UDP 有更低的延迟（不执行命令） UDP 牺牲了稳定性（不能防丢包等） 在 Windows 8 中，微软已经在 UDP 协议上启用了 RDP 协议。 至于是否使用 UDP，还是看自己（还有当地的网络情况）。 如果想要使用 frp 通过 UDP 协议传输，需要把客户端 frpc.ini 配置的部分再抄一遍，把 type 改为 UDP 即可。 12345678910111213[common]server_addr = 39.1.2.3 # 这里是 vps 的 ipserver_port = 7000[rdp]type = tcplocal_ip = 127.0.0.1local_port = 3389 # 本地的 Remote Desktop 对应端口remote_port = 5200 # 服务器接收 Remote Desktop 信息的端口，可以改[rdp-udp]type = udplocal_ip = 127.0.0.1local_port = 3389remote_port = 5200 如果想禁用 UDP，一个方案是把 frpc.ini 的 UDP 部分删掉；也可以通过（在两个设备）组策略关掉远程桌面使用 UDP 的选项，在组策略的以下位置： 1计算机配置/Windows 设置/管理模板/Windows 组件/远程桌面服务/远程桌面会话主机/连接/选择 RDP 传输协议 部分错误及解决方案frps 和 frpc 无法连接 如果客户端无法连接通过 frpc 连接到服务器，可能是服务器没有开放防火墙的对应端口； 如果显示 i/o deadline reached 等奇奇怪怪的错误，检查一下 frps 和 frpc 是不是最新版。 frp 建立，但无法远程桌面可能是服务器没有开放防火墙的对应端口。 mstsc 字体模糊关闭根据网络调整质量，可改为256kbps-2M，然后开启平滑字体。 如果仍然无效，可能需要远程登录成功、退出以后重新登录。 2019.11.30 更新：如果网络不好，这个真的没法解决，只能选择将就着用，或者换 Teamviewer。 mstsc 和 Teamviewer 打开文件资源管理器时卡顿（更新于 2019.10.21）必然发生，每次都会卡 5 秒左右。 在远程的电脑是 Win10 1903 时，两款软件都会出现这样的问题；升级到 1909 后，问题均消失。 大概 Teamviewer 也调用了 Windows mstsc 的 api 吧，然后 mstsc 出锅了。 后记利用 frp，还可以进行一些骚操作：把自己的电脑当做云盘（比云服务提供的大）、配合 Shadowsocks 和学校寝室的电脑搭建校园网的代理。总之，几个东西的搭配，就能搞很多东西出来了。 内网穿透的其他方案内网穿透还有其他实现方案，如果使用 P2P 的方案，这样所有流量就不用跑服务器转一圈了，而是两台电脑的流量直连，不会受限于两台电脑连接服务器的速度，也不会消耗服务器的流量。 引用知乎上 iittttt 用户的总结，目前用的较多的方案有： 项目名 开/闭源 P2P/非P2P 免费/收费 n2n 开源 P2P 免费 服务器较少，暂停开发 ngrok 分版本开源 非P2P 免费或收费 官方服务器被墙 反向ssh 开源 非P2P 免费 TeamViewer 闭源 P2P 免费或收费 Hamachi 闭源 P2P 免费或收费 花生壳 闭源 非P2P 免费或收费 免费限速 除此之外，推荐（100 台设备以下）免费的 ZeroTier，能够开机自启。使用带 GUI 的客户端来进行配置，配置过程参考这篇博客。不过缺点是，没有加入的设备，必须要安装客户端配置以后才能使用（frp只用配置服务器和内网设备，其他设备即可通过端口直接访问）。","tags":[{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://blog.lyh543.cn/tags/Microsoft/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.lyh543.cn/tags/Windows/"},{"name":"frp","slug":"frp","permalink":"https://blog.lyh543.cn/tags/frp/"},{"name":"远程桌面（RDP）","slug":"远程桌面（RDP）","permalink":"https://blog.lyh543.cn/tags/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%EF%BC%88RDP%EF%BC%89/"}]},{"title":"Hexo 插入 LaTeX 公式","date":"2019-10-14T16:00:00.000Z","path":"latex/Hexo-insert-latex/","text":"使用 MathJax 渲染 Hexo 中的数学公式本文摘自 https://www.sail.name/2018/05/31/use-mathjax-in-hexo/. MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers。 理论上方法是多种多样的，都是基于 MathJax 的。但我试了很多都不行不排除我太菜了，不会搞的可能 目前的方法摘自 https://github.com/viosey/hexo-theme-material/issues/604. 在主题配置文件里加入： 1234vendors: # MathJax 2.7.0-2.7.1 mathjax: https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js 在用到 mathjax 的 Markdown 文档的 front-matter 里填入mathjax: true即可。 12345678---title: Hexo 插入 LaTeX 公式tags:- Hexo- LaTeXcategory:- LaTeX--- 预览： Simple inline $a = b + c$. Simple inline $a = b + c$. $$\\frac{|ax + by + c|}{\\sqrt{a^{2}+b^{2}}}$$ $$\\frac{|ax + by + c|}{\\sqrt{a^{2}+b^{2}}}$$ 使用 MathJaX 注意 具体 LaTeX 语法见博客：LaTeX数学公式学习笔记 值得注意的是，LaTeX 中本来就存在的 \\ 在 MathJax 都需要替换为 \\\\，如换行为 \\\\\\\\，范数的 \\| 在 MathJax 中应为 \\\\|。这个问题是 Markdown 和 MathJax 双重渲染造成的。 而对于某些 Markdown 中的符号（指的就是一对 * 和 _），这个时候需要一个 \\ 来进行转义。 这里转义的目的是使得 Markdown 不把他识别为关键字，而上面的 \\\\ 可以理解为先在 Markdown 中渲染在 \\，然后进行 MathJax 编译的时候再理解为 LaTeX 转义符。 1234567\\begin&#123;equation&#125;\\begin&#123;split&#125;x&amp;&#x3D;a+b+c\\\\\\\\&amp;&#x3D;d+e\\\\\\\\&amp;&#x3D;f+g\\end&#123;split&#125;\\end&#123;equation&#125; \\begin{equation}\\begin{split}x&amp;=a+b+c\\\\&amp;=d+e\\\\&amp;=f+g\\end{split}\\end{equation}","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.lyh543.cn/tags/Hexo/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://blog.lyh543.cn/tags/LaTeX/"}]},{"title":"LaTeX 数学公式学习笔记","date":"2019-10-14T16:00:00.000Z","path":"latex/latex-math-equation/","text":"LaTeX 更多语法请见另一篇博客。 纯正的 LaTeX 调用公式的语法请见最后一部分。 基本语法 MathJax 在一对 $ 中间即是行内公式，在一对 $$ 即是行间居中公式。亦可以在 \\begin{equation} 和 \\end{equation} 之间打行间公式。LaTeX 稍有区别（见后），但也可以使用上面的东西。 1$$a+b=c$$ $$a+b=c$$ 1\\begin&#123;equation&#125;a+b\\end&#123;equation&#125; \\begin{equation}a+b\\end{equation} 另外，还可以使用 \\( \\)、 下标_，上标^，后面跟{}如$a^{2}_{j}$: $a^{2}_{j}$ []即是中括号。如$[1+2]$: $[1+2]$ 编译时无视空格、回车，空格只用于分隔识别符。公式中需要空格请前往#排版 LaTeX换行中行末需要\\\\，由于 Markdown(Hexo) 和 MathJax 进行了两次渲染，所以需要\\\\\\\\。 目前已发现的需要用 \\转义的符号有：%，&amp;，\\，{}。 Markdown(Hexo) 中需要 \\\\。下文如不提及是在 Markdown(Hexo) 中使用 \\，均为\\\\。 1234567\\begin&#123;equation&#125;\\begin&#123;aligned&#125;x&amp;&#x3D;a+b+c\\\\\\\\&amp;&#x3D;d+e\\\\\\\\&amp;&#x3D;f+g\\end&#123;aligned&#125;\\end&#123;equation&#125; \\begin{equation}\\begin{aligned}x&amp;=a+b+c\\\\&amp;=d+e\\\\&amp;=f+g\\end{aligned}\\end{equation} 符号和 Onenote 的基本一样，大概是相互借鉴 Onenote 把 LaTeX 的符号照搬，然后 Onenote 简化了分数等一些部分吧。 常用运算符 中文 LaTeX语句 数学符号 点乘 \\cdot $\\cdot$ 叉乘 \\times $\\times$ 除号 \\div $\\div$ 分数 \\frac{1}{x^2+1} $\\frac{1}{x^2+1}$ 1/2 $1/2$ 方根 \\sqrt[3]{2} $\\sqrt[3]{2}$ \\surd{2} $\\surd{2}$ 取模 a \\bmod b $a \\bmod b$ 7 \\equiv 1 \\pmod 3 $7 \\equiv 1 \\pmod 3$ 范数 | x | $\\ 常用关系符在关系符前面加\\not可得其否定形式。\\not\\equiv: $\\not\\equiv$ 另外，可以使用 \\stackrel{}{} 实现两符号的上下重叠。见排版。 中文 LaTeX语句 数学符号 等价 \\equiv $\\equiv$ 不等于 \\neq $\\neq$ 相似 \\sim $\\sim$ 全等 \\simeq $\\simeq$ 微积分 中文 LaTeX语句 数学符号 极限 \\lim_(n-&gt;\\infty)\\frac{\\sin n}{n} $\\lim_{n\\to 0}\\frac{\\sin n}{n}$ 连续求和 \\sum_{n=1}^{\\infty}{\\frac{1}{n}} $\\sum_{n=1}^{\\infty} {\\frac{1}{n}}$ 连续求积 \\prod_\\varepsilon $\\prod_\\varepsilon$ 积分 \\int_{0}^{1}{\\frac{1}{n+1}} $\\int_{0}^{1}{\\frac{1}{n+1}}$ 二重积分 \\iint_{0}^{1}{\\frac{1}{n+1}} $\\iint_{0}^{1}{\\frac{1}{n+1}}$ 偏导数 \\frac{\\partial y}{\\partial x} $\\frac{\\partial y}{\\partial x}$ 有些上下标的位置在文中公式和独立公式中是不一样的，以 \\sum 为例： 文中公式 $\\sum_1^2x$ 的效果为：$\\sum_1^2x$； 独立公式 $$\\sum_1^2x$$ 的效果为： $$\\sum_1^2x$$ 但也可以用 \\limits 和 \\nolimits 来控制上下标的出现位置： 使用方法如 $\\sum\\limits_1^2x$ 就强制将上下标写在上边和下边：$\\sum\\limits_1^2x$ 而 $$\\sum\\nolimits_1^2x$$ 使其强制出现在右边角上： $$\\sum\\nolimits_1^2x$$ 上下划线 中文 LaTeX语句 数学符号 加粗 \\mathbf{x} $\\mathbf{x}$ \\bm{x} 在 bm package 中 MathJax 不支持 \\boldsymbol{x} 在 amsmath 中 $\\boldsymbol{x}$ 上划线 \\overline{123} $\\overline{123}$ 下划线 \\underline{123} $\\underline{123}$ 上括弧 \\overbrace{a+b+\\cdots+z}^{26} $\\overbrace{a+b+\\cdots+z}^{26}$ 下括弧 \\underbrace{a+b+\\cdots+z}_{26} $\\underbrace{a+b+\\cdots+z}_{26}$ 向量 \\vec{a}\\qquad\\vec{AB} $\\vec{a}\\qquad\\vec{AB}$ \\overrightarrow{AB} $\\overrightarrow{AB}$ \\overleftarrow{AB} $\\overleftarrow{AB}$ 矩阵 matrix 参考博客：https://blog.csdn.net/bendanban/article/details/44221279 另外貌似也可以使用 \\begin{array}。 裸矩阵使用 $$\\begin{matrix}...\\end{matrix}$$ 生成矩阵。矩阵中每一行以 \\\\换行（Markdown 中是\\\\\\\\），矩阵的元素用 &amp; 来分隔开。 行间矩阵 $$\\left(\\begin{smallmatrix}1&amp;2\\\\3&amp;4\\end{smallmatrix}\\right)$$ 请使用 $$\\begin{smallmatrix}...\\end{smallmatrix}$$ 如， 1234567$$ \\begin&#123;matrix&#125; 1 &amp; 2 &amp; 3 \\\\\\\\ 4 &amp; 5 &amp; 6 \\\\\\\\ 7 &amp; 8 &amp; 9 \\end&#123;matrix&#125; \\tag&#123;1&#125;$$ $$ \\begin{matrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{matrix}$$ 带括号的矩阵如果需要带括号的矩阵，一种是用 \\left( 和 \\right) 括住 \\begin{matrix} ... \\end{matrix}。注意，如果不加 \\left 和 \\right，括号是和其他字符等高，而不是完全括住了矩阵。 另一种是使用 \\begin{bmatrix}...\\end{bmatrix}。 不同的 matrix 名对应的矩阵列表如下： 代码 pmatrix bmatrix Bmatrix vmatrix Vmatrix 示例 $$\\begin{pmatrix} 1&amp;2\\\\3&amp;4\\end{pmatrix}$$ $$\\begin{bmatrix} 1&amp;2\\\\3&amp;4\\end{bmatrix}$$ $$\\begin{Bmatrix} 1&amp;2\\\\3&amp;4\\end{Bmatrix}$$ $$\\begin{vmatrix} 1&amp;2\\\\3&amp;4\\end{vmatrix}$$ $$\\begin{Vmatrix} 1&amp;2\\\\3&amp;4\\end{Vmatrix}$$ 但是直接用 {}，它不香吗？ 对于 smallmatrix，只能使用第一种方法，不能使用后面的更改 matrix 类型的方法。 数组 array貌似 array 也可以用于建矩阵，而且必须指定列对齐的形式： $$\\begin{array}{clr}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end{array}$$ 12345\\begin&#123;array&#125;&#123;clr&#125;1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;array&#125; clr 的每个字母分别代表了一列的对齐方式：第一列居中 c(enter)、第二列左对齐 l(eft)、第三列右对齐 r(ight)。 讨论情况 cases12345$$f(x)&#x3D;\\begin&#123;cases&#125;0&amp; x&#x3D;0\\\\1&amp; x \\neq 0\\end&#123;cases&#125;$$ $$f(x)=\\begin{cases}0&amp; x=0\\\\1&amp; x \\neq 0\\end{cases}$$ 如果是需要对齐等于号，可以使用 \\begin{align}（详解看 排版）。大括号需要下一段提到的 \\left\\{ \\right. 来实现。 $$ \\left\\{ \\begin{aligned}I_0 &amp;= 1 - e^{-1} \\\\I_n &amp;= 1-nI_{n-1} \\quad (n=1,2,…)\\end{aligned} \\right.$$ 奇奇怪怪的括号 参考博客：https://blog.csdn.net/miao0967020148/article/details/78712811 使用括号的时候，可以加一句\\left \\right，大概是告诉 LaTeX，我要用括号了，这样 LaTeX 会根据括号中内容中的高度自动调整括号的高度。 中文 LaTeX语句 数学符号 大括号 $\\left\\{ \\frac{a}{b} \\right\\}$ $\\{ \\}$ $\\left\\{ \\frac{a}{b} \\right\\}$ 尖括号 $\\left \\langle \\frac{a}{b} \\right \\rangle$ $\\left \\langle \\frac{a}{b} \\right \\rangle$ 单、双竖线 由于和 Markdown 表格语法冲突，单竖线和双竖线的语法写在表格下 取整函数 $\\left \\lfloor \\frac{a}{b} \\right \\rfloor$ $\\left \\lfloor \\frac{a}{b} \\right \\rfloor$ 取顶函数 $\\left \\lceil \\frac{c}{d} \\right \\rceil$ $\\left \\lceil \\frac{c}{d} \\right \\rceil$ 混合括号 $\\left [ 0,1 \\right )\\left \\langle \\psi \\right |$ $\\left [ 0,1 \\right )\\left \\langle \\psi \\right|$ 单左括号 $\\left \\{ \\frac{a}{b} \\right .$ 加个点就可以省略了 $\\left \\{ \\frac{a}{b} \\right .$ 单竖线：$\\left| \\frac{a}{b} \\right|$ $\\left| \\frac{a}{b} \\right|$双竖线：$\\left\\| \\frac{a}{b} \\right\\|$ $\\left\\| \\frac{a}{b} \\right\\|$ （提醒 MathJax 用户：上述符号前的 \\ 都应使用 \\\\，而 left 和 right 前仍为 \\） 但是要注意，\\left 和 \\right 中间不能出现换行 \\\\。如果实在需要调整括号高度，可以参照下一行。 还可以使用 \\big，\\Big，\\bigg，\\Bigg 手动控制括号的高度。 1$$\\Bigg ( \\bigg [ \\Big \\\\&#123; \\big \\langle \\left | \\| x \\| \\right | \\big \\rangle \\Big \\\\&#125; \\bigg ] \\Bigg )$$ $$\\Bigg ( \\bigg [ \\Big \\{ \\big \\langle \\left | | x | \\right | \\big \\rangle \\Big \\} \\bigg ] \\Bigg )$$ 排版 中文 LaTeX语句 数学符号 注释 普通空格 $a \\space b \\\\; c \\\\ d$ $a \\space b \\; c \\ d$ 1cm短空格 $a\\quad b$ $a\\quad b$ 2cm长空格 $a\\qquad b$ $a\\qquad b$ 换行并对齐 $\\begin{aligned}x&amp;=a+b+c\\\\&amp;=d+e\\\\&amp;=g+f\\end{aligned}$ $\\begin{aligned}x&amp;=a+b+c\\\\&amp;=d+e\\\\&amp;=g+f\\end{aligned}$ 开头 \\begin{aligned} 结束 \\end{aligned}行末 \\\\ 需要对齐的符号前 &amp; &amp; 可以放在任意符号之前表示“在此处对齐” 省略号 1...n1 \\dots n $1 \\dots n$ 1 \\cdots n $1 \\cdots n$ \\vdots $\\vdots$ \\ddots $\\ddots$ 公式标号 a^2 + b^2 = c^2 \\tag{1} $a^2 + b^2 = c^2 \\tag{1}$ 原生 LaTeX 的 $$a+b$$ 是自带编号的 重叠符号 \\stackrel{F}{=} $\\stackrel{F}{=}$ 数学符号表常用希腊字母表： 小写 大写 var小写 var大写 delta $\\delta$ $\\Delta$ \\ $\\varDelta$ phi $\\phi$ $\\Phi$ $\\varphi$ $\\varPhi$ psi $\\psi$ $\\Psi$ \\ $\\varPsi$ epsilon $\\epsilon$ \\ $\\varepsilon$ \\ chi $\\chi$ 用法：小写即为 \\ 加英文名；大写只要首字母大小就行；var 是 \\var 加大/小写字母。 如 \\varPsi 为 $\\varPsi$。 更多的： 纯正 LaTeX 插入公式由于我在接触 LaTeX 之前就学了 MathJax，所以上述的大多数语法都是基于 MathJax 而非纯正 LaTeX 语法。 LaTeX 插入公式的格式和 MathJax 稍有区别，但是公式的语法还是差不多的。 LaTeX 插入数学公式需要调用宏包： 123\\usepackage&#123;amsmath&#125;\\usepackage&#123;amssymb&#125;\\usepackage&#123;amsthm&#125; % 某些数学定理和证明会用到 （貌似 TeXstudio 自带，不需要这两行命令也能写数学公式） 行内公式的格式有： 123\\(a+b\\)$a+b$ %最常用；MathJax 仅支持这种\\begin&#123;math&#125;a+b\\end&#123;math&#125; 行间公式： 123\\[a+b\\]$$a+b$$ %最常用；MathJax 仅支持这种\\begin&#123;displaymath&#125;a+b\\end&#123;displaymath&#125; MathJax 支持另一种行间公式：\\begin{equation}a+b\\end{equation}。 LaTeX 也支持这个功能，但是会进行自动标号（MathJax 不会标号）。 要想不标号，请使用 \\begin{equation*}。与 \\section*{} 如出一辙。 在 LaTeX 引用公式可见 latex 引用公式_天天向上的专栏-CSDN博客。 需要注意的是，和其他引用相同，在 LaTeX 引用公式可能需要编译两遍。 LaTeX 中换行MathJax 中可以在 $$a+b$$ 之中 插入 \\\\ 以换行，这样就可以在内输入多个公式。然而 LaTeX 中不允许这样做。这种情况下需要写为多个公式，每个公式用一对 $$ 括起来。","tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"https://blog.lyh543.cn/tags/LaTeX/"}]},{"title":"Linux 日常命令","date":"2019-10-14T14:04:00.000Z","path":"linux/linux-tips/","text":"帮助文档长的帮助： man &lt;command&gt; 短的帮助： tldr &lt;command&gt; 有了 tldr 以后，很多教程都可以删掉了。 更换镜像源 包管理器 命令 apt(ubuntu20) sudo wget -O /etc/apt/sources.list http://mirrors.cloud.tencent.com/repo/ubuntu20_sources.list pip pip config set global.index-url http://pypi.doubanio.com/simple npm npm config set registry https://registry.npm.taobao.org docker sudo wget -O /etc/docker/daemon.json https://blog.lyh543.cn/linux/linux-tips/docker.json maven wget -O ~/.m2/settings.xml https://blog.lyh543.cn/linux/linux-tips/maven.xml tlmgr tlmgr option repository http://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnet 文件当前文件夹pushd 和 popd 起了 cd 的作用，还能自动将当前目录压栈、出栈。 1234567891011121314$ pwd~$ pushd /tmp/tmp ~$ pwd/tmp$ popd~$ pwd~ pwd 查看当前文件夹，dirname $0 查看运行的脚本所在文件夹。配合 $() 语法可以直接切换到当前目录： 1cd $(dirname $0) 查看文件/文件夹/磁盘的大小 中文 英文 命令 查看磁盘大小 display filesystem df -h 查看目录下的文件大小 list ls -hs 查看目录下的文件夹的大小 disk usage du -h --max-depth=1 以上的 -h 都是 --human-readable，不使用这个开关，则会使用一个数字表示大小（单位为 KB）；使用开关后，则会使用 200K，1.8G 的形式。注意 du 如不加 --max-depth 参数，会统计完所有的目录。 进程任务管理器可以使用 top 或 htop（后者对鼠标、颜色支持更好）。 进程后台运行使用 nohup使用 nohup 的话，一行代码就 ok： 12# nohup &lt;command&gt; &amp; &amp;&gt;/dev/nullnohup ssserver &amp; &amp;&gt; /dev/null 可能会看到 ignore input 之类的警告，不用管，Ctrl+C 退出前台即可，此时 ssserver 正在后台运行。 使用 pm2这个要麻烦一点，要从 npm 下载，所以还得先下载 npm。 12345678apt install npmnpm install pm2 -gpm2 --name s1 -f start http-server # 配置 pm2pm2 save # 可选命令，作用是保存当前的 pm2 状态pm2 startup # 可选命令，下次开机的时候可以恢复到 save 的状态pm2 ls # 可选命令，列出当前 pm2 的任务 使用 systemd也可以配置 systemd。 进程开机自启在 sudo /etc/rc.local 最后追加命令，然后给权限 sudo chmod a+x /etc/rc.local 即可。 不过貌似 alias 语句无效，可能 alias 是用户级的命令，需要用户登录时执行。 也可以配置 systemd。 用户添加用户并给予 sudo 权限1234sudo useradd &lt;newuser&gt; --disabled-password # 禁用密码，只允许 ssh 登录sudo usermod -aG sudo &lt;newuser&gt; # 将用户加入 sudo 组sudo -u &lt;newuser&gt; # 上号echo &gt;&gt; ~/.ssh/authorized_keys \"ssh-rsa xx\" # 添加 ssh 公钥 然后上号 sudo 检查一下是不是可以了。如果不行，可以试试在 /etc/sudoers 里面修改 %sudo 一行： 1%sudo ALL=(ALL:ALL) NOPASSWD:ALL ssh在使用 Git 和搭建服务器的时候都会用到 ssh，于是笔记也比较零散。 在这里丢几个链接： 创建 ssh 密钥并给 Git/服务器使用 ssh 远程登录服务器 修改 ssh 的端口 Windows 上使用 ssh","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"ssh","slug":"ssh","permalink":"https://blog.lyh543.cn/tags/ssh/"},{"name":"tips","slug":"tips","permalink":"https://blog.lyh543.cn/tags/tips/"}]},{"title":"使用 Shadowsocks 搭建回国代理","date":"2019-10-14T04:33:12.000Z","path":"linux/build-shadowsocks/","text":"前言本文就记流水账一般，记录一下，方便以后再配置的时候查阅。这些方法基本都是可以百度到的。 2019.12.1 更新：发现周围有些人在问我如何搭建代理，我直接把这篇文章分享给他们，但是发现这篇博客写的太浅薄了，对新手也不够友好。最近也挺忙，要是有空，就再把这篇文章写的更加详实吧。先挖点坑： 为什么有些网站无法访问 如何访问这些网站（借助一个中介，介绍 Shadowsocks 原理） 服务器是什么？虚拟服务器是什么？如何使用？（介绍 ssh） 对于萌新，你们可能需要提前准备： 以下三选一（个人推荐 wsl）： Ubuntu 双系统或虚拟机（如果你看不懂这个选项可以直接跳过） wsl（百度“WSL(Windows Subsystem for Linux)的安装与使用”） Windows 的 ssh 客户端（不推荐，但是如果你电脑的硬盘实在不够用了，可以选择这个选项） 准备好学习 Linux 命令行的决心 愿意在遇到问题的时候上网搜索，即使可能消耗十几分钟到一整天的时间 本文正式开始。 租服务器首先，去租阿里云或腾讯云的虚拟服务器。学生的话，都是一月 10 元即可（找不到入口可以在知乎搜一下相关回答）。 系统推荐使用 Debian 或 Ubuntu。 租了服务器以后，会给你的服务器的 ip 地址（下面为方便叙述，设为 39.1.2.3）和密码。 ssh 远程登录服务器ssh 是什么，可以见前言。 注意阿里云的服务器要开放防火墙的端口，不然连不上！！！！！！！！作者就是被这个坑了一下午还没弄好。上面需要开放 22 端口，协议选 tcp。 在本地 Ubuntu（或 wsl 或 Windows 的 ssh 客户端）使用 ssh -p22 root@39.1.2.3 登录远程服务器。 要是出现 ssh: connect to host 39.1.2.3 port 22: Resource temporarily unavailable，再本地尝试 ping 39.1.2.3，要是连不上，说明 ip 被封了，需要删掉服务器，重新建一台服务器。 服务器配置 Shadowsocks成功连上以后，在服务器安装 shadowsocks-libev： 12apt update # debian 下是 apt，CentOS 换成 yum install 即可apt install shadowsocks-libev 修改配置文件： 1nano /etc/shadowsocks-libev/config.json 修改为以下内容： 123456789&#123; \"server\":\"0.0.0.0\", \"server_port\":443, \"local_port\":1080, \"password\":\"lyh543\", \"timeout\":600, \"method\":\"aes-256-cfb\", \"fast_open\": false&#125; 注意： server 不能为 127.0.0.1，不然连不上； server_port 建议不要使用默认的 8838，可以修改为 0-65535 间的其他端口，比如 22222； 如果有：local_address 必须删掉； password 改为自己设的密码。 然后执行 ss-server（CentOS 下是 ssserver -c /etc/shadowsocks.json）。理论上服务器端就配置好了。 在本地下载 Shadowsocks， 并修改 Shadowsocks 配置（具体过程略），就可以进行连接了。（再次提醒，记得开放服务器的对应端口不然你一个小时又没了，这里是 443，协议选 tcp）。 如果连接以后，随便上一个网站，看到服务器上出现 INFO connecting www.baidu.com:443 from x.x.x.x，那么恭喜你，成功啦！ 服务器上后台运行由于服务器一般是不断电一直运行的。因此一般不用考虑开机自启的。但是后台运行比较重要： 使用 nohup 的话，一行代码就 ok： 12# nohup &lt;command&gt; &amp; &amp;&gt;/dev/nullnohup ssserver &amp; &amp;&gt; /dev/null （实际山 ssserver 自带了后台运行的方法，但是通用方法它不香吗） 到这里，Shadowsocks 的配置就基本完成了。 番外篇：配置 bbr搭上梯子以后，发现有时候丢包率有 40% 左右。 Google 了一下，说是可以上 BBR。BBR 是什么，如何开启，可以看下面两篇博客，我就不再复读了。 Google BBR是什么？ 注意，BBR 是针对 TCP 发包的，也就是说，设置好以后，对于所有代理软件和服务器上的所有网页等都会生效。 Ubuntu 18.04/18.10快速开启Google BBR的方法 常见错误及解决方案无法 ssh 登录远程服务器 尝试 ping 你的服务器，输入命令 ping x.x.x.x，如果显示 100% 丢失（或 100% packet loss），说明这个 ip 已经被墙了，需要删掉服务器，重新开一台； 可能没有开放服务器上的 22 端口（协议为 tcp）？ 服务端配置好了，本地连不上/连上以后显示 500 Internal Proxy Error 可能是某些信息（如网址、密码、加密方式）没对应上，总之某些信息出锅了，而不是网络故障。 可能 Shadowsocks 使用的端口被屏蔽了，在服务端修改端口，然后在本地客户端也修改为对应的端口，再尝试链接。 可能是端口被服务端其他进程占用了（可以通过命令 lsof -i &lt;端口号&gt; 查看）。如果确实，再改一个。 如果仍然没有搞定，可能需要通过查看 nohup.out 文件来看 Shadowsocks 的日志的最后二十行： 1tail -n 20 nohup.out 然后上网百度 / Google。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"},{"name":"服务器","slug":"服务器","permalink":"https://blog.lyh543.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"ssh","slug":"ssh","permalink":"https://blog.lyh543.cn/tags/ssh/"},{"name":"代理","slug":"代理","permalink":"https://blog.lyh543.cn/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"MATLAB 并行运算","date":"2019-10-09T01:44:45.000Z","path":"matlab/matlab-parallel/","text":"MATLAB 有强大的 Parallel Computing Toolbox，可以使用 MATLAB 来用 CPU 和 GPU 跑并行运算。 更重要的是，他方便啊！！！比起 C/C++ 还要调库、学更多的东西，MATLAB 有些跑多线程的方法简直就是一键启动多线程，方便的不要不要的。 parfor最简单的一种，就是把 for 改为 parfor。如下代码： 123for i = 1:testCases AverageWaitTime = AverageWaitTime + QueueStimulator(serviceTime, comeTime) / testCases;end 如需要并行运算，只需： 123parfor i = 1:testCases AverageWaitTime = AverageWaitTime + QueueStimulator(serviceTime, comeTime) / testCases; end 如果出现不能并行运算的语法，MATLAB 会报错。 并行计算需要数十秒，用于初始化 Parallel Pool，所以请注意，如果本身单线程只需要几秒就能跑完的程序，是没有必要并行运算的。除掉初始化的时间，并行运算会比普通的快的多（12核心下：4.2s -&gt; 0.6s）。 另外，CPU 12 核心的 Parallel Pool 占用内存达到了 8GB 额，16GB 内存可能会有点吃紧。建议加内存条。 GPU 并行运算目前 MATLAB R2019b 的 GPU 运算只适用于运行 NVIDIA CUDA 的 GPU。 官方快速入门文档","tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"}]},{"title":"矩阵求导（转载）","date":"2019-10-04T09:22:53.000Z","path":"maths/matrix-derivative/","text":"太硬核了，放个链接（挖个坑）就跑。 https://zhuanlan.zhihu.com/p/24709748 https://github.com/microsoft/ai-edu/blob/master/A-基础教程/A2-神经网络基本原理简明教程/Appendix/01.1-基本数学导数公式.md#115-矩阵求导 由于链接 2 有变动，因此下面对文章内容进行备份。 01.1-基本数学导数公式1.1 基本函数导数公式1.1.1 基本函数及其导数 公式序号 函数 导数 备注 1 $y=c$ $y’=0$ 2 $y=x^a$ $y’=ax^{a-1}$ 3 $y=log_ax$ $y’=\\frac{1}{x}log_ae=\\frac{1}{xlna}$ 4 $y=lnx$ $y’=\\frac{1}{x}$ 5 $y=a^x$ $y’=a^xlna$ 6 $y=e^x$ $y’=e^x$ 7 $y=e^{-x}$ $y’=-e^{-x}$ 8 $y=sin(x)$ $y’=cos(x)$ 正弦函数 9 $y=cos(x)$ $y’=-sin(x)$ 余弦函数 10 $y=tg(x)$ $y’=sec^2(x)=\\frac{1}{cos^2x}$ 正切函数 11 $y=ctg(x)$ $y’=-csc^2(x)$ 余切函数 12 $y=arcsin(x)$ $y’=\\frac{1}{\\sqrt{1-x^2}}$ 反正弦函数 13 $y=arccos(x)$ $y’=-\\frac{1}{\\sqrt{1-x^2}}$ 反余弦函数 14 $y=arctan(x)$ $y’=\\frac{1}{1+x^2}$ 反正切函数 15 $y=arcctg(x)$ $y’=-\\frac{1}{1+x^2}$ 反余切函数 16 $y=sinh(x)=(e^x-e^{-x})/2$ $y’=cosh(x)$ 双曲正弦函数 17 $y=cosh(x)=(e^x+e^{-x})/2$ $y’=sinh(x)$ 双曲余弦函数 18 $y=tanh(x)=(e^x-e^{-x})/(e^x+e^{-x})$ $y’=sech^2(x)=1-tanh^2(x)$ 双曲正切函数 19 $y=coth(x)=(e^x+e^{-x})/(e^x-e^{-x})$ $y’=-csch^2(x)$ 双曲余切函数 20 $y=sech(x)=2/(e^x+e^{-x})$ $y’=-sech(x)*tanh(x)$ 双曲正割函数 21 $y=csch(x)=2/(e^x-e^{-x})$ $y’=-csch(x)*coth(x)$ 双曲余割函数 1.1.2 导数四则运算$$[u(x) + v(x)]’ = u’(x) + v’(x) \\tag{30}$$$$[u(x) - v(x)]’ = u’(x) - v’(x) \\tag{31}$$$$[u(x)*v(x)]’ = u’(x)*v(x) + v’(x)*u(x) \\tag{32}$$$$[\\frac{u(x)}{v(x)}]’=\\frac{u’(x)v(x)-v’(x)u(x)}{v^2(x)} \\tag{33}$$ 1.1.3 偏导数如$Z=f(x,y)$，则Z对x的偏导可以理解为当y是个常数时，Z单独对x求导： $$Z’_x=f’_x(x,y)=\\frac{\\partial{Z}}{\\partial{x}} \\tag{40}$$ 则Z对y的偏导可以理解为当x是个常数时，Z单独对y求导： $$Z’_y=f’_y(x,y)=\\frac{\\partial{Z}}{\\partial{y}} \\tag{41}$$ 在二元函数中，偏导的何意义，就是对任意的$y=y_0$的取值，在二元函数曲面上做一个$y=y_0$切片，得到$Z = f(x, y_0)$的曲线，这条曲线的一阶导数就是Z对x的偏导。对$x=x_0$同样，就是Z对y的偏导。 1.1.4 复合函数求导（链式法则） 如果 $y=f(u), u=g(x)$ 则： $$y’_x = f’(u) \\cdot u’(x) = y’_u \\cdot u’_x=\\frac{dy}{du} \\cdot \\frac{du}{dx} \\tag{50}$$ 如果$y=f(u),u=g(v),v=h(x)$ 则： $$\\frac{dy}{dx}=f’(u) \\cdot g’(v) \\cdot h’(x)=\\frac{dy}{du} \\cdot \\frac{du}{dv} \\cdot \\frac{dv}{dx} \\tag{51}$$ 如$Z=f(U,V)$，通过中间变量$U = g(x,y), V=h(x,y)$成为x,y的复合函数$Z=f[g(x,y),h(x,y)]$ 则： $$\\frac{\\partial{Z}}{\\partial{x}}=\\frac{\\partial{Z}}{\\partial{U}} \\cdot \\frac{\\partial{U}}{\\partial{x}} + \\frac{\\partial{Z}}{\\partial{V}} \\cdot \\frac{\\partial{V}}{\\partial{x}} \\tag{52}$$ $$\\frac{\\partial{Z}}{\\partial{y}}=\\frac{\\partial{Z}}{\\partial{U}} \\cdot \\frac{\\partial{U}}{\\partial{y}} + \\frac{\\partial{Z}}{\\partial{V}} \\cdot \\frac{\\partial{V}}{\\partial{y}}$$ 1.1.5 矩阵求导如$A,B,X$都是矩阵，则： $$B\\frac{\\partial{(AX)}}{\\partial{X}} = A^TB \\tag{60}$$ $$B\\frac{\\partial{(XA)}}{\\partial{X}} = BA^T \\tag{61}$$ $$\\frac{\\partial{(X^TA)}}{\\partial{X}} = \\frac{\\partial{(A^TX)}}{\\partial{X}}=A \\tag{62}$$ $$\\frac{\\partial{(A^TXB)}}{\\partial{X}} = AB^T \\tag{63}$$ $$\\frac{\\partial{(A^TX^TB)}}{\\partial{X}} = BA^T, {dX^TAX \\over dX} = (A+A^T)X \\tag{64}$$ $${dX^T \\over dX} = I, {dX \\over dX^T} = I, {dX^TX \\over dX}=2X\\tag{65}$$ $${du \\over dX^T} = ({du^T \\over dX})^T$$ $${du^Tv \\over dx} = {du^T \\over dx}v + {dv^T \\over dx}u^T, {duv^T \\over dx} = {du \\over dx}v^T + u{dv^T \\over dx} \\tag{66}$$ $${dAB \\over dX} = {dA \\over dX}B + A{dB \\over dX} \\tag{67}$$ $${du^TXv \\over dx}=uv^T, {du^TX^TXu \\over dX}=2Xuu^T \\tag{68}$$ $${d[(Xu-v)^T(Xu-v)] \\over dX}=2(Xu-v)u^T \\tag{69}$$ 1.1.6 标量对矩阵导数的定义假定$y$是一个标量，$X$是一个$N \\times M$大小的矩阵，有$y=f(X)$， $f$是一个函数。我们来看$df$应该如何计算。 首先给出定义： $$df = \\sum_j^M\\sum_i^N \\frac{\\partial{f}}{\\partial{x_{ij}}}dx_{ij}$$ 下面我们引入矩阵迹的概念，所谓矩阵的迹，就是矩阵对角线元素之和。也就是说： $$tr(X) = \\sum_i x_{ii}$$ 引入迹的概念后，我们来看上面的梯度计算是不是可以用迹来表达呢？ $$\\frac{\\partial{f}}{\\partial{X}} =\\begin{pmatrix}\\frac{\\partial{f}}{\\partial{x_{11}}} &amp; \\frac{\\partial{f}}{\\partial{x_{12}}} &amp; \\dots &amp; \\frac{\\partial{f}}{\\partial{x_{1M}}} \\\\frac{\\partial{f}}{\\partial{x_{21}}} &amp; \\frac{\\partial{f}}{\\partial{x_{22}}} &amp; \\dots &amp; \\frac{\\partial{f}}{\\partial{x_{2M}}} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\frac{\\partial{f}}{\\partial{x_{N1}}} &amp; \\frac{\\partial{f}}{\\partial{x_{N2}}} &amp; \\dots &amp; \\frac{\\partial{f}}{\\partial{x_{NM}}}\\end{pmatrix} \\tag{90}$$ $$dX =\\begin{pmatrix}dx_{11} &amp; d{x_{12}} &amp; \\dots &amp; d{x_{1M}} \\d{x_{21}} &amp; d{x_{22}} &amp; \\dots &amp; d{x_{2M}} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\d{x_{N1}} &amp; d{x_{N2}} &amp; \\dots &amp; d{x_{NM}}\\end{pmatrix} \\tag{91}$$ 我们来看矩阵$(90)$的转置和矩阵$(91)$乘积的对角线元素 $$((\\frac{\\partial f}{\\partial X})^T dX){jj}=\\sum_i^N \\frac{\\partial f}{\\partial x{ij}} dx_{ij}$$ 因此， $$tr({(\\frac{\\partial{f}}{\\partial{X}})}^TdX) = \\sum_j^M\\sum_i^N\\frac{\\partial{f}}{\\partial{x_{ij}}}dx_{ij} = df = tr(df) \\tag{92}$$ 上式的最后一个等号是因为$df$是一个标量，标量的迹就等于其本身。 1.1.7 矩阵迹和导数的部分性质这里将会给出部分矩阵的迹和导数的性质，作为后面推导过程的参考。性子急的同学可以姑且默认这是一些结论。 $$d(X + Y) = dX + dY \\tag{93}$$$$d(XY) = (dX)Y + X(dY)\\tag{94}$$$$dX^T = {(dX)}^T \\tag{95}$$$$d(tr(X)) = tr(dX) \\tag{96}$$$$d(X \\odot Y) = dX \\odot Y + X \\odot dY \\tag{97}$$$$d(f(X)) = f^{‘}(X) \\odot dX \\tag{98}$$$$tr(XY) = tr(YX) \\tag{99}$$$$tr(A^T (B \\odot C)) = tr((A \\odot B)^T C) \\tag{100}$$ 以上各性质的证明方法类似，我们选取式(94)作为证明的示例： $$Z = XY$$ 则Z中的任意一项是 $$z_{ij} = \\sum_k x_{ik}y_{kj}$$$$dz_{ij} = \\sum_k d(x_{ik}y_{kj})$$$$= \\sum_k (dx_{ik}) y_{kj} + \\sum_k x_{ik} (dy_{kj})$$$$=dX_{ij} \\cdot Y_{ij} + X_{ij} \\cdot dY_{ij}$$从上式可见，$dZ$的每一项和$(dX)Y + X(dY)$的每一项都是相等的。因此，可以得出式(94)成立。 参考资料 矩阵求导术","tags":[{"name":"转载","slug":"转载","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"数学","slug":"数学","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"网络流","date":"2019-10-03T16:00:00.000Z","path":"cpp/acm/network-flow/","text":"在 ACM 中第一次听到网络流，但是还没认真学就被迫退役了。（菜的真实） 第二次是在肖老师的 算法设计与分析 课程上，大概了解了网络流的思想。 本文参考《算法设计》，对网络流的研究偏向理论，会涉及到一些证明。 定义流网络流网络（flow network）是一种带权有向图，但是有一个源点（source）和一个汇点（sink），每个权叫做该边的容量（capacity）$c(e)$。如下图。 Flow Network 对流网络我们有三点假设： 没有边进入 $s$ 点，没有点离开 $t$ 点 所有结点至少在一条边上 所有的容量都为整数（这点很重要，是 Ford-Fulkerson 算法会结束的前提） 流流是一个比较形象的概念，好比每个有向边都是一根管道，权重代表这根管道能流多少水。 但是要想用数学定义下来，还是比较麻烦。 $s-t$ 流是一个满足以下条件的函数： 对于图中任意一边 $e$，有 $0 \\leq f(e) \\leq c(e)$ 对于图中任意一点 $v$，有 $\\sum_\\text{e in to v}f(e) = \\sum_\\text{e out of v}f(e)$ 这里是把每一种流法定义为了不同的函数 $f$，用这个函数作用于每一条 $e$ 即可查看这种流法里“管道” $e$ 里流经了多少水。 流的价值： $v(f) = \\sum_\\text{e out of s}f(e)$。 最大流即为最大价值的流。 下图的一个流为 24。（但最大流为 28，从上往下流进 $t$ 点的流量为 9、9、10，请读者自己思考这是如何达到的） 流 割然后我们要引入： $s-t$ 割，就是把图分为 $A$、$B$ 两块的一种方法，要满足 $A$ 块有 $s$，$B$ 块有 $t$。 并定义 A-B 割的容量为流出 $A$ 块的所有容量之和： $$cap(A, B) = \\sum_\\text{e out of A} c(e)$$ 最小割即指容量最小的割。 Cut 最大流-最小割定理接下来我们想要证明最大流-最小割定理： 在每个流网络中，一个图中，一个 s-t 流的最大值等于一个 s-t 割的最小容量。 首先我们证明引理： $$\\sum_\\text{e out of A} {f(e)} - \\sum_\\text{e in to A} {f(e)} = v(f)$$ 这里的 “out of” 和 “in to” 指的是穿出、穿进 $A$ 块的单向边。 证明： \\begin{equation}\\begin{split}v(f) &amp;= \\sum_\\text{e out of s}f(e) &amp; (流的定义) \\\\&amp;= \\sum_{v \\in A}\\bigg(\\sum_\\text{e out of v}f(e) - \\sum_\\text{e in to v}f(e)\\bigg) \\qquad &amp; (加了一堆为值 0 的表达式) \\\\&amp;= \\sum_\\text{e out of A}f(e) - \\sum_\\text{e in to A}f(e) &amp; (证明见后)\\\\\\end{split}\\end{equation} 第三行的证明需要讨论几种情况的边： 如果某边 $e$ 的两个点都在 $A$ 内，这条边在第二行的贡献为一正一负，抵消为零； 如果某边 $e$ 穿出了 A（即入点在 $A$ 内，出点在 $B$ 内），这条边在第二行的贡献为一次正值； 如果某边 $e$ 穿入了 A（即入点在 $B$ 内，出点在 $A$ 内），这条边在第二行的贡献为一次负值。 综上讨论和 “out of” “in to” 的定义可得第三行的正确性。 由上面的结果，我们可以继续往下推得：对于某个图中的任意流 $f$ 和任意 $(A,B)$ 割，有： $$v(f) \\leq cap(A,B)$$ 证明： \\begin{equation}\\begin{split}v(f) &amp;= \\sum_\\text{e out of A}f(e) - \\sum_\\text{e in to A}f(e) \\\\&amp;\\leq \\sum_\\text{e out of A}f(e) \\\\&amp;\\leq \\sum_\\text{e out of A}c(e) \\\\&amp;=cap(A,B).\\end{split}\\end{equation} 那么显然地，对于一个流网络，如果找到一个流 $f$ 和 $cap(A,B)$，有 $v(f)=cap(A,B)$，那么 $f$ 就一定是最大流，且 $(A,B)$ 一定是最小割。 到这里，貌似还没有证明最大流等于最小割，因为我们不知道是不是一定存在一个流和割，满足 $v(f)=cap(A,B)$。我们后面会提到 Ford-Fulkerson 算法，对于这个算法返回的流，我们可以构造一个 $s-t$ 割使得该割等于算法返回的流，即完成了证明。 最大流算法贪心算法最容易想到的是先用贪心跑一下。贪心算法如下： 刚开始设所有边的 $f(e)=0$； 找到任意一条从 $s$ 连向 $t$，且每条边都还没有流满（即 $f(e) &lt; c(e)$）的路径 P。增大该路径每条边上的流； 反复执行上步操作直到流不动了。 贪心在一些图上确实有很好的表现，但是很容易构造出贪心不是最优解的情况，如下： 贪心算法 造成这个的问题是，可能会先选到一条不好的边，导致某个瓶颈满了，其他边无法继续流。 于是就想到了一种可以把已经被占满的边撤销、改回来的方法，叫剩余图(Residual graph)。 剩余图根据之前的设定，原图中的每一条边 $e$ 都有 $c(e)$ 和 $f(e)$。 对于原图的每一条边，我们在一个新的图中都定义两条相互反向的边，把他命名叫剩余边（Residual edge）。 定义剩余边的权重（剩余容量，Residual capacity）：我们把与原图的边同向的边的剩余容量设为原边还能流的量 $c(e)-f(e)$，把反向的边设为原边已经流过的量 $f(e)$。 $c_f(e)=\\begin{cases}c(e) - f(e) &amp; {\\rm if} \\quad e \\in E \\\\f(e) &amp; {\\rm if} \\quad e^R \\in E\\end{cases}$ 刚才的新图便叫做剩余图（又叫残余网络，Residual graph）。 剩余图 Ford-Fulkerson 算法良心的肖老师也提供了演示 PPT。 Ford-Fulkerson 的算法即是先建立剩余图，然后在剩余图上进行我们最开始的贪心。 在增大每边的流量时，需要减少同向边的容量，同时增加反向边的容量。 这样做的好处，就是当有一条边被正向流满，导致图中好像没有可以增加流时，此时可以使用这条边的反向边进行增加流。 如 贪心算法 提到的图中，上到下的边被流满了，如果此时开放下到上的边，就可以增加 10 的流量，即达到最大流。顺便一提，“开放一条边”这个过程被称作 “增广路”（Augmenting path）。 贪心算法 下面是 Ford-Fulkerson 算法的伪代码。 Ford-Fulkerson 算法 算法的正确性证明分为两个部分：一要证明算法会终止；二要证明算法返回的流为最大流。 算法终止的证明如下： 显然，在所有 $c(e)$ 都是整数的前提下，算法每一个步骤中的 $f(e)$ 和增广（Augment）值都一定为整数。 而每次的增广值一定大于 0，故每次增广，流的值会增长至少 1。 显然流的值不可能无限大（一个显然的上界就是 $\\sum_\\text{e out of s}c(e)$），因此算法必然会停止。 算法返回的流为最大流的证明放在下面。 最大流-最小割定理证明作个铺垫，由 Ford-Fulkerson 算法的终止条件，显然有：如果算法终止，算法返回的流不存在增广路了。 接下来我们要证明两点：一是不存在增广路的流是最大流；二是最大流等于最小割。 证明的方式是证明以下三个命题等价： (i) 存在割 $(A,B)$ 使得 $cap(A,B)=v(f)$(ii) 流 $f$ 是最大流(iii) 流 $f$ 不存在增广路 (i) -&gt; (ii) 由前面的引理可得。 (ii) -&gt; (iii) 反证：如果 $f$ 还存在增广路，按照 Ford-Fulkerson 的算法跑一下就可以使流的值变大，与最大流的前提矛盾。 (iii) -&gt; (i) 设 $A$ 为在最后的剩余图从源点 $s$ 出发能到达的所有点的集合，$B=V-A$。 显然 $(A,B)$ 为原图的一个割，且有： $$\\begin{split}v(f) &amp;= \\sum_\\text{e out of A}f(e) - \\sum_\\text{e in to A} f(e) \\qquad &amp; (由前面的引理) \\\\&amp;= \\sum_\\text{e out of A}c(e) &amp; (证明见后) \\\\&amp;= cap(A,B) &amp; (割容量的定义)\\end{split}$$ 第二行的证明：对于 $e$ out of A，一定有 $f(e)=c(e)$，否则： $e$ 在剩余图中仍然存在。设 $e=(u,v)$，由 “out of” 的定义， $u \\in A$，$v \\notin A$。由 $A$ 的假设，在剩余图中 $s$ 到 $u$ 存在通路。将该通路与 $e$ 拼接，则 $s$ 到 $v$ 也有通路，与 $v \\notin A$ 矛盾。 同理，对于 $e$ in to A，一定有$f(e)=0$，否则 $e^R$ 将存在于剩余图。 证明完毕。算法的正确性也同时被证明了。 时间复杂度设图中点数为 $n$，边的数量为 $m$，边的最大容量为 $C$。 由于假设所有点都在至少一条边上，有 $n \\leq 2m$，即 $O(n + m) = O(m)$。 Ford-Fulkerson 算法会停止的证明中，我们证明了 $v(f)$ 有一个上界为 $\\sum_\\text{e out of s}c(e)$，也就是 $O(mC)$； 算法每次迭代必定增长 1。 而每一次迭代的复杂度显然可以在 $O(m)$ 之内完成。 因此，Ford-Fulkerson 算法的时间复杂度为 $O(m^2 C)$。 但是，这个算法不是多项式时间复杂度的！！！！这个算法是伪多项式时间复杂度的。原因是 $C$ 对于输入规模是指数级的。而如果选择增广路的方法不恰当，我们构造出下图，迭代次数确实可以达到 $\\Theta(C)$ 次。 如果每次增广都选择中间的边，那么迭代次数就为 $\\Theta(C)$ 次 缩放最大流算法问题就在于，每次选择了瓶颈（bottleneck）最小的边进行增广。能不能选择最大的边呢？于是就有了缩放最大流（Scaling Max-Flow）算法。 我们维护一个 $\\Delta$，迭代过程中让 $\\Delta$ 由大到小。每次增广时只考虑大于 $\\Delta$ 的边。下面上代码： 缩放最大流算法 Dinitz、Edmonds 和 Karp 分别独立证明了增广路算法能够在 后记最大流问题中还有一个经典的问题: 最小吧 费用最大流问题。请大家自学。对于求最大流的算法, 在实践中往往使用效率更高的 Dinic 算法或 ISAP 算法（参考《算法竞赛入门经典-训练指南》)。对于竞赛来说, 实际更重要的在于网络流模型的建立, 这时把网络流算法作为模板来使用就可以了。","tags":[{"name":"图论","slug":"图论","permalink":"https://blog.lyh543.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.lyh543.cn/tags/%E6%90%9C%E7%B4%A2/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"}]},{"title":"MATLAB 函数","date":"2019-09-30T11:50:36.000Z","path":"matlab/matlab-functions/","text":"收集一些好用的函数名，具体语法等用时再查文档。 常用的可以看 MATLAB 教程书籍的附录。这里放一个整理的 pdf。 统计函数向量的元素和/矩阵的每列和/最值/均值123456789cumsum(A) % 累积和/每列的累积和，即前缀和sum(A)min(A)max(A)mean(A)[x, l] = min(A) % 顺便把最小值位置 index 给 lsum(A,2) % 矩阵的每行和（平均数），2 是第二维 向量长度、矩阵大小12length(V)size(A) %返回一个1x2数组 列排序（返回数列、原数列元素在新数列的index）12[B I] = sort(V)[B I] = sort(V,'descend') %降序 find很重要很重要！！ 第一行找到 v 中大于 0 的元素的下标。第二行把下标矩阵作为原矩阵的下标，则可以直接筛选到对应下标的元素组成的矩阵。 相当于实现了一个筛选矩阵元素的功能。可以用 if 改写，但是 MATLAB 中矩阵运算更快，因此能用矩阵运算就不要用 if。 123v = [1 0 -3 7 -5];idx = find(v&gt;=0); % idx == [1 2 4]v1 = v(idx); % v1 = [1 0 7] 注意到，除了把下标矩阵 idx 传给 v 以外，还可以直接把 v&gt;=0 传给矩阵，省去了一个 find 的过程。 12v = [1 0 -3 7 -5];v2 = v(v&gt;=0); % v2 = [1 0 7] 好用的函数收集（从 xls/xlsx csv txt）读写表格：xlsread，readmatrix（MATLAB R2019a 起）。 注意 readmatrix 如不指定 NumHeaderLines 参数时，会自动识别并去掉行表头。写代码的时候小心。 映射、map：containers.Map。 分段函数：piecewise。 最优化、规划问题相关求函数最小值，有一堆工具箱函数不知道有什么区别，可能使用的算法不同： 功能 函数名 注释 单变量优化 fminbnd() 求一元函数最小值 无约束优化 fminsearch() 使用无导数法计算最小值 fminunc() 计算无约束的多变量函数的最小值 有约束优化 fmincon() 在有线性约束下计算最小值 线性规划 linprog() 解线性规划问题 整数规划 intlinprog() 解整数线性规划问题 遗传算法 ga() 包含以上所有功能，不过精度较低 基于问题的最优化最优化相关的基于问题的方法 Problem-Based Approach： 12345678910111213141516x = optimvar('x',2,'LowerBound',0);xb = optimvar('xb','LowerBound',0,'UpperBound',1,'Type','integer');prob = optimproblem('Objective',-3*x(1)-2*x(2)-xb);cons1 = sum(x) + xb &lt;= 7;cons2 = 4*x(1) + 2*x(2) + xb == 12;prob.Constraints.cons1 = cons1;prob.Constraints.cons2 = cons2;% Convert the problem object to a problem structure.problem = prob2struct(prob);% Set Optionsproblem.options = optimoptions('intlinprog','Display',\"off\");% Solve the resulting problem structure.[sol,fval,exitflag,output] = intlinprog(problem) 说白了，就是 prob2struct 函数能够将 4*x(1) + 2*x(2) + xb == 12 这样的直白的优化式子和约束条件，换为 intlinprog 的 Aeq beq。如果使用传统的方式，这一步转化需要人工完成。对于复杂的问题，这样更不容易出错。 跑出来的 sol 是一个 1*3 向量，那么 x 和 xb 对应哪些变量呢？ 可以使用 varindex： 12345678&gt;&gt; varindex(prob)ans = 包含以下字段的 struct: x: [1 2] xb: 3 就可以看出对应关系了。 更多相关资料可查看 Problem-Based Optimization Setup - MATLAB &amp; Simulink 插值拟合相关该部分详解可见数模自学笔记——插值和拟合。 功能 函数名 注释 一维插值 interp1 二维插值 interp2 样条插值 csape 多项式拟合 polyfit 多项式值计算可使用 polyval 概率统计相关 功能 函数名 注释 正态概率函数 normpdf pdf: Probability Density Function 正态分布函数 normcdf cdf: Cumulative Density Function 正态下侧分位数 norminv(p) 返回 $x$ 满足 $\\varPhi(x)=p$ 按正态分布生成随机数 normrnd 上述函数的卡方分布版本 将四个函数的 norm 改为 chi2 很香 上述函数的均匀分布版本 将四个函数的 norm 改为 unif 上述函数的指数分布版本 将四个函数的 norm 改为 exp 正态均值检验、参数估计 ttest 正态方差检验、参数估计 vartest 总体均值差检验、参数估计 ttest2 $\\chi^2$ 拟合优度（goodness-of-fit）检验 chi2gof 正态分布拟合 normfit 使用 Wald 检验 曲线拟合工具箱 cftool 分布拟合工具箱 distributionFitter 工具箱函数 命令 名称 cftool 曲线拟合工具箱 distributionFitter 分布拟合工具箱 图论 命令名 作用 graphallshortestpaths 求图中所有顶点对之间的最短距离 graphconncomp 找无向图的连通分支，或有向图的强弱连通分支 graphisdag 测试有向图是否含有圈，不含圈返回1，否则返回0 graphisomorphism 确定两个图是否同构，同构返回1，否则返回0 graphisspantree 确定一个图是否是生成树，是返回1，否则返回0 graphmaxflow 计算有向图的最大流 graphminspantree 在图中找最小生成树 graphpred2path 把前驱顶点序列变成路径的顶点序列 graphshortestpath 求图中指定的一对顶点间的最短距离和最短路径 graphtopootder 执行有向无圈图的拓扑排序 graphtraverse 求从一顶点出发，所能遍历图中的顶点 绘图及图片处理见绘图。 符号编程见符号编程。","tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"},{"name":"最优化","slug":"最优化","permalink":"https://blog.lyh543.cn/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"}]},{"title":"MATLAB 编程基础","date":"2019-09-30T11:50:36.000Z","path":"matlab/matlab/","text":"前言推荐官方提供的入门手册：MATLAB 快速入门 help xxx 用于查看命令，doc xxx 直接调用文档 单引号 &#39; 和双引号 &quot; 一样，推荐单引号。用单引号转义单引号，如 disp(&#39;f&#39;&#39;(x)&#39;) 输出 f(x) 用分号 ; 结束语句，以屏蔽输出。 等于 ==，不等 ~=，取反 ~，与或是 &amp;&amp; 和 ||。 行末 ... 表示下一行接着这行。 构造矩阵12345678&gt;&gt; a = [2 2; 5 8]2 25 8&gt;&gt; 1:2:10 % 1 3 5 7 9&gt;&gt; 1:5 % 1 2 3 4 5&gt;&gt; linspace(1,2,10)% (start, end, length)% 1.0000 1.1111 1.2222 1.3333 1.4444 1.5556 1.6667 1.7778 1.8889 2.0000 1:5 语法是闭区间，和 Python 左闭右开不一样。 构造常见矩阵123456&gt;&gt; rand(2) 0.8147 0.0975 0.9058 0.2785&gt;&gt; eye(5)&gt;&gt; ones(3)&gt;&gt; zeros(3) % 可用于初始化 神奇的是， zeros 一开始并没有占用内存，而 ones 就会占用。 另有 normrnd(mu, sigma) 按正态分布生成随机函数，sparse 构造稀疏矩阵。 矩阵的合并、取行列123&gt;&gt; a = [2 2; 5 8]&gt;&gt; A=[a,a]&gt;&gt; A=[a;a] 1234567&gt;&gt; a = [2 2; 5 8]&gt;&gt; a(1, 2) % 第一行第二列，2&gt;&gt; a(1,1:2) % 2 2&gt;&gt; a(1,:) % 2 2&gt;&gt; a([1,2],:) % 2 2; 5 8&gt;&gt; a(end-1:end,:) %% 取倒数两列，倒数第一行&gt;&gt; A(1,:)=[] %% 删除第一行，a = [5 8] 可以把矩阵变为线性矩阵： 12A = [1 2 3; 6 5 4];A(:); %返回 [1 6 2 5 3 4]' 看起来没什么用，但是求矩阵元素和 sum(A(:))、最大值就很香了。 四则运算 A\\B B/A (当A为方阵）等价于A^(-1)*B （对应元素）点乘、点除、幂：A.*A，A./B，A.\\B，A.^B，A.^4 矩阵变换 转置：A&#39; 上、下三角矩阵：tril，triu 逆矩阵：inv(a) 取对角变为列向量：diag(A) 取对角矩阵：diag(diag(A)) 左右翻转：fliplr(A) 将增广矩阵化为简化为阶梯形：rrefA) 特征值、特征向量：[V,D] = eig(A) $V^{-1} \\cdot D \\cdot V = A$ 即$D$的对角线是特征值. 范数 norm() 编程语法数据类型double, char, sym, struct, cell数组以1开头（毕竟万物皆矩阵） 取整函数ceil 向上取整、floor 向下取整、round 四舍五入、fix 向零取整。 然而 C++ 用户还是喜欢使用 int32 强制转换12c = char(49)a = double('1') 查询数据类型12class(A)% 返回数据类型名字的字符串khx cell 数组各元素可为不同类型tql 123456a=cell&#123;2,3&#125;a&#123;4&#125; = 'str'a&#123;1,2&#125; = 123class(a&#123;4&#125;) % == ‘str'class(a(4)) % == 'cell'，注意区别 感觉有点鸡肋，但是 strsplit 能用。 全局变量MATLAB 脚本执行的时候，其变量默认是既不跨文件，也不跨函数的，只是在命令行中调用脚本，其变量会保留在命令行中。 如在 test.m 中 a=2; fun(1);（fun.m 为 function y=fun(x); a=1;）以后，a 的值为 2。 如果需要全局变量，在声明和定义的部分都要写 global a;。 修改上述脚本得到： 12345678global a;a=2;fun(1);disp(a);function y=fun(x) a=1;end 输出 1。 输入输出12345score=input('请输入您的成绩：') %输入MATLAB表达式name=input('请输入您的姓名：','s') %输入姓名disp(a) 显示数组内容fprintf('%6d', score)str=sprintf('%6d',score) %不能输出 转义字符：单引号&#39; 貌似字符串的单双引号可以混用。 文件输入输出件另一篇博客。 控制流程for123for a = 1:10 % for a = [array] string('njjnb')end 支持 continue 和 break。 ifMATLAB 代码实属随和，判断条件部分，加不加括号都可以。 1234567if (a == 1) disp('1');elseif a == 2 sprintf(\"hehe\");else disp('233');end 逻辑运算符==，&amp;，|，~，~=，&gt;，&lt;、&gt;=、&lt;= 用逻辑运算符比较时，矩阵对应元素比较，得到的结果也是矩阵。 对于 if while 是否执行的判定，实际上是判断矩阵的每个元素是否都是非零值。这一点在判断等于、大于小于的时候挺合理，但是在某些情况下会有问题： 比较的两个矩阵维度不同时，会运行报错 判断不等时容易出错： 123456a = [1 2 3];b = [2 3 3];if (a ~= b) disp('not equal')end 上面的代码不会输出 not equal。原因是 a~=b 的结果矩阵中，第三个元素是 1，是非零值。将代码改写为 ~(a == b) 会有同样的问题。 解决方案是，使用 ~isequal(a, b)。他能比较两个矩阵是否相同，并给出一个逻辑值 1/0。也可以对不同维数的矩阵给出 0 而不是报错。 123456a = [1 2 3];b = [2 3 3];if (~isequal(a,b)) disp('not equal')end 输出 not equal。 switch123456switch name(1) case &#123;'a','b','c','d','e','f','g','h'&#125;, disp(['Hello,',name]) otherwise, disp(['Welcome,',name])end 函数MATLAB 函数好多啊，容易被绕进去。那我就不按教程讲叭。 函数这个词，有两个含义： 一个是数学上的含义，指数（数组）到数（数组）的映射； 第二个是编程意义上的，传入一个或多个参数，按规定执行某些操作，然后返回一个或多个参数。 原生 C 语言作为一种编程语言，只有第二种，因此概念不会混淆； 而 MATLAB 作为一个数学计算软件+脚本编程软件，两种函数都要有，于是初学者就混淆了。 MATLAB 的编程函数有两种：函数文件和子函数，具体区别放在后面。MATLAB 的数学函数，网上都说有两种，分别是内联函数和匿名函数，但是我觉得要加上符号函数，一共三种。 在以后的版本中将会删除 inline 内联函数。请改用 匿名函数。 因此对内联函数不做介绍，仅提供官方文档以查阅。 而匿名函数和符号函数呢，前者是可以代值运算的函数，后者是可以进行求导积分泰勒展开等等等等。 用比较形象的话来说，匿名函数就是 f(x)=x^2，而符号函数是 y=x^2。 匿名函数可以求 f(1)、f(2) 等等，但是 x 并不是一个已经声明的符号（或者说，自变量），它只起了占位的功能，代值的时候就会被替换。 而符号函数不能直接求 y(1)，而且需要提前声明 x 是符号（ sym x;），但是它就可以进行求导等操作。你可能会说，数学上，可以通过 y=f(x) 相互转换吖。确实，二者是可以互相转换的。具体方法在后面提到。 函数文件和子函数函数文件是把函数作为模块，可以被其他程序调用，是模块化编程很重要的一点。而子函数是作为主函数的一部分，只能被主函数调用，不能被其他程序调用。 存储上，函数文件需要单文件存储。而子函数不用。如果涉及到了子函数，该文件所有函数（主函数和子函数）都需要写 end。 调用时，使用 hello 或 test(1, 2)。 正常情况下，函数外的参数不能被使用，自变量也不能被修改。和 C 一样。若想要使用全局变量，在声明和使用变量时，都需要加 global 关键字， 1234% hello.mdfunction ret = hellodisp('hello world');ret = 1; 1234567% test.mfunction r=test(r1, r2)r = r1 + r2 + get_r3();endfunction r3 = get_r3r3 = 2;end 返回值可以为多参数。可以用 nargin 和 nargout 检测输入、输出参数个数。函数中支持 return。 12345function [r, v]=myfun(x) r=x.^2; %计算第1个输出参数 if nargout&gt;=2, v = 2*x; %计算第2个输出参数 end Function in Function 摘自：如何评价 MATLAB R2016b ? - winner245的回答 - 知乎https://www.zhihu.com/question/50662537/answer/122451045 在 MATLAB R2016b 以后，还支持在函数里面写函数，并且对于输入和输出相同的函数（即原地调用），性能会有优化。 1234567891011function maintic, x = rand(1e8,1); toctic, y = notInplace(x); toctic, x = inplace(x); tocisequal(x,y)function y = notInplace(x)y = 1.2*x; function x = inplace(x)x = 1.2*x; 匿名函数官方文档写的很好，就直接引用了。 匿名函数是一个 函数句柄 （function_handle）（我注：第一句话官方翻译的太烂了，我重新写了一下；函数句柄可理解为指向某个函数的指针，它并不存储这个函数）。匿名函数可以接受输入并返回输出，就像标准函数一样。但是，它们可能只包含一个可执行语句。 例如，创建用于计算平方数的匿名函数的句柄：sqr = @(x) x.^2;变量 sqr 是一个函数句柄。@ 运算符创建句柄，@ 运算符后面的圆括号 () 包括函数的输入参数。该匿名函数接受单个输入 x，并显式返回单个输出，即大小与包含平方值的 x 相同的数组。 通过将特定值 (5) 传递到函数句柄来计算该值的平方，与您将输入参数传递到标准函数一样。a = sqr(5) 返回 25 许多 MATLAB® 函数接受将函数句柄用作输入（我注：无需创建符号变量 syms，直接调用即可不过貌似不多）。例如，通过将函数句柄传递到 integral 函数，计算 sqr 函数从 0 到 1 范围内的积分：q = integral(@(x) x.^2,0,1); 可以对匿名函数嵌套：g = @(c) (integral(@(x) (x.^2 + c*x + 1),0,1));上述 g(2) == 3。 可以使用不带参数或多个参数的匿名函数：t = @() datestr(now); d = t() 匿名函数可以有多个返回值（本文作略，请查阅官方文档）。 @ 还可以把一个程序函数变成一个函数句柄。如，定义 function y=fun(x)，就可以用 g(@fun,1) 跑遗传算法了。 匿名函数可以转化为符号函数：f=@(x)x^2; syms x; y=f(x); 符号函数可以转为匿名函数：syms x; y=x^2; f=matlabFunction(y); MATLAB 结构体MATLAB 结构体在实际应用中用到的不多，但是作为程序员，还是简单叙述一下。 MATLAB 的结构体不需要定义，当有数据要放入结构体中时，就直接用 . 装进去即可。 123456s.a = 1;s.b = &#123;'A','B','C'&#125;% s = struct with fields:% a: 1% b: &#123;'A' 'B' 'C'&#125; MATLAB 自带函数这都是查手册可以解决的事情。 我总结的可见 MATLAB 函数。 字符串与文件见 MATLAB 字符串与文件。 MATLAB 符号编程syms 英文文档 见 MATLAB 符号编程。 MATLAB 绘图见 MATLAB 绘图。 MATLAB显示回显不回显：使用分号 ;回显：使用回车或逗号 , 显示模式分数模式12format rat %% 分数模式format %% 小数模式 注意这里的分数仍然是近似解，只是将近似解化为了分数形式。如果需要完全精确的结果，请使用符号编程 或考虑使用其他数学软件如 Mathematica。 对于符号编程中的函数，由于其返回的是分数，可通过 double() 或 vpa() 函数将其转为小数，后者返回的同样是 sym 类型，但可以给出任意的精度（对，任意！）。 显示小数位数12format long %%小数位数更多format short %%回到短模式 清屏、清变量123clc %% 清屏clearclear A B %% 清变量 暂停12pause %按任意键以继续pause(0.5) MATLAB 和 MAT 文件MAT 文件即是将 MATLAB 运行中存储在工作区的变量等从内存存储到文件，方便下次继续使用。（这比其他编程语言方便的多） 读取的方法就一行： 1load data 稀疏矩阵创建稀疏矩阵可以使用 sparse 函数： 12345678% 设 M, N, K 为同维列矩阵，表示稀疏矩阵的 M(i) 行 N(i) 列是 K(i)S = sparse(M, N, K);% 将普通矩阵转为稀疏矩阵S = sparse(A); % 构造单位矩阵的稀疏矩阵S = speye(10); 稀疏矩阵和其他矩阵一样，可以使用 S(a,b) 读取，+ - * / ^ 运算，以及其他函数。 稀疏矩阵的特殊操作有： 12% 用图像描述稀疏矩阵的非零元的分布spy(S); 稀疏矩阵和普通矩阵的互相转化： 123% S 为稀疏矩阵，M 为普通矩阵S = sparse(M);M = full(S);","tags":[{"name":"编程语言入门","slug":"编程语言入门","permalink":"https://blog.lyh543.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"}]},{"title":"C++ 面向对象——继承、派生和多态","date":"2019-09-29T07:03:12.000Z","path":"cpp/cpp-grammar/cpp-inheritance-derive-polymorphism/","text":"继承和派生派生，就是从原来的大类，通过增加新的东西、特性、条件，变成了新的小类。如，从哺乳动物通过增加特性（汪汪叫、喵喵叫），派生到狗、猫。 狗和猫，都继承了哺乳动物的特点（胎生等），派生的时候，狗、猫都会自动继承哺乳动物有的特点，无需重复声明。 名称上，被派生的（哺乳动物）叫基类（父类），派生出来的猫、狗叫做派生类（子类）。他们间的继承关系，是由派生类到大类。 （貌似继承和派生是反义词） 在 C++ 中，除了单继承，还可以多继承（狗同时继承了哺乳动物和岸生动物的特点）。 派生类的功能： 继承了基类的所有成员； 可以改造基类的成员； 添加新的成员。 继承类的定义定义继承类的语法格式如下： 1234class Dog: &lt;继承方式&gt; Terrestrial, &lt;继承方式&gt; Mammalia&#123; //定义派生新增加的成员&#125;; 继承方式分为：公有继承（public）、私有继承（private，默认）、保护继承（private），后面有详细解释。 保护成员 和 继承方式：公有继承、私有继承、保护继承无论使用那种继承，基类的对象及其成员都会成为派生类的一部分，但是成员的属性可能发生变化。但是，无论使用哪种继承，基类的私有成员在派生类不能直接访问，必须通过基类提供的公有函数、保护函数访问。 于是产生了保护成员： 公有成员 对于 派生类 和 类外部 都是可见的；私有成员 对于 派生类 和 类外部 都是不可见的；保护成员 是二者的一个中和，他对于 派生类 是可见的，对于 类外部 是不可见的。 说完保护成员，三种继承的区别就很简短了： 公有继承（public）：公有继承是 is a 的关系，基类的 public 和 protected 成员属性都不会改变。这是最常用的。 私有继承（private）：他是一个 has a 的关系。基类的 public 和 protected 成员都会变为 private。 保护继承（protected）：是私有继承的变体。基类的 public 和 protected 成员都会变为 protected。 也可以用下面的表格来说明： 基类 public 成员 protected 成员 private 成员 public 继承 public protected 不可见 protected 继承 protected protected 不可见 private 继承 private private 不可见 另外，struct 也是可以继承的： In C++, a structure’s inheritance is the same as a class except the following differences: When deriving a struct from a class/struct, the default access-specifier for a base class/struct is public. And when deriving a class, the default access specifier is private.– Struct inheritance in C++ - Stack Overflow 实际开发中，私有继承和保护继承有多少应用场景呢？ 知乎上有这么一个问题，可见其实用的真的很少，很多私有继承可以用类的组合来代替，而 Java 直接就把私有和保护两种继承给砍掉了。 私有继承和类的组合私有继承和类的组合都有一个类（下称 Y 类）能用到另一个类（下称 X 类）的 public 成员和函数，而不能使用 private 成员的特性，开发时，具体选择哪个使用呢？ 一般来说，C++ 程序员更喜欢类的组合，一是理解起来容易，二是 Y 类可以使用 X 类的多个对象（继承不能）。 但是，如果有使用 X 类的 private 成员，或者需要2使用 虚函数，就需要使用私有继承。 个人感觉，如果有继承的层次感（如哺乳动物 -&gt; 狗）的结构，建议使用继承；否则使用类的组合（线段有两个点 class Point）。 派生类的构造和析构派生类的构造函数理论上只需要给新的成员提供初始化顺序，而父类的成员只需要用父类的构造函数即可（如果是私有成员，是必须使用构造函数）。具体语法如下： 简要介绍背景：一个 ShoppingCard 类，存了用户的钱钱数；有一个 MemberCard 类继承了 ShoppingCard，并增加了一个 cardid 成员。 12345678910class MemberCard : public ShoppingCard&#123;public: char* cardid; int score; MemberCard(const char* _cardid, float _money) : ShoppingCard(_money) //, &lt;更多的父类&gt;(&lt;参数&gt;) &#123; strcpy(cardid,_cardid); &#125;&#125;; 在 &lt;更多的父类&gt; 处，除了写更多的父类，还可以写： 对象成员（即成员是另一个类的对象），这样就可以也把对象成员初始化了； 甚至，可以写基本数据类型的变量（如 score(0)），因为 C++ 可以使用类似的方法对他们赋初值。 调用构造函数的时候，成员初始化列表 ShoppingCard(_money) 先被执行，再执行派生类的构造函数 strcpy(cardid,_cardid);。相反地，调用析构函数时，先调用派生类的析构函数，再按构造函数中提到的父类的逆序调用父类的析构函数。也就是说，析构函数直接就是 ~MemberCard(){/*Some Codes*/}，没有 :ShoppingCard(_money) 部分。 如果省略基类构造函数，则默认调用基类的默认构造函数 ShoppingCard()。 派生类重载基类的成员函数一句话，其实直接重定义（写一个和父类函数的名字、参数完全相同的函数），即可覆盖父类继承来的函数。而如果又想调用基类里已经被重定义的函数，那么调用时加 基类名::函数名() 即可。如： 12345678class MemberCard : public ShoppingCard&#123;public: consume(int money)&#123;..1&#125;&#125;A;A.consume(100); //调用继承类MemberCard::consume()A.ShoppingCard::consume(100); //调用父类ShoppingCard::consume() 使用不同基类的同名对象基类名::成员 同样适用于不同类的对象的同名成员。 12345678class Test1 &#123; public: int a; &#125;;class Test2 &#123;public: int a; &#125;;class Inheri : public Test1, public Test2 &#123;&#125; B;B.a; //编译错误：有歧义B.Test1::a; //正确 多继承多继承才是混乱的开始。（逃 多继承类的定义、构造函数、析构函数定义多继承类、构造及析构函数的语法上面已经提到过了。只是再强调一下构造和析构函数的执行顺序： 构造函数：顺序执行 : 后面的所有构造函数、再执行 { } 里的部分（即从上往下执行） 析构函数：先顺序执行 { } 里的部分，再逆序执行 : 后的所有构造函数。 多继承的二义性 虚基类上面提到，不同基类的同名对象，可以通过 基类名::函数名() 准确调用。可是，如果是同一个类的同名对象呢？ 这个问题的产生，还和 C/C++ 编译有关。C/C++ 编译类的时候，实际上是把类的内容全部复制了一份到对象里面（详见另一篇博客）。 因此，如果有下图的继承结构，编译以后 AMCar 里就会出现两份 Car 的成员。 AMCar 虽然我们知道两个 Car 等价的，但是编译器却认为这是不等价的。（摊手） 于是，就引入了一个新概念，叫 虚基类。 虚基类要实现的效果是这样的。 虚基类 AMCar 实现的时候，要修改 ACar 和 MCar 的代码，将公共父类 Car 声明为 virtual 虚基类。 123class MCar : public virtual Car &#123; /* */ &#125;;class ACar : virtual public Car &#123; /* */ &#125;;class AMCar : public ACar, public MCar &#123;&#125;; public 和 virtual 的顺序无关紧要。 这样以后，就会只存在一个 Car 了。但是继承路径是怎样的呢（Car 是谁的真基类呢）？这取决于 AMCar 声明 ACar 和 MCar 的顺序。Car 是第一个声明它的真基类。对于上面的情况，Car 是 ACar 的真基类，是 MCar 的假基类。 对于构造函数执行时的顺序，同层次虚基类先于非虚基类。不同层次的，遵守“先生成基类，再生成派生类”的规定。 多态 在许多情况下，我们希望同一个函数的行为随调用的上下文而有所不同，这种情况称为多态。如果“调用的上下文”是在程序编译阶段确定下来，这叫静态多态；如果“调用的上下文”在程序运行阶段才能确定，这叫动态多态。 在编译的阶段，编译器的一个重要的工作就是解释函数调用语句，要把这句函数调用语句和某个可执行代码块绑定起来，这个过程叫做绑定（Binding）。 说了一堆看不懂的话。 不过看样子，静态多态就是函数重载，这又分为根据参数不同的函数重载，和派生类中对基类的同名函数的重载。另外提一句，由于运算符重载属于成员函数重载，于是也属于静态多态。 运算符重载更多内容可见另一篇博客。 赋值兼容规则通常情况下，C++ 不允许不同类型的变量的指针、引用赋值给其他类型的指针、引用。 但是，继承类是个特例。只要兼容一定规则，就可以在基类和派生类之间赋值。这种规则被称为赋值兼容规则。 可以把派生类的对象赋给基类的对象 可以把基类的指针、引用指向派生类 在猫猫狗狗继承的意思上理解的话，可以把猫猫狗狗的信息当做普通动物的信息用，而不能反过来把普通动物的信息当做猫猫狗狗用（不然问起来这个动物一天吃多少鱼就很奇怪了啊）；在代码实现层面上理解，是可以舍弃派生类额外的数据实现转换；而如果反过来了，派生类的新增的变量就没有定义了。 戴波老师用一句很精炼的话来总结： 所有的狗都是动物，但不是所有的动物都是狗——所有的派生类对象都是基类的对象。 以上转化是由派生类向基类的强制转换，叫做向上强制转换 Upcasting。由于其合理性，可以进行隐式转换。反过来，如果先把基类转为派生类，这叫向下强制转换 Downcasting。虽然不大合理，但是可以显式转换。但转换以后，应当格外小心，不要访问到一些未初始化的成员。 动态多态——虚函数虚函数的产生，其实是因为上面提到的，指针居然可以指向不同于指针类型的类型。这就会产生一个问题，我就想用基类指针指向的派生对象的派生函数，那咋办嘛。 于是，虚函数，就是在执行的时候，才会根据其指针指向的对象是基类还是派生类，来进行对应的重载。这也正是动态重载的定义——在执行的时候，再进行重载。 举个栗子，现有 ShoppingCard 与其派生类 MemberCard，想对一个 ShoppingCard 实现虚函数，具体的代码如下： 12345678910111213141516171819//1. 父类成员函数加 virtualclass ShoppingCard&#123;//...public: virtual bool consume(float money); //...&#125;//2. 派生类函数名、参数、返回值完全一致class MemberCard: public ShoppingCard&#123;//...public: bool consume(float money); //...&#125;//3. 对派生类的对象使用基类的引用/指针ShoppingCard * card = new MemberCard;MemberCard.consume(1.0); 注意虚函数有条件：他不能为以下函数之一： 静态成员函数 全局函数 友元函数 虚函数的实现该部分不难，不过仅作了解。 简单的来说，就是两句话： 编译时，每个定义了虚函数的类会有其对应的 虚函数表 VTABLE，存有该类中。（派生类的存在派生类里） 创建对象时，每个对象会获得指向其对应的 VTABLE 的指针。 虚构造函数和析构函数虚构造函数是不存在的。该问题等价于 先有鸡还是先有蛋。（想想，为什么？） 而虚析构函数就没有这个问题，其本质和其他虚函数是一样的。 纯虚函数和抽象类此节开篇一句： 基类往往表示一种抽象的概念，提供一些公共的接口，而这些接口往往不需要实现。 醍醐灌顶。 虚函数在定义后加 =0 即表示纯虚函数，不需要有实现。如上例的代码： 123456class ShoppingCard&#123;//...public: virtual bool consume(float money) = 0;&#125; 即可以把基类函数改为纯虚函数。 抽象类的概念就是开篇的那句说的“只提供公共接口，不需要实现”的类。这个概念不涉及到 C++ 语法，具体做的时候，把成员函数定义为纯虚函数即可。 但是我在实际写代码（环境为 Visual Studio 2019）的过程中，注意到了几个点： 抽象类不能实例化； 只要有一个虚函数没有实现，他就是一个抽象类； 如果派生类没有实现基类的虚函数，那么这个派生类也是抽象类。 所以，如果基类有虚函数，派生类要想有实例化（即能定义该类的对象），必须实现这个函数。 这是为了防止一个父类的指针指向了子类，调用父类虚函数时，发现该子类没有定义函数体的情况。 而如果子类确实不需要这个函数，解决办法可以是写一个对应名字和参数的空函数 void foo(){} 来实现。 多态的意义说了那么多，那动态多态有什么用嘛，还搞得好复杂，甚至还可能出现漏洞。 于是我去知乎搜了一下： 首先需要明确多态性的用途，是为了接口的最大程度复用，以及其定义： 多态性的定义，可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。——https://zhuanlan.zhihu.com/p/47057750 静态多态能实现接口的很大程度的复用，而动态多态就可以最大化复用的程度吧。 2020.1.6 更新：在写了一个大实验以后，我发现了动态多态在实战中的用途。 简单的来说，现在有 class A 为基类，其有派生类 A1、A2、A3 等。我们定义 std::vector&lt;A*&gt;，里面的指针可能指向 A1、A2、A3。 使用动态多态的话，可以实现：将多个不同的派生类 Ai 装在一个集合中，但是调用的时候却是调用 Ai 各自派生类的成员函数。 静态多态则做不到，在 Ai 转为 A 的一瞬间，他就失去了他的派生成员。如下程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class A&#123;public: virtual void foo() &#123; cout &lt;&lt; \"A\" &lt;&lt; endl; &#125;&#125;;class A1 : public A&#123;public: void foo() &#123; cout &lt;&lt; \"A1\" &lt;&lt; endl; &#125;&#125;;void test1() //尝试静态多态&#123; A a; A1 a1; vector&lt;A&gt; vA; vA.push_back(a); vA.push_back(a1); for (auto i : vA) i.foo();&#125;void test2() //动态多态&#123; A * a = new A; A1 * a1 = new A1; vector&lt;A*&gt; vA; vA.push_back(a); vA.push_back(a1); for (auto i : vA) i-&gt;foo();&#125;int main()&#123; test1(); cout &lt;&lt; endl; test2();&#125; 该程序的输出为： 12345AAAA1","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"神经网络 笔记","date":"2019-09-27T08:28:59.000Z","path":"computer-science/neural-networks/","text":"该文章为微软亚洲研究院开的实践空间站的 神经网络基本原理课程 的笔记。 开始之前可以先看一下知乎：如何简单形象又有趣地讲解神经网络是什么？ 课程大纲 基本概念 线性回归 线性分类 非线性回归 非线性分类 模型的推理与应用部署 深度神经网络 卷积神经网络 循环神经网络","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]},{"title":"LaTeX 高阶部分","date":"2019-09-24T13:23:36.000Z","path":"latex/latex-high-level/","text":"该文章记录 LaTeX 原理等部分，和前一篇的简单用法分开。 LaTeX 编译过程LaTeX 编译过程中会有六个文件： .aux——存放交叉引用信息； .dvi——是 LaTeX 编译运行后的主要结果。用户可以使用 DVI 预览软件查看 .dvi 内容； .log——记录上一次编译器运行的日志； .pdf——PDF 文件，文件是 pdflatex 编译运行后的主要结果； .synctex.gz； .tex——LaTeX 和 TeX 源文件，进行编译处理。 手动导入宏包一般情况下，如果使用到编译器没有自带的宏包的时候，编译器会自动进行下载。然而总会有一堆奇怪的原因导致不能下载。 有一个方法就是手动下载然后导入。 包的扩展名可能为 sty 或 cls。下载以后，放在编译器的根目录（具体在哪里我也没搞懂），或者放在需要的源文件的同一目录下也可以。","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://blog.lyh543.cn/tags/LaTeX/"}]},{"title":"遗传算法 和 MATLAB","date":"2019-09-23T13:13:10.000Z","path":"matlab/genetic-algorithm/","text":"参考链接：如何通俗易懂地解释遗传算法？有什么例子？ - 严晟嘉的回答 - 知乎https://www.zhihu.com/question/23293449/answer/120220974 那就不多说了，仅说说自己更多的理解。 遗传算法原理遗传算法的原理其实大家在初中生物就学过了，对你没看错，是生物书，就是那个达尔文的进化论。 我们希望有这样一个种群，它所包含的个体所对应的函数值都很接近于f(x)在[0,9]上的最大值，但是这个种群一开始可能不那么优秀，因为个体的染色体串是随机生成的。如何让种群变得优秀呢？ 不断的进化。每一次进化都尽可能保留种群中的优秀个体，淘汰掉不理想的个体，并且在优秀个体之间进行染色体交叉，有些个体还可能出现变异。 遗传算法的迭代过程遗传算法其实就是模拟了进化的过程。大概流程如下： 初始化种群，给他们一大堆随机的基因（将不同基因的种群布满所有地方） 计算每个个体的适应度函数（生物学上来说就是判断它适不适应当前的环境，为优胜劣汰做准备。适应度函数即代表这个个体的优秀程度，如求函数 f(x) 最大值时，适应度函数即 f(x) 本身） 对个体按适应度排序，这是为了后面选择做准备 接下来准备培养后代，要进行选择（选择父母来繁衍后台）。可以采用轮盘赌选择方法（当然还有很多别的选择方法），各个个体被选中的概率与其适应度函数值大小成正比；也可以进行优胜劣汰，淘汰掉适应度低的个体，直接选前代最优的个体。 选完以后，进行交叉，开始繁衍后代。 还要考虑变异的可能。虽然变异概率小，但是在一个大种群里面，还是可能变异出更优秀的个体的。 交叉变异完了，后代繁衍好了，至此，一轮迭代完成了。下一次迭代又会回到第二步。 实际运用中，我们会把所有基因映射到一个二进制串里，一是可以把多自变量映射为一个变量（即基因），二是方便进行基因交叉和变异。这个过程叫编码。 我们需要写解码公式（貌似不需要编码公式），这样才能计算适应度。具体怎么计算可以看转载来源（咕咕咕）。 在 MATLAB 中调用遗传算法第一种调用方法，就是直接调用 ga() 函数。第二种是调用工具箱。 ga() 函数额官方没有汉化文档。 MATLAB 的 ga() 函数可以寻找函数在无约束或线性、非线性、整数约束下的最小值。 123456789101112x = ga(fun,nvars)x = ga(fun,nvars,A,b)x = ga(fun,nvars,A,b,Aeq,beq)x = ga(fun,nvars,A,b,Aeq,beq,lb,ub)x = ga(fun,nvars,A,b,Aeq,beq,lb,ub,nonlcon)x = ga(fun,nvars,A,b,Aeq,beq,lb,ub,nonlcon,options)x = ga(fun,nvars,A,b,[],[],lb,ub,nonlcon,IntCon)x = ga(fun,nvars,A,b,[],[],lb,ub,nonlcon,IntCon,options)x = ga(problem)[x,fval] = ga(___)[x,fval,exitflag,output] = ga(___)[x,fval,exitflag,output,population,scores] = ga(___) 额参数怎么这么多啊。一个一个说一下吧： problem 应该是一个类，在此不表（还没学呢.jpg）。剩下的， fun 是一个函数句柄，如 @(x)x^2 或 @myfun nvars 是自变量的维数 $A$ 和 $b$ 是自变量（称为 $x$，下同）的限制条件，满足 $A \\cdot x \\leq b$ $A_{eq}$ 和 $b_{eq}$ 是 $x$ 的限制条件，满足 $A_{eq} \\cdot x = b_{eq}$ $lb$ 和 $ub$ 是 $x$ 的下界（lower bound）和下界（upper bound），满足 $lb \\leq x \\leq ub$ nonlcon 意思是非线性限制条件（non-linear constraints）。在这里是一个函数句柄，接受变量 $x$，返回 $C(x)$ 和 $C_{eq}(x)$ 的函数值组成的向量，要求遗传算法在 $C(x) \\leq 0 \\wedge C_{eq}(x) = 0$ 的非线性范围下进行搜索。 IntCon，整数限制，是一个元素取值从 1 到 nvars 的向量，要求 $x$ 的这些维度需要取整数。注意如果设了这一项，$A_{eq}$、$b_{eq}$、nonlcon(2) 需要设为空（整数规划不能和线性规划同时具备）。 上述 $A$、$b$、$A_{eq}$、$b_{eq}$、nonIcon 如果想要设为空，请使用 []。 如果想要屏蔽输出 Optimization terminated: ....，要使用 option 参数： 12op=optimoption('ga');op.Display=off; 更多细节还是看官网吧。 优化工具 Optimization Tool网上有人说 gatool，但是这个工具在 R2015b 版本中被移除了。文档说，在之后的版本应该使用 optimtool 打开 Optimization App。但在 MATLAB 命令行中输入 optimtool 后，提示该工具也快要被移除了，现在建议 Optimizing Without the App 了。。。行吧行吧。具体里面什么内容我也咕咕咕了。。。 但是不得不说，MATLAB nb！","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"},{"name":"最优化","slug":"最优化","permalink":"https://blog.lyh543.cn/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"}]},{"title":"MATLAB 绘图","date":"2019-09-23T12:33:01.000Z","path":"matlab/matlab-plot/","text":"按自变量、因变量值绘图这是老师教的方法。官方文档 这个方法的实现是：将输入的 n 个点中，相邻两个点都用直线连接。当点足够密时，可以认为曲线是平滑的了。需要散点图在最后加一个参数 .。 已知表达式123xx = linspace(0, 2*pi, 100);yy = sin(xx);plot(xx,yy); 参数方程1234t = linspace(0,2*pi,100);x1 = r*cos(t);y1 = r*sin(t);plot(x1,y1) plot 散点图1plot(1:5, 1:5, '.'); % 另可用 `o`, `*` 按符号函数绘图官方文档 fplot 可以直接传函数进去（推荐用符号函数，用匿名函数会警告）。传一个函数即是普通函数，传两个就是参数方程。区间用一个二元向量 [1 2]表示。 1234fplot(f)fplot(f,xinterval)fplot(funx,funy)fplot(funx,funy,tinterval) ezplot（不知道是什么）12ezplot(sin(x)/x);ezplot(t,t^2,[1,2]); scatter 散点图后来老师讲了带参数的 plot，真香。 123for i = 1:10 scatter(i,rand()), hold on;end 使用实心圆可以使用 scatter(i,rand(), 8, &#39;filled&#39;)。 histogram 直方图旧版使用 hist，新版使用 histogram。 输入一个向量，绘出 x 的每个元素的直方图。 其中，默认把 x 的值分为 10 个区间。 三维线图plot3，和 plot 用法类似，给定 n 个点的 (x, y, z) 坐标，plot3 绘制其连起来的线图。 三维面图surf 三维面图要稍微麻烦一点，需要给定 X, Y, Z 三个矩阵（而不是向量），其中 X, Y 可以用 meshgrid 函数和 x, y 的 n 个坐标进行生成。 下面的代码将生成抛物线 $z=x^2+y^2$ 在 [-5,5] 的范围。 12345x = -5:0.1:5;y = -5:0.1:5;[X, Y] = meshgrid(x, y);Z = X.^2 + Y.^2;surf(X,Y,Z); MATLAB 自带了生成绘制标准球（sphere）、椭球（ellipsoid）和标准圆柱侧面（cylinder）的 X,Y,Z 的函数。 如果想要生成其他大小、位置的球/圆柱，可以考虑坐标变换。下面的代码生成了半径为 R，球心在 [-R, -R, L] 的球。 12345[x1, y1, z1] = sphere;x1 = x1 * R - R;y1 = y1 * R - R;z1 = z1 * R + L;surf(x1, y1, z1); 也可以手算得到 X, Y, Z： 1234567891011close alla = 6000;b = 5000;[r,t]=meshgrid(linspace(0,a,50),linspace(0,2*pi,50));x=r.*cos(t); y=r.*sin(t);z = b*sqrt(1-(x.^2+y.^2)/(a*a));z = real(z);surf(x,y,z);hold on;surf(x,y,-z)axis equal 如果给定函数和范围想要直接画出图形，可以改用 fsurf。 mesh 散点图动画程序框架动画框架即是播放一张图片，然后暂停 0.05s。 显然，如果绘图过程耗时远小于 0.05s，则可以做出 20 帧的动画。 1234567891011close all;N = 100;for i=1:N hold off; % ... 绘图语句 hold on; % ... 绘图语句 % ... 绘图语句 % 完成绘图后暂停 pause(0.05);end; image 输出图片12background = imread('Snakes_And_Ladder.png');image(background); 输出了以后还可以用 hold on; plot 在图上绘制几何图形，每个像素为一个单位长度。但需要注意，该图的原点在左上角，x、y 轴的正方向分别为右方、下方。 提示：还可以使用 axis equal off 来保持图片的长宽比，然后隐藏坐标轴。 输出视频输出视频的原理是将绘图窗口（gcf 为当前绘图窗口）的图片插入视频，最后导出一个 30 帧的视频。 下面用到了类的写法。 1234567mp4 = VideoWriter('highway.mp4','MPEG-4');mp4.open();for i=1:N % 绘图 mp4.writeVideo(getframe(gcf));endmp4.close(); 图的注释、美化hold on使用两个 plot （或其他画图语句）后，第二个会删掉前面的图并且重新画。 要想将两个图叠加在一起，需要在第一次绘图以后加一句 hold on。如： 1234plot(...);hold on;plot(...);plot(...) 如下次绘图不想叠加了，就在这次绘图之后加一句 hold off 即可。 但请注意，hold on 和 hold off 的原理是设置图/表的 NextPlot 属性为 add 或 replace，并非立即刷新。在下次绘图时，会检查 NextPlot 的属性，再决定是否覆盖掉，还是将图形进行叠加。 因此，下图的代码中的 hold off 其实无意义。 12345plot(...);hold off;hold on;plot(...);plot(...) 另外，很神奇的是，在 MATLAB R2020a 中，rectangle 的语法很诡异。（在 MATLAB R2017a 中没有这个问题） 123456plot(...);hold off;rectangle();hold on;plot(...);plot(...) 多图并排1234subplot(1,2,1);scatter(rand(1,10000),rand(1,10000))subplot(1,2,2)；scatter(rand(1,10000),rand(1,10000)) 另外，从 R2019b 开始，您可以使用 tiledlayout 和 nexttile 函数显示平铺绘图。 123456789101112x = linspace(0,10);y1 = sin(x);y2 = cos(x);tiledlayout(2,1)% Top plotax1 = nexttile;plot(ax1,x,y1)% Bottom plotax2 = nexttile;plot(ax2,x,y2) 坐标轴格式调整12axis off % 隐藏坐标轴axis equal % 使坐标轴的 x, y, z 轴单位长度相同 图的注释123plot(x,y);title('y=f(x)')xlabel('x'), ylabel('y') 线图的美化1234h = plot(x1,y1, 'r-'); % 选择曲线颜色、线型 r 红色，k 黑色，b 蓝色，o set(h, 'linewidth' ,2); % 调整线的属性legend('X', 'Y');axis([0 25 0 20]) % 调整坐标区的范围 散点图的美化123plot(d(:,1),y,'o','markersize',12)set(gca,'fontsize',14)set(gcf,'color','w')","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"}]},{"title":"MATLAB 字符串与文件","date":"2019-09-23T11:46:47.000Z","path":"matlab/matlab-string-and-file-function/","text":"char 和 string老师上课讲的字符串是 char 类型，等价于字符矩阵，形式为 &#39;this is a char&#39;，和 C 语言等不一样的是，结尾无 \\0。 MATLAB R2016b 引入了一种新的 string 字符串类型，每个字符串为一个元素，这样构建一个 n*m 矩阵就只需要一个二维矩阵（如果是 char，需要三维矩阵，或者改用二维 cell）。string 字符串用双引号以示区别 &quot;this is a string&quot;。 两种类型可以互相转换 cstr = char(str); str = string(cstr);，并且在不少地方都可以通用。 char 字符串函数 函数名 函数用途 length或strlength 计算 char 字符串的长度 s=[s1,s3,num2str(num)] 连接 char 字符串 num2str 数字转字符串 str2num 字符串转数字 strtok(str, delim) 查找 str 的第一个 delim 之前和之后的字符串 strcat, strvcat 横向/纵向拼接字符串（纵向时可能会补长度） strsplit(str,delimiter) 按 delimiter 分割 str（多 delimiter 用 cell 传递） 分割字符串str2 = strsplit(str,delimiter) 12str = 'ABC;UVW;QWERTY';strsplit(str, &#123;';', 'V'&#125;); % == \"ABC\" \"U\" \"W\" \"QWERTY\" string 字符串 从 R2016b 开始，您可以使用字符串数组而不是字符数组来表示文本。字符串数组的每个元素存储一个字符序列。序列可以具有不同长度，无需填充，例如 “yes” 和 “no”。只有一个元素的字符串数组也称为字符串标量。您可以按照标准数组运算对字符串数组进行索引、重构和串联，还可以使用 + 运算符向字符串追加文本。如果字符串数组表示数字，则可以使用 double 函数将其转换为数值数组。 前面提到，char 和 string 两种类型可以互相转换 cstr = char(str); str = string(cstr);，并且在不少地方都可以通用。 但是注意，二者对于矩阵处理的函数可能不同，这是因为一个 string 字符串被视为元素，而一个 char 字符串被视为矩阵，二者在字符串拼接、length 函数上的效果会有不同。 string 还引入了更多了函数，也非常方便。 但是 string 似乎不能处理字符串内的某个字符，此时可能需要将 string 转换为 char 来处理。 文件函数和C语言很像。打开文件、读取、关闭。fid 是文件句柄。 1234567fid = fopen('myout.txt', 'wt'); %打开fprintf(fid,'name=%s', name); %格式化读取fgets(fid); %读取一行和回车if ~feof(fid) %判断文件末 fgetl(fid); %读取一行无回车endfclose(fid) %关闭 打开文件 打开模式 意义 r 只读，文件必须存在 w 写；若存在，则清空 a 在文末追加 字母后加 t 以文本形式（默认） 字母后加 b 以二进制形式 字母后加 + 读写都可 fclose(&#39;all&#39;) 直接关闭所有文件。 读取文件读一行：A = fgetl(fin);。当读入空行时，返回 0x0 矩阵。scanf 天下第一！：A = fscanf(fin,&#39;%d%d%c&#39;)。得到的 A 是一个矩阵。 这两个够用了.jpg","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.lyh543.cn/tags/MATLAB/"}]},{"title":"LightOJ 1298 递推求一堆数的乘积之和","date":"2019-09-16T16:00:00.000Z","path":"cpp/acm/LightOJ_1298/","text":"这是一道在 2019 暑期集训做到的题。 链接：https://vjudge.net/contest/312000#problem/G 这个题意是给定 $k$ 和 $p$，要求 $\\varphi(x)$ 之和，$x$ 的质因数分解有 $k$ 个质数并且包含且只包含质数表前 $p$ 个（下称“前 $p$ 种”）质数。$k, p \\leq 500$。 当时做这个题的时候，直接就交了一个 $O(n^3)$ 的 DP 上去，就 T 掉了。还以为是被卡常了，结果发现标程是 $O(n^2)$ 的。（LightOJ 真是慢，n = 500 O(n^3) 都过不了，别人 CodeForces n=10000 O(n^2) 就能卡过去） 转换以后，我认为题意是要从前 $p$ 种质数中枚举 $k-p$ 个数（可重复），然后相乘求和，类似于 $n$ 球放进 $m$ 盒问题，每一个 dp[m][n] 都是由 dp[m-1][t] $0 \\leq t \\leq n$ 得到的，就写了一个 $O(n^3)$ 的算法。 但实际上这个题，每个 dp[m][n] 可以由 dp[m-1][n-1] 和 dp[m][n-1] 得到。因为这是数学问题（指涉及到了一堆乘法和加法）。 看到别人的 dp 转移方程我是懵逼的，但是我尝试者打表举例来说： 同样是按照我的定义来说吧：从前 $n$ 种质数中取 $m$ 个数（可重复）。dp[0][0] = 1。 dp[n][m] n=1 n=2 n=3 n=4 m=1 dp[1][1]=2 dp[2][1]=2+3 dp[3][1]=2+3+5 dp[4][1]=2+3+5+7 m=2 dp[2][1]=2*2 dp[2][2]=2*2+2*3+3*3 dp[3][2]=2*2+2*3+3*3+2*5+3*5+5*5 dp[4][2]=2*2+2*3+3*3+2*5+3*5+5*5+2*7+3*7+5*7+7*7 m=3 dp[3][1]=2*2*2 dp[3][2]=2*2*2+dp[2][2]*3 dp[3][3]=2*2*2+2*2*3+2*3*3+3*3*3+dp[3][2]*5 数据过长，略 写完 $m=2$，貌似已经可以看到一点规律了： 12dp[n][m] = dp[n-1][m] + dp[n][m-1]*prime[n](dp[0][i] = 1) 用人话举例来说，就是 dp[3][2]（前两种质数中取三个）的情况是以下两种情况的求和：一是不取第三种质数，该情况等于 dp[2][2]；二是取至少一个第三种质数，该情况的值又正好等于 dp[3][1] 的值乘以第三个质数。 这题的分析就很明了了。 **其实这样一手动打表，转移方程具体该谁乘谁加谁就很明了了，并不需要O(n)，只需要O(1)**。这大概就是这题的教训了吧。 另外 Light OJ 上把 %lld 改成 I64d，就从 9ms 卡到 3000ms 了。心态爆炸。以后还是用 iostream 吧。 最后放一下 AC 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;//#define _CRT_SECURE_NO_WARNINGS#define ld long double#define ll long long#define int ll#define eps 1e-11#define fastio ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);using namespace std;typedef pair&lt;int, int&gt; P;const int maxn = 1e4 + 5, mod = 1e9 + 7;bool vis[maxn] = &#123; 0 &#125;;int prime[maxn], cnt = 0;void euler(int n)&#123; for (int i = 2; i &lt; n; i++) &#123; if (!vis[i]) prime[cnt++] = i, vis[i] = 1; for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt; n; j++) &#123; vis[i*prime[j]] = 1; if (i%prime[j] == 0) break; &#125; &#125;&#125;int dp[505][505] = &#123; 0 &#125;, base[505];signed main()&#123; //ofstream fout(\"out.txt\"); fastio; euler(maxn); for (int n = 1; n &lt;= 501; n++) &#123; dp[n][0] = 1; for (int m = 1; m &lt;= 501; m++) &#123; dp[n][m] = dp[n - 1][m] + dp[n][m - 1] * prime[n - 1]; dp[n][m] %= mod; &#125; &#125; base[0] = 1; for (int i = 1; i &lt;= 500; i++) &#123; base[i] = base[i - 1] * (prime[i - 1] - 1); base[i] %= mod; &#125; int T; scanf(\"%I64d\", &amp;T); for (int kase = 1; kase &lt;= T; kase++) &#123; int k, p; scanf(\"%I64d%I64d\", &amp;k, &amp;p); printf(\"Case %I64d: %I64d\\n\", kase, dp[p][k - p] * base[p] % mod); &#125;&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数论","slug":"数论","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.lyh543.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Hexo Indigo主题配置","date":"2019-09-16T16:00:00.000Z","path":"blog/hexo-indigo/","text":"额，在用了两个月的 Material 主题以后，有点喜新厌旧了（逃 其实是有些地方不大方便：在读长文章的时候没有一个 Table of Content（toc，或者有但是我不会开）；另一个就是博客的分类和标签太弱了，再加上宽大的卡片式设计，遍历文章标题的效率非常低，跳转非常不方便，基本只能靠搜索；最后是每篇博客的那张图就是在那几张 Material Design 的壁纸里面随机，看久了确实没什么意思。再加上 Hexo 换个主题挺方便的，所以就动手了。 这次选的是 indigo，仍然是基于 Material Design 的，而且过渡动画挺好看的。分类和标签页都运用了选项卡，这样的查找效率就很高了。 在配置方面也还好，作者写了手册，按照手册一步一步做就行了，要是配置过一遍 Hexo 博客的人，做起来是不吃力的。 但是在评论部分，稍微有点卡，因为之前的 Material 主题是用 gitalk 配置的。而 gitalk 的 id 为了避免过长，于是用的是标题的 md5 值。indigo 的 gitalk 部分貌似也是有考虑到 id 过长的问题，但是处理方法不是 md5，于是以前的 issues 不能被现在识别到，需要去修改 gitalk 部分的代码。但是之前的 md5 也是自己改的，所以对于我这个 JS 小白来说，迁移到 indigo 也不是很难。 最后还是没有解决 toc 的问题。在 issues 下我看到一个人有相同的情形，但他是 emacs 造成了，而我使用的是 vs code。于是挖个坑在这里，希望能解决吧。 更新：关于 toc，我最后解决的方案是，备份文件以后，重新 hexo init blog 和 git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo，按照 indigo 作者的方法安装依赖，然后再把配置文件、博客文件复制过去即可。 可能是我之前使用的 Material 主题，切换主题的时候直接修改站点配置文件的 theme 选项，某些文件出现错误导致的问题。","tags":[{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"}]},{"title":"C++类型转换","date":"2019-09-16T16:00:00.000Z","path":"cpp/cpp-grammar/cpp-type-conversion/","text":"隐式类型转换就是编译器自动转； 显式类型转换类如 (char) 强制类型转换运算符MSDN 强制转换运算符C++ 强制转换运算符| 菜鸟教程 C 存在隐式转换和显式转换。C++ 的隐式转换和 C 相同，而把 C 的非常笼统且不安全的显式转换细分为了四种显式转换，如下。 reinterpret_cast字面意思是按位“重新解释”，可以实现 指针 和另一种指针/整数 的互相转换。 12int * int_ptr = new int;char * char_ptr = reinterpret_cast&lt;char*&gt; int_ptr; const_cast能（且只能）为变量加上或删除 const、volatile 和 __unaligned 特性。 但需要注意的是，const_cast 修改使用 const 创建的变量是未定义行为。原因是，如果在创建变量时使用 const int，编译器可以进行优化，修改这种变量是未定义行为（详见 cv 限定符 部分）。 123456789101112131415161718void square(const int* px) &#123; int* p = const_cast&lt;int*&gt;(px); // const_cast 去掉了 px 的 const volatile 限制 *p = (*p) * (*p);&#125;int main() &#123; int i = 5; // 创建变量时使用 const const int ci = 5; // 创建变量时使用 const const int* pi = new int(5); // 创建变量时不使用 const square(&amp;i); square(&amp;ci); // 未定义行为 square(pi); cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ci &lt;&lt; \" \" &lt;&lt; *pi; // 在 g++ 和 msvc 中均输出 25 5 25 // 但 VS 调试器显示 ci 对应内存的值为 25，显然是 cout 语句被编译器优化了 return 0;&#125; 如果定义为 const volatile 阻止编译器优化，修改这种变量是合法的。 1234567891011121314151617void square(const volatile int* px) &#123; int* p = const_cast&lt;int*&gt;(px); // const_cast 去掉了 px 的 const volatile 限制 *p = (*p) * (*p);&#125;int main() &#123; int i = 5; const int ci = 5; const volatile int cvi = 5; // 使用 volatile 阻止编译器优化 square(&amp;i); square(&amp;ci); // 未定义行为 square(&amp;cvi); cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; ci &lt;&lt; \" \" &lt;&lt; cvi; // 在 g++ 和 msvc 中均输出 25 5 25 return 0;&#125; static_caststatic_cast&lt;int&gt; 类似于 C 的显式转换，可用于父类向派生类转换、int 向 char 转换等。这些报错都是在编译阶段完成。 12float f = 2.33;int i = static_cast&lt;int&gt;(f); // 合法 12345678struct A &#123;&#125;;struct B: public A &#123;&#125;;int main() &#123; A a; B* b = static_cast&lt;B*&gt;(&amp;a); // 合法 return 0;&#125; 但是不同的是，显式转换是真的什么都可以转，而 static_cast 还是做了一些限制的，比如不能做 const_cast reinterpret_cast 以及不相关的类型转换。 1234567891011struct A &#123;&#125;;struct B &#123;&#125;;int main() &#123; A a; B* b1 = (B*)&amp;a; // 不报错 B* b2 = static_cast&lt;B*&gt;(&amp;a); // 报错 int i1 = (int)&amp;a; // 不报错 int i2 = static_cast&lt;int&gt;(&amp;a); // 报错 return 0;&#125; dynamic_cast 用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 对不明确的引用的转换将抛出 bad_cast 异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换 bad_cast 异常 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"Hexo 建站","date":"2019-09-16T16:00:00.000Z","path":"blog/hexo-building-blog/","text":"先放一个Hexo官方文档的链接。 初始化 hexo 博客12npm install hexo-cli -ghexo init lyh543.github.io 这步会创建一个 lyh543.github.io 文件夹，文件夹里是一个基础的博客。接下来安装博客所需的最基础的 npm 包。 12cd lyh543.github.ionpm install 然后接常规二连就可以了 常规二连1234# hexo clean# 如果后面突然报bug，可以试下clean（虽然我也不知道有什么用）hexo ghexo d #可以替换为git add, commit, push三连 貌似调用hexo的任何命令的前 20 秒内命令行会没有回显，用Windows下的任务管理器查看是 node 占用了高 CPU。不知道是不是通病。 甚至可以简写为（以下二选一）： 12hexo d -ghexo g -d 配置 hexo-serverHexo 提供了本地即时预览网页的功能，需要安装 hexo-server: 1npm install hexo-server --save 安装以后，hexo s以后即可在http://127.0.0.1:4000/预览自己的博客了。本地更新文件以后，hexo 会即时更新，刷新网站即可预览更改。 配置 deploy配置deploy就不用再到 git 里 push 了。 deploy 之前配置博客根目录下_config.yml最后三行为（冒号后一定要有空格！！！！） 1234deploy: type: git repo: https://github.com/lyh543/lyh543.github.io branch: master 还要安装hexo-deployer-git： 1npm install hexo-deployer-git --save 给 hexo 换主题先区分两个概念：主题配置文件和站点配置文件。 站点配置文件用于配置站点，在/_config.yml；主题配置文件用于配置主题，在 /theme/&lt;theme name&gt;/_config.yml。二者同名，故用概念区分，下同。 理论上，只要在/theme文件夹下配置好以后，修改站点配置文件的theme一项，即可方便的切换主题。 本文以material主题做示范，演示如何下载、配置主题。 在github把上面的库clone到本地； 在 Hexo 博客中的/theme/文件夹下创一个material文件夹； 接下来把刚才clone的整个库复制到material文件夹里； 最后改一下站点配置文件： 123theme: materiallanguage: zh-CN 即可。 Material主题配置具体需要注意的点见另一篇博客。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.lyh543.cn/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"},{"name":"npm","slug":"npm","permalink":"https://blog.lyh543.cn/tags/npm/"}]},{"title":"Hexo 备份（及一次翻车的经历）","date":"2019-09-16T16:00:00.000Z","path":"blog/hexo-backup/","text":"由于 Hexo 的本地文件是没有上传到 Github 的，某天突发奇想，想把 Hexo 文件夹直接移至 Onedrive 自动备份。后来发现由于 Hexo 的 node_modules 文件太多了(10000+)，以至于需要同步很久。另外，每一次 generate，都会有一堆东西要删除，但是由于 Onedrive 的设定，这些文件就在 Onedrive 云端保留了，非常混乱。 于是就不整了。 把文件移出 Onedrive 时，每次都会导致死机（是的，死机也可能和我用 Win10 预览版有关），猜测是文件夹太深了，于是删掉了 Node_modules 文件夹再复制过来就好了。 然后，然后，接下来才是重点， 当我 npm install hexo &amp;&amp; hexo d -g 以后，发现根本没有 html 文件生成！！！ 查了一下才发现 hexo 本身有一大堆依赖的东西，但是仅仅 npm install hexo 一句是不会完全安装的。参考博客 于是自己把安装所有依赖的包的过程写了一个 bash 脚本，以后备份了文件夹，要是原来的文件没了，可以直接调用这个脚本。 123456789101112131415161718# setup.bash# 放在 Hexo 目录下set -xnpm install hexonpm install --save hexo-deployer-gitnpm install --save hexo-servernpm install --save hexo-generator-archivenpm install --save hexo-generator-categorynpm install --save hexo-generator-indexnpm install --save hexo-generator-searchnpm install --save hexo-generator-tag# npm install --save hexo-helper-post-topnpm install --save hexo-helper-qrcodenpm install --save hexo-inject# npm install --save hexo-mathnpm install --save hexo-renderer-ejsnpm install --save hexo-renderer-markednpm install --save hexo-renderer-stylus 但是，当我切换到另一个 indigo 主题的时候，它的 toc 我怎么也用不了。可能是上面这一步出了问题。建议按照下面的备份方法以后，重建 Hexo 目录使用官方建立新博客的方法，然后再把配置文件、博客文件复制过去。 那么，备份又怎么办呢？ 干脆写个批处理脚本，再弄进任务计划，每周执行一次。 由于批处理的语法都是现查，Windows自带的帮助还写的很烂，整个过程可能花了一两个小时。 12345678910111213141516171819202122:: backup.bat:: 放在 Hexo 目录下@echo offtitle Backup lyh543.github.ioset sourceDirectory&#x3D;C:\\Users\\lyh\\Documents\\Git\\lyh543.github.ioset destinationDirectory&#x3D;C:\\Users\\lyh\\OneDrive\\Documents\\lyh543.github.io.backupdel &#x2F;f &#x2F;s &#x2F;q %destinationDirectory% &gt;nulrd &#x2F;s &#x2F;q %destinationDirectory% &gt;nulmd %destinationDirectory%\\echo .deploy_git\\ &gt;xcopy_exlude_files.txtecho public &gt;&gt;xcopy_exlude_files.txtecho node_modules &gt;&gt;xcopy_exlude_files.txtecho.xcopy &#x2F;s &#x2F;i %sourceDirectory% %destinationDirectory%\\ &#x2F;EXCLUDE:xcopy_exlude_files.txtecho.del &#x2F;q xcopy_exlude_files.txt %destinationDirectory%\\xcopy_exlude_files.txt &gt;nulpause 加入任务计划的方法就自行百度吧。 2019.11.5 更新 这样还是很蠢啊。最好的办法就是基于 Git 本身，将整个项目 push 到 Github。 可以选择 push 到同一个库的另一个 branch，坏处是必须要公开所有文件。 我采用的方法是全部 push 到另一个私有 Github 库。 具体实现就不多说了，这些是 Git 基础。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.lyh543.cn/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"}]},{"title":"C++ 面向对象编程 概述","date":"2019-09-16T16:00:00.000Z","path":"cpp/cpp-grammar/cpp-oop-summerize/","text":"C++面向对象编程 这一分类只是学校课程的笔记，C++语法 分类中也会有不少的 C++ 面向对象的知识。 C++ = C + 面向对象（对象和类） + … 面向过程的缺点大型程序中，有很多全局数据和全局函数，这导致了函数和数据之间数目巨大的潜在连接。若全局数据有所改动，可能会导致所有访问这个数据内的全部函数的重写，程序维护困难。 面向对象语言特点抽象、封装、继承、多态。 抽象抽象描述了一个对象的基本特征,可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边。可以理解为抽象关注接口，即可观察到的行为；而封装则关注这些行为的实现。 抽象的过程： 注意问题描述、实质；以及其实现过程或细节 数据抽象：共有状态或属性 行为抽象：共有行为特征、功能 封装是对ADT的具体实现、形成接口与实现的分离、信息隐藏。 12345678class classname&#123; public: //public members //friend function private: //private members&#125;; 继承是某类（派生类）对象可以继承另外一类对象（基类）的特征和功能，依靠复制基类的数据和函数。 多态： 123F(动物 *P）&#123; p-&gt;run(); &#125;//F即为多态函数，当传递狗对象给p时，执行狗.run()//传递猫对象给p时，执行猫.run()……","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"A*（坑）","date":"2019-09-16T16:00:00.000Z","path":"cpp/acm/Astar/","text":"一种搜索算法的优化（最优性剪枝），引入估值函数，同时考虑 f(n) 和 g(n) 来进行搜索（蜜汁复杂度）。 A* 的主体是 BFS（包括Dijkstra）， 估值函数 h(x) 和最短路 d(x)（坑）h(x) &lt; d(x)h(x) == d(x)h(x) &gt; d(x) K短路给一张有向带权图，求 1 到 n 的第 k 短路。跑 Dijktra，即使每个点只跑 k 遍，也会炸掉。于是发明估值函数， f(i)=1到i的目前算的距离+i到n的最短距离 然后以估值函数作为优先队列排序的依据即可。 h(x) = d(x) 代码？挂了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define ll long long//#define DEBUGusing namespace std;const ll maxn = 10005, maxm = 500005, maxd = 0x7fffffff;struct edge &#123; ll b; ll d;&#125;;list&lt;edge&gt; gg[maxn], gf[maxn];//ll f[maxn]; // s 到 i 已经经过的距离ll g[maxn]; // x 到 t 的最短距离ll vf[maxn] = &#123; 0 &#125;; //经过i点的次数, 经过k次就不再入队ll vg[maxn] = &#123; 0 &#125;;struct cmpf &#123; bool operator ()(edge a, edge b) &#123; return a.d + g[a.b] &gt; b.d + g[b.b]; &#125;&#125;;struct cmpg &#123; bool operator ()(ll a, ll b) &#123; return g[a] &gt; g[b]; &#125;&#125;;priority_queue&lt;ll, vector&lt;ll&gt;, cmpg&gt; qg;priority_queue&lt;edge, vector&lt;edge&gt;, cmpf&gt; qf;ll ans[maxn];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); ll n, m, k = 1, s, t = 2; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 0; i &lt; m; i++) &#123; int _a, _b, _d; cin &gt;&gt; _a &gt;&gt; _b &gt;&gt; _d; //不知道要不要算已经到t还往回走的路，现在是没算的 //if (_a != t) gf[_a].push_back(&#123; _b,_d &#125;); gg[_b].push_back(&#123; _a, _d &#125;); &#125; for (int i = 1; i &lt;= n; i++) &#123; ans[i] = g[i] = maxd; &#125; g[t] = 0; qg.push(t); while (!qg.empty()) &#123; ll cur = qg.top(); qg.pop(); if (vg[cur]) continue; vg[cur] = 1; for (auto iter = gg[cur].begin(); iter != gg[cur].end(); iter++) &#123; if (!vg[iter-&gt;b] &amp;&amp; iter-&gt;d + g[cur] &lt; g[iter-&gt;b]) &#123; g[iter-&gt;b] = iter-&gt;d + g[cur]; qg.push(iter-&gt;b); &#125; &#125; &#125; //f[s] = 0; qf.push(&#123; s,0 &#125;); while (!qf.empty()) &#123; edge cur = qf.top(); qf.pop(); if (vf[cur.b] &gt;= 1) &#123; continue; &#125; ans[cur.b] = cur.d; vf[cur.b]++; for (auto iter = gf[cur.b].begin(); iter != gf[cur.b].end(); iter++) &#123; if (vf[iter-&gt;b] &lt;= k)// &amp;&amp; iter-&gt;d + f[cur] &lt; f[iter-&gt;b]) &#123; //f[iter-&gt;b] = iter-&gt;d + f[cur.b]; qf.push(&#123; iter-&gt;b , iter-&gt;d + cur.d &#125;); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; \" \"; &#125;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"https://blog.lyh543.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.lyh543.cn/tags/%E6%90%9C%E7%B4%A2/"},{"name":"坑","slug":"坑","permalink":"https://blog.lyh543.cn/tags/%E5%9D%91/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"}]},{"title":"Hexo 使用 Gitalk 评论","date":"2019-09-16T16:00:00.000Z","path":"blog/gitalk/","text":"2019.10.29 更新：由于 Gitalk 对 GitHub 之外的网站支持不好（在 github.io 以外的域名下都不能进行评论），现已迁移至 Valine。Valine 的博客推送做的不是很好，不过有第三方实现方案。可查阅 官方网站。 2019.11.6 更新：由于 GitHub OAuth API 限制，只能有一个回调网页Authorization callback URL，但是没有限制为 github.io。可在 https://github.com/settings/developers 对应的地方修改。Gitalk 真香。邮件是由 GitHub 发的，稳定性比自己邮箱发会稳定得多。 阅读 Material 主题 的主题配置文件以后，可以发现，Material 主题的配置文件是自带了评论区的功能，但是给的几个网站都不是很好用。（disqus国内用不了，changyan需要备案，gitment作者删库跑路了停更并把服务器关了）。 安装步骤在 Material 的 github 网站的 issue 下找到了关于新增 gitalk 的 pull request。 所以按照 pull request 修改、添加对应的文件就可以了。 注意在本地不应该修改_config.template.yml，而应该直接修改主题配置文件_config.yml。其他 Hexo 主题的添加方式同理。 其中_config.yml的内容需要到 Github New OAuth Application注册申请。申请需要填的东西有： 标题 内容 Application name 随便写，建议填你的网站名&lt;username&gt;.github.io Homepage URL 博客域名https://&lt;username&gt;.github.io/ Application description 随意，可不填 Authorization callback URL 博客域名https://&lt;username&gt;.github.io/ register 以后会得到一个Client ID和Client Secret。需要分别填进主题配置文件。 主题配置文件需要作如下修改： 12345678910comment: use: gitalk gitment_client_secret: valine_leancloud_appId: valine_leancloud_appKey: gitalk_owner: # 你的github用户名，如lyh543 gitalk_repo: # 你的github仓库名，如lyh543.github.io gitalk_client_id: # 刚才获取的 Client ID gitalk_client_secret : # 刚才获取的 Client secret lable 过长的 bug配置好并 hexo d -g 以后，打开一篇文章，发现“未找到相关的 issues 进行评论”。使用 Github 登录以后，就会显示 Error: Validation Failed。 去 Gitalk 的 Issues 下还真找到了这个 Issue, 还是被置顶了的。 看样子 bug 是因为 Gitalk 是默认用文章标题作 issue 的 lable，并以此作为该评论区的唯一识别码。Github 限制了 issue 的 lable 长度不超过 50，如果使用中文，在链接中一个中文等于三个字符，导致 label 过长，无法正常生成评论。 该 Issues 下有一条评论给出了一个方案，使用标题的 Hash 值的前 50 位作为 label。 我尝试以后发现仍然不行，不懂 JavaScript 的我猜测是 JavaScript 的函数名引用错了。经 Google 以后，找到了一个可用的 JavaScript。 无法自动为博客初始化 issue 的 bug还有一个问题，他不会为每一篇博客自动生成 issue，也就是初始化评论。 解决方案有不少，但是感觉挺麻烦的，做的话有点力不从心。在这里抛几个链接吧： （ruby脚本，Gitalk 官方）评论初始化（Nodejs）自动初始化Gitalk评论（ruby脚本）自动初始化 Gitalk 和 Gitment 评论 大概就这样结帖了。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.lyh543.cn/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"}]},{"title":"数学建模实验","date":"2019-09-16T12:25:23.000Z","path":"mcm/mcm-experiment/","text":"上课对象：大一、大二 时间安排：十月中下旬——明年上半年（两个学期——周末班课程） 内容典型模型： 最优化模型 微分模型（ODE） 差分模型 插值问题与方法 拟合问题和方法 随机系统模型 数据建模（回归分析） 图论 PDE 遗传算法 分数构成平时成绩（表现：调研报告、实验作业）：60% 组队 2-3 人期末成绩：40% 在线测试，独立完成（程序设计基础） 作业建立专题研究组 整理建模案例库（平时成绩） 离散组——差分模型、图论模型（图论建模） 连续组——常微分模型、偏微分模型 预测组——预测模型（拟合、回归分析、神经网络） 机器学习与大数据——常规机器学习、聚类算法、分类算法、神经网络、深度学习等 仿真组——计算机模拟、随机系统模拟、蒙特卡洛模拟 算法组——智能算法（遗传算法、模拟退火、粒子群算法等）、DFS、树、图（复杂一点的算法） 实验项目讨论组（实验作业）综合实验：复现论文模型实验。（最多 1 个）","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数学建模","slug":"数学建模","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"Excel 公式","date":"2019-09-13T16:00:00.000Z","path":"microsoft/excel/excel-equation/","text":"Office链接 统计计算求和：=SUM(D38:D41) 平均数：=AVERAGE(D38:D41)中位数：=MEDIUM(D38:D41) 众数：=MODE(D38:D41)最大值：=MAX(D38:D41)最小值：=MIN(D38:D41) 部分统计对开启筛选后的部分表格进行统计，可以用 SUBTOTAL() 函数，第一个参数为上述常用函数的标号。 矩阵计算用 Excel 求逆矩阵 选定目标矩阵区域 输入 =MINVERSE(A1:C3) （矩阵区域） 按 Ctrl+Shift+Enter 以进行数组赋值 时间今天：=TODAY()现在：=NOW() 分支 ifIF语句：=IF(F3=233,&quot;&quot;对啦,&quot;错了额&quot;) 检测错误输入 ERR 即可查到以下公式： 公式|ERROR.TYPE()|IFERROR()|ISERR()|ISERROR()-|-|-|-|-|-返回|整数值|和 IF() 语句的结合|返回布尔值|返回布尔值 逻辑运算符、布尔函数 中文 等于 不等于 符号 = &lt;&gt; TRUE 和 FALSE 在数学运算中被视为 1 和 0。 逻辑运算函数有 NOT()，AND()，OR()，NAND()，NOR()，XOR()。 寻找FIND() 和 FINDB()，是单个单元格对单个单元格的字符串意义上的匹配。配合 ERROR 系统使用。 也可以使用 VLOOKUP()，不过是多单元格对单个单元格的内容和格式匹配。格式不同匹配不上，用的我心态爆炸","tags":[{"name":"Excel","slug":"Excel","permalink":"https://blog.lyh543.cn/tags/Excel/"}]},{"title":"统计陷阱 《How to Lie With Statistics》","date":"2019-09-11T01:37:09.000Z","path":"others/how-to-lie-with-statistics/","text":"pdf","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"C++ 面向对象——类与对象","date":"2019-09-09T23:55:13.000Z","path":"cpp/cpp-grammar/cpp-class-and-object/","text":"类的定义类（Class）其实和 C++ 结构体差不多。 1234567891011121314151617class ClassName&#123; public: //公有成员 void setTime(int h, int m, int s); void showTime()&#123;...&#125; //在类内部实现成员函数 protected: //保护型成员 private: //私有成员 int h, m, s;&#125;void ClassName::setTime(int h, int m, int s)&#123; ...&#125; //在类外部实现成员函数 public，protected，private 叫做段约束符。private 和 protected 只允许类的内部成员访问。protect 和 private 在派生的地方不同。不写段约束符时，成员默认是 private 的。 三个段约束符的顺序可换；可以把公开成员分开写，需要用多个 public 约束。 :: 叫做作用域分辨符。 类成员的定义、使用和 struct 完全一样。.，-&gt;。略。 对了，以类声明的变量叫做 对象（Object）。 静态数据成员12345678class ClassName&#123; public: static int s_value; //声明 static const int cs_value = 10; //常量：声明+定义 int value;&#125;int ClassName s_value = 10; //定义 ClassName 的对象各自有成员 value，但他们共同拥有成员 s_value。 对于非常量的静态成员，必须在类内声明，类外定义（常量定义可以写在里面或外面）。 静态成员函数见后。 const 数据成员const 数据一般是不可以被修改的，理应每个类的成员的值都一样，是可以共用以节省空间的。实际呢？ 如果把一个数据设为 const ，他会自动变为 static 吗？ 12345678910class Test&#123;public: const int c = 10;&#125;A, B;int main()&#123; std::cout &lt;&lt; &amp;A.c &lt;&lt; \" \" &lt;&lt; &amp;B.c;&#125; 输出 00007FF64CC64034 00007FF64CC64038。显然是没有共用的，必须加 static 才可以共用内存。 类类型本身、指针、引用作为函数参数123void setTime(ClassName o); //类对象作为参数，会有拷贝构造函数void setTime(ClassName * po); //对象指针作为参数void setTime(ClassName &amp; ro); //对象引用作为参数 类的成员函数这部分简单，不多说。 构造函数在声明一个对象，或 new 一个对象的时候，会触发构造函数。 （注意 malloc 不会） 已经有的对象可以通过新建一个对象，然后赋值过去。 12CString A;A = CString(); 一般构造函数123456789class CString&#123; //... public: CString()&#123;...&#125;; //该函数即为构造函数&#125;CString aStr; //调用构造函数aStr.CString(); //也会调用构造函数 重载构造函数1234567891011121314151617181920class CString&#123; //... public: CString()&#123;&#125; CString(int n) &#123; if (n &gt; 0) &#123;size = n; buf = new char[n]&#125;; &#125; CString(const char * str) &#123; size = strlen(str) + 1; buf = new char[size]; strcpy(buf, str); &#125;&#125;CString str1; //调用 CString()CString str2(2); //调用 CString(int)CString str3(\"3\"); //调用 CString(const char *) 定义函数要 {}，就不用打 ; 了，声明函数要打 ;。这不是 C 语言基础吗 拷贝构造函数当使用 CString str2 = str1; 时，编译器实际上调用了默认的 CString(CString &amp;) 拷贝构造函数，把 str1 的内容通过位拷贝，复制给了 str2。 同时，拷贝构造函数也是将 const CString &amp; 强转为 CString 的方法。 如果我们不想这么做，而是手动复制部分数据，可以使用： 123456class CString&#123; //... public: CString(CString &amp;)&#125;&#123;...&#125;;&#125; 注意 CString str2 = str1; 和 CString str2; str2 = str1; 是有区别的！！！ 函数类型 函数原型 调用场景 强制转换 int () int(A); 和 int i = A;（隐式） 拷贝构造函数 CString(const CString &amp;) CString B = A; 和 return A; 赋值函数 CString&amp; operator = (const CString &amp;) Cstring B; B = A; 二者是不同的。 所以，重载拷贝构造函数的时候，要思考是否同时需要重载赋值函数。 类到其他类型的强制转换既然提了把其他结构转为这个类的方法，那就顺便说说把这个类转为其他的结构吧。 把 int 当作一个一元操作符可还行。 12345678910class teamS &#123;private: int s; //solved int p; //penaltypublic: operator int() &#123; return s * 100 - p; &#125;&#125;; 析构函数函数结束后，函数中声明的对象的内存会被释放，但对象申请的动态内存不会。因此需要一个析构函数，这样，声明对象的函数运行完以后，即会执行析构函数，然后再释放对象的内存，最后退出函数。 123456789class CString&#123; //... public: ~CString() //该函数即为构造函数 &#123; if(buf) delete []buf; &#125;;&#125; 以下场景会触发对象的析构函数： 声明对象的函数运行结束； 指向对象的指针被 delete 时。(free 不会） 这样以后，程序猿就不用再考虑什么时候对象不再使用，得释放内存了。 this 指针在调用成员函数的时候，我们发现如果使用其他对象的成员需要加 对象-&gt;，而使用自己的成员却不需要。而调用不同对象的同一个成员时，编译器不会弄混用的是谁的成员。这是因为：编译器对成员函数隐含加上了 this 形参。 因此调用某对象的成员函数时，使用该对象的成员不需要加对象名和 -&gt;（也可以加 this-&gt;）。 需要返回该对象（或该对象的引用）时，使用 *this 即可。 静态成员函数静态成员函数与众不同的地方在于，它没有 this 参数。声明仅仅是在返回类型前加了一个 static。 123456class CString&#123; int maxn; public: static int maxlength()&#123;return maxn;&#125;&#125; 友元函数 友元类对于某些需要封装过的数据的函数，调用这些数据不大容易。因此，产生了友元的机制。 友元函数是让类外的函数可以访问到类的 private 成员；友元类是让类下的所有函数可以访问前一个类里的 private 成员。 注意友元函数是类外的函数，因此没有 *this 参数，且不用 ClassName:: 作用域符。（不过定义部分还是可以写在声明后面） 1234567891011121314class Y; //前向声明class X&#123; //... friend operator &gt;&gt; (istream &amp; in, X &amp; x); friend class Y; //类 Y 是 X 的友元&#125;operator &gt;&gt; (istream &amp; in, X &amp; x)&#123; /*...*/ &#125;class Y&#123; //Y 的成员函数可随意调用 X 的 private 成员&#125; 友元类没有对称性、传递性。 友元函数虽然方便，但是破坏了 OOP 的封装性，不能滥用。 类的组合一句话，就是一个类的某个成员是另一个类的对象。 注意构造函数和析构函数一般需要调用包含的类的构造和析构函数，否则无法修改前一个类的 private 成员。具体语法如下： 123456789101112131415class Point&#123; int x, y; public : Point(int _x, int _y)&#123;x = _x; y = _y;&#125; /*...*/&#125;class Circle&#123; Point center; int radius; Circle(int _x, int _y, int _radius) : Point(_x, _y) &#123; radius = _radius; &#125;&#125; const 对象、函数一句话，const 对象不能被非 const 的成员函数调用。 12345const CString str; //常对象int CString::size() const &#123; /*...*/&#125;; //常函数","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"gdb 简易调试","date":"2019-09-04T03:05:31.000Z","path":"cpp/cpp-grammar/gdb/","text":"虽然还是喜欢用 Visual Studio 设置编译选项：-g启动与推出：r(run)，q(quit)设置断点：break（设断点），info（info breakpoint 展示断点），del，enable，disable，watch（跟踪某值）控制程序执行：next，step（下一行），continue，finist，set，call查看程序状态：list（展示代码），backtrace，p(print) &lt;variable&gt;（打印此时变量值），break，``执行上一条指令：（回车）","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"C++ I/O 输入输出","date":"2019-09-04T02:34:08.000Z","path":"cpp/cpp-grammar/cpp-io/","text":"C 语言风格 I/O 请见C I/O。 流：从某种 IO 设备上读入或写出的字符序列。 标准库中的 IO 对象，除了 cin、cout，还有： cerr：用来输出警告、错误给程序的使用者（可以理解为第二块屏幕） clog：用于产生 log。 cin, cout123int ch;cin &gt;&gt; ch; //ignore endline when readingcout &lt;&lt; endl; istream::getline()getline() 会吃掉回车。 下面这种方法只能用于读 char *。 12char word[50];cin.getline(word, 50); //ignore endline when storing 而下面这种方法，把 cin 作为参数则只能用于读取 string。 12string str;getline(cin,str); 需要注意，cin.getline 是属于 iostream 的，而 getline(cin,str) 是属于 string 的。 istream::get()get() 有两个重载函数： 读一个字符 读一个字符串。 如果无参数，则是读字符，类似于 getchar()： 1ch = cin.get(); 上面两个都是读取一个字符，若可用则返回它，不可用时会对 cin 设置 failbit 和 eofbit。 如果带参数，可以读 char `char *‘。 12char str1[n];cin.get(str1, n, '\\n') 这是读一个字符串，并且可以指定分隔符（最后分隔符会被吃掉）。 错误示范1123int a; char s[10];cin &gt;&gt; a;cin.getline(s); istream&amp; operator&gt;&gt; 不会吃掉最后的空格！！！ 紧接在读取数字等类型的 cin 语句后，getline 会读取其前一条语句留在输入法中的 &quot;\\n&quot;而结束。 1cin &gt;&gt; a &gt;&gt; s; 而上面这个方法则没有问题。 cin会过滤空白字符，而cin.getline()不会。 错误示范2123int a, b, c;cin &gt;&gt; a &gt;&gt; b;cin &gt;&gt; c; 输入”1a2”时，当’a’不能输入到b时，输入流将关闭。需要cout.flush() 设置输出格式1234567#include&lt;iomanip&gt;cout &lt;&lt; fixed; //一定先 cout &lt;&lt;fixed, 某 OJ 上不写会出错cout &lt;&lt; setprecision(n); //设置有效位数，四舍五入cout &lt;&lt; setw(n); //设置对齐位数cout &lt;&lt; setiosflags(ios::left); //设置对齐方向resetiosflags(ios::left);cout &lt;&lt; hex &lt;&lt; setiosflags(ios::showbase) &lt;&lt; 17 &lt;&lt; 18; //hex十六进制，oct八进制，dec十进制 二进制输出函数|作用basic_istream&amp; read(char_type* s, std::streamsize count)|以二进制形式输入（不看是不是字符，直接莽输入）basic_ostream&amp; write(const char_type* s, std::streamsize count)|以二进制形式输出（失败时调用 setstate(badbit)） 从文件输入、输出1234567int i;ofstream output;ifstream input;output.open(\"output.txt\");input.open(\"input.txt\");input &gt;&gt; i;output &lt;&lt; i; fstream 的成员函数 函数 作用 void open(filename, mode) 打开文件，详见 open() bool is_open() const 判断是否打开 void close() 关闭文件 get() 读取一个字符或一行，详见 get() getline() 读取一行（不读回车），详见 getline() basic_istream&amp; read(str, std::streamsize count) 以二进制形式输入（不看是不是字符，直接莽输入） basic_ostream&amp; write(str, std::streamsize count) 以二进制形式输出（失败时调用 setstate(badbit) bool eof() 判断文件是否结束 open()12void fstream::open(const char * filename, ios_base::openmode mode)void fstream::open(const std::string &amp; filename, ios_base::openmode mode) 其中 mode 是位掩码类型（即可以用 | 进行叠加）： 常量 解释 app 每次写入前寻位到流结尾（输出补充在文末） binary 以二进制模式打开 in 为读打开 out 为写打开 trunc 在打开时舍弃流的内容（若存在文件则覆盖） ate 打开后立即寻位到流结尾（初始位置：文件末） mode 的默认参数：fstream：ios_base::in | ios_base::outifstream：ios_base::in | ios_base::truncofstream：ios_base::out 文件指针位置相关操作以下 p 代表 put，对输出流操作；g 代表 get，对输入流操作。 文件指针实际上就是一个标记字节的数字，起始为 0。 用成员函数 tellg()/tellp() 获取当前位置，返回 streampos（实际上是一个整型，在 VS 2017 x86/x64 上范围和 signed long long 相同）。 修改的成员函数有绝对和相对的。下仅以 seekp() 作示范，seekg() 用法相同。 12istream&amp; seekg (streampos pos); //(1)istream&amp; seekg (streamoff off, ios_base::seekdir way); //(2) (1) 修改到绝对指针，(2) 修改到相对指针，off (offset) 为位移量（可以为负），way 为位移的正负（way &gt; 0 时往流的末尾，way == 0 时往流的开头，建议用 true/false，但既然 off 可以为负，感觉就很鸡肋了）。 string 和 iostream 的关系参见这篇博客。 重载 iostream 参考博客: http://blog.csdn.net/caroline_wendy/article/details/15336063 1. 输出操作符(ostream)重载1std::ostream &amp;operator&lt;&lt; (std::ostream&amp; os, const ClassA&amp; ca); ostream需要修改，不能复制，所以应该为**非常量引用类型(nonconst &amp;)；输出类不需要修改, 应该为常量引用类型(const &amp;)**； 函数有可能使用内部的私有成员，需要定义为**友元(friend)**； 重载操作符应该为非类成员函数(nonmember function)。如果为类成员函数，则也必须为标准库成员函数，显然无法完成。 注意函数不要有格式信息(minimal formatting)，为了和标准输入操作符进行统一。 2. 输入操作符(istream)重载1std::istream &amp;operator&gt;&gt; (std::istream&amp; is, ClassA&amp; ca); 基本同输出操作符； 参数都为 non-const（都需要修改)； 操作符函数应该包括错误恢复(error recovery)，保证输入错误时，不会产生未知错误； 可以增加 I/O 条件状态(condition state)进行判断，输入错误原因。 刷新输入缓冲区在读 int 的时候如果读到了非数字字符，输入流就会被关闭（输入流会变成错误状态），无法继续读入。 解决的办法就是重新打开输入流（将错误状态更改为有效状态），顺便可能需要忽略掉一些字符。 cin.clear() 是将错误状态更改为有效状态cin.sync() 是清除缓冲区中的未读信息cin.ignore() 是忽略缓冲区中指定个数的字符，还可以指定忽略的结束符 也就是说，当我们想要刷新输入流并忽略掉已经在缓冲区的字符时，我们可以使用以下方法： 12cin.clear();cin.sync(); 但是，在 Visual Studio 2019 上，他貌似并没有清楚缓冲区的未读信息。 在 Stack Overflow 上提到了这么一句， cin.sync discards all unread characters from the input buffer. However, it is not guaranteed to do so in each implementation. Therefore, ignore is a better choice if you want consistency. 大意是， cin.sync 在各个平台上实现的方法可能不一样，比如这里在 Visual Studio 2019 上就不能用 sync 来清楚缓冲区的未读信息。可以改为如下： 12cin.clear();cin.ignore(10000, '\\n'); 这样可以忽略掉缓冲区的一行字符。 注意 ignore 还可以忽略还没有输入的字符，如以下程序： 1234char ch;cin.igore(10);while (cin &gt;&gt; ch) cout &lt;&lt; ch; 运行程序，输入 qwertyuiopasdf，会输出 asdf。 命令行程序控制输入命令行防止错误的输入真是令人头疼的问题了。一般有两个方案： 只使用 cin.getline() 读入，一行一行的读 读错了以后马上刷新，按上面一个标题的办法","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"尾递归优化","date":"2019-09-03T03:19:49.000Z","path":"computer-science/tail-call-optimization/","text":"递归函数都会面临到栈溢出的问题，不过有些递归是可以改写为循环的形式。 这类递归有一个特点：总是在最后一步进行递归。 下面的 Python 代码不是一个尾递归函数： 1234def fact(n): if n == 1: return 1 return n * fact(n-1) 因为在递归 fact() 函数以后，又执行了 n*结果，。 要改写成尾递归，可以这么写： 1234def fact(n, ans = 1): if n == 1l return ans return fact(n-1, ans * n) 但这么写已经能改写为普通循环了。 部分语言可以直接将尾递归优化为循环版本，但是大部分语言都没有作尾递归优化。Python 也没有。","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"C++：what's plus","date":"2019-09-02T08:58:17.000Z","path":"cpp/cpp-grammar/cpp-whats-plus/","text":"除了面向对象，C++ 和 C 有什么区别呢？ C++ 不兼容 C 的地方C 可以用非 const 指针指向 const 变量，从而间接修改 const 变量。而 C++ 不允许。 C++ 新增的东西 几种数据类型：逻辑类型（C 中是用 # define true 1)、引用类型、类类型。 使用 new 和 delete 进行内存释放 函数重载 默认形参 内联函数（inline） 引用相关知识","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"C++ 面向对象编程 课程相关","date":"2019-09-02T07:29:42.000Z","path":"cpp/cpp-grammar/cpp-oop-course/","text":"笔记链接： C++ 面向对象编程 概述 C++：What’s Plus C++ 面向对象——类与对象 C++ 面向对象——继承、派生和多态 C++ 模板 C++ 名称空间 C++ 异常处理 预习：http://icc.hep.com.cn 该课程的资料在 https://github.com/misterfishing/cpp 上。 实验：🐎图一堆 实验内容：一个大实验——精灵游戏（增强版，参见第六章） 考核形式： 平时成绩（60%）：课前预习（20%） + 课后作业（20%） + 实验成绩（20%）期末测试（40%）：上机测试，闭卷","tags":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"const、volatile 和 constexpr","date":"2019-09-01T16:00:00.000Z","path":"cpp/cpp-grammar/cpp-const-volatile-and-constexpr/","text":"cv 限定符cv（const 与 volatile）类型限定符 | cppreference.com cv 限定符是 const 和 volatile 的合称。 当对象最初被创建时，所用的 cv 限定符决定对象的常量性或易变性。 const 大家都懂，就是不能修改的常量 (constant)，直接修改会编译报错，间接修改（如利用 const_cast&lt;int&amp;&gt; 等手段）为未定义行为。还有一点，就是写为 const 之后，编译器会进行优化。 而 volatile 翻译过来是“易变”的，表明该变量可能通过软件甚至硬件方式变化。这会阻止编译器对这个变量进行任何优化，包括但不限于：不会将变量放到寄存器中；不会对 const volatile 变量当做 const 进行优化。（不过，CPU 仍可以将变量放入缓存中，因为缓存对程序员是透明的） 代码例子见 const_cast 部分。 C99 的 const12const int n = 10;int a[n]; 上面的代码不能通过 C99 标准的 C 编译器（以及 C++ 编译器）。因为 C99 对 const 的定义为只读的变量（而不是常量）。 const 和 constexprC: #define ll long longC++: ‘const int k=5;’ const中可以有变量名，但constexpr的表达式中不能有变量（可以有常量），因为： constexpr 在编译时进行初始化，const 在运行时初始化！ 底层const 和顶层 const不是很懂，感觉没用","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"指针 pointer & 引用 reference","date":"2019-09-01T16:00:00.000Z","path":"cpp/cpp-grammar/pointer-reference/","text":"指针和变量的存储方式每个指针指向的是第一个字节，但是数是倒着存的（第一个字节是最低位）。如存一个int i=1024，再从第二个字节开始读，结果是4（当然先要清掉周围的内存）。 测试代码及输出： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int i[10] = &#123; 0,1024&#125;, *pi = &amp;i[1]; cout &lt;&lt; pi &lt;&lt; \" \" &lt;&lt; *pi &lt;&lt; endl; pi = (int*)(int(pi) + 1); cout &lt;&lt; pi &lt;&lt; \" \" &lt;&lt; *pi;&#125;/*输出：00C3FD04 102400C3FD05 4*/ 指针和 const pointer and const const 先向前看，没有就再向后看？ 函数指针12345678//正确用法：int (*f)(int,char); // f是指向“具有两个参数，返回 int 的函数”的指针int (*f)(void);int (*f) (ostream&amp;, const vector&lt;string&gt;&amp;); //例三//错误用法：int *f(int) // f是一个函数，返回一个“指向 int 的指针”int *f(void) // 参数是 void 也得写 使用时直接 f(x) 即可。f 又被称为回调函数(callback function)。 例三的 f 的变量类型为 int (*) (ostream&amp;, const vector&lt;string&gt;&amp;)。 C++ 11 中 NULL，0，nullptr 等价。 函数指针和 typedef 组合在一起就很怪： 12345678typedef char (*PTRFUN)(int);PTRFUN pFun;char glFun(int a)&#123; return;&#125;void main()&#123; pFun = glFun; (*pFun)(2);&#125; 别名 PTRFUN 居然是写到括号里面了。 void * 指针void * 指针只表示与它相关的值是个内存地址，但该内存的数据类型是未知的。它是能够接受任何数据类型的特殊指针。void * 最重要的用途是作为函数的参数，向函数传递一个类型可变的对象。另一种用途就是从函数返回一个无类型的对象。在使用void * 指针之前，必须显式地将它转换成某种数据类型的指针后使用，其他操作都不允许。（可以使用，不能赋值） 12345678 int i=4,*pi=&amp;i; void* pv; double d=9,*pd=&amp;d; pv=&amp;i; //L1：正确 pv=pi; //L2：正确cout&lt;&lt;*pv&lt;&lt;endl; //L3：错误 pv=pd; //L4：正确 cout&lt;&lt;*(double*)pv; //L5：正确，输出9 begin 和 end (C++11)头文件的两个函数，用于确定指向数组首元素和尾元素后一位置的指针，方便遍历数组。 12345int a[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;for (int *p = begin(a); p != end(a); p++)&#123; //...&#125; 对于容器的用法有： 12345678910stack&lt;int&gt; s;for (auto &amp;i : s)&#123; //i&#125;for (auto iter = s.begin(); iter != end; iter++)&#123; //*iter&#125; 动态内存malloc &amp; free from C12345678#include &lt;cstdlib&gt;int main()&#123;int * a;a = (int*)malloc(sizeof(int));*a = 3;free(a);&#125; new &amp; delete (C++)new 用于从内存中分配指定大小的内存用法 1：p=new type;用法 2：p=new type(x);用法 3：p=new type[n];delete 用于释放 new 分配的堆内存用法 1：delete p;用法 2：delete [ ]p; 注意对 int 数组，delete p 和 delete [] p 效果一样。但若把 int 换成自定义的类型，则 delete p 只释放第一个元素的内存，delete [] p 才释放全部内存，因为 **delete 后就会走析构函数，基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是可以的；但是对于类对象数组，只能用 delete[]**。总之保证 new delete 的 [] 的配套使用。 new/delete 与 malloc/free的区别 new 能够自动计算要分配的内存类型的大小，不必用 sizeof 计算所要分配的内存字节数 new 不需要进行类型转换，它能够自动返回正确的指针类型。 new 可以对分配的内存进行初始化。 new 和delete 可以被重载，程序员可以借此扩展new和delete的功能，建立自定义的存储分配系统。 智能指针自动回收所指对象，无需调用delete回收。 需要包含头文件 memory auto_ptr ：动态分配对象以及当对象不再需要时自动执行清理，构造时获取对某个对象的所有权，在析构时释放该对象，两个指针不能同时拥有同一个对象； 1234567891011int*p = new int(0);auto_ptr&lt;int&gt; ap(p);auto_ptr&lt;int&gt;ap2(new int(10));*p = 5;cout &lt;&lt; *p &lt;&lt; \" \" &lt;&lt; *ap &lt;&lt; endl;auto_ptr&lt;string&gt; p1(new string(\"There is only one point to me.\"));auto_ptr&lt;string&gt; p2;p2 = p1; //L1，p1不再指向任何对象，其所指对象由p2指向cout &lt;&lt; *p1; //L2，发生运行错误，因为p1没有指向任何对象。 shared_ptr：作用有如同指针，但会记录有多少个shared_ptrs共同指向一个对象。最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。 unique_ptr：它持有对对象的独有权——两个unique_ptr不能指向一个对象，不能进行复制操作只能进行移动操作 引用分为： 左值引用：int &amp; a = b; 右值引用：int &amp;&amp; a = 3+1; 引用不是值，不占用存储空间，引用的地址就是其所引用的变量的地址 引用必须被初始化，且不可重新赋值 可以建立数组或数组元素的引用，但不能建立引用数组 12345int i = 0, a[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;, *b[10];int (&amp;ra)[10] = a; //L1：正确，ra是具有10元素的整型数组的引用int *(&amp;rpa)[] = b; //L2: 错误！！！！int *(&amp;rpa)[10] = b; //L3：正确，rpa是具有10个整型指针的数组的引用int &amp;ia[10]=a; //L4：错误，ia是引用数组，每个数组元素都是引用 注意数组引用要注明长度！！！！！ 由 int *(&amp;rpa) 可以看出，指针的* 是连着 int 的，引用的 &amp; 是连着 变量名 的。 函数和引用参见这篇引用的博客。 右值引用右值引用是C++11为了支持移动操作而引入的新型引用类型，其重要特点就是只能绑定到即将（瞬间）销毁的对象上，比如常量或表达式。通过右值引用可以方便地将它引用的资源“移动”到另一个对象上。 右值引用存的是表达式的值（表达式中变量变化不改变其值） double &amp;&amp; rr = r; 是错的。 const 和引用const 引用其实和右值引用差不多，变量修改不会改变引用值了。 题外话：指针和引用谁好？C 只有指针，没有引用；Java 只有引用，没有指针；C++ 二者皆有（C++ 和 Java 的引用不同，但在此不表）。 那么，指针和引用谁好呢？","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"C++ 函数","date":"2019-09-01T16:00:00.000Z","path":"cpp/cpp-grammar/cpp-function/","text":"函数原型函数原型就是函数声明，常放在头文件里。 函数参数f(void)==f() f(int*)==f(int[])==f(int[10]) 默认参数 在声明或定义中写默认参数，声明中必须写（不然人家咋知道调用的是谁呢） 1234567double sqrt(double f=1.0);void main()&#123; cout&lt;&lt;sqrt()&lt;&lt;endl;&#125;double sqrt(double f) &#123; return f*f; &#125; 一旦某个参数开始指定默认值，它右边的所有参数都必须指定默认；一旦某个参数开始取默认值，它右边的所有参数都必须取默认； 12345int f(int i1,int i2=2,int i3=0); //正确int g(int i1,int i2=0,int i3); //错误f(3); //正确，i1=3,i2=2,i3=0f(1,,3); //错误 引用的作用域不同作用域内，允许说明不同的默认形参值。 12345678910int add(int x = 5, y = 6);int main()&#123; int add(int x = 7, y = 8); add(); // return 15&#125;int add(int x, int y)&#123; return x + y;&#125; 函数和引用传递引用 需要从函数中返回多于一个值。 需要修改实参值本身。 传递地址可以节省复制大量数据的内存空间和时间。 返回引用int &amp; index(int i){return a[i];} 有了引用，甚至能写这种骚代码： index(2) = 30; 内联函数加 inline 即可。能够节省开销。 内联函数不允许有循环和 switch 语句，否则按照普通函数来处理。 结构、类的成员函数具体见结构的博客。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"带权并查集","date":"2019-08-30T16:00:00.000Z","path":"cpp/acm/带权并查集/","text":"带权并查集是并查集的一种，每个元素除了知道和什么元素有关，还知道是什么关系。比如 A 和 C 相同，B 和 D 相反，A 和 B 相反，则可以推出 C 和 D 相同。（这好像是种类并查集，不过不影响，种类并查集的题也能用带权并查集所以就不用学种类并查集辽）。 更广义的带权并查集中有这么一个定义，每个元素除了知道和谁有关（祖先是谁）以外，还要存一个和祖先的有向距离 dist。如图。 带权并查集1 按上面的 A、B、C 的例子，A、C距离为0，B、D 距离为 1。 当我们需要合并 A、B 的时候，如图，除了按照常规的将 A 的祖先 (C) 成为 B 的祖先 (D) 的爸爸，我们还需要重新计算 D 到 C 的距离。 带权并查集2 显然，$$ \\overrightarrow{DC} = \\overrightarrow{AC} + \\overrightarrow{BA} - \\overrightarrow{BD} $$即，$$ D.dist = A.dist + BA - B.dist $$ 特别地，当元素关系是 1（相同） 或 0（不同） 的时候，+ 和 - 可以用异或 ^ 代替。 下面是一道 Lutece 上的题。这个题使用的和上面的带权并查集有点不一样当时还没学带权并查集，自己想的，它的距离定义是和当前父亲的距离，而不是和祖先的距离。对于按上面定义的带权并查集，有另外一个 Codeforces 上的题。 123456789101112131415161718192021222324252627282930313233//Lutece 2153 对答案//https://acm.uestc.edu.cn/contest/12/problem/Kconst int maxn = 10000001;struct ufset&#123; int father; int change_with_father; //和当前父亲的距离&#125;presum[maxn]; //presum[i]:1~iufset findrt(int a)&#123; if (presum[a].father == a) return &#123; a, 0 &#125;; else &#123; ufset rt = findrt(presum[a].father); presum[a].father = rt.father; presum[a].change_with_father = presum[a].change_with_father xor rt.change_with_father; return presum[a]; &#125;&#125;int merge(int a, int b, int c)&#123; int ra = findrt(a).father, rb = findrt(b).father; if (ra == rb) &#123; return (presum[a].change_with_father xor presum[b].change_with_father xor c)xor 1; &#125; else &#123; presum[ra].father = rb; presum[ra].change_with_father = c^presum[a].change_with_father^presum[b].change_with_father; return 1; &#125;&#125; 下面这个就是一个带有离散化的带权并查集的板子。原题是暑期集训时在 Codeforces 上做的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//http://codeforces.com/problemset/problem/1074/Dtypedef pair&lt;int, ll&gt; P;unordered_map&lt;int,P&gt; m; //需要离散化void init(int cur)&#123; if (m.find(cur) == m.end()) m[cur] = &#123; cur,0 &#125;;&#125;int findrt(int cur) //return father&#123; if (m[cur].first == cur) return cur; else &#123; int fa = findrt(m[cur].first); m[cur].second ^= m[m[cur].first].second; m[cur].first = m[fa].first; return m[cur].first; &#125;&#125;void merge(int l, int r, int x)&#123; init(l); init(r); int rl = findrt(l), rr = findrt(r); if (rl == rr) return; m[rl].first = rr; m[rl].second = m[l-1].second ^ m[r].second ^ x;&#125;int query(int l, int r)&#123; init(l); init(r); if (findrt(l) == findrt(r)) &#123; return m[l].second ^ m[r].second; &#125; else return -1;&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"最近公共祖先 LCA（坑）","date":"2019-08-30T16:00:00.000Z","path":"cpp/acm/最近公共祖先/","text":"倍增法倍增思路相当于层序遍历，逐层或几层跳跃查，查询时间复杂度为 O(logn) ，空间复杂度为 O(nlogn)对于每个结点先存储向上1层、2层、4层的结点，每个点有depth信息。 倍增法：构建一个 fa[i][j] 数组， i 结点向上 2^j 层的结点是谁，然后再统一下层数。先让他们同层数，然后二分搜索。后面是 log(树的长度) j 的最大值还可以优化，对于每一个深度的结点就搞一个数组存最大 j 值 log2(j) 1if(fa[u][j] == fa[v][j]) 不跳；//只跳到LCA的往下一对儿子 注意跳到根结点以上的越界情况的判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Lutece 2144 吞吐量//https://acm.uestc.edu.cn/contest/12/problem/B//B题良心样例，5组数据错了4个，修了以后就AC了#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int maxn = 100005, maxlog = 17, maxans = (int)1e9+1;struct edgeS &#123; int point; int distance;&#125;;list&lt;edgeS&gt; neigh[maxn];edgeS up[maxn][maxlog] = &#123; 0 &#125;;int depth[maxn];int dfs(int cur, int father)&#123; int i = 1; while ((1&lt;&lt;i) &lt; depth[cur]) &#123; up[cur][i] = &#123; up[up[cur][i-1].point][i-1].point, min(up[cur][i-1].distance, up[up[cur][i - 1].point][i - 1].distance) &#125;; i++; &#125; list&lt;edgeS&gt;::iterator iter; for (iter = neigh[cur].begin(); iter != neigh[cur].end(); iter++) &#123; if (iter-&gt;point != father) &#123; depth[iter-&gt;point] = depth[cur] + 1; up[iter-&gt;point][0] = &#123; cur, iter-&gt;distance &#125;; dfs(iter-&gt;point, cur); &#125; &#125; return 0;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt; n ; i++) &#123; int a, b, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; neigh[a].push_back(&#123; b, d &#125;); neigh[b].push_back(&#123; a, d &#125;); &#125; depth[1] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; maxlog; j++) up[i][j].distance = maxans; dfs(1,0); for (int i = 0; i &lt; q; i++) &#123; int a, b, ans = maxans; cin &gt;&gt; a &gt;&gt; b; if (depth[a] &gt; depth[b]) swap(a, b); // make sure b is deeper than a int diff = depth[b] - depth[a]; int j = 0; while (diff != 0) &#123; if (diff &amp; (1&lt;&lt;j)) &#123; ans = min(ans, up[b][j].distance); b = up[b][j].point; diff ^= (1 &lt;&lt; j); &#125; j++; &#125; if (a == b) &#123; cout &lt;&lt; ans &lt;&lt; endl; continue; &#125; for (int i = maxlog-1; i &gt;= 0; i--) &#123; if (up[a][i].point != up[b][i].point) // excluding overflow that are both 0 &#123; ans = min(min(ans, up[a][i].distance), up[b][i].distance); a = up[a][i].point; b = up[b][i].point; &#125; &#125; ans = min(min(ans, up[a][0].distance), up[b][0].distance); cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125;&#125; Tarjan 离线算法 转载自：https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.03.md RMQ 在线算法 LCA to RMQ tql","tags":[{"name":"图论","slug":"图论","permalink":"https://blog.lyh543.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.lyh543.cn/tags/%E6%90%9C%E7%B4%A2/"},{"name":"坑","slug":"坑","permalink":"https://blog.lyh543.cn/tags/%E5%9D%91/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Markdownlint 使用","date":"2019-08-30T16:00:00.000Z","path":"blog/markdownlint/","text":"Markdownlint 是 Visual Studio Code 的一个 Markdown 插件。 markdownlint_intro 下载链接 VS Code插件目录：%userprofile%/.vscode/extensions 如何忽略项 Rules can be enabled, disabled, and customized by creating a JSON file named .markdownlint.json or a YAML file named .markdownlint.yaml (or .markdownlint.yml) in any directory of a project. Visual Studio Code - File（工具栏） - Preference - Settings - Extensions - markdownlint - Markdownlint: config - Edit in settings.json 也可以直接到%userprofile%AppData\\Roaming\\Code\\User\\settings.json里面找到 12345678910111213141516&#123; \"workbench.colorTheme\": \"Quiet Light\", \"markdownlint.config\": &#123; \"default\": true, \"MD033\": false, \"MD014\": false, \"MD029\": false, \"MD040\": false, \"no-hard-tabs\": false &#125;, \"explorer.confirmDelete\": false, \"explorer.confirmDragAndDrop\": false, \"markdownlint.ignore\": [ \"*/markdown-grammar.md\" ]&#125;","tags":[{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"https://blog.lyh543.cn/tags/Visual-Studio-Code/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.lyh543.cn/tags/Markdown/"}]},{"title":"KMP 和 AC 自动机","date":"2019-08-30T16:00:00.000Z","path":"cpp/acm/KMP_AC自动机/","text":"xyynb! KMP这里，字符串从1开始计数！由于串是从1开始计数，可以把第一个格子设为$，避免越界。 123char s[maxn], p[maxn];s[0] = p[0] = '$';cin &gt;&gt; s+1 &gt;&gt; p+1; KMP众所周知，KMP 是一种单串匹配算法，把朴素算法的O(|S|*|T|)优化到了O(|S|+|T|)。 KMP 如上图，在进行朴素算法时，如果我们已经进行了一些匹配成功，实际上我们就知道了原串的一些信息，理论上就可以使用这个信息来加速匹配，跳过一些绝对不可能匹配成功的情况。所以，该怎么做呢？这就是 KMP 很迷的地方之一，也是我一直看不懂 KMP 的一个点。 border ：最长相等前后缀为此，xyy提到了 border 的概念。border 即是某个字符串的最长相等前后缀（不包含自己）。有了这个定义，再结合上面的图，就可以看到，如果在某个字符失配了，说明这个字符前的模式串 T 和字符串 S 是相等的，由于 border 的存在，可以直接跳过一些字符串，直接跳到失配字符前的模式串 T 的 border，比较 border 之后的字符。一定没有错过什么能够正确匹配的情况吗？是的，反证可以证明，要是存在，那border就不是最长了。也就是说，KMP 分为两个步骤，求 T 中每个字符前的子串对应的border长度，然后匹配。一般把前者（每个字符前的子串对应的 border 的长度）定义为 fail[] 数组，或者 xyy 的 π() 函数。 求 fail[] 数组在T也很长的时候，暴力求解 fail[] 数组也是不可取的。 fail() 这种情况下，可以看出： 由于 π(3)=1 ，可得 T[1...1]==T[3...3]；又由于 T[2]==T[4] ， T[1...2]==T[3...4]所以 π(4)=2=π(3)+1。 综上，**若T[i+1]==T[π(i)+1]，则π(i+1)=π(i)+1**。 那如果T[i+1]≠T[π(i)+1]呢？ border的border仍然是原串的border 有一个神奇的性质，border的border仍然是原串的border。 由于 abacaba 是原串的 border，则 黄串+c+绿串==蓝串+c+红串。由于 aba 是 abacaba 的 border，则 黄串==绿串，蓝串==红串。所以，黄串==绿串==蓝串==红串。 因此，我们可以用递归的方法，如果T[i+1]≠T[π(i)+1]，则检查T[i+1]==T[π(π(i))+1]，以此类推，直至出现相等。如果真的很惨，一个border都没有，那么应该递归到某个π(i)=0，这时，T[i+1]==0。 综上，求fail[]数组的代码为： 12345678910void getFail()&#123; for (int i = 1; i &lt;= pl; i++) &#123; int j = i-1; while (j &gt; 0 &amp;&amp; p[fail[j]+1] != p[i]) j = fail[j]; fail[i] = j ? fail[j] + 1 : 0; &#125; return;&#125; 匹配的过程匹配的过程可以按照上面说的，“如果在某个字符失配了，说明这个字符前的模式串T和字符串S是相等的，由于border的存在，可以直接跳过一些字符串，直接跳到失配字符前的模式串T的border，比较border之后的字符。” 但是还有一个更为漂亮的方法：把原串“拼到”匹配串“的后面”。求原串中哪些位置出现了匹配串的问题，就转化成了： 求新串中有哪些串的border正好是匹配串。（忽略掉所有长于匹配串的border） 匹配过程的代码就和求fail[]数组差不多了。实际上我们也没有拼起来，只是模拟了一下。 1234567891011121314151617void kmp()&#123; int j = 0;//fail[i-1] for (int i = 1; i &lt;= sl; i++) &#123; while (j &gt; 0 &amp;&amp; p[j + 1] != s[i]) j = fail[j]; j = (p[j + 1] == s[i]) ? j + 1 : 0; //这里不使用(j&gt;0)作为测试条件，是因为 j==0 和 p[j + 1] == s[i] 可能同时成立。 //求fail[]过程中不存在这个问题，因为fail[0] = -1 if (j == pl) &#123; ans[anslen++] = i - pl + 1; j = fail[j];//border:不包含自己 &#125; &#125;&#125; KMP完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//Lutece 2210 qh与复读机 III//https://acm.uestc.edu.cn/problem/qhyu-fu-du-ji-iii/description#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+5;char p[maxn], s[maxn];int ans[maxn] = &#123; 0 &#125;, fail[maxn] = &#123;-1 &#125;, anslen = 0, pl, sl;/*fail[i]：前i位的最长border（不包含自己）字符串从1计数!!!!aabcaabaabcaa0100123123456*/void kmp()&#123; //KmpGetFail for (int i = 1; i &lt;= pl; i++) &#123; int j = i - 1; while (j &gt; 0 &amp;&amp; p[fail[j] + 1] != p[i]) j = fail[j]; fail[i] = j&gt;0 ? fail[j] + 1 : 0; &#125; int j = 0;//fail[i-1] for (int i = 1; i &lt;= sl; i++) &#123; while (j &gt; 0 &amp;&amp; p[j + 1] != s[i]) j = fail[j]; j = (p[j + 1] == s[i]) ? j + 1 : 0;//不能使用(j&gt;0) if (j == pl) &#123; ans[anslen++] = i - pl + 1; j = fail[j]; &#125; &#125; //原版匹配 /*for (int i = 1, j = 1; i &lt; sl;) &#123; if (j == 0) &#123; i++; j++; continue; &#125; if (s[i] == p[j]) &#123; j++; if (j == pl) &#123; ans[anslen++] = i - j + 2 ; j = fail[j-1] + 1; &#125; i++; &#125; else &#123; j = fail[j - 1] + 1; &#125; &#125; return;*/&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); s[0] = p[0] = '$'; cin &gt;&gt; s+1 &gt;&gt; p+1; pl = strlen(p+1), sl = strlen(s+1); kmp(); for (int i = 0; i &lt; anslen; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; \" \"; &#125;&#125; AC 自动机留坑了。","tags":[{"name":"坑","slug":"坑","permalink":"https://blog.lyh543.cn/tags/%E5%9D%91/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.lyh543.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Python 常用函数","date":"2019-08-30T13:42:45.000Z","path":"python/python-functions/","text":"需要引入模块的函数，以模块（需要 import 的文件名）为标题进行分组。函数和模块均以字母排序。 builtins 内置函数1234567891011121314151617181920212223# 数学相关abs(float)max(a1,a2,a3,...) # 这里的输入参数是一个 sequence，和 C 语言不同，很有意思# 字符串相关str.find(',') # 找到就返回第一个下标，找不到就返回 -1（注意不是 False）' '.join(list) # 将 list 等组合为一个字符串，用 ' ' 分隔str.split() # 将字符串按 sep = ' ' 分拆成 list# 容器相关 set() # 定义集合# 其他elem in list # 在 list 中查找元素，返回 bool，这个直接用 in 关键字可太猛了isinstance(variable, tuple of type) # 判断变量类型range(start, stop[, step]) # 得到一个序列，可用于 for，或转换为 list 类型reversed(range(10)) # 将一个 list/str 翻转 bisect二分搜索。 123bisect.bisect_left(a, x, lo=0, hi=len(a)) # 返回第一个大于等于 x 的下标bisect.bisect_right(a, x, lo=0, hi=len(a)) # 返回第一个大于 x 的下标bisect.bisect # == bisect_right 可见 Python 的 bisect_left 和 bisect_right 等价于 C++ 的 lower_bound 和 upper_bound。 functools123functools.partial(func, **kw)functools.reduce(func, list)functools.wraps(func) math1math.sqrt(float) re正则表达式相关内容请查看 正则表达式 1re.findall('\\d+',str) % 找到 str 中的数并组成 list sys1sys.argv % 以 list 形式返回程序被调用时的参数 time123time.sleep(second)time.time() % 单位为秒","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.lyh543.cn/tags/Python/"}]},{"title":"《编程珠玑》笔记","date":"2019-08-28T16:00:00.000Z","path":"computer-science/Programming-Pearls/","text":"编程珠玑每一章讲了编程、开发的不同的方面。 第一章讲如何准确、正确的定义问题。 第二章讲算法设计（灵光一现，啊哈！算法）。 第三章提到数据结构和编程的关系（欸有点面向对象的感觉）。 第四章运用循环不变式来证明程序的正确性。 第五章运用脚手架、断言调试程序。 第六章概述了加速程序的几个方向，并在第八至x章分别阐述。 第七章书如其名：粗略估算。 第八章重新设计算法来降低程序的渐进时间复杂度。 第九章对利用率高的代码进行优化，使得渐进复杂度的常数减小。 第十章强调对空间的压缩。 十一章：排序算法，指快速排序 十二章：取样问题，指随机从 m 个数中取 n 个数 十三章：搜索，其实展示了用于存储和搜索的数组、链表、二叉搜索树、C++ set、bitset、箱（桶）这些数据结构。 十四章：堆 十五章：字符串，讲到了设计一个字典并压缩的过程。 将一个字符串 $S$ 的后 i 位移到前 i 位如当 i = 3，$S = abcdefg$，则要求 $S^R = efgabcd$。 该问题出现在《编程珠玑》第二章。时间复杂度要求为 $O(n)$，空间复杂度要求为几十字节，并且算法尽量简洁。 一个方法可以尝试以下方法： 将 x[0] 移动到临时变量 t，把 x[i] 移动到 x[0]，将 x[2*i] 移动到 x[i]，以此类推……直至取回 x[0]。若按该法没有移动所有元素，则对 x[1]、x[2]……x[i-1] 进行同样操作。 上述算法较好的完成了时空复杂度，但是不够简洁。 更简洁的方法：基本操作的威力更简洁的办法是先实现一个 reverse() 函数，用于翻转一个字符串（如把 qwerty 变为 (qwerty)^R = ytrewq），时间复杂度为 $O(n)$，复杂度为几个字节。设 $S$ 串前 i 位为 $T_1$，后 (n-i) 位为 $T_0$。注意到 ${(T_1^R T_0^R)}^R = T_0 T_1$，即可以调用三次 reverse() 函数实现该问题： 123reverse(0,i-1);reverse(i,n-1);reverse(0,n-1); 该算法简洁，而且不容易出错。 格式信函编程出现在3.2。 要写这种的话，不如手写一个把模板转为实例的函数，方便维护。 模板： 123456789Welcome back, $1!We hope that you and all the membersof the $0 family are constantlyreminding your neighbors thereon $5 to shop with us.As usual, we will ship your order to $3 $1 $2. $0 $4 $5 $6, $7 $8 解释器（伪代码）： 12345678910111213read fields from databaseloop from start to end of schema c = next character in schema if c ! ='$' printchar c else c = next character in schema case c of '$': printchar '$' '0' - '9': printstring field[c] default: error(\"bad schema\") 有点像 C 的风格。在这种情形下，C++ 的 cout 风格也不一定好。 更一般性的问题也许更容易解决第三章 3.6。 对于程序设计来说，这意味直接编写 23 种情况的问题很困难；而编写一个处理 n 种情况的通用程序，再令 n = 23 来得到最终结果，却相对要容易一些。 —— Polya: How to solve it 咖啡罐问题David Gries 在其 Science of Programming 中将下面的问题称为“咖啡罐问题”。 给定一个盛有一些黑色豆子和一些白色豆子的咖啡罐以及一大堆“额外”的黑色豆子，重复下面的过程，直至罐中仅剩一颗豆子为止：从罐中随机选取两颗豆子，如果颜色相同，就将它们都扔掉并且放入一个额外的黑色豆子；如果颜色不同，就将白色的豆子放回罐中，而将黑色的豆子扔掉。 证明该过程会终止。最后留在罐中的豆子颜色与最初罐中白色豆子和黑色豆子的数量有何函数关系？ 这个问题看起来很有意思。步骤会结束的证明是每次操作以后，罐子里总会减少一颗豆子；而对于最后剩余的豆子的颜色，可以关注到每次操作会拿走 0 到 2 颗白豆子，没有改变白豆子数量的奇偶性，因此最后剩白豆子的充要条件是罐子里原有奇数颗白豆子。 循环不变式出现在第四章。 程序验证的基本技术：精确定义不变式并在编写每一行代码时随时保持不变式的成立。 如二分搜索中， t 总在 [l, r] 中。 证明二分搜索的正确性的方法分为三个部分： 初始化。循环初次执行的时候不变式为真。 保持。如果在某次迭代开始的时候以及循环执行的时候，不变式都为真，那么循环体执行完后，不变式仍为真。 终止。即循环一定能停止。 话说 1 和 2 就是数学归纳法你看隔壁叔叔，都二十岁了还在打数理基础。证明了 1 和 2，我们就能证明，如果循环能够停止，那么其结果一定是正确的。因此我们还需要证明 3。 对于二分搜索算法，初始化和保持只要按照流程分类讨论就不难。停机的证明是停止条件是 [l, r] 内没有元素，而每次循环以后，范围必定减小至少 1（说必定减少都不行，减少的序列可能是一个收敛级数）。 顺便一提，后来我才知道，循环不变式是《算法导论》从第一章就开始强调的概念。 断言出现在第四、五章。 上面提到的循环不变式也是一种断言。 断言在程序维护过程中至关重要：当你拿到一段你从未见过而且多年来也没有其他人见过的代码时，有关该程序状态的断言对于理解程序时很有帮助的。 而断言这种东西，在 C 语言还真的有：assert。关于该语法，放到另一篇博客。 总之工程开发要多用。 程序调试在第五章。 调试不仅可以验证程序的正确性，还能验证其理论时间复杂度。 附一份我写的二分实现的 lower_bound() 函数，及用 assert 验证其正确性的代码，以及验证其时间复杂度的代码。但是时间复杂度的验证貌似不稳定。 粗略估算出自于第七章。也是我认为非常难的一章，因为涉及到大量的“常识”。下面就列举一下本书中出现过的应该掌握的常识。 换算法则1. 72法则 如果增长率为 $x\\%$，那么在 $y$ 年后将会翻倍，其中 $xy = 72$。 即 $f(x)=(1+x\\%)^{\\frac{72}{x}} \\approx 2$。$1 \\leq x \\leq 15$ 时，误差在 $5\\%$ 内； $6 \\leq x \\leq 9$ 时，误差在 $1\\%$ 内。 $x$ 1 2 3 4 5 6 $(1+x\\%)^{\\frac{72}{x}}$ 2.0471 2.03989 2.03279 2.02582 2.01895 2.0122 $x$ 7 8 9 10 15 20 $(1+x\\%)^{\\frac{72}{x}}$ 2.00555 1.999 1.99256 1.98622 1.95591 1.92776 2. “π 秒就是一个纳世纪”一世纪有 $3.155 \\times 10 ^ 7$ 秒。 生活常识常见的河流的流速：不到 2 英里（3.21 公里）/小时 Little 定理 系统中物体的平均数量等于物体离开系统的平均速率和每个物体在系统中停留的平均时间的乘积。 原定理没有提进入速率，但是如果物体离开和进入系统的总体出入流是平衡的，那么离开速率就是进入速率。 Little 定理简单的说来就是： 队列中物体的平均数量 = 进入速率 × 平均停留时间 例1：排队一个夜总会需要排队进入。这个夜总会能容纳 60 人，每个人在里面呆三小时，那么进入夜总会的速率是 20 人/小时。这样你就能从队伍前面有多少人来判断大概还有多少时间进去。 例2：死亡率和平均寿命由 Little 定理可知： 每年的死亡率 × 平均寿命 = 1 如死亡率为 1.4%，则平均寿命为 71 岁。 自己的电脑的运算速度对于一个程序员，知道现在电脑的运算量也非常重要。我就花了一天的时间，测试了一下 C 语言中各种运算的时间。由于内容过长，另开文章以阐述。 安全系数出现自第七章。 在做出可靠性、可用性保证时，给出和我们的目标差十倍的结果；在估算规模、开销和时间进度时，应该给出 2-4 倍保守的结果。 随机序列的最大连续子序列和的期望出自于第八章。习题 8.6。 这是个挺有意思的题目，但是很少有人研究： 假定输入数组的各个元素是从 $[-1,1]$ 中均匀选出的随实数，那么最大子序列和的期望值是多少？ 我手算了 $n=1$ 时期望为 1/4， $n=2$ 时期望为 1/2。 以下是几个相关链接： https://stackoverflow.com/questions/11261066/expectation-of-the-maximum-consecutive-subsequence-sum-of-a-random-sequencehttps://www.quora.com/What-is-the-expected-value-of-the-sum-of-the-maximum-sum-subvector-if-the-arrays-elements-are-random-real-numbers-chosen-uniformly-from-1-1# 链接中有人用 Mathematica 模拟，跑出了 $n \\leq 5$ 的精确解为：1/2，1/4，23/32，291/320，4141/3840。 也有人提到，经过 $n \\leq 10000$ 的模拟，答案应该是 $O(\\sqrt n)$ 的。从理论上来说，可以把问题类比为 random walk，从而化归为布朗运动，得到 $O(\\sqrt n)$ 的证明。 这题放在这里也太硬核了吧。。。。 从 n 元序列随机取 m 个出自第 12 章。 程序的输入包含整数 m &lt; n。输出是 [0, n-1] 范围内 m 个随机整数的有序列表，不允许重复。从概率的角度说，我们希望每个数出现的概率相同。 下面写一下书上的三种算法。 动态计算概率，然后用随机数取数，时间复杂度为 $O(n)$： 1234567891011void gen1(int m, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; if (rand() % (n-1) &lt; m) &#123; cout &lt;&lt; i &lt;&lt; \"\\n\"; m--; &#125; &#125;&#125; 显然该算法不适合用于生成 1 个 32 位随机整数（m=1, n=2^32）。 向集合里塞随机数，直至集合大小为 m。当 m 远小于 n 时，算法复杂度为 $O(m \\log m)$。 12345678void gen2(int m, int n)&#123; set s; while(s.size() &lt; m) s.insert(rand() % n); for (int i : s) cout &lt;&lt; i &lt;&lt; \"\\n\";&#125; Floyd 算法（习题 12.9），基于算法 2 改良，保证在任何情况下，算法复杂度都是 $O(m \\log m)$。 这里仅给出递归版，实际上也可以改为非递归版本： 123456789101112131415161718void gen3(int m, int n, set&lt;int&gt; &amp; s)&#123; if (m == 0) return; gen3(m-1, n-1, s); int t = rand() % n; if (!s.insert(t).second) s.insert(n - 1);&#125;void gen3(int m, int n)&#123; set&lt;int&gt; s; gen3(m, n, s); for (int i : s) cout &lt;&lt; i &lt;&lt; \"\\n\";&#125; 算法正确性的证明可以用 循环不变式 的方法：第六行之后的循环不变式为 “$[0, n-2]$ 之间的整数被选到的概率为 $\\frac{m-1}{n-1}$”，证明一次循环以后不变式仍然成立，需要用到概率论中的条件概率，讨论 $t \\in [0, n-2]$ 且已被选中、$t$ 没有被选中这两种情况，详细过程略。 使用 shuffle 算法。由于算法需要完整生成 n 个数的序列，以及进行排序，所以算法时间复杂度为 $O(n + m\\log m)$。 1234567891011int gen4(int m, int n)&#123; int * arr = new int[n]; for (int i = 0; i &lt; n; i++) arr[i] = i; for (int i = 0; i &lt; m; i++) swap(arr[i], arr[ randint(i, n-i) ]); sort(arr, arr + m); for (int i = 0; i &lt; m; i++) cout &lt;&lt; arr[i] &lt;&lt; \"\\n\";&#125; 习题 12.10 如何从 n 个对象（可以依次看到这 n 个对象，但事先不知道 n 的值）中随机选择一个？具体来说，如何在事先不知道文本文件行数的情况下读取该文件，从中随机选择并输出一行？ 这一章全是概率题啊。。。。 算法： 12345678910111213string genline()&#123; string str, tempstr; int k = 1; while(!eof()) &#123; tempstr = getline(); //在 1/k 的概率下执行 if 后的语句 if (rand() % k == 0) str = tempstr; &#125; return str;&#125; 简单的用文字描述算法就是：存储第一行。在读入第 $k$ 行时，使用随机数使得，有 $1/k$ 的概率将第 $k$ 行替换存储的行，否则保存存储的行不变。算法的正确性同样可由 循环不变式 证得。 习题 12.11 在一种彩票游戏中，每位玩家有一张包含 16 个覆盖点的自拍，覆盖点下面隐藏着一个 1-16 的随机排列。玩家翻开覆盖点则出现下面的整数。只要整数 3 出现，则盼玩家负；否则，如果 1 和 2 都出现（顺序不限），则玩家获胜。随机选择覆盖点的顺序就能够获胜的概率如何计算？请列出详细步骤，假定你最多可以使用一个小时的 CPU 时间。 看到最后一句话我以为是要枚举，但实际上可以用 $O(mn)$ 的动态规划来做。算完答案以后，我发现，其实这就是一个概率题！ 原题等价于列举 1-16 的全排列，共 16! 种情况。计算其中 3 先于 1 或 2 出现的种数（输的种数），以及 1 和 2 都先于 3 出现的种数（赢的种数）。 由于 1、2、3 并无特殊意义，我们可以考虑用两张 key 牌来称呼 1 和 2，lose 牌称呼 3。 这个题可以用动态规划来做，二维为剩余牌的总张数 n ，和剩余 key 牌的张数（由于输掉游戏只需要一张牌，因此不需要单独一维来计算，当然，作为本题的延伸，可以考虑有需要抓到多张牌才算输的情况）。转移状态时，讨论三种情况：抓到 lose 牌，抓到 key 牌，抓到其他牌。另外要注意，如果游戏还没结束，必须至少有一张 key 牌和一张 lose 牌在场上，即 $n \\geq 1 + key$。这是边界条件。 存储赢的种数为 $answer[n][key].win$，存储输的种数为 $answer[n][key].lose$，最终赢/输的比值为 $answer[16][2].win / answer[16][2].lose$。 转移方程为： $$\\begin{split}answer[n][key].win &amp;=\\begin{cases} 0 &amp; n &lt; 1 + key \\\\ n! &amp; n \\geq 1 + key \\space and \\space key = 0 \\\\ 0 \\\\ \\quad + key \\cdot answer[n-1][key-1].win &amp; otherwise\\\\ \\quad + (n - 1 - key) answer[n-1][key].win\\end{cases} \\\\ \\\\answer[n][key].lose &amp;=\\begin{cases} 0 &amp; key = n &lt; 1 + key \\space or \\space 0 \\\\ (n-1)! \\\\ \\quad + key \\cdot answer[n-1][key-1].lose &amp; otherwise\\\\ \\quad + (n - 1 - key) answer[n-1][key].lose\\end{cases} \\\\\\end{split}$$ 实现的 C++ 代码为： 123456789101112131415161718192021222324252627282930313233struct posibility&#123; long long win = 0; long long lose = 0;&#125;;const int nMax = 20, keyMax = 2;void LotteryGame(const int N, int Key)&#123; posibility answer[nMax][keyMax + 1]; long long Factorial[nMax]; Factorial[0] = 1; for (int i = 1; i &lt;= N; i++) Factorial[i] = i * Factorial[i - 1]; for (int n = 1; n &lt;= N; n++) &#123; answer[n][0].win = Factorial[n]; for (int key = 1; key &lt;= min(Key, n - 1); key++) &#123; answer[n][key].win = key * answer[n - 1][key - 1].win + (n - 1 - key) * answer[n - 1][key].win; answer[n][key].lose = Factorial[n - 1] + key * answer[n - 1][key - 1].lose + (n - 1 - key) * answer[n - 1][key].lose; &#125; &#125; cout &lt;&lt; \"Win/Lose = \" &lt;&lt; answer[N][Key].win &lt;&lt; \"/\" &lt;&lt; answer[N][Key].lose &lt;&lt; \" = \" &lt;&lt; double(answer[N][Key].win) / answer[N][Key].lose; //注意这不是赢的概率，这是赢输的比值&#125; 有意思的是，程序的结果正好为 1/2（即赢的概率为 1/3）。我怀疑是程序或者转移方程写错了，打开调试，发现，无论 $n$ 为何值，$answer[n][2]$ 中 win 总是 lose 的一半！ 那么从简单的情况验证一下：$n = 3$ 时 $win/lose$ 确实是 $2/4$。举到 $n=4$ 时，我明白了这个题目确实和 n 没有关系！ 我们不考虑其他数，只考虑 1 2 3 的相对位置，即，从所有全排列抽出 1 2 3。3 在前的排列有 3 1 2 3 2 1 1 3 2 2 3 1 四种；1 2 在前的排列有 1 2 3 2 1 3 两种。再将这些情况插回上述全排列所空出的位置，则输的种数就是 $4 \\times 16!/3!$，赢的种数就是 $2 \\times 16!/3!$。无论一共有多少张卡，赢的概率都为 1/3！ 被概率题教育了 桶的小细节如果有 bins 个桶，最大值为 maxval，那么直观地，元素 t 可以放在第 t*bins/maxval 个桶中。然而，这容易导致数值溢出。 推荐使用 t/(1 + maxvalue/bins)，防止溢出，并且也没有使用浮点数，造成可能的误差。 后缀数组计算最大重复子串这里我们讨论单词 banana 的最大重复子串。定义字符串 c 和字符指针数组 a： 123char c[MAXN] = \"banana\", a*[MAXN];for (int n = 0; c[n] != 0; n++) a[n] = &amp;c[n]; 实现的效果如下： a[0] -&gt; bananaa[1] -&gt; ananaa[2] -&gt; nanaa[3] -&gt; anaa[4] -&gt; naa[5] -&gt; a 然后，对 a 数组按字典序进行排序得到： a[0] -&gt; aa[1] -&gt; anaa[2] -&gt; ananaa[3] -&gt; bananaa[4] -&gt; naa[5] -&gt; nana 然后对相邻字符串比较即可。 在常见字符串上有 $O(n \\log n)$ 的复杂度（排序不分），当然如果使用 aaaaaaaaaaa 一类的字符串，比较的复杂度也会被卡到 $O(n^2)$。","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Windows 使用小技巧","date":"2019-08-26T16:00:00.000Z","path":"microsoft/windows/windows-tips/","text":"也不只是 Windows 的，也可能是某款软件如 Chrome 或 Excel 的，这样就不局限于 Windows 系统了。 好用冷门快捷键集合 快捷键 作用 说明 Ctrl +Shift + T 重新打开关闭的标签页 在 Visual Studio Code 和 Chrome 等可用 Home 和 End 按键对于大多数小白，键盘上的这两个键形同摆设，但是在纯键盘流/处理大文件（千行以上）时，这两个键就很香了。 在文本编辑器中，Home 跳到本行开头；End 跳到本行结尾；如果想到跳到全文开头/结尾，加 Ctrl 就可以了。 Excel 中的 End 按键对于处理大量数据的 Excel 表格，有些时候拖滚动条都要拖好久。我们知道，Home 和 End 在其他应用能跳到同行的开头和结尾，但是貌似不能解决几千甚至几万行的 Excel。 所以，Excel 对 End 进行了“魔改”，按了 End 以后，并没有立即跳转到行末，而是等待输入一个方向键，即可跳转到该方向的最后一个位置。 Shift 高级菜单在某些地方按住 Shift，能发现某些地方多了一些选项。 如，右键单击任务栏时，按住 Shift，发现多了一个 关闭资源管理器 的选项。（不过貌似也没什么用，没有任务管理器的直接重启 explorer 进程好用）； 按住 Shift 右键单击任务栏 又如，在文件资源管理器中任意地方按住 Shift 右键单击，可以看到多了两个选项：在此处打开 Powershell 和 在此处打开 Linux Shell。类似于 Linux 资源管理器。 按住 Shift右键单击文件资源管理器 管理员身份 Ctrl + Shift按住 Ctrl+Shift 并单击左键启动程序，可以以管理员身份启动程序。 这在很多地方都适用，如文件资源管理器、开始菜单、任务栏、“运行”菜单等。 按住 Ctrl+Shift 设置 Windows 防火墙以允许被 ICMP Ping在局域网里可以 ping 自己的 Windows 电脑，而互联网里却 ping 不了。这是因为 Windows 强大的防火墙默认关闭了 ping 的应答。 打开 ICMP Ping 应答，可以在防火墙的 GUI 界面里点、点、点，但是也可以只需要一行命令行（命令行还是香，再怎么说，教程里面复制粘贴也太方便了）。 参考链接：微软官方文档。 在 Windows 10 上（准确的说，在 Windows Vista 及以上），以管理员身份打开 cmd 或 Powershell，然后输入 1netsh advfirewall firewall add rule name=\"ICMP Allow incoming V4 echo request\" protocol=icmpv4:8,any dir=in action=allow 看到 确定。 即可。 右键菜单自定义可以修改注册表：HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\，其中 Directory 指 文件夹 类型的右键菜单；该目录下，每个目录都是一个右键选项。 如想要删除某些“发送到百度云盘”、“通过 QQ 发送给手机”等选项，可以在注册表找到上述位置进行修改，也可以下载使用软媒设置大师（这条五毛，括号内册 软媒设置大师 如想要自己添加选项，则可以自己写注册表，格式如下： 1234567Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@&#x3D;&quot;Windows Terminal Here&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@&#x3D;&quot;C:\\\\Users\\\\liu\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe&quot; 效果 获取 UWP 离线安装包 转载：https://zhuanlan.zhihu.com/p/43012490 启动 Fiddler。此时建议退出其它联网的程序； 打开 WinConfig，勾选上 Microsoft Store 并 Save Changes； 打开 WinConfig 勾选 Microsoft Store 并保存 在商店中点击下载应用。当下载开始时，在 Fiddler 的列表中寻找 Host 值为 tlu.dl.delivery.mp.microsoft.com 、URL 值以 /filestreamingservice/files/ 开头、Result 值为 206 (Partial Content) 的行。 示例 任选一行右键＞Copy＞Just Url，或者使用快捷键 Ctrl+U。此时链接已复制到剪贴板，可以用下载工具开始下载了。注意，这个链接每个人都是不同的，并且有效期只有 15 分钟，要尽快下载。","tags":[{"name":"tips","slug":"tips","permalink":"https://blog.lyh543.cn/tags/tips/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://blog.lyh543.cn/tags/Microsoft/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.lyh543.cn/tags/Windows/"},{"name":"Excel","slug":"Excel","permalink":"https://blog.lyh543.cn/tags/Excel/"}]},{"title":"字符编码（转载）","date":"2019-08-22T16:00:00.000Z","path":"computer-science/character-encoding/","text":"ASCII，Unicode 和 UTF-8 转自：https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用 8 个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是 255（二进制 11111111 = 十进制 255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 65535，4个字节可以表示的最大整数是 4294967295。 由于计算机是美国人发明的，因此，最早只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 char-encoding-problem 因此，Unicode 应运而生。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode 标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要 4 个字节）。现代操作系统和大多数编程语言都直接支持 Unicode。 现在，捋一捋 ASCII 编码和 Unicode 编码的区别：ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节。 字母 A 用 ASCII 编码是十进制的 65，二进制的 01000001； 字符 0 用 ASCII 编码是十进制的 48，二进制的00110000，注意字符 &#39;0&#39; 和整数 0 是不同的； 汉字 中 已经超出了 ASCII 编码的范围，用 Unicode 编码是十进制的 20013，二进制的 01001110 00101101。 你可以猜测，如果把 ASCII 编码的 A 用 Unicode 编码，只需要在前面补 0 就可以，因此，A 的Unicode编码是 00000000 01000001。 新的问题又出现了：如果统一成 Unicode 编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把 Unicode 编码转化为“可变长编码”的 UTF-8（8-bit Unicode Transformation Format）编码。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果你要传输的文本包含大量英文字符，用 UTF-8编码就能节省空间： 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 \\ 01001110 00101101 11100100 10111000 10101101 从上面的表格还可以发现，UTF-8 编码有一个额外的好处，就是 ASCII 编码实际上可以被看成是 UTF-8 编码的一部分，所以，大量只支持 ASCII 编码的历史遗留软件可以在 UTF-8 编码下继续工作。 搞清楚了 ASCII、Unicode 和 UTF-8 的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式： 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。 用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件： rw-file-utf-8 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器： web-utf-8 所以你看到很多网页的源码上会有类似 &lt;meta charset=&quot;UTF-8&quot; /&gt; 的信息，表示该网页正是用的 UTF-8 编码。 UTF-8 和 BOM 转载自：https://www.cnblogs.com/zhongru_tu/archive/2008/04/11/1147792.html 而 UTF-8 和 UTF-8 without BOM 又是什么呢？ BOM 的全称叫做”Byte Order Mark”。在 UTF-8 文件中常用 BOM 来表明这个文件是 UTF-8 文件，而 BOM 的本意是在 UTF-16 中用来表示高低字节序列的。在字节流之前有 BOM 表示采用低字节序列（低字节在前面），而 UTF-8 不用考虑字节序列（以字节为编码单元，没有字节序的问题），所以其实有无BOM都可以。 微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。微软的记事本、Word 等只能正确打开含 BOM 的 UTF-8 文件，然而 UltraEdit 却恰恰相反，会把 UTF-8 文件的 BOM 误认为 ascii 编码。 到底该不该在 UTF-8 中使用 BOM，知乎上吵得也不可开交，至少 Unicode 说二者皆可。","tags":[{"name":"转载","slug":"转载","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"C++ 基本计算的速度","date":"2019-08-19T16:00:00.000Z","path":"cpp/cpp-grammar/cpp-calculating-efficiency/","text":"前言ACM 时，曾经测试过 Lutece 的速度并记录在这篇博客，毕竟 OJ 运算速度直接关系到了每一次写的代码的复杂度。 脱坑 ACM 以后，在编程珠玑里面看到了自己的电脑的运算速度应该作为常识记住，于是就花一天的时间测了一下，并进行了简要分析。附测试的代码和完整数据。 本文涉及到的次数并不准确，因为没有计算 for 循环递增量以及执行 for 循环的时间。本文只是粗略统计一下电脑计算速度的数量级，以及比较各状态下的速度。 测试环境 测试电脑：Surface BookCPU：Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz测试线程数：1操作系统：Windows 10 10.0.18912.1001 (64 bit)编译器：MSVC 2017编译选项（除测试架构和编译选项时）：X64, Release, O2 优化每次测试组数：20（程序启动的前两组速度有明显的差异，因此统计运算速度时之计后 18 组） 结论 对于架构和编译选项来说，O2 优化能带给程序 3-9 倍的速度提升；同样的代码编译出的 64 位程序较 32 位快 13% - 218%； 整型的运算的加、乘都是 1e9 次/秒数量级的，浮点类型的加、乘都是 1e8 次/秒数量级。对于 log 和 sqrt 类型，整型可能会慢于浮点类型，但都在 1e7次/秒 数量级； 极端数据范围的数据运算不影响整型运算的速度，略微影响浮点型运算的速度（10%）； 高精度运算在 long long 范围内加，比 C 自带整型类型慢三个数量级；100 位的加法也只比前面慢不到一个数量级（后经测试，乘法慢于加法，但差别不大，虽然是乘法 $O(n^2)$，但 n=100 也较小）。 测试一：架构和编译选项测试的是 long long 类型从 1 加到 1e9。以下是测试结果： 1s 运算次数 debug(Od) release(Od) release(O1) release(O2) x86 3.05E+08 \\ \\ 9.55E+08 x64 3.47E+08 3.61E+08 1.9E+09 3.04E+09 注：Od 为禁用优化，O1 为最大优化（优选大小），O2 为最大优化（优选速度）。 可以观察到，在没有优化的情况下，debug 和 release 的区别其实不大。但是开了 O2 优化以后，程序获得了 3-9 倍的加速。 而对于 x86 和 x64 来说，无优化下，x64 略快于 x86 （约 13%）；而在 O2 优化下，x64 较 x86 快了 218%。 测试二：数据类型和运算测试的类型有 int，long long，float，double 和一个自定义的高精度运算 BigInteger（源码包含在测试代码中）。测试的运算有 +，*，cmath 中的 sqrt() 和 log()。 int，long long，double 都是从 1 测到 1e9。在进行 float 的测试时发现使用 i++，当数据达到 $2^{24} \\approx 1.6 \\times 10^7$ 时，i 的值不会发生变化（1 溢出了，这和和浮点数的记法有关）。于是对于 float 的测试都是从 1 测到 1e7，重复 100 次。BigInteger 由于太慢，只从 1 测到 1e7。 以下是测试结果： 1s 运算次数 int long long float double BigInteger + 3.26E+09 3.04E+09 5.92E+08 5.20E+08 1.51E+06 * 1.99E+09 2.00E+09 6.36E+08 6.43E+08 1.11E+06 log() 3.70E+07 4.94E+07 5.69E+07 5.35E+07 \\ sqrt() 6.79E+07 6.83E+07 7.63E+07 5.59E+07 \\ 从数量级上来看，整数的加和乘能达到 1e9 次/秒 的数量级，而浮点数也能达到 1e8 次/秒 的数量级。相比下，高精度就慢得多了，只能达到 1e6 次/秒 的数量级，比整数运算低了 3 个数量级。（所以 ACM 中，能用 __int128 就别用高精度）。 对于不同精度的整型和浮点型数据，加法上，int 比 long long 快约 7%，float 比 double 快约 14%。但是乘法上，long long 甚至比 int 快不到 1%，double 比 float 快 1%。都不是很明显。 对于 log 和 sqrt 函数来说，int 和 long long 反而可能比 float 和 double 慢。这可能是因为 C 语言并没有实现整型的 log 和 sqrt 函数，而是把整型强转为浮点数来进行计算。但是这几种数据类型的运算仍然在一个数量级。 测试三：数据范围对运算速度的影响由于浮点数有移位的过程，所以可能数据范围对运算速度也有一定影响。 本次测试选用了 long long（做对照），float，double，BigInteger，分别从 1e7, 1e10, 1e14 开始累加量为 1，累加 1e9 次（或 1e7次，循环 100 遍）（BigInteger 由于过慢，只累加 1e7 次；float 由于上面提到的 1 溢出问题，只计算从 1e7 累加至 1.5e7）。 1s 运算次数 long long float double BigInteger 1e7 2.03E+09 5.87E+08 5.97E+08 1.70E+06 1e10 2.02E+09 \\ 5.36E+08 1.08E+06 1e14 2.11E+09 \\ 5.31E+08 9.78E+05 1e100 \\ \\ \\ 3.32E+05 可以注意到，long long 的数据范围和运算速度关系确实不大；而double 会有影响：数据范围从 1e7 扩大到 1e14，运算速度下降了 11%，但是仍然在一个数量级内。 而 BigInteger 的影响同样也不大，即使是从 1e7 加到 1e100，运算速度也只下降了一个数量级。可能是其他操作比较慢","tags":[{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"apt 笔记","date":"2019-08-19T16:00:00.000Z","path":"linux/apt/","text":"APT，高级打包工具（英语：Advanced Packaging Tools，缩写为APT）是Debian及其派生的Linux软件包管理器。 ——Wikipedia 第一件事：更新源apt-get的下载链接可以理解为是存在本地的。如果第一次用apt-get，或者太久没有用，可能某些链接就失效了。所以，这种情况下就得先： 1sudo apt-get update 第零件事：更换中科大源由于众所周知的原因，Ubuntu 的源在国内访问很慢，建议换国内的镜像源。由于 USTC 的 wiki 对操作方法写的很清楚了，所以直接贴一个链接好了。 https://lug.ustc.edu.cn/wiki/mirrors/help/ubuntu 安装1sudo apt install &lt;package name&gt;","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"}]},{"title":"句柄（handle）","date":"2019-08-19T16:00:00.000Z","path":"computer-science/handle/","text":"参考链接：https://zh.wikipedia.org/wiki/%E5%8F%A5%E6%9F%84https://www.zhihu.com/question/27656256 句柄（HANDLE）是什么？ 维基百科： 在程序设计中，句柄（handle）是 Windows 操作系统用来标识被应用程序所创建或使用的对象的整数。其本质相当于带有引用计数的智能指针。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，可以使用句柄。 知乎上比较简短而有趣的回答有： 如果当初把 handle 这个词翻译成”编号”，那得省大家多少事啊。文件编号窗口编号太容易理解了一个古怪的词汇，句柄，不知道吓退了多少学习 windows 编程的人 另外一个回答： 最早的 windows 开发书籍，handle 是被翻译成“把手”的。虽然不好听，但是个人认为相当传神。1.虽然你握住的只是把手，却能拉动整扇门，而且你根本不用在意那门长什么样子2.一扇门如果有多个把手，被不同的人（进程）握住，门往哪儿走就不好说了 比较专业的回答： 句柄就是个数字，一般和当前系统下的整数的位数一样，比如 32bit 系统下就是4个字节。这个数字是一个对象的唯一标示，和对象一一对应。这个对象可以是一个块内存，一个资源，或者一个服务的 context（如 socket，thread）等等。这个数字的来源可以有很多种，只要能保证和它代表的对象保持唯一对应就可以，比如可以用内存地址，也可以用句柄表的序号，或者干脆用一个自增 ID，再或者用以上的值去异或一个常数。传统上操作系统内核和系统服务 API 都是 C 语言接口的，但是其内部设计理念上又是 OO （面向对象）的，所以有对象概念却没有对应的语言语法支持。句柄的作用就是在 C 语言环境下代替 C++ 的对象指针来用的。创建句柄就是构造，销毁句柄就是析构，用句柄调用函数相当于传入 this 指针。如果有系统 API 是 C++ 接口的，那么就没有句柄了，而是某个接口指针，IXXXPtr 之类的，比如 Windows 的 com ptr。 查了这几个资料，大概说的比较清楚了，我也不多加赘述。 另外，Windows.h 对 HANDLE 类型的定义，还真就是指针： 1typedef HANDLE *void","tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.lyh543.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"C/C++ && 和 || 的优先级","date":"2019-08-19T16:00:00.000Z","path":"cpp/cpp-grammar/c-priority-between-and-or/","text":"结论：&amp;&amp; 高于 || 记忆上面，可以认为我们更常使用 Disjunctive normal form 而不是 Conjunctive normal from。这是；离散数学-逻辑代数的一些知识。通俗的来讲，就是 ( x&lt;1 and y&lt;1 ) or (x&gt;1 and y&gt;1) or (x&lt;2 and y&gt;2) 这样的先与后或的 DNF 结构更常用，因此规定没有括号的情况下，默认加括号为这样的形式。 顺便，&lt;&lt;高于&amp;&amp;。因此，cout&lt;&lt;1&amp;&amp;1只会输出 1。 测试代码 1： 1234567891011int main()&#123; cout &lt;&lt; \"a b c (a||b)&amp;&amp;c a||(b&amp;&amp;c) a||b&amp;&amp;c\\n\"; for (int i = 0; i &lt; 8; i++) &#123; int a = i&amp;1; int b = (i&gt;&gt;1)&amp;1; int c = (i&gt;&gt;2)&amp;1; cout &lt;&lt; a &lt;&lt; \"\\t\" &lt;&lt; b &lt;&lt; \"\\t\" &lt;&lt; c &lt;&lt; \"\\t\" &lt;&lt; ((a||b)&amp;&amp;c) &lt;&lt; \"\\t\\t\" &lt;&lt; (a||(b&amp;&amp;c)) &lt;&lt; \"\\t\\t\" &lt;&lt; (a||b&amp;&amp;c)&lt;&lt; endl; &#125;&#125; 输出： 123456789a b c (a||b)&amp;&amp;c a||(b&amp;&amp;c) a||b&amp;&amp;c0 0 0 0 0 01 0 0 0 1 10 1 0 0 0 01 1 0 0 1 10 0 1 0 0 01 0 1 1 1 10 1 1 1 1 11 1 1 1 1 1 测试代码2： 1234567891011int main()&#123; cout &lt;&lt; \"a b c (a&amp;&amp;b)||c a&amp;&amp;(b||c) a&amp;&amp;b||c\\n\"; for (int i = 0; i &lt; 8; i++) &#123; int a = i&amp;1; int b = (i&gt;&gt;1)&amp;1; int c = (i&gt;&gt;2)&amp;1; cout &lt;&lt; a &lt;&lt; \"\\t\" &lt;&lt; b &lt;&lt; \"\\t\" &lt;&lt; c &lt;&lt; \"\\t\" &lt;&lt; ((a&amp;&amp;b)||c) &lt;&lt; \"\\t\\t\" &lt;&lt; (a&amp;&amp;(b||c)) &lt;&lt; \"\\t\\t\" &lt;&lt; (a&amp;&amp;b||c)&lt;&lt; endl; &#125;&#125; 输出： 123456789a b c (a&amp;&amp;b)||c a&amp;&amp;(b||c) a&amp;&amp;b||c0 0 0 0 0 01 0 0 0 0 00 1 0 0 0 01 1 0 1 1 10 0 1 1 0 11 0 1 1 1 10 1 1 1 0 11 1 1 1 1 1","tags":[{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"C/C++ 位序","date":"2019-08-19T16:00:00.000Z","path":"cpp/cpp-grammar/位序/","text":"1234567int main()&#123; int i[2]; i[0] = 1 &lt;&lt; 10, i[1] = 0;//将i[1]初始化为 0，保证i[0]之后的位全为 0 int *p1 = &amp;i[0], *p2 = (int*)((int)p1 + 1); cout &lt;&lt; *p1 &lt;&lt; \" \" &lt;&lt; *p2;&#125; 输出 1024 4。 可以看出这里使用的是 LSB 0 位序。 比特序分为两种：LSB 0 位序和MSB 0 位序。LSB 0 位序是指：字节的第 0 位存放数据的 least significant bit，即我们的数据的最低位存放在字节的第 0 位。MSB 0 位序是指：字节的第 0 位存放数据的 most significant bit，即我们的数据的最高位存放在字节的第 0 位。 i[2] 的存储状态如下（为方便表示，假设 &amp;i[0] == 0x100） 0x100 0x101 0x102 0x103 00000000 00100000 00000000 0000000 读 *p1 (0x100) 时，读到的是 100 00000000，即 1024；读 *p2 (0x101) 时，读到的是 100，即 4。 对于更深层次的问题，先挖个坑，学计算机网络时也许要接触。","tags":[{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"},{"name":"坑","slug":"坑","permalink":"https://blog.lyh543.cn/tags/%E5%9D%91/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"vi 笔记（萌新向）","date":"2019-08-19T16:00:00.000Z","path":"linux/vi/","text":"有一个特别经典的段子是，要想生成随机数，可以让一群没有用过 vi 的人尝试退出 vi 。习惯了 Windows 写字板的用户，遇到没有 GUI 的 vi 时，确实很容易懵逼。但是 vi 这个神器，大佬用起来，秒杀其他一切编辑器。但是对于刚入坑 linux 的同学，如何使用 vi 比高级操作更重要，于是今天我就简单总结一下 vi 的基本操作。 在任何状态按 esc 就能回到初始状态。 在初始状态按 i ，即可进行编辑。编辑完按 esc 退出。 在初始状态按:，即进入功能菜单： a. :w 为保存， :w! 为强制保存； b. :q 为（不保存）退出，:q! 为（不保存）强制退出； c. :wq 为保存并退出， :wq! 为强制保存并退出。 字母键作方向键：上下左右是 hjkl 四个。其中，最左的 h 是左，最右的 l 是右；而剩下的 jk 中，左边的 j 是下，右边的 k 是上。 有这些就基本够用了吧，还有新的就再来填坑。 deepin 无法在 vim 中使用 ctrl+shift+c/v 复制的解决办法我也不知道是什么原理，但是就是这样： 1echo \"set clipboard=unnamed\" &gt;&gt; ~/.vimrc 切换 sudo 并保存很多时候打开了一个只读文件，改完才发现没权限保存，要是退出了又得重改。 可以在 vi 中使用命令 :w !sudo tee % 保存。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"}]},{"title":"字符串数组以字典序排序","date":"2019-08-19T16:00:00.000Z","path":"cpp/cpp-grammar/lexicographical-order/","text":"12345678910bool operator &lt; (char * a,char * b)&#123; int l = min(strlen(a), strlen(b)); for (int i = 0; i &lt; l; i++) &#123; if (a[i] &lt; b[i]) return 1; if (a[i] &gt; b[i]) return 0; &#125; return strlen(a) &lt; strlen(b);&#125; 注意，就数字集合 {1, 2, 3, …, n} 的排列而言，这个集合的全排列本身可以看成是 n 进制的数，这种情况下，所有排列的字典序等价于所有按照全排列顺序把数字写成的数集合的升序。而不是把数转成字符串再按字典序排序！！！！！！ 顺便，1~11 的字典序排序为 1 10 11 2 3 4 5 6 7 8 9.","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"C/C++ 字节对齐（Byte alignment）","date":"2019-08-19T16:00:00.000Z","path":"cpp/cpp-grammar/c-byte-alignment/","text":"C/C++ 的结构，就像是一个将几种数据结构打包的功能。在使用的时候，可能会注意到，结构体的大小不等于结构体所有成员的大小之和,原因是编译器进行了字节对齐。 字节对齐的目的如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。比如在 32 位 CPU 下，假设一个整型变量的地址为 0x00000004（下面简写为 0x04），那它就是自然对齐的。 需要字节对齐的根本原因在于 CPU 访问数据的效率问题。32 位 CPU 把内存的每 4 个字节分为一组，一次可以同时访问一组。比如，可以同时访问 0x00 - 0x03，也可以同时访问 0x04 - 0x07，但不能同时访问 0x03 - 0x06。 若不进行字节对齐，假如一个 int 存储在了 0x03 - 0x06，那么读取这个 int 需要 CPU 读取两次内存，降低了效率。而进行了字节对齐，效率会有一定的提升。 这段话也解释了，64 位系统相比 32 位系统更大（由于字节对齐，需要更多的空位），但是运行速度会快一些（对于 8 字节的数据类型，如 long long 和 double 的读取会快一些）。 C 语言编译器对字节对齐的要求 标准数据类型：只要地址是它的长度的整数倍就行了； 数组：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。 联合：按其包含的长度最大的数据类型对齐。 结构体：结构体中每个数据类型都要按其包含的长度最大的数据类型对齐。 如 1234567891011struct foo&#123; char c10[10]; long long ll; char c;&#125;;int main()&#123; std::cout &lt;&lt; sizeof(foo); //输出 32&#125; 该结构中，c10 虽然只占 10 个字节，但是由于它要对齐 8 字节的 long long，因此会在 c10 后填充到 16 个字节（填充了 6 字节）。同样的， c 后面也会填充到 8 字节。整个结构占了 16 + 8 + 8 = 32 字节。 把上述代码的 long long 改为 int，整个结构占了 12 + 4 + 4 = 20 字节。 1234567891011struct foo&#123; char c10[10]; int i; char c;&#125;;int main()&#123; std::cout &lt;&lt; sizeof(foo); //输出 20&#125; 手动设置字节对齐在设计不同CPU下的通信协议时，或者编写硬件驱动程序时，寄存器的结构这两个地方都需要按统一字节对齐，所以需要手动设定字节对齐。 可以使用 #pragma pack() 语句设置字节对齐，如下： 12345678910111213#pragma pack (1) /*指定按2字节对齐*/struct foo&#123; char c10[10]; int i; char c;&#125;bar;#pragma pack () /*取消指定对齐，恢复缺省对齐*/int main()&#123; std::cout &lt;&lt; sizeof(foo); //输出 15&#125; 结构体占了 10 + 4 + 1 = 15 字节。","tags":[{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"C++ 结构体","date":"2019-08-18T16:00:00.000Z","path":"cpp/cpp-grammar/struct/","text":"C++ 中的结构体结合了类，于是就有很多很有意思的写法。 构造函数12345678struct teamS &#123; int s; //solved int p; //penalty teamS() &#123;&#125;; teamS(int _s = 1, int _p = 2):s(_s), p(_p)&#123;&#125;&#125;;teamS s(6,66); 重载 [] 使结构变为类似于数组的形式起初是看到 map 在这么用，试了一下，发现没有报错，有点香。 对一维数组重载，记得使用引用 &amp;。 123456789101112131415struct triple&#123; int first; int second; int third; int &amp; operator [](int i) &#123; switch (i) &#123; case 0: return first; case 1:return second; case 2:return third; &#125; &#125;&#125; 对二维数组的重载，使用的是指针 *，就不需要引用了。 12345678910struct matrix&#123; long long v[3][3] = &#123; 0 &#125;; long long * operator[](int i) &#123; return v[i]; &#125;&#125;m;m[1][2] == m.v[1][2]; 运算符重载C++引入了运算符重载，并有以下规则： 只能重载已有的运算符，已有的少部分也不能重载（::、# 等）； 重载以后的优先级不变。 运算符重载的格式为： 12345678910class Complex&#123; double real, imagine; public: /*...*/ Complex() &#123;&#125;; Complex(int r = 0, int i = 0) &#123;&#125;; Complex operator + (Complex num) &#123; /* */ &#125;&#125;c1,c2;c1 = c2 + 1;c1 = c2.operator+(1); 但是无法使用 c1 = 1 + c2，因为重载的 + 是属于 Complex 类的，而不是 int。 正确的使用方法是：把该重载声明为 Complex 类以外的函数（如果函数需要访问 Complex 的 private 成员，注意使用友元关键字） 1friend Complex operator + (Complex num, Complex C) &#123;/* */&#125; 这样，编译器就能愉快的把 int 转换为 Complex 了。 下面写几个值得一提的特殊的运算符重载。 类型转换函数把 int 当作一个一元操作符可还行。 12345678struct teamS &#123; int s; //solved int p; //penalty operator int() &#123; return s * 100 - p; &#125;&#125;; 重载 ++ 自增运算符 转自：https://blog.csdn.net/anye3000/article/details/6618495 我写类的时候，重载了 ++ 运算符，然后 date++ VS 报错。查了以后，才意识到，++ 分了前置/前缀形式和后置重载/后缀形式。 1234567891011121314151617181920class A&#123;private: int m_i;public: //++i A&amp; operator++() &#123; ++m_i; return *this; &#125; //i++ const A operator++(int) &#123; A tmp = *this; ++(*this); return A(tmp); &#125;&#125; 注意： 为了区分前后，用 ++() 表示前自增，用 ++(int)后自增。 **前自增应该返回引用 A&amp;**，因为按照前自增的标准定义，应该支持 ++++a 的语法，而且两次前自增都应该是对 a 对象的自身操作。如果返回A类型，那第二次前自增调用的是临时对象的前自增操作，和定义也不同； 后自增应该返回 const，这可以防止形如 a++++ 的用法。不能返回 const &amp;，因为实现里面返回的是临时的 temp，不能返回临时的指针。所以就涉及到了复制构造（Copy Construction）的问题了额。还是多用前自增吧…… 一般通过前自增操作来实现后自增操作符函数。 重载等于 =重载 = 和拷贝构造函数很相似，于是放在拷贝构造函数一节。 从基类派生出结构有点不可信，但确实可以。 In C++, a structure’s inheritance is the same as a class except the following differences: When deriving a struct from a class/struct, the default access-specifier for a base class/struct is public. And when deriving a class, the default access specifier is private.2009年6月11日– Struct inheritance in C++ - Stack Overflow 结构和类的区别真就只有 private 和 public 了？","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"Windows 控制台常用操作","date":"2019-08-18T16:00:00.000Z","path":"cpp/cpp-grammar/windows-console/","text":"参考链接：https://github.com/guyaqi/backups/blob/master/notes/cpp1-2.md Win32 API 的函数大多名称较长，如果不是有意向专门学习的话，没有太大的必要特地记住(用的时候还是会忘) 微软公司出产的各种 API，都可以在 msdn 找到详细的文档和简单的例子，如果你想了解某个 Win32 API 的所有用法，这是最权威的地方。 所有 Win32 API 都需要包含 Windows.h 头文件。 system() 函数直接执行 cmd 命令行的命令。对于在学 C++ 之前学命令行/批处理的人，这个用起来很香。 涉及字符串的函数这部分可能会有点坑。因为涉及到字符串编码，所以在英文上可能没什么问题，但是换成中文就会乱码。 摘自：https://github.com/guyaqi/backups/blob/master/notes/cpp1-4.md TCHAR 与 TEXT 宏,这两个宏在对应的情况下有不同的解释，这与你的编译器默认使用的编码方式相关。 当 UNICODE 宏被定义的时候（MSVC 编译器指令 /D UNICODE)，TCHAR 是 wchat_t，TEXT 宏被解释成 C 语言内部用来转换宽字符的宏 L&quot;somestr&quot; 如果没有定义 UNICODE 宏，TCHAR 就是 char，TEXT 宏不进行任何操作。 这种设定是在 utf-8 编码没有被广泛支持的时候,为了程序代码能够兼容使用不同代码的机器设定的，比如我使用的 win7 默认使用 gb2312（还是 gbk 来着）字符集对应的编码方式,而 win10 以上和其他使用 linux 内核的系统默认使用 utf-8 编码方式。 值得一提的是 utf-8 使用 char，而通常 C++，Java，C# 对 UNICODE 的支持指的是使用 utf-16 的编码方式，在 C++ 中 utf-16 字符就是 wchar_t（宽字符）。 简单的来说，C++ 有两种编码，一种是 ASCII 与其的拓展 UTF-8，另一种是 Unicode。C++ 默认使用的 char 是 ASCII 的，也就是说，你调用 Win32 API 时使用的是 char 字符串，但是程序按 Unicode 执行（Visual Studio 默认），那么就会出现乱码。（也可能出现编译错误，因为 wchar_t 和 char 是不能隐式转换的） 有三种解决办法： 一是将所有设计到字符和字符串的地方都改为 Unicode 流派的 wchar_t, wstring, wiostream 等等。如下面的程序： 12TCHAR title[] = TEXT(\"新标题\");setConsoleTitle(str); 不过，在涉及到 char 到 wchar_t 的转换时，容易出问题。貌似没有好的转换方法。也就是，要么全部用 Unicode，要么就不用 Unicode。 方法二是将涉及到这样的函数的后面加一个 A。原因是，Visual Studio 的源码是这样实现这些函数的： 12345#ifdef UNICODE#define SetConsoleTitle SetConsoleTitleW#else#define SetConsoleTitle SetConsoleTitleA#endif // !UNICODE 可以看到，这类函数都是用宏定义将函数分为两类，然后分开执行。第二种方法就是直接去执行带 A 的版本。 第三种方法就是取消 Unicode 的宏定义。具体在 Visual Studio 的 项目属性-&gt;配置属性-&gt;常规-&gt;字符集，设置为多节字符集（多字节字符集即没有设置UNICODE宏，使用Unicode字符集就是设置了 UNICODE 宏）。 设置的效果可以去 C/C++-&gt;预处理器-&gt;预处理器定义 查看 注意 QT-Addin 生成的 Visual Studio 项目默认是加上 UNICODE 宏，只去 项目属性-&gt;配置属性-&gt;常规-&gt;字符集 没用，还要手动把 QT-Addin 设置的 UNICODE 宏删掉。参考链接 程序信息部分中望龙腾 C++ 岗笔试考过。 123456789101112#include&lt;iostream&gt;#include&lt;direct.h&gt;using namespace std;int main()&#123; cout &lt;&lt; _getcwd(0, 0) &lt;&lt; endl // 获取当前文件夹 &lt;&lt; \"__FUNCSIG__:\" &lt;&lt; __FUNCSIG__ &lt;&lt; endl // 获取函数完整签名 &lt;&lt; \"__FUNCTION__:\" &lt;&lt; __FUNCTION__ &lt;&lt; endl // 获取函数名 &lt;&lt; \"__LINE__:\" &lt;&lt; __LINE__; // 获取行数&#125; 输出： 1234C:\\Users\\liu\\Desktop\\test\\cpp__FUNCSIG__:int __cdecl main(void)__FUNCTION__:main__LINE__:11 窗口部分窗口部分大多可以直接通过 system() 调用命令行的命令修改。 修改窗口标题一个是用 cmd 命令的版本： 1system(\"title newTitle\"); 好随意的标题 还有另一个版本，调用 Win32 API： 12TCHAR title[] = TEXT(\"新标题\");setConsoleTitle(str); 但是如果涉及到变量字符串，就会变得比较麻烦了，建议涉及到标题部分的变量的地方都使用 utf-16 的东西，如 wchar_t，wstring，wcout。如果需要 char 到 wchar_t 的转化。目前测试了 swprintf() 和 mbtowc() 函数，在配合 setConsoleTitle() 函数时均出现了问题。 如果必须使用 char，可以尝试下面的方法： 12char title[] = \"新标题\";setConsoleTitleA(title); 强制指定使用 char。貌似挺好用的。 修改窗口颜色1system(\"color 3f\"); 3 和 f 分别是用 16 进制数字表示的 foreground color 和 background color。具体对应关系可以自己在命令行中输入 color /?。 修改窗口大小1system(\"mode con: cols=120 lines=35\"); mode 语句有更多的用处不过看不懂 光标部分获取光标位置命令行上的光标位置是用 HANDLE 定义的。关于 HANDLE 是什么，可以自行 Google 或看这篇博客。 1HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); 注意到这个 handle 是随着输出的位置动态变化的，因此不需要在输入前后反复获取。 设置光标的颜色——以后输出内容的颜色12HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);SetConsoleTextAttribute(handle, (fc&lt;&lt;4) + bc); fc 和 bc 分别是用 16 进制数字表示的 foreground color 和 background color。具体对应关系可以自己在命令行中输入 color /?。 顺便附 https://github.com/guyaqi/backups/blob/master/notes/cpp1-2.md 的作业 CPP 文件。 下面是摘自 https://github.com/guyaqi/backups/blob/master/notes/cpp1-2.md 的一个 C++ 程序。 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;Windows.h&gt;int main()&#123; int fc, bc; HANDLE handle; handle = GetStdHandle(STD_OUTPUT_HANDLE); srand(time(0)); while (true) &#123; fc = rand() % 16; bc = rand() % 16; SetConsoleTextAttribute(handle, (fc&lt;&lt;4) + bc); putchar('#'); &#125; return 0;&#125; 设置光标的位置——设置以后输出内容的位置123HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);COORD coord = &#123;6,6&#125;;SetConsoleCursorPosition(handle, coord); 其中 COORD 类型包含两个成员 X 和 Y 表示坐标。cursor 翻译为光标。 1234typedef struct _COORD &#123; SHORT X; SHORT Y;&#125; COORD, *PCOORD; 不显示光标123HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);CONSOLE_CURSOR_INFO cursor = &#123;100,FALSE&#125;;SetConsoleCursorInfo(handle, &amp;cursor); CONSOLE_CURSOR_INFO 有两个成员：第一个 dwSize 表示光标占格子（高度）的百分比，范围是 1-100；第二个 bVisible 表示是否可见。 键盘按键获取按键状态12SHORT GetKeyState(int nVirtKey);SHORT GetAsyncKeyState(int nVirtKey); 首先，这个东西是获取执行函数时，某按键的状态，而不是类似于 cmd 的 choice。要是要等待输入的话，貌似要使用 for(;;) 的死循环语法（但是实测不会像 for(;;); 一样占用过高 CPU），个人感觉不是一个好的输入的形式（先挖个坑，以后来填）。 如果一定要用该方式进行输入，为防止语句运行过快导致某次短按按键被 getKeyState() 读多次，有两种输入形式： 可以在成功读入一个字符以后，应进行 Sleep(100)（100ms 是玄学调参的结论）。这样做的话，长按的按钮会每 100ms 被识别一次，但是短按后 100ms 以内其他操作无效。 可以用 while(getKey() &lt; 0) 读到按键结束为止。此方法把长按、短按都视为一次按键。 其次，这两个函数的区别也有点迷。理论上，前者是获取的 Windows message queue 里的信息（至于这是什么，我也不懂），后者是获取即时的硬件状态，Stack Overflow 上也建议使用后者，但是我在 Visual Studio 上测试的效果，其实是差不多的。（又挖坑） 再次，对于数字和（大写）字母，参数 nVirtKey 即是它的 ASCII 码。对于其他按键，可以查阅 MSDN 文档的虚拟键码部分。 最后，对于其返回值，由于按键有上（up）、下（down）和按住（toggled）、没有按住（untoggled），两两组合，共四种状态，因此表示也一共有四种状态。 参考链接：https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getkeystate 把 MSDN 的文档翻译过来就是，返回值的最高位是 1，表示该按键是按下的（down），反之则没有被按下（up）；返回值的最低位是 1，表示该按键被按住（toggled），如果最低位是0，则既没有被按下（up），也没有被按住（untoggled）。 下表是按键状态和对应的返回值： 按键状态 返回值 按下并按住（可理解为长按） 1000 0001（-127） 按下但不按住（可理解为短按） 1000 0000（-128） 不按下且没有按住 0000 0000（0） 不按下但按住（有点迷） 0000 0001（1） 关于按住（toggle）这个状态的理解有点迷。 但是若只需要判断是不是按下，那就可以忽略低位。一种实现是 GetKeyState(nVirtKey) &amp; 0x80，第二种是判断 GetKeyState(nVirtKey) &gt;= 0。 注意这里的 对于这段的理解还是挺迷的，不过以后需要的时候再来深究吧。 计时、获取系统时间戳见另一篇博客。 文件管理Directory Management就是命令行中获取当前文件夹、更改当前文件夹（即cd）等操作。 微软官方文档链接：Directory Management 12DWORD GetCurrentDirectory(DWORD BUFSIZE, TCHAR[] Buffer);bool SetCurrentDirectory(TCHAR[]) 具体详解请看微软官方文档 遍历文件需要 FindFirstFile FindNextFile 和 FindClose 函数。 具体详解请看微软官方文档 得到文件大小需要上面遍历文件得到的 File Handle。 1234DWORD GetFileSize( HANDLE hFile, LPDWORD lpFileSizeHigh); 第二参数可省。 具体详解请看[微软官方文档](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfilesize）","tags":[{"name":"Windows","slug":"Windows","permalink":"https://blog.lyh543.cn/tags/Windows/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.lyh543.cn/tags/Visual-Studio/"},{"name":"Win32 API","slug":"Win32-API","permalink":"https://blog.lyh543.cn/tags/Win32-API/"}]},{"title":"bitset","date":"2019-08-18T16:00:00.000Z","path":"cpp/cpp-grammar/bitset/","text":"数学的集合这个概念，可以用 C 的布尔数组实现。然而，使用 bool 类型，导致每一个元素都会占用一个字节。实际上，每一个字节理论上能存 8 个元素的状态，可以使用 char 或 int 数组来模拟。而 C++ STL 自带了一种数据结构，bitset，就不用自己手写啦。 声明12#include &lt;bitset&gt;using std::bitset; 定义和初始化1bitset&lt;32&gt; b; //32位，全为0。 给出的长度值必须是常量表达式。 位集合的位置编号从 0 开始，因此，bs 的位序是从 0 到 31。以0位开始的位串是低阶位（low-order bit），以31位结束的位串是高阶位(high-order bit)。 简单的来说就是，bitset 和数组一样，从 string 的角度看，string 的顺序和 bitset 顺序是相反的（string 的最后一位被赋给了 bitset 第一位）；从 unsigned long 的角度看，从左往右是从低位到高位。 bitset 有以下构造函数： 1234bitset&lt;n&gt; b; //b有 n 位，每位都为 0bitset&lt;n&gt; b(unsighed long u); //b是 u 的一个副本bitset&lt;n&gt; b(string s); //b是 s 中含有的位串的副本bitset&lt;n&gt; b(const * s, size_t pos, size_t n); //b是 s 中从位置 pos 开始的 n 位的副本 貌似不是很好懂，但只要记住以下形式等价即可： bitset&lt;8&gt; b(&quot;11000&quot;); bitset&lt;8&gt; b(24); //24(10) == 00011000(2) bitset&lt;8&gt; b; b[3] = b[4] = 1; 并且记住“过多则忽略高位，过少则置高位为 0” 的原则。 访问 bitset 的位使用 b[] 即可。 bitset 的一堆函数 函数名 函数作用 bool b.all() 检查 b 中是否全部位被设为 1 bool b.any() 检查 b 中是否任一位被设为 1 bool b.none() 检查 b 中是否无位被设为 1 size_t b.count() 返回设为 1 的位数 size_t b.size() 返回 bitset 的大小，即 bitset 定义参数中的 n bool b.test(pos) 类似 operator[]，但是进行越界检查，若越界则抛出 std::out_of_range b.set() 设置所有位为 1 b.set(size_t pos, bool value = true) 类似使用 b[pos] = value 赋值，但是进行越界检查，同上 b.reset() 设置所有位为 0 b.reset(size_t pos) 类似 于b[pos] = 0 赋值为 0，但是进行越界检查，同上 b.flip() 类似于 ~b，但是在原位，不进行 Copy Construction b[0].flip() 等价于 b[0] = ~b[0] b.flip(size_t pos) 仅翻转 pos 位（翻转 1 和 0），进行越界检查 输出 bitset 的函数1. to_string(char zero = &#39;0&#39;, char one = &#39;1&#39;)123456template&lt; class CharT = char, class Traits = std::char_traits&lt;CharT&gt; class Allocator = std::allocator&lt;CharT&gt;&gt; std::basic_string&lt;CharT,Traits,Allocator&gt; to_string(CharT zero = CharT('0'), CharT one = CharT('1')) const; 用 zero 表示 0，用 one 表示 1，返回 bitset 的 basic_string （大概是广义的 string？）形式。默认 to_string() 就是返回 bitset 的 01 串的 string。 2. to_ullong()unsigned long long bitset::to_ullong() 转换 bitset 的内容为 unsigned long long 整数。和构造 bitset 一样，bitset 的首位对应数的最低位，而尾位对应最高位。 如果不能用 unsigned long long 表示，则抛出 std::overflow_error。 （有意思的是，只有 bitset 的这两个函数会抛出 std::overflow_error 异常） 3. b.to_ulong()和上面一样，就是改下数据范围。 为什么介绍这么草率呢？因为 MSVC 的实现是先强转为 unsigned long long 再转为 unsigned long 判越界。貌似也没什么毛病.jpg 12345678_NODISCARD unsigned long to_ulong() const &#123; // convert bitset to unsigned long unsigned long long _Val = to_ullong(); unsigned long _Ans = (unsigned long)_Val; if (_Ans != _Val) _Xoflo(); return (_Ans);&#125; 题外话：bitset::any(), none(), all(), count() 的实现bitset::any()，bitset::none()，bitset::all()，bitset::count()，这四个函数都可以通过记录 count，每次修改时记录 count 的变化，来实现 O(1) 的时间复杂度，然而 MSVC 2017 和 GCC 4.7.1 的实现是 O(n) 的。 猜测原因是记录 count 的变化会在修改 bitset 时花费更多的时间，对于不使用这四个函数的用户，这样会使程序变慢。而对于需要 O(1)时间复杂度的用户，手动实现类似功能是很方便的。 但是平时使用的时候需要注意时间复杂度是 O(1) 的。 另外，在 bitset::count() 的实现上，GCC 使用了汇编指令 POPCNT，而 MSVC 使用的是如下的神奇代码： 1234567891011121314151617181920212223242526_NODISCARD size_t count() const noexcept &#123; // count number of set bits const char *const _Bitsperbyte = \"\\0\\1\\1\\2\\1\\2\\2\\3\\1\\2\\2\\3\\2\\3\\3\\4\" \"\\1\\2\\2\\3\\2\\3\\3\\4\\2\\3\\3\\4\\3\\4\\4\\5\" \"\\1\\2\\2\\3\\2\\3\\3\\4\\2\\3\\3\\4\\3\\4\\4\\5\" \"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\" \"\\1\\2\\2\\3\\2\\3\\3\\4\\2\\3\\3\\4\\3\\4\\4\\5\" \"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\" \"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\" \"\\3\\4\\4\\5\\4\\5\\5\\6\\4\\5\\5\\6\\5\\6\\6\\7\" \"\\1\\2\\2\\3\\2\\3\\3\\4\\2\\3\\3\\4\\3\\4\\4\\5\" \"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\" \"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\" \"\\3\\4\\4\\5\\4\\5\\5\\6\\4\\5\\5\\6\\5\\6\\6\\7\" \"\\2\\3\\3\\4\\3\\4\\4\\5\\3\\4\\4\\5\\4\\5\\5\\6\" \"\\3\\4\\4\\5\\4\\5\\5\\6\\4\\5\\5\\6\\5\\6\\6\\7\" \"\\3\\4\\4\\5\\4\\5\\5\\6\\4\\5\\5\\6\\5\\6\\6\\7\" \"\\4\\5\\5\\6\\5\\6\\6\\7\\5\\6\\6\\7\\6\\7\\7\\x8\"; const unsigned char *_Ptr = &amp;reinterpret_cast&lt;const unsigned char&amp;&gt;(_Array); const unsigned char *const _End = _Ptr + sizeof (_Array); size_t _Val = 0; for ( ; _Ptr != _End; ++_Ptr) _Val += _Bitsperbyte[*_Ptr]; return (_Val);&#125; 其实就是把每个 byte 的 256 种情况对应的 1 的数量打了个表。 Stack Overflow 上有人提到为什么 MSVC 不使用 POPCNT实现，POPCNT 比这样实现更快。 回答是 POPCNT 在部分 CPU 架构上的结果是不可预测的，而 MSVC 更想要跨架构的通用解决方案。 这篇博客的测试中显示， POPCNT 比打表形式快了约 2.7 倍。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://blog.lyh543.cn/tags/STL/"}]},{"title":"记大学短暂的ACM生涯","date":"2019-08-18T14:02:19.000Z","path":"cpp/acm/记大学短暂的ACM生涯/","text":"高中参加过 OI，大学里面自然对 ACM 比较感兴趣。在自我介绍的时候提了一句，有没有想一起参加 ACM 的还被同学听成了 SM。 但是在大一上的时候，因为闲着没事做，就又报了一个算法研究小组。两边都是很肝的。得放弃一边。我觉得 ACM 太功利了，就选择了算法小组。当时的观点是这样的： ACM 太功利了，现在参加的人越来越多，也很大程度上是为了拿奖； ACM 很多做法太套路化了，为了最快的解题，甚至需要背代码； 和高考、其他竞赛一样，一考定终身的形式太残酷了，要是发挥失常，就只有等下一年、等不起的就必须放弃。 但是不巧的是，大一下的时候，算法小组组会的时间和程序设计课程 完 全 冲 突。于是那边就不得不咕咕咕了。 正好 ACM 这边，学校在准备校赛，我就和室友一起去参加。初赛因为考的比较基础，甚至有算矩阵行列式的题。当时好像是 17 个题，我们两个人（另外一个室友咕咕咕了）做了 11 个题。 校赛初赛截图 决赛题很难，但是我们三个人各做了一个题，摸了一个校二等奖。我做的是一个枚举所有情况的暴力题，数据范围 10，正好 $O(n!)$，暴力莽过，拿了一血。 后来就发现其实大家也不是那么强，说不定还是可以去参加一下，摸一个奖的。然后就又入坑了。 大一下的暑期前集训里面，两周一个专题，每个专题有10-20个题，包括了很多我在 OI 没有接触过的算法，比如线段树、树状数组、前缀和、仅仅听过名字的 KMP、AC自动机等等等等。可以说是在那段时间学到了很多东西了很多新知识。不过那段时间的基础学科就不怎么样了。 后来顺便就参加了暑期集训，因为是打算拿奖的，就得参加比赛，然后进校队 blah blah 的。一开始感觉表现还可以，能够偶尔几名，但是集训后期就慢慢掉下去了，掉到了26名。感觉这段时间每天中午加下午五小时队内赛，晚上累的不想补题（不想思考，但是会强迫自己去补一些小的知识点，补题就算了，学新的算法也不行，头晕），由于室友每天两点~四点睡，我也很难早睡，每天起的很晚，也没有时间补题。导致我每天说“明天必补线段树（莫队）”，但是都没有补。这么想想，相同的时间里，暑期集训学到的东西甚至没有我暑期前集训在课余时间学的更多（也可能是暑期前集训就是专门学知识，暑期集训就是专门打比赛练手感，而我前期太摸了，导致后期就很废物）。然后作息也比较奇怪，不能午觉，每天被迫晚睡晚起，比赛的状态也越来越差。这样的状态，加上本来就没学到什么大的知识点，于是就不想参加二轮集训了，也不想继续打 ACM 了，毕竟前面提到的三个原因还是有一点影响的。 现在我在乐山的家里敲着这篇文章，也算是给我的 ACM 生涯画一个句号吧。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://blog.lyh543.cn/tags/%E6%9D%82%E8%B0%88/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"}]},{"title":"Copy Assignment & Constructor","date":"2019-08-17T16:00:00.000Z","path":"cpp/cpp-grammar/cpp-copy-assignment-and-constructor/","text":"123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class Test&#123; public: Test() &#123;&#125; Test(const Test &amp;t) &#123; cout&lt;&lt;\"Copy constructor called \"&lt;&lt;endl; &#125; Test&amp; operator = (const Test &amp;t) &#123; cout&lt;&lt;\"Assignment operator called \"&lt;&lt;endl; &#125;&#125;;int main()&#123; Test t1, t2; t2 = t1; // calls assignment operator, same as \"t2.operator=(t1);\" Test t3 = t1; // calls copy constructor, same as \"Test t3(t1);\" return 0;&#125; output: 12Assignment operator calledCopy constructor called Copy constructor is called when a new object is created from an existing object, as a copy of the existing object (see this G-Fact). And assignment operator is called when an already initialized object is assigned a new value from another existing object.","tags":[{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://blog.lyh543.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"Lutece 速度","date":"2019-08-17T16:00:00.000Z","path":"cpp/acm/Lutece速度/","text":"long long 运算 int 运算 double 运算 2e9次 406ms 2e9次 395ms 2e9次 794ms 1000ms 5e9次 5e9次 2.5e9次 12345678//int testint main()&#123; int a =0; for (int i =0;i&lt;1e9;i++) a += i; return a;&#125; 12345678//long long testint main()&#123; long long a =0; for (long long i =0;i&lt;1e9;i++) a += i; return a;&#125; 12345678//double testint main()&#123; long double a = 0; for (long double i = 0; i &lt; 1; i += 1e-9) a += i; return a;&#125;","tags":[{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"}]},{"title":"最长上升连续子序列 LIS","date":"2019-08-17T16:00:00.000Z","path":"cpp/acm/最长上升连续子序列_LIS/","text":"贪心，二分搜索，O(nlogn) 注意 lower_bound 和 upper_bound 的选择：upper_bound 是不下降子序列，lower_bound 是上升子序列。因为上升子序列的 LIS 里面一个数不能排在相同的数的后面，所以这个数必须要找到 lower_bound() upperbound() 的 last 参数取不到这个点，类似于end()lower_bound 和 upper_bound 123456789101112131415161718192021222324//上升子序列//leng[i]: max lis length from a[0] to a[i]//lis[i]: least last number of a i-length lisvoid getLIS(int a[], int lis[], int leng[])&#123; int maxlen = 0; lis[1] = a[0]; int len = 1; // length of lis leng[0] = 1; for (int i = 0; i &lt; n; i++) &#123; if (a[i] &gt; lis[len]) &#123; lis[++len] = a[i]; leng[i] = len; &#125; else &#123; leng[i] = upper_bound(lis+1, lis + len+1, a[i]) - lis; lis[leng[i]] = a[i]; &#125; maxlen=max(maxlen, leng[i]); &#125;&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"一句话描述的算法","date":"2019-08-17T16:00:00.000Z","path":"cpp/acm/oneline-algorithm/","text":"求逆序对数：用归并排序，计数交换的次数 用 scanf 读 string （即使关了同步，cin 读 string 太慢）：——2019.7.20 用 scanf 读 char，然后使用 string operator +=。 看到 1e18 就可以考虑二分了。二分天下第一。 ——2019.7.21 给定 $0 \\leq k \\leq 1e18$，在 $1e9$ 内找到四个数 $x_1, x_2, y_1, y_2$，使得 $x_1 y_2 - x_2 y_1 = k$。（AGC 036A）——2019.7.22 令 $x_1=1e9, y_1=1$，即可算出符合条件的 $x_2, y_2$。 线段覆盖问题中，要求用尽量少的边，覆盖指定区域（Vjudge）——2019.7.24 按左边界从先到后（相同时右边界从后到先）插入优先队列。当前处理的边的左边界若早于当前时间，则修改为当前时间再重新入队。 给定长度为 $n$ 迭代无序数列，$O(n)$ 求第 $k$ 大 ： 使用快排，但是一次排序以后，只排 k 存在的那部分。若快排选的中间数合适，均摊下来是 $O(n + \\frac{n}{2} + \\frac{n}{4} + …) = O(n)$。 分治复杂度计算：——2019.9.19 若 $T(n) = k \\cdot O(\\frac{n}{2}) + \\Theta(n)$，则 $T(n) = O(n^{log_2 k})*T(1)$。（构造等比数列证明） 矩阵求逆：——2019.9.20 目前最快的矩阵求逆法仍然是 $O(n^3)$ 的。但是将矩阵用高斯消元法分解为上三角形矩阵和下三角形矩阵的乘积，然后分别求逆矩阵，该算法（LU）虽然和高斯消元法是时间复杂度相同，但是可以进行并行计算。 $\\Theta(n)$ 生成 1-n 的随机排列—— Fisher–Yates Shuffle 洗牌算法。 123for (int i = 0; i &lt; n; i++) arr[i]=i+1;for (int i = 0; i &lt; n; ++i) swap(arr[i],arr[random(i, count) ]); //random(i, count) 指 [i, count] 区间上的随机数 可以用数学归纳法证明其正确性。——2019.10.16 $O(\\log s)$ 计算二进制数中有多少个 1—— 2020.10.23： 12345678int bitCount(int z) &#123; z = (z &amp; 0x55555555) + ((z &gt;&gt; 1) &amp; 0x55555555); z = (z &amp; 0x33333333) + ((z &gt;&gt; 2) &amp; 0x33333333); z = (z &amp; 0x0f0f0f0f) + ((z &gt;&gt; 4) &amp; 0x0f0f0f0f); z = (z &amp; 0x00ff00ff) + ((z &gt;&gt; 8) &amp; 0x00ff00ff); z = (z &amp; 0x0000ffff) + ((z &gt;&gt; 16) &amp; 0x0000ffff); return z;&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数论","slug":"数论","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"auto 和 decltype 类型","date":"2019-08-16T16:00:00.000Z","path":"cpp/cpp-grammar/auto-decltype/","text":"auto1auto i = 1; auto 和 const 引用引用字面常量需要手动 const，引用类型常量就自带 const 了 12345678int i;const int ic = I;auto &amp;ri = i; // int &amp;ri=iauto &amp;rc = ic; // const int &amp;rc=ic, 顶层constauto &amp;r0=4.3 //错误，不能够将非常绑定到常数const auto &amp;r1=4.3 //正确 一条auto可以同时定义多个变量，但数据类型只能有一种。 12auto x = 3, y = 12, z = 30; //正确，x,y,z为int类型auto a = 3, b = 3.2; //错误，a和b的类型不同 decltype12decltype(表达式1) 变量=表达式2；decltype((表达式1)) 变量=表达式2; //定义引用 从表达式1的结果类型定义变量，并用表达式2的值初始化量。 当表达式1是变量时，decltype不会忽略顶层const，其结果是定义与表达式1相同类型的变量（包括顶层const和引用在内）。 不懂 用双重括号把表达式括起来时，定义的一定是引用。而用单括号时，只有当变量本身是引用时，定义的才是引用。 decltype 和 const 引用引用字面常量和常量表达式需要手动 const，引用类型常量就自带 const 了 样例： 123456789int i = 10, j,*p=&amp;i,&amp;r=i;const int ic = i,&amp;cj=ic;decltype(i + 3.4) x = 9; // double x;decltype(ic + 3) y1; // int y1;decltype(ic) y2 = 4; // const int y2=4;//decltype(ic) y3; // 错误，const int y3decltype(p) p1; // int *p1decltype((i)) ri = j; // int &amp;ri=jdecltype(*p) rp = i; // int &amp;rp=i atuo decltype 和 数组在处理数组的问题上，auto将对象定义为指向数组第一个元素类型的指针，decltype采用与数组完全相同的类型变定义数组。 123int a[] = &#123;1,2,3,4,5&#125;;auto p1 = a; // 等价： int *p1decltype(a) p2; // 等价： int p2[5]","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"lower_bound() 和 upper_bound() 返回值","date":"2019-08-16T16:00:00.000Z","path":"cpp/cpp-grammar/lowerbound-upperbound/","text":"结论 lower_bound() 是第一个大于等于 value 的数upper_bound() 是第一个大于 value 的数 如果需要小于（小于等于），可以使用： lower_bound() - 1 是最后一个小于 value 的数upper_bound() - 1 是最后一个小于等于 value 的数 lower_bound() 和 upper_bound() 在 set/multiset/map/multimap 中仍可用（作为成员函数使用），其中 map 只能搜索第一个元素（毕竟是以第一个元素排序的）。 测试数据 1 2 2 2 3 3 4 5 lower_bound(2) = 1:a[1-1] = 1a[1] = 2a[1+1] = 2 upper_bound(2) = 4:a[4-1] = 2a[4] = 3a[4+1] = 3 测试代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; const int n = 8; int a[n] = &#123; 1,2,2,2,3,3,4,5 &#125;; for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"lower_bound: \" &lt;&lt;endl; int l = lower_bound(a, a + n, 2) - a; cout &lt;&lt; \"a[\" &lt;&lt; l &lt;&lt; \"-1] = \" &lt;&lt; a[l - 1] &lt;&lt; endl; cout &lt;&lt; \"a[\" &lt;&lt; l &lt;&lt; \"] = \" &lt;&lt; a[l] &lt;&lt; endl; cout &lt;&lt; \"a[\" &lt;&lt; l &lt;&lt; \"+1] = \" &lt;&lt; a[l + 1] &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"upper_bound: \" &lt;&lt; endl; l = upper_bound(a, a + n, 2) - a; cout &lt;&lt; \"a[\" &lt;&lt; l &lt;&lt; \"-1] = \" &lt;&lt; a[l - 1] &lt;&lt; endl; cout &lt;&lt; \"a[\" &lt;&lt; l &lt;&lt; \"] = \" &lt;&lt; a[l] &lt;&lt; endl; cout &lt;&lt; \"a[\" &lt;&lt; l &lt;&lt; \"+1] = \" &lt;&lt; a[l + 1] &lt;&lt; endl;&#125;","tags":[{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://blog.lyh543.cn/tags/STL/"}]},{"title":"Visual Studio C++","date":"2019-08-16T16:00:00.000Z","path":"cpp/cpp-grammar/header-files-for-Visual-Studio/","text":"格式化代码Visual Studio 2017，在 编辑 - 高级 - 设置文档的格式。快捷键为 Ctrl+D，Ctrl+E。 给Visual Studio的头文件catch.hppbits/stdc++.h 放到C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\VC\\Tools\\MSVC\\14.15.26726\\include目录下 因版本不同而不同 通过宏定义判断1#ifdef _MSC_VER 更改程序编码1#pragma execution_character_set(\"utf-8\") 预编译头 pch.h 或 StdAfx.h预编译头的作用用 Visual Studio 编程的小白都有过这样的经历：每次新建一个项目都会给我建一个 pch.h （或 StdAfx.h，下略），删掉以后还不能通过编译，还得到设置里面关掉。 今天在刷知乎：什么c++要“在头文件中声明，在源文件中定义”？的时候，突然看到了预编译头这四个字，于是打算研究一下。 预编译头的出现，还得从 C/C++ 程序编译原理说起。 #include是什么？一条预处理指令。于是你就需要搞清楚预处理在c++程序的编译过程中大约发生在什么环节。以下引用 cppreference.com: The preprocessor is executed at translation phase 4, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler. C++ 的预处理器在编译之前执行，它看到 #include 指令，就会把那个文件的内容替换到当前位置。其它的预处理指令例如#define、#ifdef 等也在这个阶段被执行、并产生相应的内容。预处理器执行完成后，所有的预处理指令都会被移除。其结果是一个单个头的大文件（我猜测这文件只存在于内存里），这个文件才会被进一步传给编译器做编译。 也就是说，对于每一次 #include，都会把被 include 文件复制进源代码，得到一个超级长的代码。这也解释了重复编译头文件是不被 Visual Studio 允许的：不然会出现重名函数。 于是，出现了预编译头： 我们把一些不经常修改的代码放到 pch.h 文件里（通常是 #include 系统的头文件、宏定义 #define）。之后进行编译的时候，系统先将预编译头编译为 .pch 文件，再编译我们的其他 .cpp 文件。在之后的编译，要是 pch.h没有发生修改，则不会重新编译该文件。由于系统自带的库文件很大，不重新编译这些文件，能够加速我们后期的编译过程。 同时，引用的这一段话也解释了，为什么单独的 pch.h 文件不能编译，必须要有一个仅有 #include&quot;pch.h&quot; 一句话的 pch.cpp：C/C++ 是不直接编译 pch.h 文件的，是把该文件的代码复制到了 pch.cpp 文件，然后对 pch.cpp 文件进行编译的。 预编译头的使用方法 现在 Visual Studio 新建项目都是自带了预编译头的，如果没有，需要自己创建一个 .h 和同名的 .cpp 文件，名字可以自取，不过 Visual Studio 使用的是 pch.h。 如果是自己创建，还需要把 项目 - （项目名）属性 - C/C++ - 预编译头 - 预编译头 改为 使用（/Yu），后面的文件名改为刚才新建的 .h 文件。 如果是新建的项目，上面 Visual Studio 已经帮我们做好了，我们以后只需要： a. 在预编译头文件中加入不经常修改的预处理命令，如 #define、#include 系统头文件或第三方库的头文件； b. 在所有你的 .cpp 文件的第一句写上 #include 你的预编译头（必须是第一句，不然编译不过）； c. 如果你的其他自定义的 .h 文件不需要库函数，可以不包含预编译头，否则写上； d. 不用管预编译头的同名 .cpp 文件。","tags":[{"name":"Microsoft","slug":"Microsoft","permalink":"https://blog.lyh543.cn/tags/Microsoft/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.lyh543.cn/tags/Visual-Studio/"}]},{"title":"Hexo Material 主题配置","date":"2019-08-16T16:00:00.000Z","path":"blog/hexo-material/","text":"Material 主题是一个基于 Material Design （质感设计）的 Hexo主题。 Hexo 更换主题的方法参见另一篇博客。 在网上找到了一个配置过程非常详实的博客，而且还修复了一些主题的小 bug，基本上按照这个博客做就好啦。 几个 bug但是按照这篇博客做了之后，还是有几个小问题： bug1：无法本地搜索要实现本地搜索，除了安装hexo-generator-search插件外，还要把主题配置文件的search.use从google修改为local。 123456# Search Systems# Available value:# swiftype | google | localsearch: use: local swiftype_key: bug2：图表显示不全原主题配置文件的图标包是从googleapis在线获取的，由于众所周知的原因，大陆不能顺利访问。但是主题配置文件中提供了镜像站的选项，把google改成中科大的镜像站ustc就可以正常显示图标了。 1234fonts: family: Roboto, \"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\", \"微软雅黑\", Arial, sans-serif use: ustc custom_font_host: bug3：代码高亮也有问题如下图。 highlight 这个在Material主题的Issues被大量提及。 解决方法步骤： 关掉主题配置文件的hanabi高亮，并开启prettify高亮； 123456789prettify: enable: true theme: \"github-v2\"hanabi: enable: false line_number: false includeDefaultColors: true customColors: 在站点配置文件里，关掉 Hexo 自带的所有 Highlight。 12345highlight: enable: false line_number: false auto_detect: false tab_replace: 下一次执行hexo g之前先hexo clean 放一个我的主题配置文件 改名以后，直接覆盖_\\themes\\material\\_config.yml就可以了，也可以做一些自己的修改。 页面计数——不蒜子Material 里面自带了不蒜子的。在主题配置文件里面打开开关，然后更换一下不蒜子的链接（原服务器倒闭了）就可以了。这个挺简单的。 1234567# _config.yml# Busuanzi 不蒜子 Viewsbusuanzi: enable: true all_site_uv: true post_pv: true busuanzi_pure_mini_js: \"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\" 推荐插件插件等配置可以参照这个 【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 一些插件的链接 hexo-generator-search 下载安装插件，需要在博客根目录使用下面这句命令 1npm install &lt;package name&gt; --save 一定要加--save参数，这样该插件才会被加入该项目的dependencies中，下次生成hexo的时候才会被编译。 插件具体使用方法建议去看各插件的github项目的README.MD文件。 博客置顶插件 摘抄自：【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 安装插件： 12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上 top 即可： 12345---title: 2018date: 2018-10-25 16:10:03top: 10---","tags":[{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"}]},{"title":"bash 笔记","date":"2019-08-15T16:00:00.000Z","path":"linux/bash/","text":"入坑 Linux 以后，命令行也是一个非常重要的工具。本文简单总结一下常用的 bash 语法。 这里只讲纯语法，文件操作、系统工具等可以看 Linux 日常。 cheatsheet 变量赋值 = 左右不能有空格 if = 左右都要有空格 var=$s 等价于 var=${s} var=$(echo 123) 等价于 var=$`echo 123` 多条语句串行执行：echo 1; sleep 1; echo 2 多条语句并行执行：echo 1 &amp; echo 2 多条语句等待前一句正确执行后执行：echo 1 &amp;&amp; echo 2 命令行末加 \\ 可使得命令跨行 for：for ((i=1; i&lt;=10; i ++)); do echo $i; done 或者：for i in {1..10}; do echo $i; done 变量对变量名的要求和 C/C++ 相同。 1var=123 注意等号左右都不能有空格。左边有空格，var 会被视为命令；右边有空格，123 会被视为命令。（而 bash 的 if 则强制要求等号左右必须有空格） 若赋值有空格，可以使用引号括起来，赋值的结果没有引号。 123$ var=\"123 456\"$ echo $var123 456 在变量名前加 $ 即可。也可以把变量名用大括号括起来。 12echo $varecho $&#123;var&#125; 值得注意的是，也可以把命令执行的结果看作是一个取值的过程，如下： 1234var=`command`var=$(command)echo the current time is $(date +%c) 后者支持嵌套。 输出echo 使用较简单。 需要看 echo 的帮助请使用 man echo 而不是一般的 echo --help。 一行一语句？bash 默认是一行一条命令。但是某些特殊符号可以打破这个规定： ; 使得一行多个命令。和一般情况相同的是，命令是串行执行： 1echo 1; sleep 1; echo 2; 输出 1，停顿一秒，然后输出 2。 &amp; 使得一行多个命令。和一般情况相同的是，命令是并行执行： 1echo 1; sleep 1 &amp; echo 2 这里的 echo 2 和 sleep 1 同时执行，所以用户并不会感觉输出 1 和 2 间出现了停顿。 bash 的具体实现是，会创建一个新进程执行 &amp; 前的代码（同时会将新进程的 pid 显示在屏幕上如 [1] 174），然后主进程继续执行这行之后的代码。 顺便，这里的 &amp; 配合 for 可以实现并行 for 语句。nb！ &amp;&amp; 使得一行多个命令。但是，只有前面的命令没有出错，才会执行后面的命令。（显然命令需要串行执行）： 12345ping localhost -c 1 &amp;&amp; echo 2# ping 成功执行，然后输出 2ping whatthefuck -c 1 &amp;&amp; echo 2# ping 失败，不输出 2 \\ 使得多行一个命令。常用于参数较多时，将命令参数分行写。 123456ffmpeg \\ -allowed_extensions ALL \\ -hwaccel cuda -i \\ 117652-8.m3u8 \\ -c:v h264_nvenc \\ 8.mp4 流程控制条件判断循环有个 C 语言风格的： 1234for ((i=1; i&lt;=10; i ++))do echo $idone 写成一行的版本： 1for ((i=1; i&lt;=10; i ++)); do echo $i; done 除此之外，还有： 1234for i in &#123;1..10&#125;do echo $i # 显示 1 至 10done 同样可以写为单行的版本： 1for i in &#123;1..10&#125;; do echo $i; done","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.lyh543.cn/tags/Linux/"}]},{"title":"C++ stringstream","date":"2019-08-15T16:00:00.000Z","path":"cpp/cpp-grammar/stringstream/","text":"参考博客: http://www.usidcbbs.com/read-htm-tid-1898.html C++ 的 iostream 输入输出流很好用，而它也有两个兄弟：fstream 和 sstream （或 stringstream），三个的用法差不多，能够触类旁通，就很舒服。本文就介绍一下 stringstream 和 iostream 的相同和不同的地方。 iostream 和 stringstream 的继承关系 iostream 和 stringstream 引入头文件和定义变量1234#include&lt;sstream&gt;std::istringstream istr;std::ostringstream ostr;std::stringstream sstr; 其中，istringstream 用于流的输入，ostringstream 用于流的输出，stringstream 用于流的输入输出。具体的区别在下面提到。 istringstream 使用方法cin 是从控制台读取数字、字符串，而 istringstream 就是从指定的字符串中读取数字、字符串。 首先指定 istringstream 读取的源字符串。下两种形式是等价的： 1234istringstream istr1;istr1.str(\"12 3.1415\");istringstream istr2(\"12 3.1415\"); 然后用类似于 cin 的语法就可以从该字符串读取数字等了。 123int a;float b;istr1 &gt;&gt; a &gt;&gt; b; //a==12, b==3.1415 ostringstream 使用方法cout 是把内容往屏幕上输出，而 ostringstream 就是把内容往字符串输出。 ostringstream 是先读入数字等内容到该 ostringstream，然后获取该 ostringstream 中存的字符串。 1ostr &lt;&lt; a &lt;&lt; b;//a==12, b==3.1415 读取 ostringstream 中的字符串需要使用成员函数 str()。 12cout &lt;&lt; ostr.str() &lt;&lt;endl;cout &lt;&lt; ostr.str().length() &lt;&lt; endl; 成员函数 str() 返回一个 string。搭配头文件 string 就可以使用 string 类的各种功能。注意该函数也可以在 istringstream 和 stringstream 中使用，同样是获取流中存储的字符串。 ostringstream 同样可以赋初值，但是在进行输入的时候，输入的东西会先修改初值的对应部分，输出超过原长的那一部分才会追加到串的后面。 123456ostringstream ostr(\"abc\");ostr.put('d');ostr.put('e');cout &lt;&lt; ostr.str() &lt;&lt; endl;ostr &lt;&lt; \"fg\";cout &lt;&lt; ostr.str() &lt;&lt; endl; 上面这段代码输出： 12decdefg stringstream 使用方法stringstream 就可以同时进行输入和输出了。（但是好像用的不多，故略）","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"C++ string","date":"2019-08-13T16:00:00.000Z","path":"cpp/cpp-grammar/string/","text":"string.length() 的复杂度在 C++ 11 以前是未定义，在 C++ 11 及以后为常数，使用时须注意。 字符串字面量R &quot;分隔符( 原始字符 )分隔符&quot; 示例：R&quot;66(\\njjnb/)66&quot; == &quot;\\\\njjnb/&quot; 其他语言的类似情况可参考 逐字字符串在各语言中的表达式。 分隔符也可以为空。示例 2：&#39;R(njjnb)&#39; == &#39;\\\\njjnb/&#39; 另有 L, u8, u, U 作为前缀，类似于66L,表示长char、UTF-8、UTF-16、UTF-32字符。 string_literal cin &gt;&gt; string 的细节只以空格为分隔符。输入 123:123，str 即为 123:123。 string 和 iostream 的关系 转载自：https://www.cnblogs.com/Solstice/archive/2011/07/17/2108715.html iostream 可以与 string 配合得很好。但是有个问题：谁依赖谁？ std::string 的 operator &lt;&lt; 和 operator &gt;&gt; 是如何声明的？string 头文件在声明这两个 operators 的时候要不要 include iostream ？ iostream 和 string 都可以单独 include 来使用，显然 iostream 头文件里不会定义 string 的 &lt;&lt; 和 &gt;&gt; 操作。但是，如果 string 要include iostream，岂不是让 string 的用户被迫也用了 iostream？编译 iostream 头文件可是相当的慢啊（因为 iostream 是 template，其实现代码都放到了头文件中）。 标准库的解决办法是定义 iosfwd 头文件，其中包含 istream 和 ostream 等的前向声明 (forward declarations)，这样 string 头文件在定义输入输出操作符时就可以不必包含 iostream，只需要包含简短得多的 iosfwd。我们自己写程序也可借此学习如何支持可选的功能。 值得注意的是，istream::getline() 成员函数的参数类型是 char*，因为 istream 没有包含 string，而我们常用的 std::getline() 函数是个 non-member function，定义在 string 里边。 我注：这也解释了，cin 的所有成员函数都不支持 string，只能只用非成员函数 getline（在 string 中） 或 operator &gt;&gt;（在 xstring 中）。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"(unoredered_)(multi)map & 离散化","date":"2019-08-03T16:00:00.000Z","path":"cpp/cpp-grammar/map/","text":"在 ACM 中经常会接触到数据范围 $10^9$，数据个数 $ 2\\times10^5$ 的题，这种题按数据范围开数组都开不下，但是数据没有出现过的数据就没有用，于是可以只讨论那 $ 2\\times10^5$ 个数。这个时候，就需要一个把不连续的 $(12,324,76)$ 映射 (map) 到连续的 $(1,2,3,…)$ 上的方法。 map 分为 treemap 和 hashmap。treemap 是树状结构，自带排序和二分搜索功能，但是插入、查询、删除的算法里面也就会带一个 $O(log n)$。hashmap 是由哈希值实现的，插入、查询、删除的算法复杂度是 $O(1)$，但是没有排序、不能二分，据说遍历的效率也会很低。 hashmap unordered_maphashmap 在 C++ 中叫做 unordered_map. 头文件及定义变量123#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int&gt; m; 如果 unordered_map 的第一个元素是自定义类型，可能还需要自定义 hash_value 函数并且重载 operator==。map：我只需要重载 operator&lt;，来用我呀 1234567891011121314151617181920struct person&#123; string name; int age; bool operator== (const person&amp; p) const &#123; return name==p.name &amp;&amp; age==p.age; &#125;&#125;;size_t hash_value(const person&amp; p)&#123; size_t seed = 0; std::hash_combine(seed, std::hash_value(p.name)); std::hash_combine(seed, std::hash_value(p.age)); return seed;&#125;unoreder_map&lt;person,int&gt; m; 另外，理论上 unordered_map 是包含在 bits/stdc++.h 里的，但是 Visual Studio 识别不到。原因是 bits/stdc++.h 中包含 unordered_map 有一句预处理 #if __cplusplus &gt;= 201103L，但 Visual Studio 过不了。 存储数据，建立映射很亲民。 123m[\"njj\"] = 1;m[\"xj\"] = 2;m[\"lyh\"] = -1; 寻找元素、输出如果存在这个映射，则直接输出就好了。 1cout &lt;&lt; m[\"lyh\"] &lt;&lt; endl; //输出 -1 但如果不存在，并尝试访问，则会自动建立映射（映射值为默认），然后输出。 1cout &lt;&lt; m[\"yg\"]; //会自动生成(\"yg\",0)，然后输出 0 ，故不能检测该元素是否存在 需要检测是否存在的话，一定要用 find()==end() 这个套路。 12if (m.find(\"kj\") != m.end()) //检查元素是否存在 cout &lt;&lt; m[\"kj\"]; 删除映射1m.erase(\"yg\"); 遍历元素和 STL 容器的遍历是一样的： 1234for (unordered_map&lt;string,int&gt;::iterator iter = m.begin(); iter != m.end(); iter++)&#123; cout &lt;&lt; iter-&gt;first &lt;&lt; \" \" &lt;&lt; iter-&gt;second &lt;&lt; endl;&#125; 或者 1234for (pair&lt;string,int&gt; p : m)&#123; cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl;&#125; 很有意思的是，(unordered_)map 的元素是 pair。这样正好能够存两个数。 但是请注意，unordered_map 的遍历效率并不高（大概是把 hash 表遍历了一遍），有需求请使用 map。 map 的更多的操作map：上面的操作我都有！C++ 中 map 的实现是红黑树，因此可以遍历、保证有序、二分搜索。 map 和 unordered_map 定义中的不同如果 map 的第一个元素是自定义类型，可能还需要重载 operator&lt;。 map 的遍历对 map 的遍历实际上是对树的遍历，所以操作较 unordered_map 一样快。 但是遍历方法和 unordered_map 是一样的。 1234for (map&lt;string,int&gt;::iterator iter = m.begin(); iter != m.end(); iter++)&#123; cout &lt;&lt; iter-&gt;first &lt;&lt; \" \" &lt;&lt; iter-&gt;second &lt;&lt; endl;&#125; 或者 1234for (pair&lt;string,int&gt; p : m)&#123; cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl;&#125; map 的二分搜索同样是超级好用的 lower_bound() 和 upper_bound()，返回值是 map 的 iterator。不过这里这两个函数做的是 map 的成员函数。 1map&lt;string,int&gt;::iterator iter = m.lower_bound(\"njjnb\"); multimap由于 multimap 不再是单射的关系，也就不能使用 m[1] 的形式访问元素。具体有什么用，感觉挺没用的，要是打脸了以后就来填坑吧。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://blog.lyh543.cn/tags/STL/"}]},{"title":"牛津通识读本","date":"2019-08-03T16:00:00.000Z","path":"others/very-short-introductions-oxford/","text":"怎么学数学 数学总是持续在自身的基础上构建，所以学习时的步步跟进就显得很重要。数学中常常会引入重要的新思想，新思想会比旧思想更加复杂，每一个新思想的引入都有可能把我们甩在后面。人们在学习高等数学时，走到一个证明的结尾处，通常会经历这样的思考：“我理解每一行是怎样由前一行得到的，但是我却不明白为什么这个定理是正确的，人们是怎样想到这个论证的。”我们经常想从证明中得到更多的东西，而不仅仅是确信它的正确性。对于数学，不要问它是什么，而只要问它能做什么。考虑规则，而不是考虑概念本身。按这种观点，数字就可以被当作某种游戏中的记号。 ——《牛津通识读本：数学》 数学中的“显然” 如果脑子里立刻就有证明，那么这条陈述才是显然的。 ——《牛津通识读本：数学》","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"C/C++ 获取秒级、微秒级、纳秒级时间戳","date":"2019-08-01T16:00:00.000Z","path":"cpp/cpp-grammar/time/","text":"转自：https://blog.csdn.net/CAIYUNFREEDOM/article/details/75388111http://sodino.com/2015/03/20/c-time-micro-nano/ 获取时间戳（s 级）1234//in &lt;time.h&gt;time_t t= time(NULL);std::cout&lt;&lt;\" s秒级 ----:\";std::cout&lt;&lt;t&lt;&lt;endl; Linux 下获取系统时间的时间戳（μs, ns 级）unistd.h 和 sys/time.h 存在于 GCC，但是 Visual Studio 没有这两个头文件。Dev-C++ 可以使用该方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt; #include &lt;sys/time.h&gt;#include &lt;cstdlib&gt; #include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;unistd.h&gt;using namespace std;time_t clocktime()&#123;//in &lt;sys/time.h&gt;struct timeval tv; gettimeofday(&amp;tv,NULL);std::cout&lt;&lt;\"10e6 微秒级s ----:\";std::cout&lt;&lt;tv.tv_sec&lt;&lt;\"s,\"&lt;&lt;tv.tv_usec&lt;&lt;\"微秒\"&lt;&lt;endl;//in &lt;time.h&gt;struct timespec tn;cout&lt;&lt;\"----\";clock_gettime(CLOCK_REALTIME, &amp;tn);std::cout&lt;&lt;\"10e9 纳秒级s ----:\";std::cout&lt;&lt;tn.tv_sec&lt;&lt;\"s,\"&lt;&lt;tn.tv_nsec&lt;&lt;\"纳秒\"&lt;&lt;endl;struct timespec current_time,last_time;double aa=1.1234567891;printf(\"double %.12f\\n\",aa);cout&lt;&lt;\"----\";clock_gettime(CLOCK_REALTIME, &amp;last_time);sleep(1);std::cout&lt;&lt;last_time.tv_sec&lt;&lt;\",\"&lt;&lt;last_time.tv_nsec&lt;&lt;endl;clock_gettime(CLOCK_REALTIME, ¤t_time);std::cout&lt;&lt;current_time.tv_sec&lt;&lt;\",\"&lt;&lt;current_time.tv_nsec&lt;&lt;\",\"&lt;&lt;pow(10,-9)&lt;&lt;endl;double delta_time = (current_time.tv_sec - last_time.tv_sec)+ (current_time.tv_nsec - last_time.tv_nsec)*pow(10,-9);printf(\"double %.12f\\n\",delta_time);&#125;int main( )&#123; clocktime(); return 0;&#125; 测试如下： 12345610e6 微秒级s ----:1500448195s,315233微秒----10e9 纳秒级s ----:1500448195s,315235598纳秒double 1.123456789100----1500448195,3152426871500448196,315388886,1e-09double 1.000146199000 ms 级时间的运算由于 C 语言既没有成员函数，也没有引用，于是，减法函数居然是在宏定义里实现的： 123456789#define timersub(tvp, uvp, vvp) \\ do &#123; \\ (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec - (uvp)-&gt;tv_sec; \\ (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec - (uvp)-&gt;tv_usec; \\ if ((vvp)-&gt;tv_usec &lt; 0) &#123; \\ (vvp)-&gt;tv_sec--; \\ (vvp)-&gt;tv_usec += 1000000; \\ &#125; \\ &#125; while (0) 还行。 可以调用的函数还有如下： 12345timersub(tvp, uvp, vvp) //v = t - utimerclear() // 清除时间timerisset() // 结构体中是否有设置时间值timercmp() // 比较时间值大小timeradd() // 两个时间值相加 MSVC 下获取本程序运行的时间（μs 级） 参考链接：https://docs.microsoft.com/zh-cn/windows/win32/sysinfo/acquiring-high-resolution-time-stamps 在测时间戳上，微软使用的是它的 API: QueryPerformanceCounter（QPC，查询性能计数器？），精确度在 1μs 内。 网站上还直接给出了可用的代码： 123456789101112131415161718192021222324#include&lt;profileapi.h&gt;LARGE_INTEGER StartingTime, EndingTime, ElapsedMicroseconds;LARGE_INTEGER Frequency;QueryPerformanceFrequency(&amp;Frequency);QueryPerformanceCounter(&amp;StartingTime);// Activity to be timedQueryPerformanceCounter(&amp;EndingTime);ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;//// We now have the elapsed number of ticks, along with the// number of ticks-per-second. We use these values// to convert to the number of elapsed microseconds.// To guard against loss-of-precision, we convert// to microseconds *before* dividing by ticks-per-second.//ElapsedMicroseconds.QuadPart *= 1000000;ElapsedMicroseconds.QuadPart /= Frequency.QuadPart; 但是在 VS 2017 上直接编译会报错：#error No Target Architecture。 Google 以后发现，需要在 项目 - （项目名）属性 - 配置属性 - C/C++ - 预处理器 - 预处理器定义 中加入 _X86_（32 位应用程序） 或 _AMD64_ （64 位应用程序），再编译即可。 最后 ElapsedMicroseconds.QuadPart 即是以微秒为单位的 long long 时间间隔变量。 获取本程序运行的时间（s 级）就是使用 clocks 啦。Just use clocks. However, accuracy is not guaranteed, and because of CPU problems, there are errors that can only be used for rough estimation. The s level should be no problem.但是不保证精度，而且因为 CPU 问题，存在误差，只能用于粗略估计。s 级应该是没有问题的。 12#include&lt;time.h&gt;float t = clock() * 1.0 / CLOCKS_PER_SEC Linux 下获取本程序运行的时间（ns 级）由于要获取 pid，挺麻烦的。需要用到的函数有： 12345678#include&lt;inistd.h&gt;pid_t getpid();#include &lt;time.h&gt;int clock_getcpuclockid(pid_t pid, clockid_t *clock_id);#include&lt;time.h&gt;int clock_gettime(clockid_t clk_id, struct timespec *tp); 写成代码就是： 1234clockid_t clock_id;timespec tp;clock_getcpuclockid(getpid(), &amp;clock_id)clock_gettime(clock_id, &amp;tp); 貌似不是特别常用，因此不再深入。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"assert","date":"2019-07-31T16:00:00.000Z","path":"cpp/cpp-grammar/assert/","text":"用途最初看到 assert，是在 ACM 时，看到的别人的高精度板子，限定了除数大于0： 1assert(b&gt;0) 但是感觉没什么用：如果 此时不等于 0，程序立即停止（abort）并返回一个非 0 值，就算 RE 了， 好像没什么用。 直到看《编程珠玑》的时候看到了它的用处： 断言的意思是，按照我为我的代码设定的逻辑，这种情况是绝对、永远为 true，如果是 false 就是代码出 bug 了。 它的作用是：它能限定当前程序的状态（如果和预期不一样就会报错），一方便是方便调试（能让程序一直保持在正确等状态下），另一方面是能让其他人理解自己的程序。 语法该函数在 &lt;assert.h&gt; 或 &lt;cassert&gt; 中。 1assert(bool) 可以这么用： 1assert(i &gt;= 0 &amp;&amp; i &lt; n) 还可以把布尔判断式写成一个 bool 类型的函数。 1234567bool isSorted(int * arr, int n)&#123; for (int i = 0; i &lt; n - 1; i++) if (arr[i] &gt;= arr[i+1]) return false; return true;&#125;assert(isSorted(arr, n)); 禁用所有 assert甚至还有一行关掉所有 assert 语句的方法： 1#define NDEBUG assert() 的涉及用法 捕捉逻辑错误。可以在程序逻辑必须为真的条件上设置断言。除非发生逻辑错误，否则断言对程序无任何影响。即预防性的错误检查，在认为不可能的执行到的情况下加一句 assert(0)，如果运行到此，代码逻辑或条件就可能有问题。 程序没写完的标识，放个 assert(0) 调试运行时执行到此为报错中断，好知道成员函数还没写完。 Which one: 断言、异常处理和 return false当程序遇到预期可能的错误时，可以进行断言、异常处理和返回一个错误返回值表示执行错误。那么到底该选择哪个呢？ 知乎上有这个问题。结论基本是： 三个词可以分为两类：一类是 assert，另一类是异常处理和返回错误值。因为 assert 应当是程序出了 bug 才会触发（程序应当“留下证据然后立即自爆”），另两个可能是用户输入了错误的内容触发的。应当修改错误或者引导用户进行正确输入。 针对采用return value 还是 exception，没有一定的结论。Stack Overflow 有一个针对这个问题的讨论，不过基本上没有结论，我比较喜欢的是抛出异常会强迫调用者处理，返回值则不会。无论那种，基本上都要有一堆的处理语句。来源","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"set——STL 自带的红黑树","date":"2019-07-26T16:00:00.000Z","path":"cpp/cpp-grammar/set/","text":"wdgmultiset set 的构造函数cppreference set 有一堆构造函数。C++ 98 有如下： 1234567set (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type()); //empty (1)template &lt;class InputIterator&gt;set (InputIterator first, InputIterator last, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type()); //range (2)set (const set&amp; x); //copy (3) default：set&lt;int&gt; s; 构造一个空的 set&lt;int&gt;； range: set&lt;int&gt; s(v.begin(), v.end()) 对 v 进行遍历，并构造一个相同的 set&lt;int&gt;； copy：从一个 set 拷贝构造为另一个。 值得一提的是第三个 range，它能将 vector list 等数据结构转化为 set。更有意思的是，vector 等模板类也有类似的构造函数，因此二者可以互相转换： 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v1&#123; 1, 4, 2, 3 &#125;; set&lt;int&gt; s1(v1.begin(), v1.end()); // s1 = &#123;1, 2, 3, 4&#125; vector&lt;int&gt; v2(s1.begin(), s1.end()); // v2 = &#123;1, 2, 3, 4&#125; return 0;&#125; 反向遍历 set12345678910set&lt;int&gt; s = &#123;1, 3, 5&#125;;// 正向遍历，输出 1 3 5for(set&lt;int&gt;::iterator iter = s.begin(); iter != s.end(); iter++) cout &lt;&lt; *s &lt;&lt; \" \";cout &lt;&lt; endl;// 反向遍历，输出 5 3 1for(set&lt;int&gt;::iterator iter = s.rbegin(); iter != s.rend(); iter++) cout &lt;&lt; *s; 集合运算集合运算包括：交集、并集、差集、对称差集（二者相互作差集，然后对两个差集作并集）、超集。 集合运算实际上不是 std::set 独享的，它可以用于任何有序的（由两个 iterator 表示的）range 上。其迭代是基于 iterator 的，所以就可以用于 vector、list、set、map 等容器之上了。 供读入的 InputIterator 可以使用 vector 和 set 的 s.begin() 和 s.end()，但是在供输出的 OutputIterator 上，vector 和 set 有些差异，在于二者添加元素方式的差异。 vector 使用尾插，因此需要使用 std::back_inserter(v)（文档） set 使用任意插入，因此需要使用 std::inserter(s, s.begin())（文档 以下函数需要引入 #include&lt;algorithm&gt;。 12345678910111213141516171819202122set&lt;int&gt; s1&#123;1, 3, 5, 7, 9&#125;;vector&lt;int&gt; s2&#123;2, 3, 5, 7&#125;;vector&lt;int&gt; s3&#123;2, 3&#125;;vector&lt;int&gt; union_v, intersection_v, diff_v, symdiff_v;set&lt;int&gt; union_s;// 将 s1 和 s2 的并集保存到 s 的最后，返回 &#123;1, 2, 3, 5, 7, 9&#125;// https://zh.cppreference.com/w/cpp/algorithm/set_unionset_union(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(union_v));set_union(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(union_s, union_s.begin()));// 将 s1 和 s2 的交集保存到 s 的最后，返回 &#123;3, 5, 7&#125;// https://zh.cppreference.com/w/cpp/algorithm/set_intersectionset_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(intersection_v));// 将 s1 和 s2 的差集保存到 s 的最后，返回 &#123;1, 9&#125;// https://zh.cppreference.com/w/cpp/algorithm/set_differenceset_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(diff_v));// 将 s1 和 s2 的对称差集保存到 s 的最后，返回 &#123;1, 2, 9&#125;// https://zh.cppreference.com/w/cpp/algorithm/set_symmetric_differenceset_symmetric_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(symdiff_v)); 注意如果不是用在 map 或 set 等自带排序的结构上，需要提前排好序。 multiset 支持操作 C++代码 插入 insert(value); 删除 erase(value); erase(iter); 查询 set::iterator iter = find(value); 二分搜索 lower_bound(value); upper_bound(value); 开头（最小） begin() 结尾（最大） --end() set.insert() 的返回值是一个 Pair，first 是（新加入或原本就存在的）该元素的 iterator，second 是 插入成功与否的 bool 值。而 multiset 只返回 iterator。 C++ 11 起，保证 multiset.insert() 插入的数在相同的数的最后（reference）。 ++和--支持list和set multiset，简直无敌。 set的*iter不会随数据插入、删除而改变（想想指针你大概就懂了）。 如何遍历 const multiset 呢？set::const_iterator iter。 unordered_setunordered_set 的实现不是二叉平衡树，而是 hash。对于自定义类型，可能需要定义 hash_value() 函数并且重载operator==。 使用的时候，没有排序，所以不能二分；遍历的效率也会很低（猜测是要遍历整个 hash 表）。用的话，一般用于查询某个数是否被存过，并且数据范围过大需要丽离散化。 set.find()妙用𝒔𝒆𝒕的𝒇𝒊𝒏𝒅函数可以直接找到和一个元素在逻辑上相等的另外一个元素find、upper_bound、lower_bound函数的相等用的并不是a==b，而是!(a&lt;b)&amp;&amp;!(b&lt;a)，只需要重定义&lt; find()没有找到就返回set.end(); 下面是一道潇神出的题，很好的利用这个性质，用 set 来判断两边是否有重叠。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Lutece 2145 人在地上走，锅从天上来//https://acm.uestc.edu.cn/contest/12/problem/C#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int maxn = 100001;struct edge &#123; int l; int r;&#125;;bool operator &lt;(edge a, edge b)&#123; return a.r &lt; b.l;&#125;set&lt;edge&gt; s;set&lt;edge&gt;::iterator iter;int merge(edge &amp; temp)&#123; if ((iter = s.find(temp)) != s.end()) &#123; temp.l = min(temp.l, iter-&gt;l); temp.r = max(temp.r, iter-&gt;r); s.erase(iter); merge(temp); return 1; &#125; else &#123; s.insert(temp); return 0; &#125;&#125;int main()&#123; cin.sync_with_stdio(0); cin.tie(0); int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; edge temp; cin &gt;&gt; temp.l &gt;&gt; temp.r; merge(temp); cout &lt;&lt; (i?\" \":\"\") &lt;&lt; s.size(); &#125;&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://blog.lyh543.cn/tags/STL/"}]},{"title":"pair 使用方法","date":"2019-07-24T16:00:00.000Z","path":"cpp/cpp-grammar/pair/","text":"pair 是。。。pair 是啥？pair 好像就是一个包含两个元素的结构。 包含头文件及定义变量123#include &lt;utility&gt;using namespace std;pair&lt;int,int&gt; p[10]; 数据存储12p[0] = &#123;1,2&#125;;p[1] = make_pair(3,4); //类似于强转吧 访问元素12cout &lt;&lt; p[0].first; //输出1cout &lt;&lt; p[1].second; //输出4 排序对于字典序排序（先按第一元素升序排序、再按第二元素升序排序），可以直接调用 sort： 1sort(p,p+10); 其余情况就需要自己定义了。 1234bool cmp(const pair&lt;int,int&gt; &amp;a, const pair&lt;int,int&gt; &amp;b)&#123; return (a.second &lt; b.second);&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://blog.lyh543.cn/tags/STL/"}]},{"title":"C++ 内置排序的排序顺序","date":"2019-07-24T16:00:00.000Z","path":"cpp/cpp-grammar/cpp-built-in-sort/","text":"结论 类型 自带排序 定义cmp结构（为&lt;） greater&lt;int&gt; 定义bool cmp函数（为&lt;） set 升序 升序 降序 \\ priority_queue 降序 降序 升序 \\ sort 升序 \\ \\ 升序 表中 \\ 表示这种语法无法适用于该排序。 测试代码12345678910111213141516171819202122//test for set#include&lt;bits/stdc++.h&gt;using namespace std;struct cmp &#123;bool operator()(int a, int b)&#123;return a &lt; b;&#125;&#125;;int main()&#123; set&lt;int&gt; test1;、 set&lt;int,cmp&gt; test3; set&lt;int, greater&lt;int&gt; &gt; test4; test1.insert(1); test3.insert(1); test4.insert(1); test1.insert(2); test3.insert(2); test4.insert(2); cout &lt;&lt; *test1.begin() &lt;&lt; \" \" &lt;&lt; *test3.begin() &lt;&lt; \" \" &lt;&lt; *test4.begin();//output:1 1 2&#125; 1234567891011121314151617181920212223//test for priority_queue#include&lt;bits/stdc++.h&gt;using namespace std;struct str&#123;int v;&#125;;bool operator &lt; (str a, str b) &#123; return a.v &lt; b.v; &#125;;struct cmp &#123;bool operator()(int a, int b)&#123;return a &lt; b;&#125;&#125;;int main()&#123; priority_queue&lt;int&gt; test1; priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; test2; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; test3; test1.push(1); test2.push(1); test3.push(1); test1.push(2); test2.push(2); test3.push(2); cout &lt;&lt; test1.top() &lt;&lt; \" \" &lt;&lt; test2.top() &lt;&lt; \" \" &lt;&lt; test3.top();&#125;//output: 2 2 1 123456789101112131415//test for std::sort#include&lt;bits/stdc++.h&gt;using namespace std;bool cmp(int a, int b) &#123; return a &lt; b; &#125;;int main()&#123; int a[2] = &#123; 0,1 &#125;; sort(a, a + 1); cout &lt;&lt; a; sort(a, a+1, cmp); cout &lt;&lt; a;&#125;//output: 0 0","tags":[{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://blog.lyh543.cn/tags/STL/"}]},{"title":"调一万年才能发现的bug","date":"2019-07-24T16:00:00.000Z","path":"cpp/acm/调一万年才能发现的bug/","text":"我脑子可能有问题.jpg仔细看题看题看题看题啊！！连续两场比赛因为看错题贡献了数小时的罚时。但是困的话，读英文就很难受，读不进去。所以打 ACM 得有一个良好的作息。 先读题跑一下样例2019.8.16 的 Codeforces Round #574 (Div. 2) D1，最后20分钟写，一直过不了样例，手跑了一下，发现是理解错样例了。差点 4.5 题。 爆数组不知道为什么，居然数据范围多大就开了多大内存。正好这题从 1 开始计数的。-2同场比赛一个 1e5 的数据范围看成 1e4 了。-1 1const int maxn = 3000; 爆char了解一下顺便提一下（cin）输出100K位的字符串是没问题的，而且速度较for更快，但是内存占用+100K 1char str[1000], length; 还有爆 int 所有数都保证在int范围内。 然后 int 一直 wa1。改成long long 就过了。哦，原来是输入保证在 int 内。 123456#define int long longsigned main()&#123; scanf(\"%lld\", &amp;a); printf(\"%lld\", a);&#125; 甚至可以爆 long long （指忘取模）快速幂（或类似物）对 ans 取模，没对 temp 取模。 12ans = ans * temp % mod;temp *= mod; 还有加法的时候忘了优先级。 1C[i][j] = C[i-1][j-1] + C[i-1][j] % mod 减法前必取模即使是减 1 也要取模。——2019.7.23 手写 hash 避免常用质数wdg 手写 hash 时，使用 1e9+7 做模数没过，改个数就过了。以后还是用非常见质数比如 19260817 100008221。 两层for的时候，i和j别写错了123456if (up[a][i].point != up[b][i].point) // excluding overflow that are both 0&#123; ans = min(min(ans, up[a][i].distance), up[b][i].distance); a = up[a][i].point; b = up[b][j].point;&#125; 多组输出时，cout不输出endl1cout &lt;&lt; a; ios::sync::with_stdio(0)以后，混写 cout 和 getchar/scanf，在本地跑没问题，但是OJ上就会炸123ios::sync_with_stdio(0)cout &lt;&lt; 'a';putchar('a'); 被卡Case #n:错误示范 12345case #1 //Capitalize cCase #0Case #1:1 //needs ' ' after ':'Case 0Case1 //needs '\\n'!!!!!!!!!!//其实可以学 cxmm 每次加一个回车 多组数据爆时间复杂度T = 10000 了解一下，本来 1 秒钟能跑 1e8 的， T = 10000，平均每组只能跑 1e4-1e5 了。或者是预处理。 尽量不要使用结构种的成员变量名做作变量名，不然错了都不报错的1234struct&#123; int d;&#125;s;int d; queue::size()不是int类型？？？1234queue&lt;int&gt; q, q2;q.push(-1);long long b = (q2.size() - q.size());printf(\"%lld\", b); 输出 4294967295。sise_t 类似于 unsigned int，必须要在 size_t 类型做运算前，强制转换为 long long。 交互题忘 endl ——2019.7.2412cout &lt;&lt; \"? \" &lt;&lt; i;cout.flush() 依旧 Idleness Limit Exceeded。 矩阵的左乘和右乘矩阵的左乘和右乘是有区别哒！注意左右。——2019.7.25","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"vector","date":"2019-07-24T16:00:00.000Z","path":"cpp/cpp-grammar/vector/","text":"本文写一写 vector 冷门但是可能有用的功能。 vector 的构造函数cppreference vector 有一堆构造函数。C++ 98 有如下： 123456789vector (const allocator_type&amp; alloc = allocator_type()); // default (1)vector (size_type n, const value_type&amp; val = value_type(), const allocator_type&amp; alloc = allocator_type()); // fill (2)template &lt;class InputIterator&gt;vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type()); // range (3)vector (const vector&amp; x); // copy (4) default：vector&lt;int&gt; v; 构造一个空的 vector&lt;int&gt;； fill：vector&lt;int&gt; v(3, 1); 构造一个 vector&lt;int&gt; 装有 3 个 1； range: vector&lt;int&gt; v(s.begin(), s.end()) 对 s 进行遍历，并构造一个相同的 vector&lt;int&gt;； copy：从一个 vector 拷贝构造另一个。 值得一提的是第三个 range，它能将 set list 等数据结构转化为 vector。更有意思的是，set 等模板类也有类似的构造函数，因此二者可以互相转换： 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v1 = &#123; 1, 4, 2, 3 &#125;; set&lt;int&gt; s1(v1.begin(), v1.end()); // s1 = &#123;1, 2, 3, 4&#125; vector&lt;int&gt; v2(s1.begin(), s1.end()); // v2 = &#123;1, 2, 3, 4&#125; return 0;&#125; 有序 vector 的集合运算见 set-集合运算。 swapvector 有一个成员函数叫 swap。这个 swap 是做什么的？ 1234567#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v1 = &#123;1, 2, 3&#125;, v2 = &#123;4, 5&#125;; v1.swap(v2); // 执行结束后，v1 = &#123;4, 5&#125;, v2 = &#123;1, 2, 3&#125;&#125; 在 cppreference 上提到，该函数可以和另一个 vector 进行交换，时间复杂度为 $O(1)$。貌似只是换一下指向数组的位置，但是可以用于滚动数组，不用再 %2 和 (cur+1)%2 啦。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://blog.lyh543.cn/tags/STL/"}]},{"title":"把球放进盒的八类组合问题","date":"2019-07-22T16:00:00.000Z","path":"cpp/acm/把球放进盒的八类组合问题/","text":"摘自 http://azaleasays.com/2011/12/16/combinatorics-n-balls-in-m-boxes/ N球放M盒，其实有8种情况： 球同，盒同，盒不可以为空 球同，盒同，盒可以为空 球同，盒不同，盒不可以为空 球同，盒不同，盒可以为空 球不同，盒同，盒不可以为空 球不同，盒同，盒可以为空 球不同，盒不同，盒不可以为空 球不同，盒不同，盒可以为空 球同、盒同，球可以/不可以为空枚举法。 例如 7 个相同球放入 4 个相同盒子，每盒至少一个，则先 4 个盒子每个放 1 个，多余 3 个。只需要考虑这3个球的去处就OK，由于盒子相同，所以只需要凑数就OK，不必考虑位置，因此只有300，211，111三种。 例如 7 个相同球放入 4 个相同盒子，可以空盒，则还是凑数，大的化小的，小的化更小的。 0007 0016 0025 0034 0115 0124 0133 0223 1114 1123 1222 11种。 代码实现上，可以用二维 DP。 球同，盒不同，盒可以/不可以为空用插板法（隔板法）解决。 球同，盒不同，盒不可以为空 的公式是把 $N$ 个球排成一排（一种方法），它们中间有 $N-1$ 个空。取 $M-1$ 个板，放到空上，就把它们分成 $M$ 部分，由于板不相邻，所以没有空盒。它的方法数有 $C_{N-1}^{M-1}$ 如果盒可以空（即 球同，盒不同，盒可以为空），为了避免空盒，先在每一个盒里假装放一个球，这样就有 $N+M$ 个球，$C_{N+M-1}^{M-1}$ 球不同的情况球不同的情况里，先来分析最特殊的：球不同，盒不同，盒可以为空。每个球都有 $M$ 种选择， $N$ 个球就有 $M^N$ 种分法。 关于剩下情况，“我先教大家一个非常特殊的三角形，这个你在 Google 百度非常难以找的到的，秘传型，一般人我不会告诉他的。” 看起来很复杂，其实很简单： 斯特林数 Stirling Triangle 性质1，左右两边都是1，第几行就有几个数，比如第5行就是1XXX1 性质2，$S(N, K) = S(N-1, K-1) + K * S(N-1, K)$，含义是第N排的第K个数等于他上一排的上一个位置数字加上一排的同样位置数字的K倍。 例如 $S(7, 3)$ 就是第 7 排第 3 个数字，所以他等于上排第 6 排第 2 个数字+第 6 排第 3 个位置 3。 画图的话，明显第 1 排是 1，第 2 排 1, 1。推理第 3 排（左右两边都是 1 ，只有中间那个数字没确定）。所以 $S(3, 2) = 第2排第1个数字+第2排第2个数字两倍 = 1+12 = 3$，所以第3排数字就是 1, 3, 1。同理 $S(4, 2) = S(3, 1) + 2S(3, 2) = 1+23 = 7$, 以此类推。 球不同，盒同，盒不可以为空$N$ 不同球，$M$ 同盒，无空盒。一共有 $S(N, M)$ 种分法，比如 7 个不同球， 4 个相同盒子，每个盒子至少一个，则看三角形的第 7 行，第 4 个数字多少。 球不同，盒同，盒可以为空$N$ 不同球，$M$ 同盒，允许空的时候（在上一种情况的基础上允许空盒）。明显是 $N$ 个球不变，一个空盒子都没有 + 有一个空盒子 + 有两个空盒子 + 有三个空盒子 + … + 有 $M-1$ 个空盒。说的简单点一共有就是 $$S(N, 1) + S(N, 2) + S(N, 3) + … + S(N, M)$$ 也就是说第 $N$ 排开始第 1 个数字一直加到第 $M$ 个数字就是总的分法。 球不同，盒不同，盒不可以为空而 球不同，盒不同，盒不可以为空 的情况同样是在 球不同，盒同，盒不可以为空 的基础上升华，因为后者是盒同的，而前者不同，所以盒子自身多了 $M!$ 倍可能， 所以 球不同，盒不同，盒不可以为空 的公式就是 $M! * S(N, M)$ 总结 $N$ 球 $M$ 盒结论 球同，盒同，盒不可以为空—穷举 球同，盒同，盒可以为空—穷举 球同，盒不同，盒不可以为空—$C(N-1, M-1)$ 球同，盒不同，盒可以为空—$C(N+M-1, M-1)$ 球不同，盒同，盒不可以为空—$S(N, M)$ 球不同，盒同，盒可以为空—$S(N, 1) + S(N, 2) + S(N, 3) + … + S(N, M)$ 球不同，盒不同，盒不可以为空—$M! * S(N, M)$ 球不同，盒不同，盒可以为空—M^N$","tags":[{"name":"转载","slug":"转载","permalink":"https://blog.lyh543.cn/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数论","slug":"数论","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"组合数学","date":"2019-07-22T16:00:00.000Z","path":"cpp/acm/组合数学/","text":"定义排列数 $$A(n,m) = A_n^m = \\frac{n!}{(n-m)!}$$ 组合数定义 $$C(n,m) = C_n^m = \\left(\\begin{smallmatrix}n\\\\m\\end{smallmatrix}\\right) = \\frac{n!}{m!(n-m)!}$$ （注意组合数记法中，$\\left(\\begin{smallmatrix}n\\\\m\\end{smallmatrix}\\right)$ 是上 $n$ 下 $m$，$C_n^m$ 是上 $m$ 下 $n$） 组合数的递推公式 $$C_n^m = C_{n-1}^m + C_{n-1}^{m-1}$$ 求法最原始的求法1234567891011int comb(int n, int m)&#123; int p = 1, q = 1; for (int i = 1; i &lt;= m; i++) &#123; p = p * (n - i + 1); q = q * i; &#125; if (p % q == 0) p /= q; return p / q;&#125; 递推$$C_n^m = C_{n-1}^m + C_{n-1}^{m-1}$$ 仅能用于预处理小范围的组合数。 1234567ll C[maxn][maxn] = 0;int init(int n)&#123; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= i; j++) C[i][j] = (j ? c[i - 1][j] + c[i - 1][j - 1] : 1);&#125; 预处理阶乘、逆元，用公式算$$C(n,m) = C_n^m = \\frac{n!}{m!(n-m)!}$$ 1234567891011ll fac[maxn];void init(int n)&#123; fac[0] = 1; for (int i = 1; i&lt; n; i++) fac[i] = i * fac[i-1];&#125;ll C(int a, int b, int m)&#123; return a &gt;= b ? fac[a] * inv(fac[b]) % m * inv(fac[a-b]) % m : 0;&#125; Lucas定理$$C^{ap+b}_{cp+d} \\equiv C^{a}_{c} \\cdot C^{b}_{d} (mod\\space p)$$ 或 $$C^{m}_{n} \\equiv C^{m/p}_{n/p} \\cdot C^{m\\%p}_{n\\%p} (mod\\space p)$$ 推导：费马小定理 Catlan 数Catlan N 球放 M 盒问题见链接 Stirling 数LGV 定理 ——2019.7.23CodeForces 348D两只乌龟走路，要求不能相交。 由 LGV 定理可得，如果起点集合为 $\\{a_1,a_2,a_3,…,a_n\\}$，终点集合为 $\\{b_1,b_2,b_3,…,b_n\\}$，则要求他们走路不相交的路径对 pair 总数有： LGV 其中,$e(a,b)$ 表示从点 $a$ 到 点 $b$ 的边权（在这里即指可走路径数）。 CodeForces 上这道题退化到只有两个起点即 $(1,2),(2,1)$ 和两个终点即 $(m-1,n),(n,,m-1)$，按照公式算一下路径即可。 \\begin{equation}ans =\\left |\\begin{matrix}e(1,2) \\to e(n-1,m) &amp; e(1,2) \\to e(m-1,n) \\\\e(2,1) \\to e(n-1,m) &amp; e(2,1) \\to e(m-1,n)\\end{matrix}\\right |\\end{equation}","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数论","slug":"数论","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.lyh543.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"树状数组 (Binary Indexed Tree)","date":"2019-07-18T16:00:00.000Z","path":"cpp/acm/树状数组/","text":"参考博客：http://www.cppblog.com/menjitianya/archive/2015/11/02/212171.html 建立树状数组的目的树状数组 (Binary Indexed Tree) 代码简洁、常数小于线段树，但功能少。即使如此也很常用。（线段树板子长抄着慢） 树状数组的作用是可以log(n)维护在线前缀和（最大最小值什么的也可以？） 树状数组要解决两个东西： int add(int i, int x) //对一个数进行更新，要求时间复杂度为 O(log n) int sum(int i) //求[x1,xi]的区间元素和，时间复杂度为 O(log n) 定义树状数组的定义是一个一维数组 tree[]，其中 tree[i] 表示 [i-(i&amp;(-i))+1,i] 这个区间内 a 数组元素的和。 但这个定义挺迷的，i-(i&amp;(-i))+1 代表什么呢？别急，慢慢往下看， 树状数组虽然是用数组实现的，但他实际上是一棵树形的，如下图。 树状数组 可以看出这棵树中，对于两个数组下标 $x$, $y$, 如果满足 $x+2^k=y$ （$k$ 为 $x$ 的二进制表示中末尾 $0$ 的个数，在后文定义 $lowbit(x)=2^k$），则定义 $y$ 是 $x$ 的父亲。如 $4$ 的 $k$ 为 $2$，则 $4$ 的父亲即是 $4+2^{k_4}=4+2^2=8$。 $C_i$是什么每一个结点 $C_i$ 存了它自己和它的所有（递归）子结点的 $A_i$ 值之和。 那么能否用数学表达 $C_i$ 存的是哪些数呢？我们来看看 $C_8$。 \\begin{equation}\\begin{split}C_8 &amp;= C_4 + C_6 + C_7 + A_8\\\\ &amp;= C_2 + A_3 + A_4 + A_5 + A_6 + A_7 + A_8\\\\ &amp;= A_1 + A_2 + A_3 + A_4 + A_5 + A_6 + A_7 + A_8\\end{split}\\end{equation} 比较显然的是，$C_i$ 存的是 ${A_i}$ 数列中的连续和，而连续和的右边界一定是 $i$。那么左边界是什么呢？ 从图上可以看出，左边界是顺着 $C_i$ 的最左儿子一直找直到找到叶子结点。 那能否用数学来直接推导出左边界呢？ 根据父子结点关系可以逆推得到 $C_8$、$C_6$、$C_7$ 的左边界，过程是这样的（为方便观察规律，标注了每个数字的二进制）： 父结点 81000 6110 7111 子结点1 40100 5101 子结点2 20010 子结点3 10001 左边界 10001 5101 7111 结论已经呼之欲出了：对于每个数 $i$，它的左边界是：把 $i$ 最右边的 $1$ 变成 $0$ ，再在这一位的加上 $1$。 顺便提一句，要遍历某个点的子结点，可以取出最右一位的 $1$ 以后，依次往后面的位加 $1$，得到的所有数就是它的所有子结点。如 $8$ 1000 的子结点就有 $4$ 0100、$6$ 0110、$7$0111。也可以换一种理解方式，$i$ 的子结点为 $ i-2^k , k \\in [0,log_2(lowbit(i))-1]$。 按照上面定义的 $k$ 为 $x$ 的二进制表示中末尾 0 的个数 再定义 $lowbit(x) = 2^{k_x}$，即 $lowbit(x)$ 为 $x$ 最右的一个 $1$，那么左边界就应该是 $i-lowbit(i)+1$，所以， $$ C_i = \\sum_{j=i-lowbit(i)+1}^{i}{A_i} $$ 求和函数 sum(int i)明白了 $C_i$ 的含义以后，我们可以用它来求 $sum(i)$ 了。用 $lowbit(i)$ 表示 $2^{k_i}$ ，则有 \\begin{equation}\\begin{split}sum(i) &amp;= A[1] + A[2] + … + A[i]\\\\ &amp;= A[1] + A[2] + … + A[i-lowbit(i)] + A[i-lowbit(i)+1] + … + A[i]\\\\ &amp;= sum(i-lowbit(i)) + C[i]\\end{split}\\end{equation} 上式可以用递归求解，边界是 $sum[0] = 0$。 用递归形式写就是： 1234int sum(int i)&#123; return i ? C[i] + sum[lowbit(i)] ： 0;&#125; 可以改写为非递归形式： 12345678910int sum(int i)&#123; int ans = 0; while(i) &#123; ans += C[i]; i -= lowbit(i); &#125; return ans;&#125; 时间复杂度是 $O(log n)$。 更新函数 add(int i, int x)更新操作即是把第 $i$ 个数增加 $x$。朴素前缀和要更新 $i$ 及以后的所有前缀和，所以复杂度是 $O(n)$。可以观察到，树状数组中，所有数的信息只存在该下标对应的结点和它的（递归）父结点的 $C_i$ 中。因此，只需要递归对父结点做同样的加减即可。根据定义，$i$ 结点的父结点是 $i+lowbit(i)$，代码也就不难写了。这一过程同样有递归和非递归形式。 递归形式： 12345678int add(int i, int x)&#123; if(i &lt;= n) &#123; c[i] += x; add(i + lowbit(i), x); &#125;&#125; 非递归形式： 12345678int add(int i, int x)&#123; while(i &lt;= n) &#123; c[i] += x; i += lowbit(i); &#125;&#125; $O(1)$ 求 lowbit(x)可以看到，不管是 add(i,x) 还是 sum(i)，其精髓在于 lowbit(i)，因为 结点 $i$ 的父结点是 $i+lowbit(i)$结点 $i$ 的子结点为 $ i-2^k, k \\in [0,log_2(lowbit(i))-1]$结点 $i$ 的左边界是 $i-lowbit(i)+1$ 上面这两句，很漂亮的诠释了树状数组何为树状。理解了这句话，就可以自己手写树状数组了。 所以呢，最后一步，也是最关键的一步，就是求 lowbit(i) 了。朴素方法（把 $i$ 反复除以2）能在 $O(log\\space i)$ 求 $k_i$，但是用位运算的方法可以把这个过程变成 $O(1)$。 由补码的知识可以得到如果不知道的去看原博 lowbit(x) = x &amp; (-x) 补码这种东西虽然不直观，初学者很难懂，但是挺神奇的，比如这里的 x&amp;(-x)，还有原博的例子 (+5) + (-5) = 00000101 + 11111011 = 1 00000000 (溢出了！！！) = 0 至此，再看文章开头对树状数组的定义： 树状数组的定义是一个一维数组 tree[]，其中 tree[i] 表示 [i-(i&amp;(-i))+1,i] 这个区间内 a 数组元素的和。 其实就很好理解了。 实现上，由于 &amp; 的优先级低于 -，可以这么写： 1int lowbit(int x)&#123;return x &amp; -x;&#125; 时间复杂度是 $O(1)$。 至此，树状数组的一般应用就讲完了。初始化的时候，不需要像线段树一样必须要开 $2^n$ 个内存，有多少数开多少内存就够了。把上面提到的三个函数组合起来就能去做最简单的 Point Update Interval Query（点更新，段询问）了。 123456789101112131415161718192021222324ll C[maxn] = &#123; 0 &#125;;ll n;ll lowbit(ll x)&#123; return x &amp; -x;&#125;void add(ll i, ll x)&#123; while (i &lt;= n) &#123; C[i] += x; i += lowbit(i); &#125;&#125;ll sum(ll i)&#123; ll ans = 0; while (i &gt; 0) &#123; ans += C[i]; i -= lowbit(i); &#125; return ans;&#125; 应用：更新区间、查询单元素树状数组最基础的模型是 Point Update Interval Query（点更新，段询问），但是做一下差分也可以实现 Interval Update Point Query（段更新，点求值）。具体实现略。 应用：求最大值理论上来说，树状数组也可以 Point Update Interval Query 求区间最大值。 在这篇博客中实现了树状数组求最大值，初始化的复杂度为 $O(nlogn)$，单点维护和区间查询的复杂度都是 $O(log^2n)$。 原理其实就是发生更改以后，遍历、更改所有（递归）父结点；查询的时候，就遍历该区间对应所有结点的值的最大值。 利用好这一句话： 结点 $i$ 的子结点为 $ i-2^k, k \\in [0,log_2(lowbit(i))-1]$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int maxn = 3e5;int a[maxn], h[maxn];int n, m;int lowbit(int x)&#123; return x &amp; (-x);&#125;void update(int x) //x指下标。在求最大值中，原数列必须保留。&#123; int lx, i; while (x &lt;= n) &#123; lx = lowbit(x); if (a[x] &lt; h[x]) for (i=1; i&lt;lx; i&lt;&lt;=1) h[x] = max(h[x], h[x-i]); h[x] = a[x]; x += lowbit(x); &#125;&#125;int query(int x, int y)//求[x,y]区间内最大值&#123; int ans = 0; while (y &gt;= x) &#123; ans = max(a[y], ans); y--; for (; y-lowbit(y) &gt;= x; y -= lowbit(y)) ans = max(h[y], ans); &#125; return ans;&#125;int main()&#123; //完成对 a[i] 输入以后开始更新 h[i] memset(h,0,sizeof(h)); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; update(i); &#125; //查询 [x, y] 最大值 ans = query(x, y); //更新 a[x] 以后更新单点 a[x] = y; update(x);&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"__int128","date":"2019-07-15T16:00:00.000Z","path":"cpp/cpp-grammar/int128/","text":"在 ACM 竞赛中，如果 8e18 的 long long 不够用了，又不是特别需要高精度，可以使用 __int128。 __int128 的数据范围是 -170141183460469231731687303715884105728 ~ 170141183460469231731687303715884105727 （1e38）。 但是并不是很好用额： 只能在 64 位环境下使用，32 位是不支持 __int128 的。 Visual Studio 2017 不支持，GCC支持。 不能使用 scanf/cin 和 printf/cout 输出。一个解决方案是，可以把转化为字符输出，即 ACM/OI 常提到的快速读入输出。 123456789101112inline __int128 read()&#123; int k=0; char f=1; char c=getchar(); for(;!isdigit(c);c=getchar()) if(c=='-') f=-1; for(;isdigit(c);c=getchar()) k=k*10+c-'0'; return k*f;&#125; 12345678910void print(__int128 x)&#123; if(x &lt; 0) &#123; x = -x; putchar('-'); &#125; if(x &gt; 9) print(x/10); putchar(x%10 + '0');&#125; 注意后面的 print 函数其实是不能输出 __int128 的最小值 -170141183460469231731687303715884105728 的，因为它是把负数取反后输出的，而补码系统里面，负数本身就比正数多一个数。不过平时影响不大，毕竟用不到这个数。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"数据结构专题 讲座","date":"2019-07-14T16:00:00.000Z","path":"cpp/acm/数据结构专题讲座/","text":"程序=数据结构+算法数据 结构分为两类：物理结构【数组、链表】，逻辑结构【树的结点关系、并查集】一般用数组不用指针 栈 Stack12345678910//STL Standard Template Library//Windows Stack: 8M//Unix Stack: 8Mstack&lt;int&gt; s;int x = 1;s.push(1);x = s.top(); s.pop();int s.size();bool s.empty(); 队列 Queue123456stack&lt;int&gt; s;int x = 1;s.push(1);x = s.front(); s.pop();int s.size();bool s.empty(); 123实现一个栈：入栈、出栈、取最小元素的时间复杂度为O(1)运用两个栈，第二个栈存小于栈首的元素的下标//这是个栈，只会出最顶层的值（逃 vector方便但不高效开一片内存，不够用就开更大的一片，然后复制过去 priority_queue实现：堆排序堆：ki&lt;=k2i &amp;&amp; k1&lt;=k2i+1//二叉搜索树：k2i&lt;=ki&lt;=k2i+1入队、出队：log(2n) 树 Tree一种重要的非线性数据结构数据按分支关系组织起来没有环 二叉树是最简单的树结构二叉树链表二叉搜索树 红黑树是一种自平衡的二叉查找树 更多特性： 结点：红色、黑色 根结点：黑色 红色子结点是黑色，黑色非空子结点是红色 空结点是黑色，在黑色的子结点 字典树 Trie （AC自动机）插入一个字符串 从根结点出发，判断字母对应边是否存在 存在：访问；不存在：新建 对终点做特殊标记 查询字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct Trie&#123; int next[MAX]; int v; //结束标志&#125;void createTrie(char *str)&#123; int len = strlen(str); Trie *p = root, *q; for(int i=0; i&lt;len; ++i) &#123; int id = str[i]-'0'; if(p-&gt;next[id] == NULL) &#123; q = (Trie *)malloc(sizeof(Trie)); q-&gt;v = 1;//初始v==1 for(int j=0; j&lt;MAX; ++j) q-&gt;next[j] = NULL; p-&gt;next[id] = q; p = p-&gt;next[id]; &#125; else &#123; p-&gt;next[id]-&gt;v++; p = p-&gt;next[id]; &#125; &#125; p-&gt;v = -1; //若为结尾，则将v改成-1表示&#125;int findTrie(char *str)&#123; int len = strlen(str); Trie *p = root; for(int i=0; i&lt;len; ++i) &#123; int id = str[i]-'0'; p = p-&gt;next[id]; if(p == NULL) //若为空集，表示不存以此为前缀的串 return 0; if(p-&gt;v == -1) //字符集中已有串是此串的前缀 return -1; &#125; return 1; //此串是字符集中某串的前缀&#125; 并查集小巧高效有用压缩路径以后，没有必要启发式合并可以用递归压缩路径(logn也没有什么问题，gcd递归也是logn)Kruskal 无向图最小生成树 线段树 Interval Tree三个小时肯定讲不完 n次查询某一区间的和（最大值）——n*O(logn) 区间查询（极值、求和、etc） 区间更新（同一加一个值） 分为三类（更新点，查询区间；更新区间，查询点；更新区间，查询区间 线段树空间应开为原数组长度的四倍 但是线段树可没这么简单。。。“懒操作”在更更新区间的有关问题上⾄至关重要。（然而我不会啊wsl） 经典问题：a[1]~a[n]操作：修改一个值；求区间最大值；求区间和 线段树的结点是区间结构图？ 树状数组树状数组已在其他文章进行拓展讲解。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Wolfram Alpha 和 Mathematica","date":"2019-07-06T16:00:00.000Z","path":"maths/wolfram-alpha-and-mathematica/","text":"之前一直分不清 Wolfram Alpha 和 Mathematica，以为在线的那个网站就是 Mathematica。 后来装了桌面 Mathematica，并且简单了解了一点语法以后，才明白二者的区别。 这两个是同一个公司的两款产品，别搞混了。他们的语法虽然有点区别，但是都是基于 Wolfram 语言。 Wolfram AlphaWolfram Alpha 是 Wolfram 公司的在线产品，具有 web 版（免费版功能较少）、移动端 app。 Wolfram Alpha 里面一般只写一个语句，基本不能进行编程。 但是他的语法比较松散，如积分用 int()、INT[]、integrate()、integrAte() 等都可以识别，不会产生歧义的括号缺失也可以自动补齐。 小白也能很方便的使用，而且打开网站，或在手机上就能用、所以大多数人用的是这个。 二重积分1integrate((x+y)/sqrt(1-x^2-y^2)+1,[y,0,1],[x,-sqrt(1-y^2),sqrt(1-y^2)]) Wolfram MathematicaMathematica 是一个强大的计算软件，能够在 PC 上进行计算，也可以进行编程。 缺点是语法严格，如函数名第一个字母都是大写，不大写则不会被识别；另外需要在电脑上安装数 GB 的程序，手机端不能使用；而且该软件不提供免费版。","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"栈的深度","date":"2019-07-05T16:00:00.000Z","path":"cpp/acm/栈的深度/","text":"C++的栈是有深度限制的，特此测试一下栈的深度。 实验环境：Lutece, Visual Studio 2017. 测试结果： 环境 Visual Studio 2017 Lutece 不在函数中另开内存 4791层 3.5e6-4e6层（占用内存64MB） 每次开100个char（100B） 3193层 每次开1000个char（1KB） 731层 测试代码： 1234567891011121314int ans = 0;void test(int i)&#123; if (i % 100 == 0) cout &lt;&lt; i &lt;&lt; endl; test(i+1); ans+=i;&#125;int main()&#123; test(1); cout &lt;&lt; ans;&#125;","tags":[{"name":"测试","slug":"测试","permalink":"https://blog.lyh543.cn/tags/%E6%B5%8B%E8%AF%95/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"}]},{"title":"Qt入门","date":"2019-06-25T16:00:00.000Z","path":"others/qt-getting-started/","text":"Qt 简介跨平台多语言应用开发框架，不仅能开发UI，还提供很多C++基础类库，很多吊打C++库 开源，非商用可免费使用。 Qt支持多语言，但是常用C++，Python UI、QTL、Mulitimedia、Network、sql、xml…… Qt 安装安装以后，可以在 VS 里使用（配合插件）。 Qt 使用信号槽将信号（用户点了按钮）与动作（程序执行动作）连接起来 旧版本： 123connect(发送者, 信号, 接受者, 动作);connect(..., SIGNAL(f(int)), ..., SLOT());connect(ExitAction, &amp;QAction::triggered, this, &amp;std::exit); 新版本。。。。。 细节更改程序编码 1#pragma execution_character_set(\"utf-8\") 模态：程序/对话框运行时，不能执行其他动作非模态：程序/对话框运行时，可以执行其他动作","tags":[]},{"title":"QQ，微信实现调用系统WebView教程","date":"2019-06-25T16:00:00.000Z","path":"others/qq-wechat-call-system-webview/","text":"实在受不了垃圾X5内核，打开网页总慢半秒 把这个X5内核调试链接复制到QQ打开 http://debugtbs.qq.com/ 点左下角强制使用系统内核，确定。 不放心的打开这个网址查看当前内核 https://ie.icoa.cn/ 这下顺滑多了，网页秒开","tags":[]},{"title":"字符串概述","date":"2019-06-25T16:00:00.000Z","path":"cpp/acm/字符串概述/","text":"库函数（轮子）#include&lt;cstring&gt; sscanf(const char \\__source, const char *__format, ...)只能读一次 int strlen(char*) int strcmp(const char *str1, const char *str2)前者小，返回负数，大，返回正数 strcpy char *strcat(char *str1, const char *str2)将 str2 接到 str1 的结尾，用 *str2 替换 str1 末尾的 ‘\\0’返回 str1 char * strchr(char * string, char ch);//寻找字符串 #include&lt;string&gt;&lt;string&gt;里的 std::string 与其大量函数。 1234567#include&lt;string&gt;string c1(\"this is a string\");string c2(5,'c'); //c2=\"ccccc\"//string copys2 = c1 + \",\" + c2;s2 += c2; 注意区分 assignment 和 copy construction函数参数为 string 时一定要设为 const string &amp; 概念","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.lyh543.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"最短路算法（坑）","date":"2019-06-24T16:00:00.000Z","path":"cpp/acm/最短路算法/","text":"找出两点间的最短路径。 Dijkstra（不能搞负权图） Bellman-Ford 和 SPFA（另一种写法） Floyd Dijkstra时间复杂度：O(|V|*|V|)。如是用优先队列维护最小值，可 以做到O(|V|*log|E|) Bellman-Ford如果最短路存在，则最短路经过的边数不超过n-1 条，由此可有下面的算法。 12345678910111213141516for(int i = 0; i &lt; n; i++) d[i] = INF;d[0] = 0;for(int k = 0; k &lt; n-1; k++)&#123; //控制次数 flag = false; //记录是否更新 for(int i = 0; i &lt; m; i++) &#123; if(dis[v[i]] &gt; dis[u[i]] + w[i]) &#123; dis[v[i]] = dis[u[i]] + w[i]; //松弛的过程 flag = true; &#125; &#125; if (!flag) break;&#125; 再跑一遍，如果最短路还在更新，则有负权回路。 最坏时间复杂度：O(|V|*|E|)。但一般没那么大。 算法局限性：稠密图中复杂度远高于 Dijkstra FloydFloyd算法利用了动态规划。用 d[i][j][k] 表示从 i 到 j，经过编号不超过 k 的点所得到的最短距离（郝东没讲清楚）。 状态转移方程： 1d[i][j][k] = min&#123;d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1]; 再压缩一下就是标准的二维数组 Floyd 了。","tags":[{"name":"图论","slug":"图论","permalink":"https://blog.lyh543.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"坑","slug":"坑","permalink":"https://blog.lyh543.cn/tags/%E5%9D%91/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"}]},{"title":"最长回文子序列","date":"2019-06-24T16:00:00.000Z","path":"cpp/acm/最长回文子序列/","text":"DP - O(n^2)1234567891011 for (int k = 1; k &lt; n; k++) &#123; for (int i = 0; i+k &lt; n; i++) &#123; dp[i][i + k] = max(dp[i][i + k - 1], dp[i + 1][i + k]); if (a[i] == a[i + k]) &#123; dp[i][i + k] = max(dp[i][i + k], dp[i + 1][i + k - 1] + 1); &#125; &#125;&#125; Manacher O(n)先在原串str每个字符左右加一个#，转化为奇数长度，新的字符串命名为m串 abba -&gt; #a#b#b#a# ,长度为9 最后记得把长度除以二 首先,在字符串m中,用p[i]表示m串第i个字符的回文半径,即p[i]尽可能大,且满足: i-1]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879可~~观察出~~证明&#96;p[i]-1&#96;即为&#96;str&#96;的回文串长度。然后，从左往右遍历。执行完一步&#96;p[i] &#x3D; mx &gt; i ? min(p[2 * id - i], mx - i) : 1;&#96;以后，要把&#96;p[i]&#96;向两边扩展。嗯这个for套while不就O(N^2)了吗？？？？其实并没有。我们看一下每个字符被访问了几次。首先遍历的时候就有一次。主要是看while()语句中被访问了几次。执行完&#96;p[i] &#x3D; mx &gt; i ? min(p[2 * id - i], mx - i) : 1;&#96;以后，如果是下图这种情况，就不需要扩展（&#96;p[i]++&#96;）；![123](https:&#x2F;&#x2F;image-static.segmentfault.com&#x2F;406&#x2F;055&#x2F;4060550705-58b9671c71085)只有下图的这种情况，才会进行扩展，此时i右边的字符被访问了两次。但是扩展以后，相应的&#96;Mx&#96;也会变大，使得下次就扩展不会考虑到这个点。所以每个字符只会被访问两次。证毕。![123](https:&#x2F;&#x2F;image-static.segmentfault.com&#x2F;282&#x2F;937&#x2F;282937517-58b966b75cbb5)可以看出，&#96;p[i] &#x3D; mx &gt; i ? min(p[2 * id - i], mx - i) : 1;&#96;是Manacher的精髓，在朴素算法上加一行，即把O(n^2^)变成了O(n).代码如下：&#96;&#96;&#96;c++#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 1e7+5;int n;char str[maxn], m[maxn &lt;&lt; 1];int p[maxn] &#x3D; &#123; 0 &#125;;int manacher(char * str)&#123; int len &#x3D; 2; &#x2F;&#x2F;m[len] &#x3D; &#39;\\0&#39;; m[0] &#x3D; &#39;$&#39;, m[1] &#x3D; &#39;#&#39;; for (int i &#x3D; 0; i &lt; n; i++) &#123; m[len++] &#x3D; str[i]; m[len++] &#x3D; &#39;#&#39;; &#125; int ans &#x3D; 1, id &#x3D; 0, mx &#x3D; 0; for (int i &#x3D; 0; i &lt; len; i++) &#123; p[i] &#x3D; mx &gt; i ? min(p[2 * id - i], mx - i) : 1; while (m[i - p[i]] &#x3D;&#x3D; m[i + p[i]]) p[i]++; if (i + p[i] &gt; mx) &#123; mx &#x3D; i + p[i]; id &#x3D; i; &#125; &#x2F;&#x2F;cout &lt;&lt; p[i]; if (p[i]&amp;1) ans &#x3D; max(ans, p[i]); &#125; &#x2F;&#x2F;cout &lt;&lt;endl &lt;&lt; m; &#x2F;&#x2F;cout &lt;&lt; endl; return ans - 1;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; cin &gt;&gt; str; cout &lt;&lt; manacher(str);&#125;","tags":[{"name":"搜索","slug":"搜索","permalink":"https://blog.lyh543.cn/tags/%E6%90%9C%E7%B4%A2/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.lyh543.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"数据结构专题 题解","date":"2019-06-24T16:00:00.000Z","path":"cpp/acm/数据结构专题题解/","text":"forgottencscN题：线段树板题懒标记：信息的合并标记对区间信息的影响 push_down()update() A题 权重：线段树3tag：加、乘、变2tag：变i -&gt; 乘0加i 求平方和 12#define int long longsigned main() 方差公式自己推退化版：洛谷 线段树模板II B题：最近公共祖先 LCAmp[i][j]存路线ms[i][j]存最小值 D题 最大16进制数单调栈 H题 拍照前缀和+单调队列 pxt潘训涛I题 排名邻接链表+优先队列nlog能过？但是没法删 平衡二叉树 123#include&lt;multiset&gt; //multiset允许重复s.insert(v);s.erese(iter); 遍历用iterator J题 种海带用链表实现环，贪心（取最大元素，用堆实现）但是贪心有点奇怪？ K题 对答案：前缀和xor == ^ L题：差分，线段树差分（d[i] = a[i] - a[i-1]） M题：分块（啊听不下去了…）","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图论讲座","date":"2019-06-24T16:00:00.000Z","path":"cpp/acm/图论讲座/","text":"基本概念G=&lt;V(G),E(G),φ(G)&gt;φ(G): E-&gt;V×V的关联函数 边：有向边：&lt;i,j&gt;无向边：(i,j)重边（平行边）：两结点间方向相同的若干条边自环：。。。对称边：可以等价为一条无向边的两条有向边 图的分类有向图、无向图、混合图（一般进行转化）、多重图（含有重边）、简单图（没有重边、自环）并不简单 简单图的边数：E&lt;=V(V-1)/2取等时为完全图K8稠密图、稀疏图没有 图的存储结构邻接矩阵、邻接表初始的INF最好不要使用0x7fffffff，不然一加就炸。 邻接矩阵的特点 空间复杂度：O(n^2) 可以O(1)查两个结点的关系 缺点：空间复杂度差，稀疏图效率低、不便于处理多重图的附加信息 邻接表的分类写法：链表、vector、静态数组 邻接表的特点 空间复杂度：O(n+m) 可以高效的访问结点的所有邻接边（结点） 可以很好的处理重边 缺点：无法高效查询任意点对间的信息 vector 使用12345678vector&lt;vector&lt;int&gt; &gt; mynode(5); //注意&gt; &gt;间有空格for(int i = 0; i &lt; 10; i++)&#123; scanf(\"%d%d\", &amp;u, &amp;v); mynode[u].push_back(v);&#125;for(int j = 0; j &lt; mynode[i].size(); j++) mynode[i][j] 图的遍历图的深度优先搜索（DFS）遍历：（带标记的深搜）实现联通块的搜索与计数：可达的就是一个联通图 一般会使用visited[maxn]数组，就可以避免来回搜索 12345678#define MAXN 100int n, m, visited[MAXN], graph[MAXN][MAXN];void dfs(int k) &#123; visited[k] = 1; //表示已访问 for (int i = 0; i &lt; n; i++) if (!visited[i] &amp;&amp; graph[k][i]) dfs(i);&#125; 度与欧拉图（见单独笔记）几种特殊的图树 n个结点，n-1条边连通图 没有回路（环），任意两结点间有唯一路径 天然的递归结构 常见问题： 树上的动态规划（DP） 最近公共祖先（LCA) 树形转线形（满二叉树） 满二叉树 生成树 树上的分治 有向无环图二分图最短路算法最小生成树有向图的强连通分量","tags":[{"name":"图论","slug":"图论","permalink":"https://blog.lyh543.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"}]},{"title":"cctype","date":"2019-06-23T16:00:00.000Z","path":"cpp/cpp-grammar/cctype/","text":"123456789101112isalpha()isalnum()iscntrl()isdigit()islower()isprint()ispunct()isspace()isupper()isxdigit()tolower()toupper()","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.lyh543.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"Hello Hexo","date":"2019-06-23T16:00:00.000Z","path":"blog/hello-hexo/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.lyh543.cn/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"}]},{"title":"Hexo 写作","date":"2019-06-23T08:33:03.000Z","path":"blog/hexo-writing/","text":"Hexo写作支持Markdown。不懂就查文档下面是一些区别于常规Markdown的点。 即时预览由于 Hexo 博客不全是使用Markdown语法，常规Markdown编辑器无法提供效果完全相同的预览。但是 Hexo 提供了本地网页即时预览博客的功能。 在命令行中输入Hexo server（简写hexo s），即可在127.0.0.1:4000即时预览博客。Microsoft Edge似乎只能在localhost:4040中预览。 blog_preview 文章信息文章放在\\source\\_post的目录里面，md文件随便放。 下面是开头的格式front-matter。 12345678910---title: Test Postdate: 2019-06-23 16:33:03tags:- ACM- 图论category:- C++top: false--- 一些其他参数： 参数 描述 默认值 layout 布局 date 创建日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true permalink 覆盖文章网址 这些文本使用 hexo new [draft] xxx 会自动按照 /Scaffold/post.md （或 /Scaffold/draft.md）的模板生成。下面是我的 post.md： 1234---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;--- 由于 hexo 在 wsl 上有十秒的延迟，加上每次新建博客会顺便创建文件夹，不是很喜欢，我在 VS Code 上使用的是一个叫 psioniq File Header 的插件，安装插件以后，编辑新文件前，按 Ctrl+Alt+H 两次即可按照 Visual Studio Code 的配置文件 settings.json 模板就可以创建开头。我的 settings.json 的相关部分长这个样子： 12345678910111213141516 \"psi-header.templates\": [ &#123; \"language\": \"*\", \"template\": [ \"---\", \"title: &lt;&lt;filename&gt;&gt;\", \"date: &lt;&lt;dateformat('YYYY-MM-DD H:mm:ss')&gt;&gt;\", \"tags:\", \"- 杂谈\", \"category:\", \"- C++\", \"mathjax: true\", \"---\" ] &#125;], 插入图片对于 Hexo 这类网站，插入图片一直是个痛点，不能像印象笔记、WordPress、CSDN 等直接将图片拖动到窗口，就可以自动上传。 但是可以使用一种叫图床的插件。对于 Visual Studio Code，我推荐的 Coding 图床插件，绑定 Coding.net 账号以后，可以在 VS Code 编辑 Markdown 的页面一键粘贴图片（将图片传到 Coding 的指定仓库，然后粘贴图片链接）。 HTML间的相对路径HTML间的常规引用： 上一级文件夹的某文件：../index/上两级文件夹的某文件：../../index/ Hexo 中，文章间的引用使用常规方法好像容易炸，因为 Hexo 创建文章是按日期创建的，如https://lyh543.github.io:4000/2019/06/26/Testblog/，不同日期的文件夹就会炸。Google 了一下，据说 Hexo 3.0 可以使用 post_link hexo-writing hexo-writing %&#125;```12345678的形式引用，但测了一下还是不行。于是是用另一种方式，通过修改&#96;站点配置文件&#96;，修改文章的命名方式，改为只由&#96;title&#96;命名。&#96;&#96;&#96;ymlroot: &#x2F;permalink: :title&#x2F;permalink_defaults: 然后就可以按HTML的常规引用了。同文件夹文章的相互引用：../hexo-building-blog/（最后的/是可选的）链接到某个标题：../hexo-writing#文章信息 或 #文章信息链接到标题的更详细的语法可以看Markdown 语法：锚点。 对_posts上一级的文件就写绝对路径吧，如 /img/test.jpg。注意从根目录开始引用博客不加 _posts，如 /cpp/Blog/hexo-writing 引入LaTeX 公式—— Mathjax为此单写了一篇博客。详见那一篇博客。 重定向博文由于我把博客当做学习笔记，经常会查博客记录的 Linux 命令、MATLAB 笔记。 虽然有搜索功能，但是对于最常用的，还是希望能够直接跳转，如在首页后添加 linux 并回车，就能跳转到 Linux 的博文。换句话说，我希望能将 https://blog.lyh543.cn/linux 重定向到 https://blog.lyh543.cn/Linux/linux-daily-command/。 如果博客是架在自己的服务器上，并且用 Nginx 作为网站服务器，一行 location = /linux {return 301;} 就能解决问题； 其实 Hexo 也有解决方法。 由于 HTML（利用 JS）支持跳转功能，我们写一个 linux.html 文件，放在 _posts 目录。由于直接这样会导致我们写的这个 HTML 会出现在首页和搜索结果下面，我们还需要进行隐藏。 在本地安装插件： 1npm install hexo-hide-posts --save 然后编写以下文件，另存为 /source/_posts/linux.html： 12345678---hidden: true---&lt;html&gt;&lt;head&gt;&lt;title&gt;正在跳转&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script language='javascript'&gt;document.location = '/Linux/linux-daily-command/'&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后上传就可以了。这是测试链接。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.lyh543.cn/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"https://blog.lyh543.cn/tags/Visual-Studio-Code/"}]},{"title":"C 语言 I/O 输入输出","date":"2019-06-17T16:00:00.000Z","path":"cpp/cpp-grammar/c-io/","text":"C++ I/O 请见C++ I/O。 C输入输出标识符 类型 输入 输出 long %ld %ld long long %lld %I64d %lld %I64d * float %f %f double %lf %f long double %llf %Lf %Lf * 在 Codeforces 使用 %lld 输出可能会炸，在 Light OJ 上使用 %I64d 会炸，所以我选择 cout🙄 为什么要 scanf_sscanf 在读入字符串的时候中存在安全漏洞，简单的来说就是读字符串时没有指定长度上限，导致可能把字符串（恶意代码）写入其他内存部分。因此使用 Visual Studio 进行工程开发时建议使用 scanf_s 或者 cout。（貌似 scanf_s 也加入了 C++ 20 的标准中，是微软提议的）。使用时，scanf_s 在用 %s 输入字符串时，要在 char* 指针后加一个长度 count 参数。其他语法和 scanf 一致。 scanf %c 不忽略空格、回车scanf(&quot;%c&quot;) 是看得见空格、回车的。相比下，cin 会看不见空格、回车。 scanf %*d 忽略对应输入1scanf(\"%d%*d%d\", &amp;a, &amp;b, &amp;c); 输入 1 2 3，a=1，2 被跳过，b=3，c 未被赋值。 printf 格式化输出1234printf(\"%7.3d\", 2); //output: \" 002\"printf(\"%-7.3d\", 2); //output: \"002 \"printf(\"%7.3f\", float(2)); //output: \" 2.000\"printf(\"%f\", 2); //output: \"0.0\" puts, gets, putchar, getchar, getc12345678puts(\"a\"); //with endlinechar a[100];gets(a); //until it get a endline or eof, and a exclude '\\n'putchar(65); //'A'char a = getchar();char a = getc(FILE* fin);//getc == fgetc 值得注意的是，gets 因为和 scanf 拥有同样的安全漏洞，在 C++ 11 中被弃用，在 C++ 14 中被移除，现在建议使用 fgets，但输入输出有不同。 fgets12char str[100];fgets(str,100,stdin); fgets 后的 str 包含 \\n，而 gets 后的 str 不包含。处理时需注意。 getch1char a = getch() //没有回显，在conio.h里 从文件输入、输出12345678910111213//从文件输入、输出（1）freopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout);// 从文件输入、输出（2）char* s;FILE *fp1,*fp2;fp1=fopen(\"input.txt\",\"r\");fp2=fopen(\"output.txt\",\"w\");fscanf(fp1,\"%s\",s);fprintf(fp2,\"Hello World! And \\\"input.txt\\\" is:%s\",s);fclose(fp1);fclose(fp2);","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"Markdown 语法","date":"2019-06-16T16:00:00.000Z","path":"blog/markdown/","text":"入门 Markdown 推荐：http://younghz.github.io/Markdown/Markdown Cheatsheet: https://bit.ly/mdcheat 本文主要记录 Markdown（如有必要，也会提到 HTML）中不常见的语法，如文字的下标、代码中含有反引号 ` 的处理方法等。 标题中出现了井号标题出现了 # 号，该怎么写呢？ 第一反应，用 \\ 转义，但是也不行。 1## C\\# 经过搜索，在 Stack Overflow 上找到了类似的问题。正确的语法是： 1## C# # 效果见 C#。 当然，不同的渲染方式可能有不同的结果。 顺便吐槽一下，Google 搜索 markdown sharp in title 的前两条都是相关问题，搜索 markdown 标题出现井号 就没有相关问题，有些问题真得用英文问才有结果。 百度搜索中英文都没有，搜索中文的结果全是 Markdown 入门教程 锚点（Anchor） 参考链接: https://www.zhihu.com/question/58630229/answer/191984051 锚（máo）点是什么呢？ 我们知道，每个网站有一个链接。而你会发现这篇博客里，每个标题也有其链接。将鼠标放在这节的标题上（就在上面三行），你会看到一个 #，将鼠标放到 # 上，你就可以看到这个标题对应的链接。 1https://lyh543.cn/Blog/markdown/#锚点（Anchor） 顺便一提，网站右边的 TOC 的目录跳转也是由这个东西实现的。 Github Flavored Markdown 支持目录/页内跳转。只需要在网页链接以后加 # 和标题，如： 1[“图片链接”标题](#图片链接) “图片链接”标题 但是并不是直接复制标题这么简单。它的语法有: 把标题中的所有大写字母变为小写； 删掉除了字母、汉字、数字、空格、连字符 - 外的字符； 把空格变为连字符 -； 如果标题不唯一，则在标题后加 -1，-2，…… 但是有些地方有点区别，如对我的另一篇博客的的 MSVC 下获取本程序运行的时间（μs 级） 标题，应使用 1[MSVC 下获取本程序运行的时间（μs 级）](/cpp/cpp-grammar/time/#MSVC-下获取本程序运行的时间（μs-级）) MSVC 下获取本程序运行的时间（μs 级） 其实这公式也不用记，如果你的博客有 toc(table of contents，即目录) 的功能，直接复制对应标题的目录的链接就可以了。 图片链接![image](https://gitee.com/uploads/images/2019/0424/194736_1331e2af_551056.jpeg) image 想要修改图片大小，必须使用 HTML 语法不会。所以还是本地用 PS 改图片大小吧。 另外，Markdown 插入本地图片一直是个很恼火的东西，这使得它比印象笔记、CSDN、WordPress 麻烦。 但是不少 Markdown 编辑器有图床的功能，能将剪贴板里的图片上传到某个云端，然后在编辑器中加入图片的链接。如 VS Code 的 Coding 图床 插件，能将图片上传至 coding.net（一个使用 Git 的国内云仓库）。 超链接123456[超链接](https://cn.bing.com/)；引用式 [博客][1] 链接。引用式 [GitHub][2] 链接，带 title。[1]: https://mazhuang.org[2]: https://github.com/mzlogin \"我的 GitHub 主页\" 超链接；引用式 博客 链接。引用式 GitHub 链接，带 title。 富文本格式12345678* 这是&lt;b&gt;加粗&lt;/b&gt;* 这也是**加粗*** 这是&lt;sub&gt;下&lt;/sub&gt;标* 这是&lt;del&gt;删除线&lt;/del&gt;* 这也是~~删除线~~* Emoji :laughing: :joy: - 这是第一个小点 - 这是第二个小点 这是加粗 这也是加粗 这是下标 这是删除线 这也是删除线 Emoji :laughing: :joy: 这是第一个小点 这是第二个小点 表格123456| 1 | 2 | 3 || :- | --- | --: || 4 | 5 | 6 || | | || |9 | || | | | 1 2 3 4 5 6 9 在第二行使用 :---------: 居中 使用 :---------- 居左 使用 ----------: 居右 表格中换行可以使用 &lt;br&gt; 表格中代码间换行：可以将代码按行分段用 ` 包含，然后在每段间加入 &lt;br&gt; 行内、段间代码行内代码行内代码 markdown 写法： 1`代码` 效果：代码。 段间代码段间代码 Markdown 写法： 1234567```c++#include&lt;iostream&gt;int main()&#123; std::cout &lt;&lt; \"Hello world!\";&#125;``` 效果如下： 12345#include&lt;iostream&gt;int main()&#123; std::cout &lt;&lt; \"Hello world!\";&#125; 代码包含反引号 ` 的情况行内代码包含一个反引号时，需要改用（一对）两个反引号将代码括起来。 段间代码包含两个反引号时，需要改用（一对）三个反引号将代码括起来。 貌似代码内包含 n 个反引号，即可用 n+1 个反引号代码括起来。挺有意思的。 引用及嵌套引用12345&gt; `#include`是什么？一条预处理指令。于是你就需要搞清楚预处理在c++程序的编译过程中大约发生在什么环节。以下引用 cppreference.com: &gt;&gt; &gt; The preprocessor is executed at translation phase 4, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler. &gt;&gt; C++ 的预处理器在编译之前执行，它看到 `#include` 指令，就会把那个文件的内容替换到当前位置。其它的预处理指令例如`#define`, `#ifdef`, 等也在这个阶段被执行、并产生相应的内容。预处理器执行完成后，所有的预处理指令都会被移除。其结果是一个单个头的大文件（我猜测这文件只存在于内存里），这个文件才会被进一步传给编译器做编译。 注意被嵌套段落的上下都有空行，不然无法嵌套。 #include是什么？一条预处理指令。于是你就需要搞清楚预处理在c++程序的编译过程中大约发生在什么环节。以下引用 cppreference.com: The preprocessor is executed at translation phase 4, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler. C++ 的预处理器在编译之前执行，它看到 #include 指令，就会把那个文件的内容替换到当前位置。其它的预处理指令例如#define, #ifdef, 等也在这个阶段被执行、并产生相应的内容。预处理器执行完成后，所有的预处理指令都会被移除。其结果是一个单个头的大文件（我猜测这文件只存在于内存里），这个文件才会被进一步传给编译器做编译。 折叠代码使用的是 HTML 语法。 12345678910111213141516&lt;details&gt; &lt;summary&gt;折叠文本&lt;/summary&gt; 可以写文本。 但是回车不能换行。&lt;br&gt; 得用 br&lt;/details&gt;&lt;details&gt; &lt;summary&gt;折叠代码，但是不能进行染色&lt;/summary&gt; int main() &#123; printf(\"folded code\"); &#125;&lt;/details&gt; 折叠文本 可以写文本。 但是回车不能换行。 得用 br 折叠代码，但是不能进行染色 int main() { printf(&quot;folded code&quot;); } LaTeX 公式原生 Markdown 不支持 LaTeX 数学公式，但诸如 Typora 等软件支持在 Markdown 中调用 MathJax 从而实现 LaTeX 公式。另外，Chrome 插件 MathJax Plugin for Github 支持渲染网页上的 LaTeX 公式。 LaTeX 公式语法","tags":[{"name":"Blog","slug":"Blog","permalink":"https://blog.lyh543.cn/tags/Blog/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.lyh543.cn/tags/Markdown/"}]},{"title":"AtCoder 计分原理","date":"2019-06-15T16:00:00.000Z","path":"others/atcoder-rating/","text":"rating.pdf","tags":[]},{"title":"状态压缩 DP","date":"2019-05-17T16:00:00.000Z","path":"cpp/acm/状态压缩DP/","text":"定义状态压缩（Bitmask）实际上是一种数据结构，用一个 int 存一行的二进制状态。 位运算技巧独立为了另一篇博客：位运算。 例题：oy环游世界Problem 2173 oy环游世界 这是记忆化搜索而非标程DP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 17;int x[maxn], y[maxn], dis[maxn][maxn];ll dp[1 &lt;&lt; maxn][maxn] = &#123;0&#125;; //dp[state][t]表示已经遍历完 state 中位为1的城市，正在t城市，还需要的最小花费int n, s;//直接递归做，最多只有18层，而且能忽略掉从 s 开始时不可能发生的情形ll dfs(int state, int cur)&#123; if (dp[state][cur] != 0) return dp[state][cur]; if (state + 1 == (1 &lt;&lt; n)) // all are visited return 0; dp[state][cur] = LLONG_MAX; for (int next = 0; next &lt; n; next++) &#123; if ((state&amp;(1&lt;&lt;next))==0) //next is not visited dp[state][cur] = min(dp[state][cur], dfs(state | (1 &lt;&lt; next), next) + dis[cur][next]);//go from cur to next, and use dfs to visit remaining cities starting from next &#125; return dp[state][cur];&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); //我偏要用0标号，因为用1开始，第0个格子会浪费掉，空间会x2 cin &gt;&gt; n &gt;&gt; s; s--; for (int i = 0; i &lt; n;i++) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; dis[i][i] = -1; for (int j = i + 1; j &lt; n; j++) dis[i][j] = dis[j][i] = abs(x[i] - x[j]) + abs(y[i] - y[j]);//与处理一下任意两点的距离 &#125; cout &lt;&lt; dfs(1 &lt;&lt; s, s); return 0;&#125; 标程的DP 1234567891011121314151617for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dp[i][j] != -1) &#123; for (int k = 0; k &lt; n; k++) &#123; if (!(i &amp; (1 &lt;&lt; k))) &#123; dp[i | (1 &lt;&lt; k)][k] = min(dp[i | (1 &lt;&lt; k)][k], dp[i][j] + edges[j][k]); if ((i | (1 &lt;&lt; k)) == (1 &lt;&lt; n) - 1) ans = min(ans, dp[i | (1 &lt;&lt; k)][k]); &#125; &#125; &#125; &#125; &#125; 例题：苇名欧一郎Problem 2178 苇名欧一郎 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 17;int init, k[maxn];ll dp[1 &lt;&lt; maxn]; //dp[state]表示已经杀掉 state 中位为1的怪兽，杀完剩下的方法数int n;void read(int &amp; num)//读二进制&#123; num = 0; int i = 0; char c; while (i &lt; n) &#123; c = getchar(); if (c &lt; '0' || c &gt; '9') continue; num = (num &lt;&lt; 1) + c - '0'; i++; &#125;&#125;ll dfs(int state)&#123; if (dp[state] != 0) return dp[state]; if (state + 1 == (1 &lt;&lt; n)) // all are killed return 1; int kill = init; for (int i = 0; i &lt; n; i++) if (state&amp;(1 &lt;&lt; (n-i-1))) kill |= k[i]; //calculate now who we can kill for (int next = 0; next &lt; n; next++) &#123; if ((state&amp;(1&lt;&lt;(n-next-1)))==0&amp;&amp;(kill&amp;(1&lt;&lt;(n-next-1)))) //next is not killed and we can kill dp[state] += dfs(state | (1 &lt;&lt; (n-next-1)));//kill next! &#125; return dp[state];&#125;int main()&#123; int T; scanf(\"%d\", &amp;T); for (int i = 1; i &lt;= T; i++) &#123; ll ans = 0; scanf(\"%d\", &amp;n); read(init); memset(dp, 0, sizeof(dp)); for (int j = 0; j &lt; n; j++) &#123; read(k[j]); &#125; printf(\"Case %d: %lld\",i,dfs(0));//谨防卡case &#125; return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"ACM","slug":"ACM","permalink":"https://blog.lyh543.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.lyh543.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"位运算","date":"2019-05-16T16:00:00.000Z","path":"cpp/cpp-grammar/bit-operation/","text":"部分转自：https://www.zhihu.com/question/38206659/answer/75338913 用位运算就多打括号！！！不然会炸 判断一个数字x二进制下第i位是不是等于1 1if ((1&lt;&lt;(i-1))&amp;1) 将一个数字x二进制下第i位更改成1。 1x = x | ( 1&lt;&lt;(i-1) ) 把一个数字二进制下最靠右的第一个1去掉。 1x=x&amp;(x-1) 取二进制下的最靠右第一位(12-&gt;4) 1a&amp;-a 枚举时要求集合不能有两个相邻的元素 1if ((mask &gt;&gt; 1) &amp; mask) continue; 在限定必须不取某些元素的前提下枚举子集 12//mask的第x位为0表示x必须不在子集中(原集合中不含这个元素)for (int mask1 = mask; mask1 &gt;= 0; mask1 = (mask1 - 1) &amp; mask) 在限定必须取某些元素的前提下枚举子集 12//mask的第x位为1表示x必须在子集中for (int mask1 = mask; mask1 &lt; (1 &lt;&lt; m); mask1 = (mask1 + 1) | mask) 位运算常用于状态压缩。","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"Excel 中精确搜索——用学号匹配名字","date":"2019-04-14T16:00:00.000Z","path":"microsoft/excel/search-in-excel/","text":"1=VLOOKUP(B2,Namelist!$A$2:$B$386,2,FALSE) 在Namelist工作簿的A2:B386里精确搜索B2，如果有，返回前者第二列的结果 如果文字格式不对，可能需要notepad复制粘贴消一波格式。 但是，仍然有bug。最后是用C++实现的。 垃圾excel","tags":[{"name":"Excel","slug":"Excel","permalink":"https://blog.lyh543.cn/tags/Excel/"}]},{"title":"C 语言程序程序设计课程","date":"2019-03-05T16:00:00.000Z","path":"cpp/cpp-grammar/c-course/","text":"傅爷 nb! 短路语句12if (a == 'q') return; 一直没有学过去的 malloc1234int * a;a = (int*)malloc(sizeof(int));*a = 3;free(a); 变量的生存期C++ (11) 有四种存储变量的方案，这四种方案生成的变量有不同的生存期。 自动生存期 用法：函数（或其他语句块 local scope、函数的形式参数、名称空间）中声明变量。生存期：函数执行过程中。 这种变量之间没有联系，互不相干（同时也可以用相同的名字）。 函数不能声明在代码块中，不然它就不能在其他函数中被使用，这一点也不“函数”。 静态生存期 静态生存期分为三种。 external linkage（文件间可见） 在 C++ 中，变量有两种声明（declaration）方式：a. 一种是定义（或定义声明，defining declaration，definition），这种会分配内存；b. 另一种是引用声明（refering declaration，declaration），不分配内存，只是引用已经存在的变量。 用法：在函数外 int g = 1000;。 在其他文件使用 g 时，需要加 external 并且不能赋初值（否则 external 无效，是定义声明），这便是引用声明。 显然，如果某变量有引用声明，该变量就只能有一个定义声明。 internal linkage（单文件中的函数可见） 用法：在函数外 static i = 1000;。 no linkage（仅在一个函数/代码块可见） 用法：在函数内 static t = 1000;。 这三种变量都会在程序运行过程中一直存在。由于这部分变量占用内存是不变的，程序干脆在运行的一开始，就分配一块内存来存这些静态变量。 编译器还会隐式自动将静态生存期的变量按位模式初始化为 0。对于有用常量表达式赋初值的静态变量，编译器会做一些计算（注意是编译器来做，sizeof 也算是这种计算，另外 C++ 11 后的 constexpr 也被包含在内）；对于复杂的（如，需调用函数），则需要动态初始化。 动态生存期 用法及生存期：从 new 开始，直到 delete。 这之中包含了 register 变量。在 C++ 11 以前，register 变量会使用 CPU 缓存进行存储，对于频繁访问的变量使用 register 能够是程序更快。不过在 C++ 11 以前，也有编译器会自动进行处理，不需要手动 register。C++ 11 直接弃用了 register，把这步完全交给了编译器，register 更像是提示程序员，该变量会被反复使用。 线程生存期 并行运算使用，C++ 11 后。 内存分配内存空间分为四个部分：静态数据区、代码区、栈区、堆区。 静态数据区：全局变量、static存储类的局部变量、常量 代码区：函数代码 栈区：auto存储类的局部变量、函数的形参、函数调用时的有关信息（如返回值） 堆区：动态变量 静态数据区和代码区的大小是固定的，而栈区和堆区的大小随程序的运行不断变化（不过操作系统会对其空间最大值有一定的限制）。 编译程序隐式自动将静态生存期的变量按位模式初始化为 0，其他变量不对其进行初始化（使用空间中的已有值，因此是不固定的） 后缀表达式+堆栈=计算题有点香 多文件编写头文件里有以下部分： 函数原型 常量（#define 或 const） 类和结构的定义（它们不涉及到变量，仅告诉编译器如何创建结构变量） 模板的定义（它只告诉编译器如何生成函数的定义） 内联函数 多个头文件可以相互引用，但是反复引用前记得加 #pragma once，或者使用 #ifndef FILENAME_H_ 宏定义判断是否被引用过。 结构/类的声明（与其成员函数）、内联函数的定义和非内联函数的声明必须放在 .h，非内联函数的函数定义必须放在 .cpp 里（不然会造成多次编译，参考：为什么c++要“在头文件中声明，在源文件中定义”？ - vczh的回答 - 知乎） 最后要在 cpp 文件里 #include &quot;mycpp.h&quot; 工程开发实现一个大的功能（正则匹配器）先从最简单的功能做起，然后慢慢加功能（不然会手忙脚乱的） 函数与过程函数： 1234int add(int a, int b)&#123; return a+b;&#125; 过程： 12345voud foo()&#123; game[0] = 1; game[100] = 100;&#125; 工程开发偏向纯函数 看清函数名、参数和注释，函数过程就不重要了 参数一定、返回值一定，测试方便","tags":[{"name":"C++","slug":"C","permalink":"https://blog.lyh543.cn/tags/C/"},{"name":"C++语法","slug":"C-语法","permalink":"https://blog.lyh543.cn/tags/C-%E8%AF%AD%E6%B3%95/"}]},{"title":"《数学女孩》笔记","date":"2018-06-30T16:00:00.000Z","path":"maths/math-girl/","text":"《数学女孩》系列以小说的形式展开，重点描述一群年轻人探寻数学中的美。内容由浅入深，数学讲解部分十分精妙，被称为“绝赞的数学科普书”。 —— 图灵新知 学习和研究的不同 我有时候在想，学习和研究到底有何不同呢?数学课上，只要读读教科书上写着的内容，然后记住公式， 再用记住的公式解开问题，对一下答案就结束了。然而我认为，研究是去探求“未知的答案”， 是向答案逼近的一个过程。 因为不知道答案才会有趣。 从自己找寻、发现答案的过程中， 才能感受到研究的魅力所在。 —— 山本裕子 ——《数学女孩2》 Q. E. D. Q.E.D. 是拉丁片语 Quod Erat Demonstrandum（意思是“这就是所要证明的”）的缩写。这句拉丁片语译自希腊语，包括欧几里得和阿基米德在内的很多早期数学家都用过。 ——《数学女孩 3：哥德尔不完备定理》 碰上前所未有的概念 出错了、不合逻辑 —— 之所以会陷入这种泥潭，是因为碰上了前所未有的概念。我们可以认为自己失败了，然后折返。不过，我们也可以认为这是一个新的发现，然后继续前进。 ——《数学女孩 3：哥德尔不完备定理》 微积分中的 $n!$ —— 斯特林公式 斯特林公式用于评估 $n!$ 的近似值。它的精度非常高，即使 $n$ 很小，其取值也十分精确。斯特林公式的典型形式是$$ln \\space n! = nln \\space n - n + O(log \\space n)$$更精确的形式是$$n! \\sim \\sqrt{2 \\pi n}(\\begin{smallmatrix}n\\\\e\\end{smallmatrix})^n$$ 由斯特林公式可以得到 $ln \\space n! = \\Omega (nlog \\space n)$。 “幸福的台阶”——一直掷 6 面骰子，直到掷出过所有面，掷骰子的期望次数出现于《数学女孩 4》。 分解为子问题——“上台阶”可以把丢出一个新数字看作上一个台阶，原事件等价于上六次台阶。 设“掷出所有点数时，掷骰子的次数”为 $X$。又设“掷出 $j$ 种点数以后，直至丢出没出过的点数时，掷骰子的次数”为 $X_j$。显然有： \\begin{equation}\\begin{split}X &amp;= X_0 + X_1 + X_2 + X_3 + X_4 + X_5 \\\\E[X] &amp;= E[X_0] + E[X_1] + E[X_2] + E[X_3] + E[X_4] + E[X_5]\\end{split}\\end{equation} 研究子问题——“上一次台阶”的期望次数现在讨论 $E[X_i]$。显然，$E[X_0] = 1$。 掷一次骰子有两种情况：掷出没有出现过的点数、掷出已经出现的点数。对于已经出现过 $j$ 个点的情况，记 \\begin{equation}\\begin{split}p_j &amp;= P \\{ 掷出没有出现过的点数 \\} = 1 - \\frac{j}{6} \\\\q_j &amp;= P \\{ 掷出出现过的点数 \\} = \\frac{j}{6}\\end{split}\\end{equation} 那么，$X_j$ 可以被视为丢概率不同的硬币，丢出一次正面的期望丢硬币次数（非常漂亮的转化）。 要计算 $E(X_j)$，我们就分别计算 $P(X_j = k)$。貌似不可直接列表算，但是可以取极限（出现了，微积分！）。有 \\begin{equation}\\begin{split}P(X_j = k) &amp;= q_j^{k-1} \\cdot p_j \\\\ &amp;= q_j^{k-1} \\cdot (1- q_j) \\\\ &amp;= q_j^{k-1} - q_j^k\\end{split}\\end{equation} 则 \\begin{equation}\\begin{split}E[X_j] &amp;= \\sum_{k=1}^{\\infty} k \\cdot P(X_j = k) \\\\ &amp;= \\lim_{n \\to \\infty} \\sum_{k=1}^{n} k \\cdot P(X_j = k) \\\\ &amp;= \\lim_{n \\to \\infty} \\sum_{k=1}^{n} k (q_j^{k-1} - q_j^k) \\\\ &amp;= \\lim_{n \\to \\infty} ( 1 \\cdot (q_j^0 - q_j^1) + 2 \\cdot (q_j^1 - q_j^2) + \\cdots n \\cdot (q_j^{n-1} - q_j^n)) \\\\ &amp;= \\lim_{n \\to \\infty} ( 1 + q_j^1 + q_j^2 + \\cdots q_j^{n-1} - n \\cdot q_j^n) \\\\ &amp;= \\lim_{n \\to \\infty} \\bigg( \\frac{1-q_j^n}{1-q_j} - n \\cdot q_j^n \\bigg) \\\\ &amp;= \\lim_{n \\to \\infty} \\bigg[ \\frac{1- (\\frac{j}{6})^n}{1-\\frac{j}{6}} - n \\cdot (\\frac{j}{6})^n \\bigg] \\\\ &amp;= \\frac{1}{1-\\frac{j}{6}} \\\\ &amp;= \\frac{6}{6-j}\\end{split}\\end{equation} 回到原问题结果就比较显然了。 \\begin{equation}\\begin{split}E[X] &amp;= E[X_0] + E[X_1] + E[X_2] + E[X_3] + E[X_4] + E[X_5] \\\\ &amp;= \\frac{6}{6} + \\frac{6}{5} + \\frac{6}{4} + \\frac{6}{3} + \\frac{6}{2} + \\frac{6}{1} \\\\ &amp;= 6H_6 \\\\ &amp;\\approx 14.7\\end{split}\\end{equation} 其中 $$H_n = \\sum_{i=1}^{n} \\frac{1}{i}$$ 为调和级数。 该问题还有通用结论： 一直掷 $n$ 面骰子，直到掷出过所有面，掷骰子的期望次数为$$n \\cdot H_n = n \\cdot \\sum_{i=1}^{n} \\frac{1}{i}$$. 哈密尔顿–凯莱定理线代相关。然而线代忘完了https://zh.wikipedia.org/wiki/%E5%87%B1%E8%90%8A%E2%80%93%E5%93%88%E5%AF%86%E9%A0%93%E5%AE%9A%E7%90%86 对于二次来说，对于矩阵 A，有： $$A^2 = tr(A) \\cdot A + |A| \\cdot I$$","tags":[{"name":"数学","slug":"数学","permalink":"https://blog.lyh543.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.lyh543.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}]