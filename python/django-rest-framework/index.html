<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Django REST Framework 学习笔记 | 小灰灰灰灰的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="后端,RESTful,Python,Django">
    <meta name="description" content="Django REST Framework 是什么如果你打算使用 Django 搭建一个 RESTful API 后端，你完全有必要学习 Django REST Framework。 Django REST Framework 提供了 Serializers、APIView、GeneticAPIView、ViewSets、权限管理、搜索、分页等功能。这些功能、特性可以全部加入我们的 RESTful">
<meta property="og:type" content="article">
<meta property="og:title" content="Django REST Framework 学习笔记">
<meta property="og:url" content="https://blog.lyh543.cn/python/django-rest-framework/index.html">
<meta property="og:site_name" content="小灰灰灰灰的博客">
<meta property="og:description" content="Django REST Framework 是什么如果你打算使用 Django 搭建一个 RESTful API 后端，你完全有必要学习 Django REST Framework。 Django REST Framework 提供了 Serializers、APIView、GeneticAPIView、ViewSets、权限管理、搜索、分页等功能。这些功能、特性可以全部加入我们的 RESTful">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-24T10:20:22.000Z">
<meta property="article:modified_time" content="2021-09-11T12:19:35.163Z">
<meta property="article:author" content="lyh543">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="RESTful">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Django">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="小灰灰灰灰的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="mdi mdi-close icon-lg"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">lyh543</h5>
          <a href="mailto:lyh543@outlook.com" title="lyh543@outlook.com" class="mail">lyh543@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg mdi mdi-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg mdi mdi-archive"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg mdi mdi-tag-multiple"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg mdi mdi-format-list-bulleted-square"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lyh543" target="_blank" >
                <i class="icon icon-lg mdi mdi-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg mdi mdi-menu"></i>
        </a>
        <div class="flex-col header-title ellipsis">Django REST Framework 学习笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg mdi mdi-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg mdi mdi-magnify"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg mdi mdi-share-variant"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Django REST Framework 学习笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-01-24T10:20:22.000Z" itemprop="datePublished" class="page-time">
  2021-01-24
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Python/">Python</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Django-REST-Framework-是什么"><span class="post-toc-text">Django REST Framework 是什么</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Django-入门"><span class="post-toc-text">Django 入门</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Django-REST-Framework-官方教程"><span class="post-toc-text">Django REST Framework 官方教程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#例：在序列器中定义可修改的外键-id"><span class="post-toc-text">例：在序列器中定义可修改的外键 id</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#例：自定义-APIException"><span class="post-toc-text">例：自定义 APIException</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#例：自定义对象级权限"><span class="post-toc-text">例：自定义对象级权限</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#例：完成序列化后再修改字段"><span class="post-toc-text">例：完成序列化后再修改字段</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在-view-中的-serializer-data-中添加字段"><span class="post-toc-text">在 view 中的 serializer_data 中添加字段</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在-GeneticAPIView-的-serializer-data-中修改字段"><span class="post-toc-text">在 GeneticAPIView 的 serializer_data 中修改字段</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#思路-1：修改-View-的过程"><span class="post-toc-text">思路 1：修改 View 的过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#思路-2：修改-Serializer"><span class="post-toc-text">思路 2：修改 Serializer</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#serializers-ListField-和-models-ManyToManyField-的梦幻联动"><span class="post-toc-text">serializers.ListField 和 models.ManyToManyField 的梦幻联动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#背景"><span class="post-toc-text">背景</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#REST-API-标准"><span class="post-toc-text">REST API 标准</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#DRF-项目部署"><span class="post-toc-text">DRF 项目部署</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Swagger-文档生成"><span class="post-toc-text">Swagger 文档生成</span></a></li></ol>
        </nav>
    </aside>


<article id="post-python/django-rest-framework"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Django REST Framework 学习笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-01-24 18:20:22" datetime="2021-01-24T10:20:22.000Z"  itemprop="datePublished">2021-01-24</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Python/">Python</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="Django-REST-Framework-是什么"><a href="#Django-REST-Framework-是什么" class="headerlink" title="Django REST Framework 是什么"></a>Django REST Framework 是什么</h2><p>如果你打算使用 Django 搭建一个 RESTful API 后端，你完全有必要学习 Django REST Framework。</p>
<p>Django REST Framework 提供了 Serializers、APIView、GeneticAPIView、ViewSets、权限管理、搜索、分页等功能。这些功能、特性可以全部加入我们的 RESTful 后端，也可以选一部分加入。</p>
<p>如果你和我一样，第一次接触后端，尚不了解 RESTful 后端的组成、功能，可能也会对上面的这些概念懵圈。</p>
<p>用通俗的话来说，RESTful 后端开发过程中，包含了相当多的重复元素，比如：</p>
<ol>
<li>将数据模型（Django 中特指我们编写的 models.Model 类）变为 json 字符串发送给前端，这个变的过程称为<code>序列化</code>；</li>
<li>RESTful API 应该对 <code>GET /activities/</code> 这类请求提供<strong>获取活动列表</strong>的功能，对 <code>POST /activities/</code> 提供<strong>创建活动</strong>的功能；</li>
<li>对于获取活动列表的功能，还应当具有搜索和分页的功能；</li>
<li>RESTful API 应该对 <code>GET /activities/1/</code> 这类请求提供<strong>获取 id 为 1 的活动信息</strong>的功能，对 <code>PUT /activities/1/</code> 和 <code>PATCH /activities/1/</code> 提供<strong>修改 id 为 1 的活动信息</strong>的功能，对 <code>DELETE /activities/1/</code> 提供<strong>删除 id 为 1 的活动</strong>的功能</li>
<li>当然，还需要判定用户是否有权限获取、修改</li>
</ol>
<p>上述步骤，使用纯 Django 也可以完成。而 Django REST Framework 所完成的，就是将具体的、重复的、步骤抽象化、简短化：将 json 到数据模型抽象化为序列器 <code>Serializer</code> 类，借助 <code>Serializer</code> 类编写 <code>序列化</code> 的过程可以最短缩减到<strong>三行</strong>；将提供了通用 RESTful 功能（如提供列表、创建对象、修改、删除）的一些 Django 视图 <code>View</code> 抽象化为 <code>GeneticAPIView</code>，读者在后面可以看到，对不同的 HTTP 方法提供不同功能的代码借助 <code>GeneticAPIView</code> 可以最短缩减到<strong>三行</strong>，搜索分页加起来也可以<strong>不超过十行</strong>；甚至的甚至，相同操作的不同 Views（如，需要对 <code>/activities/</code> 和 <code>/users/</code> 提供相同的列表、创建、获取、修改、删除方法）甚至可以用一个 <code>ViewSet</code> 进行描述。</p>
<p>当然，这种方法适合描述 RESTful API 中大部分通用功能，如果涉及到更细化的操作，如 <code>signup</code> 和 <code>login</code>，就没法用到 ViewSets 这类操作了。而在过于抽象的代码上，如果需求发生了少许更改，也可能导致较大的代码改动，如对于 <code>/activities/</code> 和 <code>/users/</code>，原本二者提供的功能相同，使用一个 <code>ViewSet</code> 就可以描述，突然要求对 <code>/users/</code> 中的注册过程添加一个验证码，都会导致这部分的代码重写。</p>
<p>综上所属，抽象化有其优点也有其缺点，在实际编码过程中，并不一定使用到 <code>ViewSets</code>，我的项目中最抽象也只用到了 <code>GeneticAPIView</code>。</p>
<h2 id="Django-入门"><a href="#Django-入门" class="headerlink" title="Django 入门"></a>Django 入门</h2><p><a href="../django-study-notes">Django 入门</a></p>
<p>Django REST Framework 教程中也包含了必要的 Django 知识，不过我仍然建议简单看一下 Django 入门教程；以及，很多时候也会去查 Django 的文档。</p>
<h2 id="Django-REST-Framework-官方教程"><a href="#Django-REST-Framework-官方教程" class="headerlink" title="Django REST Framework 官方教程"></a>Django REST Framework 官方教程</h2><p><a href="https://q1mi.github.io/Django-REST-framework-documentation/tutorial/1-serialization_zh/" target="_blank" rel="noopener">汉化版教程链接</a></p>
<h2 id="例：在序列器中定义可修改的外键-id"><a href="#例：在序列器中定义可修改的外键-id" class="headerlink" title="例：在序列器中定义可修改的外键 id"></a>例：在序列器中定义可修改的外键 id</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 为了防止循环引用，这里使用字符串表示 ActivityPhoto 类</span></span><br><span class="line">    banner = models.ForeignKey(<span class="string">'activities_photos.ActivityPhoto'</span>, null=<span class="literal">True</span>, default=<span class="literal">None</span>, on_delete=models.SET_NULL,</span><br><span class="line">                               verbose_name=<span class="string">"首页图"</span>, related_name=<span class="string">"banner_of"</span>)</span><br></pre></td></tr></table></figure>

<p>Django REST Framework 处理外键 id 有点复杂。因为它的 <code>update</code> 默认是修改 id 值：如果你想修改 Acitivity 的 <code>banner.id</code> 为 4，DRF 的默认操作是把这个 Acitivity 外键现在指向的 banner 的 id 改为 4，而不是把 Acitivity 的外键重新指向 id 为 4 的 banner。</p>
<p>但是，请注意到，万能的 Django 为这个 Activity 提供了一个 <code>banner_id</code> 属性。在读取的时候，这个东西和 <code>banner.id</code> 的值是一样的，但在写入的时候：</p>
<ul>
<li>修改 <code>banner.id</code> 的操作是将外键现在指向的 banner 的 id 改为 4，且修改为 <code>None</code> 时会报错：<code>不存在 ActivityPhoto</code></li>
<li>修改 <code>banner_id</code> 的操作是将外键重新指向 id 为 4 的 banner，且修改为 <code>None</code> 表示设置这个外键为 null</li>
</ul>
<p>于是，Serializer 里直接写 <code>banner_id</code> 就行了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivitySerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Activity</span><br><span class="line">        fields = (<span class="string">"id"</span>, <span class="string">"banner_id"</span>)</span><br><span class="line">        read_only_fields = (<span class="string">"id"</span>)</span><br><span class="line">    <span class="comment"># 默认的 banner_id 是 allow_null=False, read_only=True，所以需要显式定义</span></span><br><span class="line">    banner_id = serializers.CharField(allow_null=<span class="literal">True</span>, read_only=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认的也不带 validator，如果不写 validator 导致数据库插入失败，就等着服务器抛 500 吧</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_banner_id</span><span class="params">(self, banner_id: str)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> banner_id <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> ActivityPhoto.objects.filter(id=banner_id):</span><br><span class="line">            <span class="keyword">return</span> banner_id</span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">"id 对应的图片不存在"</span>)</span><br></pre></td></tr></table></figure>

<p>Django 永远滴神！</p>
<h2 id="例：自定义-APIException"><a href="#例：自定义-APIException" class="headerlink" title="例：自定义 APIException"></a>例：自定义 APIException</h2><p>Django 中的 <code>raise Http404</code> 用着很爽，可以在任何函数打断当前 view 的执行，直接返回一个 404 的 HttpResponse。但是不能自己定义别的返回值，诸如 104、500、503 等等。</p>
<p>一种思路是手写一个装饰器，在原本的 view 外包装一个 <code>try ... catch</code> 代码块，再自己定义各种 Exception 就可以实现了。</p>
<p>不过，Django REST Framework 在自己的 View 中提供了这个功能，我们只需要继承 <code>rest_framework.exceptions.APIException</code> 就可以了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnedriveUnavailableException</span><span class="params">(APIException)</span>:</span></span><br><span class="line">    status_code = <span class="number">503</span></span><br><span class="line">    default_detail = <span class="string">'Onedrive 服务未登录。'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># raise OnedriveUnavailableException 即可返回 503，&#123;"detail": "Onedrive 服务未登录。"&#125;</span></span><br></pre></td></tr></table></figure>

<p>太香了！</p>
<h2 id="例：自定义对象级权限"><a href="#例：自定义对象级权限" class="headerlink" title="例：自定义对象级权限"></a>例：自定义对象级权限</h2><p><a href="https://q1mi.github.io/Django-REST-framework-documentation/api-guide/permissions_zh/#_3" target="_blank" rel="noopener">文档</a></p>
<p>需求是这样的，我们需要仿照 <code>IsAdminOrReadOnly</code>，编写一个 <code>IsPresenterOrAdminOrReadOnly</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsPresenterOrAdminOrReadOnly</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_object_permission</span><span class="params">(self, request, view, activity: Activity)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(</span><br><span class="line">            request.method <span class="keyword">in</span> SAFE_METHODS <span class="keyword">or</span></span><br><span class="line">            request.user <span class="keyword">and</span></span><br><span class="line">            (activity.presenter.filter(id=request.user.id) <span class="keyword">or</span> request.user.is_staff <span class="keyword">or</span> request.user.is_superuser)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityAttenderUpdateView</span><span class="params">(GenericAPIView)</span>:</span></span><br><span class="line">    permission_classes = (IsPresenterOrAdminOrReadOnly,)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">patch</span><span class="params">(self, request: WSGIRequest, id: int)</span> -&gt; Response:</span></span><br><span class="line">        activity = get_object_or_404(Activity, id=id)</span><br><span class="line">        self.check_object_permissions(request, activity)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>如果你正在编写自己的视图并希望强制执行对象级权限检测，或者你想在通用视图中重写 <code>get_object</code> 方法，那么你需要在检索对象的时候显式调用视图上的 <code>.check_object_permissions(request, obj)</code> 方法。</p>
</blockquote>
<h2 id="例：完成序列化后再修改字段"><a href="#例：完成序列化后再修改字段" class="headerlink" title="例：完成序列化后再修改字段"></a>例：完成序列化后再修改字段</h2><p>DRF 的 GeneticAPIView 写起来真的很爽，把 Models 和 Serializer 写好以后，GeneticAPIView 只需要几行就能写完，完成搜索、分页、序列化、返回 Response。但是，不可避免的是，某些时候想要传回更多的字段，或者由于权限问题隐藏某些字段。这个时候，我们就需要自己改写一部分 GeneticAPIView。</p>
<h3 id="在-view-中的-serializer-data-中添加字段"><a href="#在-view-中的-serializer-data-中添加字段" class="headerlink" title="在 view 中的 serializer_data 中添加字段"></a>在 view 中的 serializer_data 中添加字段</h3><p>需求是这样的：原本的 login 函数完成了接收 <code>username</code> 和 <code>password</code> 并验证，正确后将该用户的信息用 <code>UserSerializer</code> 序列化后返回：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request: WSGIRequest)</span> -&gt; Response:</span></span><br><span class="line">    err_response = Response(status=status.HTTP_401_UNAUTHORIZED)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'username'</span> <span class="keyword">not</span> <span class="keyword">in</span> request.data <span class="keyword">or</span> <span class="string">'password'</span> <span class="keyword">not</span> <span class="keyword">in</span> request.data:</span><br><span class="line">        <span class="keyword">return</span> err_response</span><br><span class="line">    username = request.data[<span class="string">'username'</span>]</span><br><span class="line">    password = request.data[<span class="string">'password'</span>]</span><br><span class="line">    user = authenticate(request, username=username, password=password)</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> err_response</span><br><span class="line">    django_login(request, user)</span><br><span class="line">    serializer = UserSerializer(user)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure>

<p>由于某些原因，我需要把 <code>csrftoken</code> 加入到返回的 JSON 中。<code>csrftoken</code> 的获取方法是 <code>csrf.get_token(request)</code>。如何将 <code>csrftoken</code> 加入序列化字段呢？</p>
<p>最容易想到，但最麻烦且最不美观的方法是修改 <code>UserSerializer</code>。有没有其他方法呢？</p>
<p>在最后一行打断点然后调试，执行到这里时看一眼 <code>serializer.data</code> 的类型，是 <code>OrderedDict</code>。<code>OrderedDict</code> 就很好办了，在 Response 之前修改一下，添加一个字段就可以了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request: WSGIRequest)</span> -&gt; Response:</span></span><br><span class="line">    err_response = Response(status=status.HTTP_401_UNAUTHORIZED)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'username'</span> <span class="keyword">not</span> <span class="keyword">in</span> request.data <span class="keyword">or</span> <span class="string">'password'</span> <span class="keyword">not</span> <span class="keyword">in</span> request.data:</span><br><span class="line">        <span class="keyword">return</span> err_response</span><br><span class="line">    username = request.data[<span class="string">'username'</span>]</span><br><span class="line">    password = request.data[<span class="string">'password'</span>]</span><br><span class="line">    user = authenticate(request, username=username, password=password)</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> err_response</span><br><span class="line">    serializer = UserSerializer(user)</span><br><span class="line">    serializer_data = serializer.data</span><br><span class="line">    serializer_data[<span class="string">'csrftoken'</span>] = csrf.get_token(request)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer_data, status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure>

<h3 id="在-GeneticAPIView-的-serializer-data-中修改字段"><a href="#在-GeneticAPIView-的-serializer-data-中修改字段" class="headerlink" title="在 GeneticAPIView 的 serializer_data 中修改字段"></a>在 GeneticAPIView 的 serializer_data 中修改字段</h3><p>这个看起来就要麻烦一点了，毕竟本身 GeneticAPIView 部分是一个函数都没有写。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(ListAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all().order_by(<span class="string">"-userprofile__experience"</span>)</span><br><span class="line">    filter_backends = (filters.SearchFilter,)</span><br><span class="line">    search_fields = (<span class="string">'username'</span>, <span class="string">'first_name'</span>, <span class="string">'last_name'</span>, <span class="string">'userprofile__student_id'</span>)</span><br><span class="line">    pagination_class = Pagination</span><br><span class="line">    serializer_class = UserSerializer</span><br></pre></td></tr></table></figure>

<p>这里的需求是：为了保护用户隐私，对于非管理员用户，不让其获取用户的 <code>username</code> 和 <code>student_id</code>，将返回的 <code>username</code> 改为 <code>***</code>、<code>student_id</code> 改为前四位（代表入学年份）。</p>
<p>这里就有两种思路了：修改每一个 View 的处理过程（不仅仅是这个 View 需要保护隐私，其他 View 也应当保护隐私）；或者直接修改 <code>Serializer</code> 的序列化过程。</p>
<h4 id="思路-1：修改-View-的过程"><a href="#思路-1：修改-View-的过程" class="headerlink" title="思路 1：修改 View 的过程"></a>思路 1：修改 View 的过程</h4><p>我们可以考虑类似于上面添加 <code>csrftoken</code> 字段的思路。读 <code>ListAPIView</code> 的源码后，可以知道，<code>get</code> 方法调用了 <code>list</code> 方法，而 <code>list</code> 中做了查询、分页、序列化、包装成分页形式再返回的操作。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListAPIView</span><span class="params">(mixins.ListModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  GenericAPIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListModelMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line"></span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>

<p>我们只需要把官方的 list 方法复制下来，然后改写一下，在序列化以后判断是否是管理员，对于非管理员，替换每个 <code>username</code> 和 <code>student_id</code> 就可以了。</p>
<p>注意到官方给的 <code>list</code> 用 if 判断了是否用到分页功能，针对不同情况作了处理。我们已经用到了分页，所以可以把 if 删掉。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListView</span><span class="params">(ListAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all().order_by(<span class="string">"-userprofile__experience"</span>)</span><br><span class="line">    filter_backends = (filters.SearchFilter,)</span><br><span class="line">    search_fields = (<span class="string">'username'</span>, <span class="string">'first_name'</span>, <span class="string">'last_name'</span>, <span class="string">'userprofile__student_id'</span>)</span><br><span class="line">    pagination_class = Pagination</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 复制官方的 list，然后根据自己的需求进行改写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request: WSGIRequest, *args, **kwargs)</span> -&gt; Response:</span></span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">        serializer_data = serializer.data</span><br><span class="line">        <span class="comment"># 对于非管理员，需要替换学号为学号前四位</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (request.user.is_staff <span class="keyword">or</span> request.user.is_staff):</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> serializer_data:</span><br><span class="line">                item[<span class="string">'username'</span>] = <span class="string">'***'</span></span><br><span class="line">                item[<span class="string">'student_id'</span>] = item[<span class="string">'student_id'</span>][<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">return</span> self.get_paginated_response(serializer_data)</span><br></pre></td></tr></table></figure>

<p>这种方法的缺点就是需要对每一个 View 进行修改，而且在 List 的结果中，非管理员也不能获得自己的详细信息了。</p>
<h4 id="思路-2：修改-Serializer"><a href="#思路-2：修改-Serializer" class="headerlink" title="思路 2：修改 Serializer"></a>思路 2：修改 Serializer</h4><p>上面的方法需要对每个 View 进行修改，并且新增的 View 如果忘记修改了，还会导致数据泄露。有没有从 Model 或 Serializer 下手的方法呢？</p>
<p>这种方案要解决两个问题，一是序列化的过程中并没有 <code>request</code>，没有 <code>request</code> 我们就没法判断当前用户是否是管理员，所以需要通过什么方法传进去；二是需要自定义序列化的过程。</p>
<hr>
<p>对于第一个问题，<a href="https://www.django-rest-framework.org/api-guide/serializers/#including-extra-context" target="_blank" rel="noopener">DRF 文档</a> 中提到，可以在序列化时提供 <code>context</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serializer = AccountSerializer(account, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br><span class="line">serializer.data</span><br><span class="line"><span class="comment"># &#123;'id': 6, 'owner': 'denvercoder9', 'created': datetime.datetime(2013, 2, 12, 09, 44, 56, 678870), 'details': 'http://example.com/accounts/6/details'&#125;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>context</code> 中提供 user 信息，我们就可以判断用户的身份了。更好的是，GeneticAPIView 在序列化时，提供了默认的 <code>context</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericAPIView</span><span class="params">(views.APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Base class for all other generic views.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return the serializer instance that should be used for validating and</span></span><br><span class="line"><span class="string">        deserializing input, and for serializing output.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        serializer_class = self.get_serializer_class()</span><br><span class="line">        kwargs[<span class="string">'context'</span>] = self.get_serializer_context()</span><br><span class="line">        <span class="keyword">return</span> serializer_class(*args, **kwargs)    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Extra context provided to the serializer class.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'request'</span>: self.request,</span><br><span class="line">            <span class="string">'format'</span>: self.format_kwarg,</span><br><span class="line">            <span class="string">'view'</span>: self</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这下我们直接在 Serializer 里用就行了，GeneticAPIView 一行都不用修改。</p>
<hr>
<p>对于第二个问题，查询资料发现，DRF 序列化的函数为 <code>to_representation</code>，其定义如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Serializer</span><span class="params">(BaseSerializer, metaclass=SerializerMetaclass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Object instance -&gt; Dict of primitive datatypes.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = OrderedDict()</span><br><span class="line">        fields = self._readable_fields</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> fields:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                attribute = field.get_attribute(instance)</span><br><span class="line">            <span class="keyword">except</span> SkipField:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># We skip `to_representation` for `None` values so that fields do</span></span><br><span class="line">            <span class="comment"># not have to explicitly deal with that case.</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># For related fields with `use_pk_only_optimization` we need to</span></span><br><span class="line">            <span class="comment"># resolve the pk value.</span></span><br><span class="line">            check_for_none = attribute.pk <span class="keyword">if</span> isinstance(attribute, PKOnlyObject) <span class="keyword">else</span> attribute</span><br><span class="line">            <span class="keyword">if</span> check_for_none <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                ret[field.field_name] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret[field.field_name] = field.to_representation(attribute)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>我们只需要重写它即可，把上面的代码复制下来，然后在 return 之前判断用户身份，替换 <code>ret</code> 的 <code>student_id</code> 和 <code>username</code> 字段。</p>
<p>不对，连复制都不需要，我们只需要调用父类的 <code>to_representation()</code>，然后加两行就可以了！</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_representation</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">    ret = super().to_representation(instance)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐藏 username 和 student_id</span></span><br><span class="line">    request = self.context.get(<span class="string">'request'</span>)</span><br><span class="line">    <span class="keyword">if</span> request <span class="keyword">is</span> <span class="literal">None</span>:     <span class="comment"># django shell 时会出现 request is None</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (request.user.is_staff <span class="keyword">or</span> request.user.is_superuser <span class="keyword">or</span> request.user.id == ret[<span class="string">'id'</span>]):</span><br><span class="line">        ret[<span class="string">'username'</span>] = <span class="string">'***'</span></span><br><span class="line">        ret[<span class="string">'student_id'</span>] = ret[<span class="string">'student_id'</span>][<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h2 id="serializers-ListField-和-models-ManyToManyField-的梦幻联动"><a href="#serializers-ListField-和-models-ManyToManyField-的梦幻联动" class="headerlink" title="serializers.ListField 和 models.ManyToManyField 的梦幻联动"></a>serializers.ListField 和 models.ManyToManyField 的梦幻联动</h2><p>对于外键这类东西，Serializer 虽然不能自动处理，但是也提供了接口，只要加一点代码就可以完成灵活的写入。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>场景是这样的：<code>主讲人</code> 是关于 <code>Activity</code> 和 <code>User</code> 的一个多对多的关系。在 Model 中是这样定义的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    presenter = models.ManyToManyField(User, verbose_name=<span class="string">"主讲人"</span>, related_name=<span class="string">"present_activity"</span>)</span><br></pre></td></tr></table></figure>

<p>对于获取 Actiivty 信息的 REST API，常见的一种写法是返回该 Activity 的所有主讲人的 id 组成的数组。</p>
<p>在 DRF 中可以使用 <a href="https://q1mi.github.io/Django-REST-framework-documentation/api-guide/fields_zh/#listfield" target="_blank" rel="noopener">ListField</a> 来实现。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivitySerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Activity</span><br><span class="line"></span><br><span class="line">    presenter = serializers.ListField(child=serializers.IntegerField(), read_only=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>但是 ListField 并不能直接将 ManyToManyField 的内容转化为 ListField。转化部分需要我们自己写。</p>
<p>怎么写呢？改 <code>to_representation</code> 吗？我尝试了一下这个，最终放弃了，因为一调用 <code>super().to_representation</code> 就会尝试把 <code>presenter</code> 序列化。</p>
<p>Python 可以定义一个类的方法为属性，如果定义了 <code>setter</code>，还可以把外界对这个属性的修改，反作用到原来的属性：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    presenter = models.ManyToManyField(User, verbose_name=<span class="string">"主讲人"</span>, related_name=<span class="string">"present_activity"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">presenter_id</span><span class="params">(self)</span> -&gt; List[int]:</span></span><br><span class="line">        queryset = self.presenter.all().values(<span class="string">'id'</span>)</span><br><span class="line">        <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> u: u[<span class="string">'id'</span>], queryset))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @presenter_id.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">presenter_id</span><span class="params">(self, value: List[int])</span>:</span></span><br><span class="line">        self.presenter.clear()</span><br><span class="line">        self.presenter.add(*value)</span><br></pre></td></tr></table></figure>

<p>然后我们指定一下 ListField 的 <code>source</code> 就可以了：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivitySerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Activity</span><br><span class="line"></span><br><span class="line">    presenter = serializers.ListField(child=serializers.IntegerField(), source=<span class="string">"presenter_id"</span>, read_only=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>就这么简单。</p>
<hr>
<p>对了，后面发现，<code>create</code> 的时候还是会报错，因为 DRF 会在创建 Activity 时尝试设定 <code>presenter</code> 值，而此时 Activity 还没有写入数据库、没有主键，于是也没法创建多对多的记录。</p>
<p>解决方法是重载 <code>create</code> 方法，在 Activity 创建之后再写 presenter：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivitySerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Activity</span><br><span class="line"></span><br><span class="line">    presenter = serializers.ListField(child=serializers.IntegerField(), source=<span class="string">"presenter_id"</span>, read_only=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        presenter = validated_data.pop(<span class="string">'presenter'</span>, [])</span><br><span class="line">        activity = super().create(validated_data)</span><br><span class="line">        activity.presenter_id = presenter</span><br><span class="line">        <span class="keyword">return</span> activity</span><br></pre></td></tr></table></figure>

<h2 id="REST-API-标准"><a href="#REST-API-标准" class="headerlink" title="REST API 标准"></a>REST API 标准</h2><p>开发 REST 的工具有了，那标准呢？这是一个非常重要的问题。就像学了 C 语言后能写出很多的程序，但是常用的代码风格、代码库依旧要参考其他的标准。</p>
<p>我为此新开了一篇博文：<a href="../restful-api-standard">RESTful API 标准</a>。</p>
<h2 id="DRF-项目部署"><a href="#DRF-项目部署" class="headerlink" title="DRF 项目部署"></a>DRF 项目部署</h2><p>可以参考 <a href="https://github.com/uestc-msc/uestcmsc_webapp_backend/blob/lyh543/docs/deploy/deploy.md" target="_blank" rel="noopener">https://github.com/uestc-msc/uestcmsc_webapp_backend/blob/lyh543/docs/deploy/deploy.md</a></p>
<h2 id="Swagger-文档生成"><a href="#Swagger-文档生成" class="headerlink" title="Swagger 文档生成"></a>Swagger 文档生成</h2><p>可以看 <a href="../drf_yasg">drf-yasg</a>。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-09-11T12:19:35.163Z" itemprop="dateUpdated">2021-09-11 20:19:35</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://blog.lyh543.cn">
            <img src="/img/avatar.png" alt="lyh543">
            lyh543
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/python/django-rest-framework/&title=《Django REST Framework 学习笔记》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon mdi mdi-sina-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/python/django-rest-framework/&title=《Django REST Framework 学习笔记》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon mdi mdi-qqchat"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/python/django-rest-framework/" data-title=" Facebook">
          <i class="icon mdi mdi-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Django REST Framework 学习笔记》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/python/django-rest-framework/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon mdi mdi-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/python/django-rest-framework/" data-title=" Google+">
          <i class="icon mdi mdi-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-lg mdi mdi-share-variant"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/python/drf-yasg/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon mdi mdi-chevron-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">drf-yasg —— Django REST Framework 文档生成</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/sql/error-cant-connect-to-local-mysql-server-through-socket/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-lg icon-pl mdi mdi-chevron-right"></i></div>
        <h4 class="title">Linux 连接 Docker MySQL 报错：error:&#34;Can&#39;t connect to local MySQL server through socket &#39;/var/run/mysqld/mysqld.sock&#39; (2)&#34;</h4>
      </a>
    </div>
  
</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: 'ec7daa4e047c3c30570d',
          clientSecret: '025a9e40a1d101f28fd1a945d286a819e9fa1c3d',
          repo: 'lyh543.github.io',
          owner: 'lyh543',
          admin: ['lyh543'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg mdi mdi-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>lyh543 &copy; 2019 - 2021</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">蜀ICP备19034464号</a><br>
                
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg mdi mdi-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/python/django-rest-framework/&title=《Django REST Framework 学习笔记》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon mdi mdi-sina-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/python/django-rest-framework/&title=《Django REST Framework 学习笔记》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon mdi mdi-qqchat"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/python/django-rest-framework/" data-title=" Facebook">
          <i class="icon mdi mdi-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Django REST Framework 学习笔记》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/python/django-rest-framework/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon mdi mdi-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/python/django-rest-framework/" data-title=" Google+">
          <i class="icon mdi mdi-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMklEQVR42u3aS47jMAxFUe9/065pA12y7iOTAkxdjYJ8LB0NGJHideFxL8a/n66+SZ78/2+vbwwZMmS8lnE/DjIBeX/1hHRTliuRIUPGAQyyCB58n4Pm84yreTdPkCFDhoxSoIyDJphXhgwZMlIGf10L1jJkyJCRJrGfKtj1j6EyZMg4jcEX8fevv3K/IUOGjFcx7nCQJ/Agmx4fl6uSIUPGaAYPcLWF1i4AiuuRIUPGUEYaLkmZrFUyA6W9X96RIUPGaEbwJZDWPm9HGrjJdmz+N2TIkDGI0b8e4E2ota3hCbAMGTLmMdJkstZI8anwugzuMmTIOIzBU83+JSg//G14MmTIOICRXiumwbdztYDWIEOGjMMYaRLLG1K/cVUgQ4aMkxmfCsG1T3mSfHV2V4YMGS9hpOV+nujyUh0/PsbNFjJkyBjKSBtJ+fSk1ZU3bWx6RmTIkDGI0QmCnViXvr/5pgwZMkYz0gkIlTfik60pXiTIkCFjHINMXAt/5DiYFvU2SawMGTKOZPAyfS2VvfHYHD1lyJBxAIMc+GrXAxyWtmXIkCFDBr8MqJXt+AahvwEZMmQMZdzh6LRT8Caw1tlWhgwZ4xh8BGWvdiGPLz3GyJAh47WMTpGrVpirHTpREitDhozRDB74akX/NJiSop4MGTJkpBcGaWsFOXQGh1EZMmTIaARfHlhrV54yZMg4h0GS2FpzGElfa8dKGTJknMNIU8fOUY+3a/TDtwwZMkYwfgDX3lWDjQWzeAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>










</body>
</html>
