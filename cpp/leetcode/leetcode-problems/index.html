<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>LeetCode 合集 | 小灰灰灰灰的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C++,LeetCode">
    <meta name="description" content="记录一些有意思的题。 经典算法二分搜索34. 在排序数组中查找元素的第一个和最后一个位置二分搜索的加强版 4. 寻找两个正序数组的中位数算是非常经典又非常复杂的一道题了。我的算法和官方题解稍有不同，可以康康（我的题解）： 123456789101112131415161718192021222324252627282930313233class Solution &amp;#123;public:">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 合集">
<meta property="og:url" content="https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/index.html">
<meta property="og:site_name" content="小灰灰灰灰的博客">
<meta property="og:description" content="记录一些有意思的题。 经典算法二分搜索34. 在排序数组中查找元素的第一个和最后一个位置二分搜索的加强版 4. 寻找两个正序数组的中位数算是非常经典又非常复杂的一道题了。我的算法和官方题解稍有不同，可以康康（我的题解）： 123456789101112131415161718192021222324252627282930313233class Solution &amp;#123;public:">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-27T11:12:57.000Z">
<meta property="article:modified_time" content="2021-09-11T12:19:35.107Z">
<meta property="article:author" content="lyh543">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="小灰灰灰灰的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="mdi mdi-close icon-lg"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">lyh543</h5>
          <a href="mailto:lyh543@outlook.com" title="lyh543@outlook.com" class="mail">lyh543@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg mdi mdi-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg mdi mdi-archive"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg mdi mdi-tag-multiple"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg mdi mdi-format-list-bulleted-square"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lyh543" target="_blank" >
                <i class="icon icon-lg mdi mdi-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg mdi mdi-menu"></i>
        </a>
        <div class="flex-col header-title ellipsis">LeetCode 合集</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg mdi mdi-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg mdi mdi-magnify"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg mdi mdi-share-variant"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">LeetCode 合集</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-10-27T11:12:57.000Z" itemprop="datePublished" class="page-time">
  2020-10-27
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/LeetCode/">LeetCode</a></li></ul></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#经典算法"><span class="post-toc-text">经典算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二分搜索"><span class="post-toc-text">二分搜索</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="post-toc-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-寻找两个正序数组的中位数"><span class="post-toc-text">4. 寻找两个正序数组的中位数</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线性数据结构"><span class="post-toc-text">线性数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#时间线、区间调度问题"><span class="post-toc-text">时间线、区间调度问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1024-视频拼接"><span class="post-toc-text">1024. 视频拼接</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#56-合并区间"><span class="post-toc-text">56. 合并区间</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#并查集"><span class="post-toc-text">并查集</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#树"><span class="post-toc-text">树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#树的遍历（非递归）"><span class="post-toc-text">树的遍历（非递归）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#先序遍历"><span class="post-toc-text">先序遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#中序遍历"><span class="post-toc-text">中序遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#后序遍历"><span class="post-toc-text">后序遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#统一写法"><span class="post-toc-text">统一写法</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#动态规划"><span class="post-toc-text">动态规划</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#877-石子游戏"><span class="post-toc-text">877. 石子游戏</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1000-合并石头的最低成本"><span class="post-toc-text">1000. 合并石头的最低成本</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#312-戳气球"><span class="post-toc-text">312. 戳气球</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#41-接雨水"><span class="post-toc-text">41. 接雨水</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#84-柱状图中最大的矩形"><span class="post-toc-text">84. 柱状图中最大的矩形</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数学题"><span class="post-toc-text">数学题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线性筛"><span class="post-toc-text">线性筛</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#巧妙的算法"><span class="post-toc-text">巧妙的算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#41-缺失的第一个正数"><span class="post-toc-text">41. 缺失的第一个正数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-字符串转换整数-atoi"><span class="post-toc-text">8. 字符串转换整数 (atoi)</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#巧妙的-C-语法"><span class="post-toc-text">巧妙的 C++ 语法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#std-stoi"><span class="post-toc-text">std::stoi</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#string-substr"><span class="post-toc-text">string::substr</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#集合的交集"><span class="post-toc-text">集合的交集</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#巧妙的数据结构"><span class="post-toc-text">巧妙的数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单调栈"><span class="post-toc-text">单调栈</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单调队列"><span class="post-toc-text">单调队列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#双堆：数据流中位数"><span class="post-toc-text">双堆：数据流中位数</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-cpp/leetcode/leetcode-problems"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">LeetCode 合集</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-10-27 19:12:57" datetime="2020-10-27T11:12:57.000Z"  itemprop="datePublished">2020-10-27</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/LeetCode/">LeetCode</a></li></ul></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>记录一些有意思的题。</p>
<h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><p>二分搜索的加强版</p>
<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h4><p>算是非常经典又非常复杂的一道题了。我的算法和官方题解稍有不同，可以康康（<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/cong-biao-zhun-de-er-fen-cha-zhao-yan-sh-hwem/" target="_blank" rel="noopener">我的题解</a>）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//尝试在 nums1 中找中位数，seq 从 0 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNum</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> seq)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums1.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// assert left &lt;= ans &lt;= right</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> mid_2 = seq - mid; <span class="comment">// 如果 mid 是中位数，mid_2 应当大于等于 mid，mid_2-1 应当小于等于 mid</span></span><br><span class="line">            <span class="keyword">if</span> (mid_2 &lt; <span class="number">0</span> || (mid_2 &lt; (<span class="keyword">int</span>)nums2.size() &amp;&amp; nums2[mid_2] &lt; nums1[mid]))</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mid_2 - <span class="number">1</span> &gt;= (<span class="keyword">int</span>)nums2.size() || (mid_2 - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums2[mid_2 - <span class="number">1</span>] &gt; nums1[mid]))</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> nums1[mid];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findNum(nums2, nums1, seq); <span class="comment">// 反向在 2 数组中找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.size(), n2 = nums2.size();</span><br><span class="line">        <span class="keyword">if</span> ((n1 + n2) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> findNum(nums1, nums2, (n1 + n2) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (findNum(nums1, nums2, (n1 + n2) / <span class="number">2</span>) +</span><br><span class="line">                findNum(nums1, nums2, (n1 + n2) / <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h2><h3 id="时间线、区间调度问题"><a href="#时间线、区间调度问题" class="headerlink" title="时间线、区间调度问题"></a>时间线、区间调度问题</h3><p>这类问题一般是给定很多时间区间（区间的起始时间、终止时间），讨论一定的问题。</p>
<p>这类问题一般可以用贪心/动态规划解，贪心之前需要进行排序。</p>
<h4 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a><a href="https://leetcode-cn.com/problems/video-stitching/" target="_blank" rel="noopener">1024. 视频拼接</a></h4><p>求覆盖完整个范围所需子区间的最小值。</p>
<p>结论：按结束时间降序排序，然后从前往后遍历（遍历的时候需要同时考虑其结束时间是否超过了当前开始时间、其开始时间是否比下一次的开始时间更远）。</p>
<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/submissions/" target="_blank" rel="noopener">56. 合并区间</a></h4><p>结论：按开始时间升序排序，能够合并的区间一定连续。</p>
<hr>
<p>还有一种巧妙的做法，注意到线段重合等价于 <code>a[1] &gt;= b[0] || b[1] &gt;= a[0]</code>，于是我们重载 <code>set</code> 的比较类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用这个比较类定义的 set 中，如果两个线段重合，这两个线段在 set 中是被认为相等的！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, Cmp&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> interval : intervals)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = s.find(interval);</span><br><span class="line">            <span class="keyword">while</span> (iter != s.end())</span><br><span class="line">            &#123;</span><br><span class="line">                interval[<span class="number">0</span>] = min(interval[<span class="number">0</span>], (*iter)[<span class="number">0</span>]);</span><br><span class="line">                interval[<span class="number">1</span>] = max(interval[<span class="number">1</span>], (*iter)[<span class="number">1</span>]);</span><br><span class="line">                s.erase(iter);</span><br><span class="line">                iter = s.find(interval);</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(interval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(s.begin(), s.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ul>
<li>并查集：<a href="https://leetcode-cn.com/problems/accounts-merge/" target="_blank" rel="noopener">721. 账户合并</a></li>
<li>带权并查集：<a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">399. 除法求值</a></li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的遍历（非递归）"><a href="#树的遍历（非递归）" class="headerlink" title="树的遍历（非递归）"></a>树的遍历（非递归）</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历 144</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode * cur = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ans.push_back(cur-&gt;val);</span><br><span class="line">        s.push(cur-&gt;right);  <span class="comment">// 先将右节点入栈，再将左节点入栈，妙啊</span></span><br><span class="line">        s.push(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历 94</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s; <span class="comment">//牢记“左链入栈”：每遍历到一个点 p，就 push(p); p = p-&gt;left;</span></span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push(p);</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        ans.push_back(p-&gt;val);</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) <span class="comment">// 继续“左链入栈”</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历 145</span></span><br><span class="line"><span class="comment">// （调换左右结点遍历顺序后）进行前序遍历，得到的结果反向输出即可</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ans_reverse;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode * p = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ans_reverse.push_front(p-&gt;val);  <span class="comment">// 从头插入结点 p</span></span><br><span class="line">        s.push(p-&gt;left);                 <span class="comment">// 由于是反向输出，所以左右节点入栈的顺序也与先序遍历相反</span></span><br><span class="line">        s.push(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: ans_reverse)</span><br><span class="line">        ans.push_back(i);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统一写法"><a href="#统一写法" class="headerlink" title="统一写法"></a>统一写法</h4><p>还有一种写法，统一了三种遍历，只需改变入栈的顺序。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/comments/495211" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/comments/495211</a></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划的题，emmm 做多了就明白套路了，做少了的话，还是多看答案，然后自己写吧。注意勤复习。</p>
<h3 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a><a href="https://leetcode-cn.com/problems/stone-game/" target="_blank" rel="noopener">877. 石子游戏</a></h3><p>两人博弈取石子，<code>dp[i][j]</code> 指取完 <code>i</code> 到 <code>j</code>（闭区间）的石子后，先手比后手高的分数。dp 转移方程中由于有先后手的交换，会有 <code>dp[][] = piles[] - dp[][]</code> 的出现。</p>
<h3 id="1000-合并石头的最低成本"><a href="#1000-合并石头的最低成本" class="headerlink" title="1000. 合并石头的最低成本"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/" target="_blank" rel="noopener">1000. 合并石头的最低成本</a></h3><p>NOI 1995 石子合并，非常经典的区间 dp。<code>dp[i][j]</code> 表示将 <code>i</code> 到 <code>j</code>（闭区间）的石子合并为一堆所需的最小总代价，而 <code>for</code> 中还需要一维表示在哪里合并。</p>
<h3 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></h3><p>类似于合并石子的区间 dp，但注意由于这道题的 dp 转移方程中包含两端的气球值，所以 dp 转移方程有些不同，但同样是需要三个 <code>for</code> 的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    nums.insert(nums.begin(), <span class="number">1</span>);</span><br><span class="line">    nums.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>))</span></span>;   <span class="comment">//dp[i, j] 表示戳爆 [i, j] 间的所有气球的最高总得分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">0</span>; len &lt; n; len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>, end = start + len; end &lt;= n; start++, end++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)              <span class="comment">// 此次戳爆第 i 个气球</span></span><br><span class="line">                dp[start][end] = max(</span><br><span class="line">                    dp[start][end],</span><br><span class="line">                    dp[start][i - <span class="number">1</span>] + dp[i + <span class="number">1</span>][end] + nums[start - <span class="number">1</span>] * nums[i] * nums[end + <span class="number">1</span>]</span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="41-接雨水"><a href="#41-接雨水" class="headerlink" title="41. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">41. 接雨水</a></h3><p>一道印象很深的题，因为题面非常直观。</p>
<h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h3><p>题面很像接雨水。</p>
<p>另外 <a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a> 也用到了这个题的算法。</p>
<h2 id="数学题"><a href="#数学题" class="headerlink" title="数学题"></a>数学题</h2><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></p>
<p>每个合数 <code>t</code> 只会在 <code>j=t最大的质因数, i=t/j</code> 时被筛掉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">is_prime</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">                primes.push_back(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : primes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i*j &gt;= n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                is_prime[i*j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不过面试一般不会要求这么高吧，会基础的埃氏筛应该就可以了；而且</p>
<h2 id="巧妙的算法"><a href="#巧妙的算法" class="headerlink" title="巧妙的算法"></a>巧妙的算法</h2><h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></h3><p>置换法</p>
<p>实现上需要注意细节，如需要使用 <code>while</code> 反复交换（我第一次使用的是 <code>if</code>）；交换的终止条件是 <code>arr[n] != arr[arr[n]-1]</code> 而不是 <code>n != arr[n]-1</code>（后者会被 <code>[1, 1]</code> 这种数组卡掉）。</p>
<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi)</a></h3><p>这个题虽然可以写一堆 <code>if</code>，但是<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/" target="_blank" rel="noopener">官方题解</a>的有限自动机让我眼前一亮。有空一定实现一次。</p>
<h2 id="巧妙的-C-语法"><a href="#巧妙的-C-语法" class="headerlink" title="巧妙的 C++ 语法"></a>巧妙的 C++ 语法</h2><h3 id="std-stoi"><a href="#std-stoi" class="headerlink" title="std::stoi"></a>std::stoi</h3><p>C 提供 <code>int atoi(const char *)</code>，而对于 string 类型，想要使用 <code>aoti</code> 只能使用 <code>const char * string::c_str()</code> 方法。不过，也可以使用 <code>int std::stoi(const string &amp;)</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"-233"</span>;</span><br><span class="line">atoi(str.c_str()) == stoi(str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="string-substr"><a href="#string-substr" class="headerlink" title="string::substr"></a>string::substr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>总是要忘记它的定义。<code>string::npos</code> 的值为从 <code>pos</code> 到字符串最后的长度。</p>
<h3 id="集合的交集"><a href="#集合的交集" class="headerlink" title="集合的交集"></a>集合的交集</h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></p>
<p>Python 版本就非常简洁：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(nums1, nums2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(set(nums1) &amp; set(nums2))</span><br></pre></td></tr></table></figure>

<p>没想到 C++ 也自带集合求交，见<a href="/cpp/cpp-grammar/set#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97">set-集合运算</a>。</p>
<h2 id="巧妙的数据结构"><a href="#巧妙的数据结构" class="headerlink" title="巧妙的数据结构"></a>巧妙的数据结构</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>简单、好用的数据结构。</p>
<p>数据结构上，递减栈为从栈底往栈顶依次递减的栈（栈里可存元素，也可以存数组下标）。算法上，一个数入栈前，将小于等于它的数全部出栈。</p>
<p>对于某些要计算“某数后面第一个比他大/小的数”的题目，有奇效，如 <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 递减栈</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(T.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; T[s.top()] &lt;= T[i])</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = s.empty() ? <span class="number">0</span> : s.top() - i;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>和单调栈相对应的就是单调队列了。</p>
<p>数据结构上，递减队列为从队首往队尾依次递减的<strong>双向</strong>队列（队列里存数组下标），其本质是类似于单调栈，但是由于题目常常加了一个长度限制，所以也需要让元素从前面出队。</p>
<p>算法上，一个数 <code>i</code> 入队列前，</p>
<ol>
<li>（如果有，）将超出边界的队首元素出队 <code>pop_front()</code>；</li>
<li>将小于等于 <code>i</code> 的队尾元素全部出队 <code>pop_back()</code>。</li>
</ol>
<p>计算滑动窗口（一个固定大小的区间）的最值有奇效，如 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!q.empty() &amp;&amp; q.front() &lt;= i - k)</span><br><span class="line">                q.pop_front(); <span class="comment">// 因窗口大小而出队</span></span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[q.back()] &lt;= nums[i])</span><br><span class="line">                q.pop_back(); <span class="comment">// 因小于当前值而出队</span></span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">                ans.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双堆：数据流中位数"><a href="#双堆：数据流中位数" class="headerlink" title="双堆：数据流中位数"></a>双堆：数据流中位数</h3><p>对于求数据流/滑动窗口的题目，可以维护 大顶堆放小一半的数 + 小顶堆放大一半的数（保证两堆大小相等或大顶堆比小顶堆大 1），两堆的顶就是中位数。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/solution/shu-ju-liu-de-zhong-wei-shu-by-leetcode/" target="_blank" rel="noopener">数据流的中位数</a></li>
<li><a href="https://leetcode-cn.com/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/" target="_blank" rel="noopener">滑动窗口中位数</a></li>
</ul>
<p>对于滑动窗口，由于有删除的需求，可以使用 <code>multiset</code> 替代堆。</p>
<p>在维护左右大小的时候，如果分情况讨论会非常复杂，不如 push/remove 的时候先保证<code>两堆大小相等或大顶堆比小顶堆大 1</code>，然后再检查是否符合<code>大顶小于小顶</code>，不符合就交换。这样思路更清晰，代价时间复杂度的常数变大了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据流的中位数，使用双堆实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; big_heap; <span class="comment">// 存小的数，保证大小等于 small_heap，或比 small_heap 多一</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; small_heap; <span class="comment">// 存大的数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap_top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = big_heap.top();</span><br><span class="line">        big_heap.pop();</span><br><span class="line">        <span class="keyword">int</span> s = small_heap.top();</span><br><span class="line">        small_heap.pop();</span><br><span class="line">        big_heap.push(s);</span><br><span class="line">        small_heap.push(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证两堆大小相等或大顶堆比小顶堆大 1</span></span><br><span class="line">        <span class="keyword">if</span> (big_heap.size() == small_heap.size())</span><br><span class="line">            big_heap.push(num);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            small_heap.push(num);</span><br><span class="line">        assert(big_heap.size() == small_heap.size() || big_heap.size() == small_heap.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否符合大顶小于小顶，不符合就交换。</span></span><br><span class="line">        <span class="keyword">if</span> (small_heap.size() &gt; <span class="number">0</span> &amp;&amp; big_heap.top() &gt; small_heap.top())</span><br><span class="line">            swap_top();</span><br><span class="line">        assert(small_heap.empty() || big_heap.top() &lt;= small_heap.top());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (big_heap.size() == small_heap.size())</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)big_heap.top() + (<span class="keyword">double</span>)small_heap.top()) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> big_heap.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口中位数，使用双 multiset 实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; big_heap; <span class="comment">// 存小的数，保证大小等于 small_heap，或比 small_heap 多一</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; small_heap; <span class="comment">// 存大的数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否符合大顶小于小顶，不符合就交换。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make_balance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (small_heap.size() &gt; <span class="number">0</span> &amp;&amp; *big_heap.begin() &gt; *small_heap.begin())</span><br><span class="line">        &#123;</span><br><span class="line">            big_heap.insert(big_heap.end(), *small_heap.begin());</span><br><span class="line">            small_heap.insert(small_heap.end(), *big_heap.begin());</span><br><span class="line">            big_heap.erase(big_heap.begin());</span><br><span class="line">            small_heap.erase(small_heap.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        assert(small_heap.empty() || *big_heap.begin() &lt;= *small_heap.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 保证两堆大小相等或大顶堆比小顶堆大 1</span></span><br><span class="line">        <span class="keyword">if</span> (big_heap.size() == small_heap.size())</span><br><span class="line">            big_heap.insert(num);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            small_heap.insert(num);</span><br><span class="line">        assert(big_heap.size() == small_heap.size() || big_heap.size() == small_heap.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        make_balance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 保证两堆大小相等或大顶堆比小顶堆大 1</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt; *big_heap.begin())</span><br><span class="line">        &#123;</span><br><span class="line">            assert(small_heap.find(num) != small_heap.end());</span><br><span class="line">            small_heap.erase(small_heap.find(num));</span><br><span class="line">            <span class="keyword">if</span> (big_heap.size() - <span class="number">2</span> == small_heap.size())</span><br><span class="line">            &#123;</span><br><span class="line">                small_heap.insert(small_heap.end(), *big_heap.begin());</span><br><span class="line">                big_heap.erase(big_heap.begin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert(big_heap.find(num) != big_heap.end());</span><br><span class="line">            big_heap.erase(big_heap.find(num));</span><br><span class="line">            <span class="keyword">if</span> (big_heap.size() + <span class="number">1</span> == small_heap.size())</span><br><span class="line">            &#123;</span><br><span class="line">                big_heap.insert(big_heap.end(), *small_heap.begin());</span><br><span class="line">                small_heap.erase(small_heap.begin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(big_heap.size() == small_heap.size() || big_heap.size() == small_heap.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        make_balance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (big_heap.size() == small_heap.size())</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)*big_heap.begin() + (<span class="keyword">double</span>)*small_heap.begin()) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> *big_heap.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        MedianFinder mf;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            mf.insert(nums[i]);</span><br><span class="line">            ans.push_back(mf.findMedian());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> window = <span class="number">0</span>; window + k &lt; nums.size(); window++)</span><br><span class="line">        &#123;</span><br><span class="line">            mf.remove(nums[window]);</span><br><span class="line">            mf.insert(nums[window+k]);</span><br><span class="line">            ans.push_back(mf.findMedian());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-09-11T12:19:35.107Z" itemprop="dateUpdated">2021-09-11 20:19:35</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://blog.lyh543.cn">
            <img src="/img/avatar.png" alt="lyh543">
            lyh543
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/&title=《LeetCode 合集》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon mdi mdi-sina-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/&title=《LeetCode 合集》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon mdi mdi-qqchat"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/" data-title=" Facebook">
          <i class="icon mdi mdi-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《LeetCode 合集》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon mdi mdi-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/" data-title=" Google+">
          <i class="icon mdi mdi-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-lg mdi mdi-share-variant"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/python/selenium/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon mdi mdi-chevron-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Python 爬虫 —— Selenium</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/python/numpy/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-lg icon-pl mdi mdi-chevron-right"></i></div>
        <h4 class="title">NumPy</h4>
      </a>
    </div>
  
</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: 'ec7daa4e047c3c30570d',
          clientSecret: '025a9e40a1d101f28fd1a945d286a819e9fa1c3d',
          repo: 'lyh543.github.io',
          owner: 'lyh543',
          admin: ['lyh543'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg mdi mdi-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>lyh543 &copy; 2019 - 2021</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">蜀ICP备19034464号</a><br>
                
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg mdi mdi-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/&title=《LeetCode 合集》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon mdi mdi-sina-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/&title=《LeetCode 合集》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon mdi mdi-qqchat"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/" data-title=" Facebook">
          <i class="icon mdi mdi-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《LeetCode 合集》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon mdi mdi-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/cpp/leetcode/leetcode-problems/" data-title=" Google+">
          <i class="icon mdi mdi-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKUlEQVR42u3aQXKDMAwF0N7/0nTbDeRLIp1BPK8yhGI/MqNakn9+4nH8GdfXz64kzzyb5baBgYHxWMZxOc7umbyO6+vX856uAQMD4wWM6qPP/jYPynkIjl4HBgYGRi8Ixs+c3IOBgYGRB9k8XGJgYGD0GEkSOwm41/fkyfMNuTgGBsYDGdUy2X9+/kp/AwMD41GMoziuYb1C2zEeGBgYuxl5gOsdjOg1AHrrwcDA2M3otQR6rcfegYzkCgYGxlZGsqAE0yvS5dc/YDAwMFYzepu2arE++TYP7uUCHAYGxiJGdbIJbxJMo8QVAwNjEaOaLo5i+SBZLZTVMDAwVjPyEDkJqdWFRm1UDAyM1YxqBOu1NieJbg+PgYGxj5E3A/L9WJ7o9raJp6ksBgbGCxiT5mISWCeHOaKiGwYGxjpGL6Usv6cWvjAXBgbGaxi99DJvSVYDbqH9gIGBsZrx7SMXeYqbnw2JnoCBgbGOUW1eJq3NbzQVmrk4BgbGIkZ0fKHaCx2ksvm2FQMD452MapLZC8e92QsBFwMDYx2jOsGkrNYL2R8CMQYGxlLGURz5NNXkNg/rH34HDAyMdYxe8lkNstUmZb70MgYDA+OxjF7B664ktvfKohYmBgbGOsYkBU0Y+bYvQX5oDGBgYLye0QvNhdDZK/BhYGBgBIuYNDt7LYob/m9gYGA8itEr5fcORuQbza/k4hgYGA9kjFLH4P78RVQLcBgYGC9g/ALeg0uppwqxmQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>










</body>
</html>
