<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>操作系统 课程笔记 | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/theme/favicon.png">
    <link rel="alternate" type="application/rss+xml" href="https://blog.lyh543.cn/rss.xml" title="小灰灰灰灰的博客 RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://blog.lyh543.cn/feed.atom" title="小灰灰灰灰的博客 Atom Feed">
    <link rel="alternate" type="application/json" href="https://blog.lyh543.cn/feed.json" title="小灰灰灰灰的博客 JSON Feed">
    <meta name="description" content="教材：《操作系统——精髓与设计原理 第八版》-- William Stallings

一 操作系统概述

操作系统的目标和功能

操作系统：

控制应用程序执行的程序
应用系统和计算机硬件之间的接口

目标：方便、有效、扩展能力

功能：
（作为用户/计算机接口的）OS ...">
    
    <link rel="preload" href="/assets/css/0.styles.832ac33f.css" as="style"><link rel="preload" href="/assets/js/app.0525e26f.js" as="script"><link rel="preload" href="/assets/js/37.26ee27a3.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.832ac33f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><container class="article-column-container"><div class="article-column"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><div class="v-card v-sheet theme--light"><div class="container"><div itemprop="articleBody" class="markdown-body content__default"><p>教材：<a href="https://www.jianshu.com/p/f9a5792d05b4" target="_blank" rel="noopener noreferrer">《操作系统——精髓与设计原理 第八版》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>-- William Stallings</p> <h2 id="一-操作系统概述"><a href="#一-操作系统概述" class="header-anchor">#</a> 一 操作系统概述</h2> <h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="header-anchor">#</a> 操作系统的目标和功能</h3> <p>操作系统：</p> <ul><li>控制应用程序执行的<strong>程序</strong></li> <li>应用系统和计算机硬件之间的<strong>接口</strong></li></ul> <p>目标：方便、有效、扩展能力</p> <p>功能：</p> <ul><li>（作为用户/计算机接口的）OS 提供的服务：
<ul><li>程序开发</li> <li>程序运行</li> <li>I/O设备访问</li> <li>文件访问控制</li> <li>系统访问</li> <li>错误检测和响应</li> <li>记账 <code>Accounting</code></li></ul></li> <li>（作为资源管理器的）操作系统负责
<ul><li>资源管理，控制数据的移动、存储、管理</li></ul></li></ul> <h3 id="操作系统的历史"><a href="#操作系统的历史" class="header-anchor">#</a> 操作系统的历史</h3> <h4 id="串行处理"><a href="#串行处理" class="header-anchor">#</a> 串行处理</h4> <ul><li>无 OS</li> <li>控制台、输入设备（卡片机阅读器）</li></ul> <h4 id="简单批处理系统"><a href="#简单批处理系统" class="header-anchor">#</a> 简单批处理系统</h4> <ul><li>监控程序</li> <li>对一批作业自动处理</li> <li>内存中只能存放一道作业</li></ul> <p><img src="/images/e42643e9fb50aeccb097341e0dcaa3029fb8758566fc841f2ba99df89ec3da3d.png" alt="简单批处理系统"></p> <p>监控程序的功能：</p> <ul><li>作业的自动续接</li> <li>内存保护</li> <li>定时器（防止作业独占）</li> <li>特权指令（内核模式下）</li> <li>中断</li></ul> <p>运行模式：用户模式、内核模式</p> <h4 id="多道批处理系统"><a href="#多道批处理系统" class="header-anchor">#</a> 多道批处理系统</h4> <p><img src="/images/10ec395463fc37b60cdcc09abd1667f9dd0a9f359164323864ac10a2db96ff52.png" alt="多道批处理系统"></p> <p>多道批处理系统：简单批处理系统的改进</p> <ul><li>内存中同时存放多个作业</li> <li>作业可并发执行</li> <li>作业调度程序</li></ul> <p>硬件支持：</p> <ul><li>I/O中断</li> <li>DMA</li> <li>……</li></ul> <p>特征：<strong>多道性、调度性、无序性、无交互能力</strong></p> <p>如下，系统可用内存250MB，三个作业可同时处理：</p> <p><img src="/images/f6cdb2d37258d0428b3007658a9f9015f27a1803bb6e192a6e4d6d2d9f73b335.png" alt="示例-信息"></p> <h4 id="分时系统"><a href="#分时系统" class="header-anchor">#</a> 分时系统</h4> <p>产生原因：人机交互、共享主机、方便上机</p> <p>分时系统：</p> <ul><li>采用多道程序设计技术处理多个交互作业</li> <li>多个用户共享处理器</li> <li>多个用户通过不同终端同时访问系统</li></ul> <p>特征：<strong>多路性、独立性、及时性、交互性</strong></p> <table><thead><tr><th>比较</th> <th>多道批处理系统</th> <th>分时</th> <th>实时系统</th></tr></thead> <tbody><tr><td>主要目标</td> <td>充分利用处理器</td> <td>减少响应时间</td> <td></td></tr> <tr><td>OS 指令源</td> <td>作业提供命令（无交互）</td> <td>终端键入命令（来自用户）</td> <td></td></tr> <tr><td>特征</td> <td>多道性、调度性、无序性、无交互能力</td> <td>多路性、独立性、及时性、交互性</td> <td>可确定性、可响应性、用户控制、可靠性、故障弱化能力</td></tr></tbody></table> <p>第一个分时操作系统：CTSS (Compatible Time-Sharing System)</p> <p><img src="/images/ea029a3ebaf6919b490b232767118719d941a4a30000332643101a781978d44b.png" alt="CTSS 内存占用示例"></p> <h4 id="实时系统"><a href="#实时系统" class="header-anchor">#</a> 实时系统</h4> <p>系统能够**及时（即时）**响应外部事件的请求，在规定的时间内开始或完成对该事件的处理，并控制所有实时任务协调一致地运行。</p> <p>应用领域：</p> <ul><li>航空航天</li> <li>军事</li> <li>工业控制</li> <li>事务系统
<s>总之家用电脑不需要</s></li></ul> <p>特征：<strong>可确定性、可响应性、用户控制、可靠性、故障弱化能力</strong></p> <h3 id="操作系统的主要成就"><a href="#操作系统的主要成就" class="header-anchor">#</a> 操作系统的主要成就</h3> <p>这部分是一个概述，具体的定义和实现在后面都会有讲。</p> <h4 id="进程"><a href="#进程" class="header-anchor">#</a> 进程</h4> <p>进程：一个正在处理器执行的程序</p> <p><img src="/images/f7da3a116faa505ad0632c9a57d81bd69e909d29b19cd1aced05042a5143e03e.png" alt="为什么会有进程"></p> <p>进程的组成：</p> <ul><li>可执行程序</li> <li>相关数据</li> <li>程序的执行上下文（execution context）
<ul><li>进程状态</li> <li>操作系统用来管理和控制进程所需的所有数据（处理器寄存器的内容、进程优先级、是否在等待I/O事件、在内存中的位置……）</li></ul></li></ul> <p>如下，正在执行的 B 进程切换到 A 时，需要保存 B 的上下文：</p> <p><img src="/images/e369dc4db527203b4d4c8031308e40a539372f1b31f3963dc921b3687aa7db2c.png" alt="典型的进程实现"></p> <h4 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h4> <p>任务：</p> <ul><li>进程隔离</li> <li>自动分配和管理</li> <li>支持模块化程序设计</li> <li>保护和访问控制</li> <li>长期存储</li></ul> <p>文件系统：实现了长期存储<br>
文件：一个有名称的对象，访问控制和保护的基本单元</p> <p>虚拟存储：</p> <ul><li>以逻辑方式访问存储器，不考虑物理内存可用的空间数量</li> <li>满足多作业F同时驻留内存的要求</li> <li>换入、换出机制</li> <li>分页机制（进程大小不同）</li> <li>每个作业部分驻留（检测到缺页时载入）</li></ul> <p>分页机制：</p> <ul><li>页：若干个固定大小的块，组成进程</li> <li><strong>虚地址</strong>（virtual address）：由页号和页内偏移量组成</li> <li>虚地址和内存中<strong>实地址</strong>（real address，物理地址）之间的动态映射机制</li></ul> <p><img src="/images/775f0c03288a2fb70482e0e18c3cd5efe02050e10273071b283b925e1c4d389a.png" alt="虚存寻址"></p> <h4 id="信息保护和安全"><a href="#信息保护和安全" class="header-anchor">#</a> 信息保护和安全</h4> <p>OS 的 4 类典型安全问题：</p> <ul><li>可用性</li> <li>保密性</li> <li>数据完整性</li> <li>认证</li></ul> <h4 id="调度和资源管理"><a href="#调度和资源管理" class="header-anchor">#</a> 调度和资源管理</h4> <p>调度策略需要考虑：</p> <ul><li>公平性</li> <li>有差别的响应性</li> <li>有效性
<img src="/images/91b7d7017b28f3c83e467190be1604282b540498dad5134a93f41493cb8c4d13.png" alt="多道程序环境中涉及进程调度和资源分配的主要组件"></li></ul> <h3 id="现代操作系统的特征"><a href="#现代操作系统的特征" class="header-anchor">#</a> 现代操作系统的特征</h3> <ul><li>微内核：只给内核分配基本功能（地址空间、进程间通信 <code>IPC</code>、基本的调度）
<ul><li>优点：简化实现、灵活、适合分布式</li></ul></li> <li>多线程
<ul><li>线程：可分派的工作单元。包括上下文、数据区域</li> <li>进程：一个或多个线程和相关<strong>系统资源</strong>的集合</li></ul></li> <li>对称多处理：多处理器架构，且每个处理器地位相同
<ul><li>多个进程/线程可以并行</li> <li>多处理器对用户透明</li> <li>OS 负责调度、同步</li> <li>优点：性能、可用性、渐增性、扩展性</li></ul></li> <li>分布式</li> <li>面向对象
<ul><li>给小内核增加模块化扩展、定制操作系统</li></ul></li></ul> <h3 id="容错性"><a href="#容错性" class="header-anchor">#</a> 容错性</h3> <p>操作系统相关技术：</p> <ul><li>进程隔离</li> <li>并发控制</li> <li>虚拟机</li> <li>检测点和回滚机制</li></ul> <h3 id="多处理器和多核操作系统考虑因素"><a href="#多处理器和多核操作系统考虑因素" class="header-anchor">#</a> 多处理器和多核操作系统考虑因素</h3> <p>关键问题：</p> <ul><li>并发进程或线程</li> <li>调度</li> <li>同步</li> <li>内存管理</li> <li>可靠性、容错性</li></ul> <p>多核系统潜在的并行能力有三个层次</p> <ul><li>应用程序以多线程形式执行能力</li> <li>多处理器的多线程程序执行能力</li> <li>核内部硬件并行、指令集并行</li></ul> <p>OS 常用策略：</p> <ul><li>应用层并行</li> <li>虚拟机</li></ul> <h3 id="主流操作系统-略"><a href="#主流操作系统-略" class="header-anchor">#</a> 主流操作系统（略）</h3> <h3 id="单体内核"><a href="#单体内核" class="header-anchor">#</a> 单体内核</h3> <ul><li>单体内核：在一大块代码中包含了所有的操作系统功能，作为单个进程运行，具有唯一的地址空间</li> <li>所有的功能部件都可以访问内核数据结构和例程</li> <li>Linux 虽然是单体内核，但是采用了模块化结构</li></ul> <h2 id="二-1-进程管理-进程描述与控制"><a href="#二-1-进程管理-进程描述与控制" class="header-anchor">#</a> 二(1) 进程管理：进程描述与控制</h2> <h3 id="什么是进程"><a href="#什么是进程" class="header-anchor">#</a> 什么是进程</h3> <p>进程：一段代码执行的时候就称为进程</p> <p>进程 = 代码 + 相关数据</p> <p>进程由以下元素表征：</p> <p><img src="/images/de668abd9bc9d7c3d0f07b76b768bfa8f91b1e3275d7385d8d2930fbd799f100.png" alt="进程的元素"></p> <ul><li>上下文数据（狭义，图中的“上下文数据”即是狭义）：CPU寄存器
<ul><li>广义：图中全部数据</li></ul></li> <li>记账信息：统计信息（CPU 时长等）</li></ul> <p>进程控制块 <code>Process Control Block</code>, <code>PCB</code></p> <ul><li>各操作系统不同</li> <li>用于中断进程后恢复进程</li></ul> <p><img src="/images/3740fece581f214cb7edc5431a02a5107d0a75677b24f5303471285d9e332d8f.png" alt="进程控制块"></p> <p>进程特征：</p> <ul><li>动态性（存在生命周期，本质特征）</li> <li>并发性（重要特征）</li> <li>独立性</li> <li>异步性：按各自独立的、不可预知的速度向前推进
<ul><li>为什么速度不可预知？——存在中断等等</li></ul></li></ul> <p>进程与程序比较：</p> <ul><li>进程：正在运行的程序实例</li> <li>进程 = 进程控制块 + 程序 + 相关数据</li> <li>引入进程概念为并发作铺垫</li> <li>程序静态，进程动态</li> <li>“程序-进程”不是一对一
<ul><li>反例 1：一个进程可以对应多个程序（一个进程调用 DLL 等，也算是多个程序）</li> <li>反例 2：一个程序可以对应多个进程</li></ul></li></ul> <h3 id="进程状态"><a href="#进程状态" class="header-anchor">#</a> 进程状态</h3> <h4 id="进程轨迹"><a href="#进程轨迹" class="header-anchor">#</a> 进程轨迹</h4> <p>进程轨迹：进程执行的指令序列，用来描述单个进程的行为</p> <p>处理器的行为可以用多个进程交替执行的轨迹来描述，如下图。</p> <p><img src="/images/16f4abf3eaf38c3a612a2c504b544cdf5cdc8bb602001aeddada7e6b2fc89337.png" alt="示例"></p> <h4 id="进程的两状态模型"><a href="#进程的两状态模型" class="header-anchor">#</a> 进程的两状态模型</h4> <p><img src="/images/dd44338af4c33499f7c7ae41408036db934626e1c9bc9886360fba0d77504e8d.png" alt="进程的两状态模型"></p> <p>简单易懂。</p> <p><img src="/images/1aa7a23cbaebde3a10eaed151a557601867cc782591daff2e4ebb939f7b8dcf8.png" alt="进程的两状态模型的排队图"></p> <h4 id="进程的创建和终止"><a href="#进程的创建和终止" class="header-anchor">#</a> 进程的创建和终止</h4> <p>进程创建的原因：</p> <ul><li>提交批处理作业后，准备处理新的批处理作业</li> <li>（终端用户）交互登陆</li> <li>为提供服务而由操作系统创建</li> <li>由现有进程派生
<ul><li>相关的进程称为父进程和子进程</li></ul></li></ul> <p>记忆方法：可以由<strong>操作系统</strong>、<strong>用户</strong>、<strong>父进程</strong>创建，其中操作系统可以因为<strong>新的作业</strong>或<strong>提供系统服务</strong>而创建。</p> <p>进程终止：</p> <p><img src="/images/5c072002825672f047f542af8992172a7ab3a2ffb4a5b11088d2eccca0dd871d.png" alt="终止的原因"></p> <h4 id="进程的五状态模型"><a href="#进程的五状态模型" class="header-anchor">#</a> 进程的五状态模型</h4> <p>将 Not Running 细分为就绪（等 CPU）和阻塞（等 I/O 之类的），得到了五状态模型：</p> <p><img src="/images/3d673eb64b22f2459f6c4e5d9b9ac13b8aca70e505a5817266e10c9f249c0b17.png" alt="进程的五状态模型"></p> <p><img src="/images/ec439cb6c9d1ee4150f9068254d3a41a567018577184e643ed883609c788c465.png" alt="进程的五状态模型的排队图"></p> <p>排队模型如上图。除此之外，还有下列几种变形：</p> <ul><li>多阻塞队列</li> <li>多就绪队列（优先级不同）</li> <li>退出状态（保留记账信息等）</li></ul> <p><img src="/images/40c97dc5b2edb605614fc76316da3e8eee5e78b0770e66b20288f763e0351b74.png" alt="进程的五状态模型的排队图（多阻塞队列）"></p> <h4 id="挂起"><a href="#挂起" class="header-anchor">#</a> 挂起</h4> <p>挂起的进程：</p> <ul><li>原因：内存资源紧张、无就绪进程（进程全阻塞等待 I/O）</li> <li>交换：把内存的一个进程的部分或全部移到磁盘中（挂起状态），然后从挂起队列取一个进程/接纳一个新进程</li> <li>挂起状态：将内存中处于阻塞、就绪、甚至是执行状态的进程放到外存，不再参与 CPU 的竞争</li></ul> <p><img src="/images/5511e243d259901289032791547d2a731bc613a177ef95b94c5c7431fc9334f1.png" alt="六状态模型"></p> <p>为区分两种挂起，便有了<strong>七状态的挂起状态图</strong>（重点）：</p> <p><img src="/images/98346f16297884d5a770f909fdf8ec6ed0c7ec9f525ea2cc1b176e44e8a2260c.png" alt="七状态模型"></p> <p>挂机进程特征：</p> <ul><li>不能立即执行</li> <li>可能在等待事件</li> <li>需要被一个代理（自身、父进程或 os）挂起</li> <li>需要被代理取出</li></ul> <p>进程挂起的原因：</p> <p><img src="/images/e1e64fb637b2b627e7c59ab74602297000a3d101436c7d3e2817d346c1790dfc.png" alt="进程挂起的原因"></p> <h3 id="进程描述"><a href="#进程描述" class="header-anchor">#</a> 进程描述</h3> <p><img src="/images/d41f5a0daf9d2e9a104f41da70c9e9dd25d3d539fb2c6c7d87c707b1b5aaf1cb.png" alt="进程的三种情况"></p> <p><img src="/images/52eaa607258e69c198ab6c4e40033add64cd587f4b94c934327b5cc60d476728.png" alt="操作系统的控制结构"></p> <hr> <p>内存表：用于跟踪内存和外存</p> <ul><li>分配给进程的内存</li> <li>分配给进程的外存</li> <li>内存块或外存块的保护属性，如为哪些进程所共享</li> <li>管理外存所需要的信息</li> <li>注：外存使用虚拟存储或交换机制</li></ul> <hr> <p>I/O 表：</p> <ul><li>I/O 的状态</li> <li>源/目标的内存单元</li></ul> <hr> <p>文件表：</p> <ul><li>是否存在</li> <li>在外存中的位置</li> <li>当前状态</li> <li>其他属性</li></ul> <hr> <p>进程表：</p> <ul><li>用于管理进程</li> <li>表中有内存、I/O、文件的引用</li> <li>表能被 OS 访问</li> <li>OS 需要知道：进程的位置、属性
<ul><li>位置包含：程序、数据、（调用）栈</li> <li>属性即 PCB</li> <li><strong>程序</strong>、<strong>数据</strong>、<strong>栈</strong>和<strong>属性</strong>构成<strong>进程映像</strong></li></ul></li></ul> <hr> <p>PCB 中的信息：</p> <ul><li>进程标识信息
<ul><li>进程的唯一标识符 <code>ID</code>，构成索引</li> <li>父进程 <code>ID</code></li> <li>用户 <code>ID</code></li></ul></li> <li>处理器状态信息
<ul><li>被设计为程序状态字 <code>PSW</code> 寄存器</li> <li>由寄存器内容组成
<ul><li>用户可见寄存器</li> <li>控制、状态寄存器</li> <li>栈指针</li></ul></li></ul></li> <li>进程控制信息
<ul><li>调度和状态信息（进程状态、优先级、调度相关信息、等待事件的标识）</li> <li>数据结构（用队列、环等链接到其他进程）</li> <li>进程间通信（两个进程通信的相关信息）</li> <li>进程特权</li> <li>存储管理（进程虚存的段表、页表的指针）</li> <li>进程所有权、使用情况（打开的文件、使用历史）</li></ul></li></ul> <p>记忆上，进程控制信息的六点可以按照章节名来记：<code>调度和状态信息</code>（对应进程调度）、<code>进程通信</code>（对应进程同步）、<code>存储管理</code>（对应第三章）、<code>进程使用情况</code>（对应 I/O、文件），外加<code>数据结构</code>和<code>进程特权</code>（对应内核模式）。</p> <hr> <p><code>进程表</code> = n * <code>进程映像的指针</code><br> <code>进程映像</code> = <code>程序</code> + <code>数据</code> + <code>栈</code> + <code>属性(PCB)</code><br> <code>PCB</code> = <code>进程标识信息 (三个 ID)</code> +<code>处理器状态信息 (PSW)</code> + <code>进程控制信息</code></p> <h3 id="进程控制"><a href="#进程控制" class="header-anchor">#</a> 进程控制</h3> <h4 id="内核"><a href="#内核" class="header-anchor">#</a> 内核</h4> <p>内核 <code>kernel</code>：操作系统的核心</p> <ul><li>操作系统中的重要系统功能</li> <li>常驻内存</li> <li>功能：
<ul><li><strong>资源管理</strong>：进程管理、存储管理、I/O 设备管理（文件管理放在核外）</li> <li><strong>支撑功能</strong>：中断处理、时钟管理、记账功能</li></ul></li></ul> <blockquote><p>中断处理既是内核的基本功能，也是整个操作系统赖以活动的基础，操作系统的一切重要活动最终都依赖于中断。</p></blockquote> <h4 id="执行模式"><a href="#执行模式" class="header-anchor">#</a> 执行模式</h4> <p>大多数处理器至少支持<strong>用户模式</strong>和<strong>内核模式</strong>。</p> <ul><li>用户模式
<ul><li>优先权较少</li> <li>运行用户程序</li></ul></li> <li>系统模式/内核模式/控制模式
<ul><li>优先权更高</li> <li>运行内核</li> <li>某些指令、内存只能在特权模式下运行/访问，如：
<ul><li>读取/修改 PSW 等控制寄存器</li> <li>原始 I/O 指令</li> <li>内存管理相关</li></ul></li></ul></li></ul> <p>记忆上，用户模式和系统模式是一一对应的。系统模式的特权可以分为三个方面：寄存器、内存、I/O。</p> <p>区分用户模式和内核模式的原因：<strong>保护 OS 和重要操作系统表不受程序干扰</strong></p> <p>内核模式的实现方案：</p> <ul><li>IA-64 处理器的 PSWR 中存在指示执行模式的位</li> <li>当用户调用操作系统服务或中断促发系统例程时，相关位被置为内核模式</li> <li>当从系统服务返回用户进程时，执行模式置为用户模式</li></ul> <blockquote><p>系统调用 <code>system call</code> 是 OS 为用户提供的接口。</p></blockquote> <h4 id="进程创建"><a href="#进程创建" class="header-anchor">#</a> 进程创建</h4> <p>回忆<a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2">进程创建的原因</a>？</p> <p>创建进程的流程：</p> <ol><li>分配 ID</li> <li>分配内存</li> <li>初始化 PCB（标识信息、处理器状态信息、控制信息）</li> <li>建立相关指针、引用（如将其插入就绪或就绪/挂起链表）</li> <li>建立/扩充其他数据结构</li></ol> <h4 id="进程切换"><a href="#进程切换" class="header-anchor">#</a> 进程切换</h4> <p>下均指用户模式下的进程切换。</p> <p><img src="/images/1fa3ae807c84a1155891b41760a02678c0213adbe7747274b173c93c1ec79b88.png" alt="进程切换的时机"></p> <h5 id="系统中断"><a href="#系统中断" class="header-anchor">#</a> 系统中断</h5> <p>系统中断：普通中断和陷阱对比。</p> <p><img src="/images/fb6259090137f1b462f3985e993b822b64b63cff0aec0a38e579d29f7a9fcd7c.png" alt="普通终端和陷阱"></p> <ul><li>内存失效：缺页等</li> <li><strong>中断不一定导致进程切换</strong>（<code>getpid()</code> 系统调用引发中断，但没有进程切换）</li></ul> <h5 id="模式切换"><a href="#模式切换" class="header-anchor">#</a> 模式切换</h5> <p>模式切换：<a href="#%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F">用户模式和内核模式</a>之间的相互转换。</p> <p>模式切换原因：</p> <ul><li>系统调用</li> <li>中断
<ul><li>中断出现时，会将程序计数器置为中断处理程序的开始地址（汇编基础 hhh）</li> <li>需要从用户模式切换到内核模式，以便中断处理能执行特权指令</li></ul></li></ul> <p>注意：</p> <ul><li><strong>模式切换不一定导致进程切换</strong>（<code>getpid()</code> 系统调用引发中断，但没有进程切换）</li> <li><strong>进程切换一定会有模式切换</strong>（<code>进程切换</code>一定要在内核模式下进行）</li></ul> <h5 id="进程状态转换"><a href="#进程状态转换" class="header-anchor">#</a> 进程状态转换</h5> <ul><li><strong>模式切换不一定有进程状态转换</strong></li> <li><strong>进程切换一定有进程状态转换</strong>（就绪、阻塞等）</li></ul> <p>进程切换步骤：</p> <ul><li>保存处理器上下文（寄存器）</li> <li>更新当前进程的 PCB（状态、数据结构等变化）</li> <li>将 PCB 的指针移至相应队列（就绪、阻塞、挂起等）</li> <li>选择另一进程执行</li></ul> <p>切换回来的步骤：</p> <ul><li>更新该进程的 PCB</li> <li>更新内存管理数据结构</li> <li>恢复被选择进程的上下文</li></ul> <h5 id="总结几个概念的关系"><a href="#总结几个概念的关系" class="header-anchor">#</a> 总结几个概念的关系</h5> <ol><li>中断、模式切换 <code>--不一定--&gt;</code> 进程切换、进程状态转换（反例均为 <code>getpid()</code>）</li> <li>进程切换 <code>--一定--&gt;</code> 模式切换、进程状态转换</li></ol> <h4 id="操作系统的执行"><a href="#操作系统的执行" class="header-anchor">#</a> 操作系统的执行</h4> <p><img src="/images/ddde0c35862ae06c5a019a286f2d1c36dc01285685570da3d68f951a4f16ebbb.png" alt="操作系统的执行"></p> <h3 id="unix-svr4-的进程管理"><a href="#unix-svr4-的进程管理" class="header-anchor">#</a> Unix SVR4 的进程管理</h3> <h4 id="unix-svr4-的进程状态图"><a href="#unix-svr4-的进程状态图" class="header-anchor">#</a> Unix SVR4 的进程状态图</h4> <p><img src="/images/1c01e23a1752eae3007999b4d1bc99ca977e01dd0f8bfd055c667d57648eae3b.png" alt="Unix SVR4 的进程状态图"></p> <ul><li>阻塞在 Unix SVR4 中被称为 <code>Sleep</code>。</li></ul> <h4 id="unix-svr4-的进程创建"><a href="#unix-svr4-的进程创建" class="header-anchor">#</a> Unix SVR4 的进程创建</h4> <ul><li>内核系统调用 <code>fork()</code>，在内核模式下完成</li></ul> <ol><li>在<strong>进程表</strong>中为新进程分配一个空项</li> <li>为子进程分配一个唯一的 <strong>ID</strong></li> <li>复制父进程的<strong>进程映象</strong>，但共享内存除外</li> <li>增加父进程所拥有的文件的计数器，反映另一个进程现在也拥有这些文件的事实</li> <li>将子进程设置为<strong>就绪态</strong></li> <li>将子进程的 ID 号返回给父进程，将 0 值返回给子进程</li></ol> <ul><li><code>fork()</code> 的返回值：<code>-1</code>（出错）、<code>0</code>（无子进程）、<code>正值</code>（子进程的 ID）</li> <li>进程创建后，可能发生：
<ul><li>控制权：父进程，执行点：调用 <code>fork</code> 的位置</li> <li>控制权：子进程，执行点：调用 <code>fork</code> 的位置</li> <li>控制权：其他进程（即使当前父子进程处于就绪态）</li></ul></li> <li>最终父进程和子进程均会在下一条语句上继续运行</li></ul> <hr> <p>例题 1：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Bye&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出 <code>HelloByeBye</code>，但父/子进程输出 <code>Bye</code> 的先后顺序未知。</p> <hr> <p>例题 2：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;hello, world\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出 8 个 <code>hello, world</code>。</p> <hr> <p>例题 3：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>     
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">&quot;Child\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">&quot;Parent\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该程序的运行无法保证输出顺序，输出顺序依赖于内核所用的调度算法。<br>
在 <code>Ubuntu 20.04 LTS</code> 测试结果如下：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ gcc test.c -o <span class="token builtin class-name">test</span>
$ ./test
Parent
Child
Parent
Child
Parent
Child
Parent
Child
Parent
Child
$
</code></pre></div><hr> <p>例题 4：下面代码执行后，问父子进程的 <code>global</code> 和 <code>vari</code> 变量值。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> global <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> pid<span class="token punctuation">;</span> 
  <span class="token keyword">int</span> vari <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;before fork\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;fork error\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    global<span class="token operator">++</span><span class="token punctuation">;</span>
    vari<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;global=%d,vari=%d\n&quot;</span><span class="token punctuation">,</span> global<span class="token punctuation">,</span> vari<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>运行后，父进程的 <code>(global, vari) = (4,5)</code>；子进程的 <code>(global, vari) = (4,5)</code>。</p> <table><thead><tr><th>变量名</th> <th>父进程</th> <th>子进程</th></tr></thead> <tbody><tr><td><code>global</code></td> <td>4</td> <td>5</td></tr> <tr><td><code>vari</code></td> <td>5</td> <td>4</td></tr></tbody></table> <p>这个例子说明，子进程的内存是父进程 <code>(global, vari) = (4,5)</code> 的复制下（而不是引用），子进程进行 <code>global++; vari--;</code> 完全不影响父进程的变量。</p> <h3 id="线程"><a href="#线程" class="header-anchor">#</a> 线程</h3> <h4 id="线程与进程"><a href="#线程与进程" class="header-anchor">#</a> 线程与进程</h4> <p>进程的两个属性（拥有资源、调度/执行的基本单位）是独立的，OS 应该能独立处理它们，为此引入线程。</p> <ul><li><strong>调度并分派的单位</strong>通常称为<strong>线程</strong>（或轻量级进程 <code>LWP</code>）</li> <li><strong>资源所有权的单位</strong>通常称为<strong>进程</strong></li></ul> <p>多线程 <code>multithreading</code>：操作系统在单个进程内支持多个并发路径的能力。</p> <p>单线程：每个进程中只有一个线程在执行（在多线程出现之前，还没有线程这个概念；显然这是在多线程出现之后才给出的定义）。</p> <p><img src="/images/c9c7e964cbd4db9b84ec977c862c66c5ac919780cf218c9f1dcb625d3674e302.png" alt="多进程与多线程的例子"></p> <p>多线程环境中，与进程相关的资源和保护：</p> <ul><li>容纳进程映像的虚地址空间（回忆<a href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0">进程映像</a></li> <li>受保护的访问：
<ul><li>处理器</li> <li>其他进程（进程间通信时，以进程为单位）</li> <li>文件</li> <li>I/O 资源</li></ul></li></ul> <p>一个进程中可能有多个线程，每个线程有：</p> <ul><li>执行状态（运行、就绪等）</li> <li>未运行时保存的线程上下文（寄存器值）</li> <li>执行栈（过程调用）</li> <li>用于局部变量的静态存储空间</li> <li>与进程内其他线程共享的内存和资源访问</li></ul> <p>如下图，多线程模式中，几个线程的 PCB 和内存地址空间是共享的，而每个线程有自己的 TCB、用户栈和内核栈。进程控制块 <code>Thread Control Block</code> 较 PCB 会简单很多，其内容如上点。</p> <p><img src="/images/d413ee8142e7bec16c3bc644d1c611d8c5447b212039cba415eb8fae3a04ec76.png" alt="单进程和多进程模型"></p> <p>进程的优点：</p> <ul><li>创建线程快于创建进程（因为 TCB 简单）</li> <li>终止线程快于终止进程（同上）</li> <li>（同一进程内）线程切换快于进程切换（上下文、数据结构少）</li> <li>线程提高了不同执行程序间通信的效率（线程间通信）</li></ul> <p>调度和分派基于<strong>线程</strong></p> <ul><li>大多数与线程相关的信息保存在线程级的数据结构中</li> <li>挂起一个进程 == 挂起内部所有线程</li> <li>终止一个进程 == 终止内部所有线程</li></ul> <p>线程主要状态：运行、就绪、阻塞（类似于进程三状态模型）<br>
和线程状态变化相关的基本操作：派生、阻塞、解除阻塞、结束</p> <p><img src="/images/74b533c2ae6d3895a26d1cf9568acfba32b8110db32111fd6bf09e3de5638fb1.png" alt="使用线程的远程过程调用示例"></p> <p>如上，即使是在单核 CPU 上运行，多线程技术在 I/O 密集型程序中能显著提高效率。</p> <p><img src="/images/f8efbe1be57a720f24a1bf56dfed62ad128bb75a915090cb79af144493620683.png" alt="单处理器上的多线程示例"></p> <p>需要线程同步的原因：一个进程中的所有线程共享一个地址空间和进程所拥有的资源，一个线程对其的修改将影响其他线程。</p> <h4 id="多线程-多进程-多核相关概念"><a href="#多线程-多进程-多核相关概念" class="header-anchor">#</a> 多线程，多进程，多核相关概念</h4> <p>多线程，多进程，多核的概念令人迷惑，不过<a href="https://zhuanlan.zhihu.com/p/82123111" target="_blank" rel="noopener noreferrer">知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>上有篇总结贴可以参考。</p> <ol><li><code>CPU 的线程数</code> == <code>可以同时并行的线程数量</code> == <code>操作系统看到的核数（可使用任务管理器或 htop 等）</code></li> <li>进程是系统资源（内存、显卡、磁盘）的分配单位，线程是调度（可以理解为 CPU 资源）的分配单位</li> <li>同进程下的线程共享该进程的资源，不同进程的线程如果想要共享资源，需要在 OS 层面上通信，效率低</li> <li>对于计算密集型进程，<code>进程线程数 == CPU线程数</code> 时能充分利用 CPU 资源，<code>进程线程数 &gt; CPU线程数</code> 时会因为 CPU 频繁进程切换导致效率反而变低</li> <li>对于 IO 密集型进程，由于进程会被频繁阻塞，<code>进程线程数 &gt; CPU线程数</code> 能够提高 CPU 利用率，提高效率</li> <li>Python 是一个特例，由于 <code>Global Interpreter Lock</code> (全局解释器锁) 的存在，一个 Python 进程中只能同时有一个线程执行</li></ol> <h4 id="线程分类"><a href="#线程分类" class="header-anchor">#</a> 线程分类</h4> <ul><li>用户级线程 <code>User-Level Thread</code>, <code>ULT</code></li> <li>内核级线程 <code>Kernel-Level Thread</code>, <code>KLT</code></li></ul> <p><img src="/images/1ff352e0972f8ffc505e4894c7b735ea5cd53cebaa644755185f2a07ab9a2479.png" alt="用户级线程和内核级线程"></p> <h5 id="用户级线程-ult"><a href="#用户级线程-ult" class="header-anchor">#</a> 用户级线程 ULT</h5> <p>ULT 下，线程由库函数实现，线程的创建、销毁全部由库函数实现。而<strong>内核不知道用户级线程的存在，依旧按照进程为单位进行调度</strong>。</p> <p><img src="/images/baa475ec5e9712501ff158c803eb51260f7e0decd97ecbd7d95763584dbb84e5.png" alt="ULT 下进程状态和线程状态的关系"></p> <p>如上图，ULT 下，会出现一些比较神奇的情况：</p> <ol><li>(a) 图是正常运行的状态</li> <li>线程 2 等待 I/O，导致进程 B 被<code>阻塞</code>，此时线程 1、2 均未被 CPU 运行，但线程 2 的数据结构中仍被标记为<code>运行</code>，如图 (b)</li> <li>I/O 事件到达，进程 B 被置为<code>就绪</code>，此时线程 1、2 均未被 CPU 运行，但线程 2 的数据结构中仍被标记为<code>运行</code>，如图 (c)</li> <li>进程 B 运行过程中，线程 2 等待线程 1 的事件，此时线程 2 被置为<code>阻塞</code>，线程 1 被置为<code>运行</code>，进程 B 仍为<code>运行</code></li></ol> <hr> <p>用户级线程优点：</p> <ul><li>线程切换不需要内核模式</li> <li>调度策略因应用程序不同而不同</li> <li>可以运行在任何操作系统上</li></ul> <p>缺点：</p> <ul><li>当用户级线程执行系统调用时，不仅阻塞当前线程，还将引起同一进程中的其他线程阻塞</li> <li>采用 ULT 策略，不能利用多处理器技术（ULT 下，内核按进程分配处理器）</li></ul> <p>解决方法：</p> <ul><li>将应用程序写成多进程程序而不是多线程</li> <li>Jacketing（套管）技术：将一个可能产生阻塞的系统调用转换成一个非阻塞的系统调用</li></ul> <blockquote><p>一种解决线程阻塞问题的方法是，使用一种称为“套管”(jacketing) 的技术。“套管”的目标是把一个产生阻塞的系统调用转化为一个非阻塞的系统调用。例如，替代直接调用一个系统 I/O 例程，让线程调用一个应用级的 I/O 套管例程，这个套管例程中的代码用于检查并确定 I/O 设备是否忙。如果忙，该线程进入阻塞态并把控制权传送给另一个线程。这个线程重新获得控制权后，套管例程会再次检查I/O设备。</p></blockquote> <h5 id="内核级线程-klt"><a href="#内核级线程-klt" class="header-anchor">#</a> 内核级线程 KLT</h5> <p>纯 KLT 软件中，管理线程的所有工作均由内核完成。应用级没有线程管理代码，只有一个到内核线程设施的应用编程接口 <code>API</code>。 Windows是这种方法的一个例子。</p> <p>优点：</p> <ul><li>（解决了纯 ULT 的两个痛点）一个进程的多个线程可以调度到多处理器上</li> <li>当一个线程阻塞时，内核可以调度同一进程内的其他线程</li> <li>此外，内核本身也可以是多线程的
缺点：</li> <li>从一个线程切换到相同进程内的另一个线程时，需要切换到内核模式</li></ul> <p><img src="/images/e73c93ff19097507f860f0d0fd90db649ff848cd093afb4062390f4a904848d4.png" alt="线程和进程操作执行时间（µs）"></p> <ul><li><code>Null Fork</code>: Fork 以后什么都不做</li> <li><code>Signal Wait</code>: 一个进程/线程发出信号到另一个进程/线程收到信号</li> <li>KLT 下操作涉及到模式切换；进程操作涉及到共享空间等</li></ul> <h5 id="混合方法"><a href="#混合方法" class="header-anchor">#</a> 混合方法</h5> <p>在混合系统中，</p> <ul><li>线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行</li> <li>一个应用程序中的多个用户级线程会被映射到一些（小于等于用户级线程数）内核级线程上（程序员还可以调节 KLT 的数量）</li></ul> <p>优点：</p> <ul><li>同一个进程中的多个线程可利用多处理器</li> <li>引起阻塞的系统调用不会阻塞整个进程</li></ul> <p>设计正确时，这种方法可结合纯 ULT 方法和纯 KLT 方法的优点，并克服它们的缺点。Solaris操作系统是使用混合方法的很好例子。</p> <h2 id="二-2-进程管理-进程调度"><a href="#二-2-进程管理-进程调度" class="header-anchor">#</a> 二(2) 进程管理：进程调度</h2> <p>如果有多个进程（线程）竞争 CPU，需要选择下一个要运行的进程（线程）。OS 中完成这部分工作的程序称为调度程序 <code>scheduler</code>。调度程序使用的算法称为调度算法 <code>scheduling algorithm</code>。</p> <p>调度的目的：满足系统目标（响应时间、吞吐量、处理器效率）的方式，把进程分配到一个或多个处理器上执行</p> <h3 id="调度的类型"><a href="#调度的类型" class="header-anchor">#</a> 调度的类型</h3> <table><thead><tr><th>调度类型</th> <th>操作</th> <th>决策内容</th></tr></thead> <tbody><tr><td>长程调度</td> <td>创建进程 <code>-&gt;</code> 挂起/就绪</td> <td>把进程添加到当前活跃的进程集中</td></tr> <tr><td>中程调度</td> <td>挂起 <code>&lt;-&gt;</code> 就绪/运行</td> <td>把进程添加到（至少部分）已在内存且可被执行的进程集中</td></tr> <tr><td>短程调度</td> <td>就绪 <code>&lt;-&gt;</code> 运行</td> <td>下次执行哪个就绪进程</td></tr></tbody></table> <p>下图为三种调度和状态图的关系。</p> <p><img src="/images/276c846bfdc127bacb591e1224689d2460e8ce934c50f0d9e09800ab155c7077.png" alt="调度与状态图"></p> <p>下图为三种调度的层次关系。</p> <p><img src="/images/8f3b60207781b74a7c41de935bb83508d4c6d9cbfae71c88208076fac3794440.png" alt="调度的层次"></p> <p>注意三种调度的关系不是包含，而是嵌套。</p> <p><img src="/images/544ae847b7d710680678853338fc26643b01aaae6aa24adcad89ee9c4acdb7a1.png" alt="具有三种调度的调度队列模型"></p> <h4 id="长程调度"><a href="#长程调度" class="header-anchor">#</a> 长程调度</h4> <ul><li>决定哪个程序可以进入系统中处理</li> <li>控制系统并发度
<ul><li>创建的进程越多，每个进程执行的时间比例越小</li> <li>可能限制并发的度给当前进程集提供满意的服务</li></ul></li></ul> <p>长程调度需考虑：</p> <ol><li>何时操作系统能够接纳进程</li> <li>接纳哪个作业为之创建进程（先来先服务，或根据优先级、期望的执行时间、I/O 需求）</li></ol> <h4 id="中程调度"><a href="#中程调度" class="header-anchor">#</a> 中程调度</h4> <p>中程调度是交换功能的一部分，是否换入取决于系统并发度的需求。在不使用虚存的系统中，换入决策还需考虑换出进程的存储需求。</p> <h4 id="短程调度"><a href="#短程调度" class="header-anchor">#</a> 短程调度</h4> <ul><li>又称分派程序</li> <li>执行最频繁</li> <li>决定下次执行哪个进程</li> <li>当前进程阻塞或被抢占时，调用短程调度程序
<ul><li>事件：时钟中断、I/O 中断、系统调用、信号等</li></ul></li></ul> <h3 id="调度的规则"><a href="#调度的规则" class="header-anchor">#</a> 调度的规则</h3> <h4 id="相关概念"><a href="#相关概念" class="header-anchor">#</a> 相关概念</h4> <ul><li>响应时间：从<strong>用户提交</strong>一个请求开始，到接收响应之间的时间间隔
<ul><li><strong>响应时间 = 输入传送时间 + 处理时间 + 响应传送时间</strong></li></ul></li> <li>截止时间：某任务必须开始执行/必须完成的最迟时间</li> <li>吞吐量：在单位时间内，系统完成的进程数</li> <li>处理器利用率：处理器处于忙状态的时间百分比</li> <li>周转时间：<strong>进程</strong>从提交到完成的时间
<ul><li><strong>周转时间 = 等待资源的时间 + 执行时间</strong></li> <li>等待资源的时间 = 就绪 + 阻塞 + 就绪/挂起 + 阻塞/挂起</li> <li>注意“周转时间”和“响应时间”针对的主体不同，前者是进程，后者是用户</li></ul></li> <li>平均周转时间：多个进程周转时间的平均值</li> <li>平均带权周转时间：多个进程带权周转时间的平均值
<ul><li>带权周转时间 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>T</mi><mi mathvariant="normal">/</mi><mi>S</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">= T/S \geq 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>，其中 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span> 为周转时间，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></span> 为服务时间（执行时间）</li> <li>若 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi mathvariant="normal">/</mi><mi>S</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T/S=1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span> 说明进程来了立即被调用，没有等待</li></ul></li></ul> <h4 id="调度规则总结"><a href="#调度规则总结" class="header-anchor">#</a> 调度规则总结</h4> <p>短程调度的主要目标：以优化系统某些方面为目的，分配处理器时间</p> <ul><li>面向用户，与性能相关：周转时间、响应时间、 最后期限（截止时间）</li> <li>面向用户，与性能无关：可预测性</li> <li>面向系统，与性能相关：吞吐量、 处理器利用率</li> <li>面向系统，与性能无关：公平性、强制优先级、平衡资源</li></ul> <h4 id="优先级的使用"><a href="#优先级的使用" class="header-anchor">#</a> 优先级的使用</h4> <p>下图为多优先级队列的一个例图。总是先执行优先级最高的进程（RQ0）。</p> <p><img src="/images/dbba9e70c56d6c0fc1bb029b5b7434d118ff6171db5cd6a7b0e2032acfb6a6e2.png" alt="优先级的使用"></p> <p>考虑进程优先级可能导致饥饿（低优先级进程迟迟无法运行），可以采用动态优先级方案（如根据等待时间变化优先级，等待时间过长后提高优先级）。</p> <h3 id="调度的决策模式"><a href="#调度的决策模式" class="header-anchor">#</a> 调度的决策模式</h3> <p>调度的决策模式：</p> <ul><li>非抢占（非剥夺）：执行进程只有在执行完毕，或因申请 I/O 或请求某些操作系统服务而阻塞自己时，才释放处理器。<strong>OS 不会主动中断进程</strong>。</li> <li>抢占（剥夺）：执行进程<strong>可能被操作系统中断</strong>，并转换为就绪态</li></ul> <p>抢占可能发生在：</p> <ul><li>新进程到达</li> <li>中断发生后把一个阻塞进程置为就绪态</li> <li>周期性的时钟中断</li></ul> <p>调度的选择函数：</p> <ul><li>决定下次选择哪个就绪进程执行</li> <li>可基于优先级、资源需求、进程的执行特性</li> <li>基于执行特性时的基本参数：
<ul><li><strong>w</strong> = 在系统里已经等待 <code>waiting</code> 的时间</li> <li><strong>e</strong> = 在系统里已经执行 <code>execution</code>的时间</li> <li><strong>s</strong> = 进程所需的总服务 <code>service</code> 时间，需要估计或由用户提供</li> <li><strong>e-s</strong> = 进程还需要执行的时间</li></ul></li></ul> <h3 id="调度算法"><a href="#调度算法" class="header-anchor">#</a> 调度算法</h3> <ul><li>系统的资源分配策 -&gt; 资源分配算法</li> <li>对于不同的系统目标，采用不同的调度算法</li></ul> <p>常见（短程）调度算法：</p> <ul><li>先来先服务 <code>First Come First Served, FCFS</code></li> <li>时间片轮转 <code>Round Robin, RR</code></li> <li>短进程优先 <code>Shortest Process Next, SPN</code></li> <li>剩余时间最短优先 <code>Shortest Remaining Time, SRT</code></li> <li>响应比高者优先 <code>Highest Response Ratio Next, HRRN</code></li> <li>反馈 <code>Feedback</code></li> <li>……</li></ul> <h4 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h4> <p><img src="/images/a4f9bec23de25af74ea9a242ede66e56daad3565dad29e43007372b52492c347.png" alt="概述"></p> <h4 id="先来先服务-fcfs"><a href="#先来先服务-fcfs" class="header-anchor">#</a> 先来先服务 FCFS</h4> <ul><li>算法：First-Come-First-Served, <code>FCFS</code>，也称为 <code>FIFO</code></li> <li>选择就绪队列中存在时间最长的进程运行 <code>max[w]</code></li> <li>即按请求 CPU 的顺序使用 CPU</li></ul> <p><img src="/images/e2794f1eebb0563cc3b7451381a053d9f123ad6550fd31e67a268fb38a02d4c2.png" alt="示例"></p> <hr> <p>算法评价：</p> <ul><li>非抢占调度</li> <li>有利于 CPU 繁忙型的进程（非抢占，能一直利用 CPU），而不利于 I/O 繁忙型的进程（需要反复排队 太惨了）</li> <li>不适合直接用于单处理器系统,通常与其它调度算法混合使用</li> <li>平均周转时间长</li> <li>对长进程有利，不利于短进程</li></ul> <h4 id="时间片轮转-rr"><a href="#时间片轮转-rr" class="header-anchor">#</a> 时间片轮转 RR</h4> <ul><li>算法：Round Robin, <code>RR</code></li> <li>每个进程被分配一个时间片，周期性产生时钟中断，中断时当前进程进入就绪队列末尾，基于 FCFS 选择下一个作业运行</li> <li>如果进程在时间片内阻塞或结束，则立即切换 CPU</li> <li>RR 算法在通用的分时系统或事务处理系统中特别有效</li></ul> <p><img src="/images/e2d616552ffc0ae85c84d1b6241dd3ff23b4a74b85519b55f44e484e570851e3.png" alt="示例"></p> <p>图中 <code>q</code> 为时间片长度，下同。</p> <p><strong>注意，D 到达的同时 C 调度时间片结束，此时优先级： D &gt; C。</strong></p> <hr> <p>算法评价：</p> <ul><li>抢占</li> <li>常用于<strong>分时系统</strong>或事务处理系统</li> <li>时间片与性能、响应时间相关
<ul><li>时间片太短——进程切换频繁，降低 CPU 效率</li> <li>时间片太长——短交互请求的响应时间变长</li> <li>时间片最好略大于一次典型交互的时间</li></ul></li> <li>对 CPU 密集型进程有利，对 I/O 型密集型进程不利（用不完一个时间片）</li></ul> <p>针对最后一点的<strong>改进：Virtural RR 算法</strong></p> <ul><li>增加一个辅助队列，接收 I/O 阻塞完成的进程</li> <li>调度优先于就绪队列</li> <li>但占用的处理器时间小于就绪队列</li> <li>类似于超市的快速结账通道</li> <li>VRR 算法比 RR 算法公平</li></ul> <h4 id="短进程优先-spn"><a href="#短进程优先-spn" class="header-anchor">#</a> 短进程优先 SPN</h4> <p>算法: Shortest Job(Process) First(Next), <code>SJF</code>/<code>SPF</code>/<code>SPN</code></p> <ul><li>短进程或短作业优先调度 <code>min[s]</code></li> <li>前提：预知执行时间</li></ul> <p><img src="/images/0ea56c428a5734629be630d7c9e98151782ee77d30c55d099ef5bd32fe20e70c.png" alt="示例"></p> <hr> <p>算法评价：</p> <ul><li>非抢占</li> <li>长进程饥饿</li> <li>有利于短进程，减小了平均周转时间</li> <li>缺少剥夺机制，不适用于分时系统/事务处理环境</li> <li>用户估计不准时，算法不一定能真正做到短作业优先调度</li></ul> <h4 id="剩余时间最短优先-srt"><a href="#剩余时间最短优先-srt" class="header-anchor">#</a> 剩余时间最短优先 SRT</h4> <p>算法: Shortest Remaining Time, <code>SRT</code></p> <ul><li>选择预期剩余时间最短的进程 <code>min[s-e]</code></li> <li>当一个新进程加入就绪队列时，如果它比当前运行的进程具有更短的剩余时间，就抢占当前正在运行的进程</li> <li><strong>在 SPN 的基础上增加了剥夺机制</strong>，抢占型</li></ul> <p><img src="/images/b830f9af056042c3b3fb157d6fac999b5d8dcc1c59e4bf792dc8c92046ea1a31.png" alt="示例"></p> <hr> <p>算法优点：</p> <ul><li>既不像 FCFS 偏爱长进程，也不像 RR 算法产生很多中断（因时间片而产生），减少了开销</li> <li>周转时间方面，比 SPN 好：只要就绪，短作业可以立即被执行</li></ul> <p>算法缺点：</p> <ul><li>需要估计预期的服务时间 <code>s</code></li> <li>存在长进程饥饿现象</li> <li>必须记录进程的已服务时间</li></ul> <h4 id="响应比高者优先-srrn"><a href="#响应比高者优先-srrn" class="header-anchor">#</a> 响应比高者优先 SRRN</h4> <p>算法: Highest Response Ratio Next, HRRN</p> <ul><li>当前进程执行完毕或需要阻塞时，选择就绪队列中响应比 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">R_p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span> 最高的进程投入执行，其中</li></ul> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>p</mi></msub><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac><mo>=</mo><mfrac><mrow><mi>w</mi><mo>+</mo><mi>s</mi></mrow><mi>s</mi></mfrac></mrow><annotation encoding="application/x-tex">R_p = \frac{\text{等待时间}+\text{要求服务时间}}{\text{要求服务时间}} = \frac{w+s}{s}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">要求服务时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">等待时间</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord text"><span class="mord cjk_fallback">要求服务时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.9463300000000001em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div></section><p><img src="/images/44fc51e62cc23ed7e5a337fbca7e62f66bc770aa0a4d4b1a5f9e63462020c674.png" alt="示例"></p> <p>算法评价：</p> <ul><li>非抢占</li> <li>动态优先权调度算法</li> <li>算法说明了进程的年龄</li> <li>是 FCFS 和 SJF 的结合，既照顾了短进程，又考虑了作业到达的先后次序，不会使长进程长期得不到服务</li> <li>但每次调度之前，都须先做响应比的计算，会增加系统开销；且难以准确计算</li></ul> <h4 id="反馈调度法-feedback"><a href="#反馈调度法-feedback" class="header-anchor">#</a> 反馈调度法 Feedback</h4> <p>SPN、SRT、SRRN 采用了“奖励短进程”的思想。虽然性能较好，但均基于进程的<strong>预期</strong>执行时间。</p> <p>算法思想：</p> <ul><li>采用<strong>惩罚运行时间较久的进程</strong>的思想</li> <li>关注<strong>已经执行</strong>的时间 <code>e</code></li> <li>抢占（但是只在时间片结束时抢占）</li> <li>动态优先级</li> <li>采用多级队列区别对待的方法——惩罚长进程</li> <li><strong>多个独立的、优先级不同的就绪队列</strong>，优先调度优先级高的队列</li> <li>进程执行过程中会降级</li> <li>算法有多个变种（根据抢占机制不同而不同）</li></ul> <p>（基于时间片轮转的）反馈调度算法：Feedback, <code>FB</code></p> <ol><li>设置多个就绪队列，每个队列赋予不同优先级</li></ol> <ul><li>第一队列优先级最高，依次递减</li> <li>优先级越高的队列，进程执行的时间片越小</li></ul> <ol start="2"><li>新进程进入时，首先放入第一个队列尾 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>Q</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">RQ0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">Q</span><span class="mord">0</span></span></span></span></span>，按 FCFS 原则排队</li> <li>如果进程在当前队列的时间片内完成则退出</li> <li>一般而言，从队列 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 中调度的进程<strong>允许执行 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">q=2^i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span> 的时间，然后才能被抢占</strong></li> <li>当且仅当进程被抢占时，会被降一级优先级</li></ol> <ul><li>如果时间片到达而没有被抢占（无其他进程需调度），则当前进程继续运行且暂时不降级。此后，一旦新进程出现，原进程会被立即抢占（无视时间片）并降一级</li></ul> <ol start="6"><li>到达最低优先级队列后，不再降级</li> <li>仅当第一队列空闲时，才调度第二队列中的进程，依次类推</li></ol> <p><img src="/images/0157b7d6af35892595f8dc7b2ad08c71e0204d59b2df82cc7a6ae3051c392c3a.png" alt="调度队列"></p> <p>重点掌握！！！</p> <hr> <p><img src="/images/d45dc487f6f1f948e555b7b454ffc4935c17eadfc3f7923b04a547f4a4c74e13.png" alt="示例"></p> <p>注意在下面的调度图中，第 6 时刻 D 到达，此时 B 在第 2 队列，但没有被立即抢占。必须等 B 的时间片用完后才会进行抢占。</p> <hr> <p>评价：多级反馈队列调度算法具有较好的性能，能较好地满足各种类型用户的需要。</p> <ul><li>终端型作业：有利（常为短作业，能在第一队列内完成）</li> <li>短作业：有利（能在前几个队列内完成）</li> <li>长进程：将依次在第 1, 2, ..., n 个队列中运行，随着优先级下降，分配的时间片长度增加，减少了抢占次数</li></ul> <p>问题：当不断有新进程到来时，长进程仍可能饥饿</p> <h3 id="实时系统与实时调度"><a href="#实时系统与实时调度" class="header-anchor">#</a> 实时系统与实时调度</h3> <p>实时系统：系统能够及时（即时）响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。对于实时系统而言，系统的正确性不仅取决于计算的结果，而且还依赖于产生结果的时间。</p> <p><strong>实时系统 = 实时控制系统 + 实时信息处理系统</strong></p> <hr> <ul><li>实时任务：具有及时性要求的、常常被重复执行的特定进程。在实时系统中习惯称为任务</li> <li>截止时间</li> <li>开始截止时间：任务在某时间以前<strong>必须</strong>开始执行</li> <li>完成截止时间： 任务在某时间以前<strong>必须</strong>完成</li></ul> <h4 id="实时任务分类"><a href="#实时任务分类" class="header-anchor">#</a> 实时任务分类</h4> <p>按截止时间分：</p> <ul><li>硬实时任务（必须在截止时间前开始/完成）</li> <li>软实时任务（可以稍微延迟一些）</li></ul> <p>按周期性分：</p> <ul><li>周期性实时任务（如每五秒就绪一次）</li> <li>非周期性实时任务</li></ul> <h4 id="实时操作系统特点"><a href="#实时操作系统特点" class="header-anchor">#</a> 实时操作系统特点</h4> <ul><li><strong>可确定性</strong>(determinism)：关注的是从设备中断到系统获知中断的时间</li> <li><strong>可响应性</strong>(responsiveness)：关注的是系统获知中断后，为中断提供服务的的时间</li> <li><strong>用户控制</strong>(user control)：需要用户能够区分软、硬实时任务，并控制任务优先级</li> <li><strong>可靠性</strong>(reliability)：要求高于非实时系统</li> <li><strong>失效弱化</strong>(fail-soft operation)：故障时尽可能多地保存性能和数据，尽可能减少损失</li></ul> <h4 id="实时调度的两个维度"><a href="#实时调度的两个维度" class="header-anchor">#</a> 实时调度的两个维度</h4> <ul><li><a href="#%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95">调度方法</a>：下次调度哪个任务</li> <li><a href="#%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F">抢占方式</a>：调度时采用什么抢占方式（在什么时候抢占）</li></ul> <h4 id="调度方法分类"><a href="#调度方法分类" class="header-anchor">#</a> 调度方法分类</h4> <p>调度方法方面，大概分为四类：</p> <ol><li>静态表驱动调度法</li> <li>静态优先级抢占调度法</li> <li>基于动态规划的调度法</li> <li>动态尽力调度法</li></ol> <h5 id="静态表驱动调度表"><a href="#静态表驱动调度表" class="header-anchor">#</a> 静态表驱动调度表</h5> <ul><li>用于调度<strong>周期性实时任务</strong></li> <li>按照任务信息（周期到达的时间、执行时间、完成截止时间以及任务的优先级），制订调度表，调度实时任务</li> <li>例：<a href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%9C%89%E5%AE%8C%E6%88%90%E9%99%90%E6%9C%9F%E7%9A%84%E5%91%A8%E6%9C%9F%E6%80%A7%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1">最早截止时间优先 <code>EDF</code></a></li> <li>此类算法不灵活，任何任务的调度申请改动都会引起调度表的修改</li></ul> <h5 id="静态优先级抢占调度法"><a href="#静态优先级抢占调度法" class="header-anchor">#</a> 静态优先级抢占调度法</h5> <ul><li>此类算法多用于<strong>非实时多道程序系统</strong></li> <li>优先级的确定方法很多，例如在分时系统中，可以对 I/O 密集型和 CPU 密集型的进程赋予不同的优先级</li> <li>实时系统中一般根据任务的时间约束赋予优先级，例如<a href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%91%A8%E6%9C%9F%E6%80%A7%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1">速率单调调度算法 <code>RMS</code></a> 即是根据任务周期长度为实时任务赋予静态优先级。</li></ul> <h5 id="基于动态规划的调度法"><a href="#基于动态规划的调度法" class="header-anchor">#</a> 基于动态规划的调度法</h5> <ul><li>当实时任务到达以后，系统为新到达的任务和正在执行的任务动态创建一张调度表</li> <li>在当前执行进程不会错过其截止时间的条件下，如果也能使新到达任务在截止时间内完成，则立即调度执行新任务</li></ul> <h5 id="动态尽力调度法"><a href="#动态尽力调度法" class="header-anchor">#</a> 动态尽力调度法</h5> <ul><li>实现简单，广泛用于<strong>非周期性实时任务调度</strong></li> <li>当任务到达时，系统根据其属性赋予优先级，优先级高的先调度。例如<a href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%9C%89%E5%AE%8C%E6%88%90%E9%99%90%E6%9C%9F%E7%9A%84%E5%91%A8%E6%9C%9F%E6%80%A7%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1">最早截止时间优先 <code>EDF</code></a> 调度算法就采用了这种方法。这种算法总是尽最大努力尽早调度紧迫任务，因此称为“最大努力调度算法”</li> <li>缺点在于，当任务完成，或截止时间到达时，<strong>很难知道该任务是否满足其约束时间</strong></li></ul> <h4 id="抢占方式分类"><a href="#抢占方式分类" class="header-anchor">#</a> 抢占方式分类</h4> <p>抢占方式分为以下四类，见表：</p> <table><thead><tr><th>抢占方式</th> <th>抢占/非抢占</th> <th>抢占时间点</th> <th>响应时间</th> <th>应用</th> <th>图</th></tr></thead> <tbody><tr><td>基于时间片的轮转调度</td> <td>抢占</td> <td>进程时间片用完</td> <td>秒级</td> <td>分时系统及一般实时处理系统</td> <td><img src="/images/1a7ff7c009c0d8165fac407523fe185914a9afed82c08179c321bd174d940d59.png" alt=""></td></tr> <tr><td>基于优先级的非抢占调度</td> <td>非抢占</td> <td>进程阻塞或完成</td> <td>数百毫秒至数秒</td> <td>多道批处理系统及不太严格的实时系统</td> <td><img src="/images/f68c7064c7f8b900b53ae7be62e4650acc2fbb7d7dd7bc8624cc3b41af266cc4.png" alt=""></td></tr> <tr><td>基于优先级的抢占点抢占调度</td> <td>抢占</td> <td>剥夺点（时间中断）到来时</td> <td>几毫秒至几十毫秒</td> <td>一般实时系统</td> <td><img src="/images/2cd1fdcbdb7a4876225188fd354391649b3be6ef25ca8ebbf31f15a9b2dbd45e.png" alt=""></td></tr> <tr><td>立即抢占式调度</td> <td>抢占</td> <td>立即</td> <td>微秒至毫秒级</td> <td>苛刻的实时系统</td> <td><img src="/images/189d229f6bff53861ede276608416ef5325b9ae153a04bcc564f69f8e16cafbb.png" alt=""></td></tr></tbody></table> <h4 id="实时调度方法实例"><a href="#实时调度方法实例" class="header-anchor">#</a> 实时调度方法实例</h4> <p>近年来，人们提出了许多关于实时任务调度的合适方法，这些方法都基于每个任务的额外信息。
最常见的信息包括：</p> <ul><li>就绪时间</li> <li>启动的限期 <code>starting deadline</code></li> <li>完成的限期 <code>completion deadline</code></li> <li>处理的时间：任务执行到完成的时间</li> <li>资源需求：任务执行过程中所需的资源集</li> <li>优先级：度量任务的相对重要性</li> <li>子任务结构：一个任务可分解为一个必须执行的子任务和一个可选执行子任务，前者有硬截止时间 <code>hard deadline</code></li></ul> <p>实时调度需要考虑的两个问题：</p> <ol><li>下次调度哪个任务？——选择 deadline 最早的任务</li> <li>使用什么抢占方式？——对于<strong>启动限期</strong>明确的任务，采用<strong>非抢占</strong>方式；对于具有<strong>完成限期</strong>的实时系统，采用<strong>抢占</strong>策略（这合理吗？）</li></ol> <h5 id="实例-有完成限期的周期性实时任务"><a href="#实例-有完成限期的周期性实时任务" class="header-anchor">#</a> 实例：有完成限期的周期性实时任务</h5> <p>在一个实时系统中，有两个周期性实时任务A和B</p> <ul><li>A：周期：20ms，执行时间：10ms</li> <li>B：周期：50ms，执行时间：25ms</li></ul> <p><img src="/images/9c1838f926b4f5176fcb7cac19ac6fabd5fcff7aa5099df3d27d7b7310ab0a74.png" alt="两个周期性任务的执行信息"></p> <p><img src="/images/40c1ab3af7398095bbc630ae8b35544533fb763af64e62b3ca1ee46430b257ca.png" alt="不同执行策略和效果"></p> <p>可见，在这个例子中，<strong>按“最早完成截止时间优先” <code>Earliest Deadline First, EDF</code> 的抢占模式</strong>能够使得所有任务都能在 deadline 之前执行完成。</p> <h5 id="实例-有开始限期的非周期性实时任务"><a href="#实例-有开始限期的非周期性实时任务" class="header-anchor">#</a> 实例：有开始限期的非周期性实时任务</h5> <ul><li>此类任务是非周期性的，不可预测的，若采用 <a href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%9C%89%E5%AE%8C%E6%88%90%E9%99%90%E6%9C%9F%E7%9A%84%E5%91%A8%E6%9C%9F%E6%80%A7%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1">EDF 算法</a>，存在危险性</li> <li>若在任务就绪前，预先知道任务的<strong>开始截止时间</strong>，则可以采用<strong>允许 CPU 空闲的 EDF 调度算法 <code>Earliest Deadline with Unforced Idle Times</code></strong></li> <li>优先调度截止时间最早的<strong>合格任务</strong>，并让该任务运行完毕
<ul><li>合格任务可以是还未就绪，但是事先知道其开始截止时间的任务</li></ul></li> <li>尽管 CPU 的利用率不高，但这种调度算法可以保证系统中的任务都能按要求完成</li></ul> <hr> <p>A、B、C、D、E五个非周期性进程，到达时间、执行时间和开始截止时间如下：</p> <p><img src="/images/0f09c62734fb10c414a49e7a627ad61f363a2bd9f092ea0b55fd8ec14f3e5954.png" alt="五个实时任务的执行信息"></p> <p><img src="/images/aae5f0d87da23e977e16bd4f5bedb7e92a44258d8c57d8eb57f1719d1e013c0f.png" alt="不同执行策略和效果"></p> <p>允许 CPU 空闲、优先调度 deadline 最早的（可能还未就绪的）合格任务，使得其能完成 B 任务。</p> <h5 id="实例-周期性实时任务"><a href="#实例-周期性实时任务" class="header-anchor">#</a> 实例：周期性实时任务</h5> <ul><li><code>Rate Monotonic Scheduling, RMS</code></li> <li>周期性任务</li> <li><strong>任务速率</strong>：任务周期（单位：秒）的倒数，以赫兹为单位</li> <li>任务速率用于优先级的确定
<ul><li>任务周期越短，优先级越高</li> <li>优先级函数是任务速度的单调递增的函数</li></ul></li> <li>系统按任务优先级的高低进行调度</li></ul> <h4 id="实时系统处理能力限制"><a href="#实时系统处理能力限制" class="header-anchor">#</a> 实时系统处理能力限制</h4> <p>假定系统中有 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span> 个周期性的硬实时任务，任务 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 的处理时间为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，周期为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，则在单处理机情况下，必须满足下面的限制条件：</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>P</mi><mi>i</mi></msub></mfrac><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^m \frac{C_i}{P_i} \leq 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></div></section><p>即系统中各个任务的处理器利用率总和不能超过 1（CPU的利用率 = 任务执行时间 / 任务周期）。</p> <h4 id="优先级反转"><a href="#优先级反转" class="header-anchor">#</a> 优先级反转</h4> <blockquote><p>高优先级任务被低优先级任务阻塞，导致高优先级任务迟迟得不到调度。但其他中等优先级的任务却能抢到CPU资源。-- 从现象上来看，好像是中优先级的任务比高优先级任务具有更高的优先权。——<a href="https://www.jianshu.com/p/c1f7aa944dda" target="_blank" rel="noopener noreferrer">信号量优先级反转（翻转）与优先级继承-- kummer话你知- 简书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <ul><li>可能发生于任何基于优先级的可抢占的调度方案中</li> <li>已在火星探路者中发生</li></ul> <p><img src="/images/6ee2f2f43447dae9c57d0dc6df355bec0fc549695c1ee4a57240abbaa1f8d346.png" alt="例子"></p> <p>解决方案是，使用<strong>优先级继承</strong>：优先级较低的任务继承任何与其共享同一资源的优先级较高的任务的优先级。</p> <p><img src="/images/d95d46d4d66424e32e1c26e3fb74aa0cc5dc56548ea763618fea476cdc709456.png" alt="解决方案"></p> <h2 id="二-3-进程管理-进程同步"><a href="#二-3-进程管理-进程同步" class="header-anchor">#</a> 二(3) 进程管理：进程同步</h2> <h3 id="并发的原理"><a href="#并发的原理" class="header-anchor">#</a> 并发的原理</h3> <p><img src="/images/adc928b89cd15576633d7109b47399ee11ca0513c045cdfad6e3a62d67b98503.png" alt="日常生活现象"></p> <p>多道程序设计为什么需要同步？</p> <ul><li><strong>进程</strong>是计算机中的独立个体，且具有<strong>异步性</strong>、<strong>并发性</strong></li> <li><strong>资源</strong>是计算机中的<strong>稀缺个体</strong>，需<strong>共享</strong>，如CPU、内存、I/O设备</li> <li>进程之间可能需要<strong>协作</strong>完成任务</li></ul> <h4 id="相关概念-2"><a href="#相关概念-2" class="header-anchor">#</a> 相关概念</h4> <p>这些概念后面会经常用到，很重要。</p> <ul><li><strong>原子操作</strong>：由一个或多个指令序列实现的动作或函数，对外不可见，一组指令要么都执行，要么都不执行。（数据库并发中的事务也有原子性）</li> <li><strong>临界资源</strong>：不可同时访问，必须互斥访问的资源，如打印机</li> <li><strong>临界区</strong>：访问<strong>临界资源</strong>的代码，任意时刻只能由一个进程在这段代码中运行</li> <li><strong>互斥</strong>：当一个进程在<strong>临界区</strong>访问共享资源时，其他进程不能进入该<strong>临界区</strong>访问共享资源的情形</li> <li><strong>忙等现象</strong>：当一个进程等待进入<strong>临界区</strong>时，它会继续消耗处理器的时间</li> <li><strong>活锁</strong>：两个或两个以上的进程为响应其他进程而持续改变自己状态，但是不做有用工作的情形</li> <li><strong>死锁</strong>：两个或两个以上的进程因等待其他进程做完某些事而不能继续执行的情形</li> <li><strong>竞争条件</strong>：多个进程或线程读写共享的数据时，结果取决于多个进程的指令执行顺序</li> <li><strong>饥饿</strong>：一个具备执行条件的进程，被调度程序无限期的忽视而不能调度的情形</li></ul> <p><img src="/images/d9393439dc3d0ca24039b39a80f0e3561ad8e1e89c5ec9cbe4147c40e9b8fc3e.gif" alt="忙等、饥饿和死锁"></p> <h4 id="并发控制的产生"><a href="#并发控制的产生" class="header-anchor">#</a> 并发控制的产生</h4> <p>产生原因：</p> <ul><li>单处理器的交替执行和多处理器的重叠执行
<ul><li>二者表达的是同样的问题——进程的相对执行速度不可预测，其取决于：
<ul><li>其他进程的活动</li> <li>操作系统处理中断的方式</li> <li>操作系统的调度策略</li></ul></li></ul></li> <li>进程执行的相对速度不可预测，给并发带来了困难
<ul><li>资源共享充满了危险性</li> <li>操作系统需要优化管理资源的分配</li> <li>定位程序的设计错误很困难</li></ul></li></ul> <hr> <p>如，两个进程共享 <code>echo()</code> （如下）可能会出现问题：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> chin<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  chin <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  chout <span class="token operator">=</span> chin<span class="token punctuation">;</span>
  <span class="token function">putchar</span><span class="token punctuation">(</span>chout<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="/images/52496acccf6f98f76ff991478a120d1a6d454185437fe04df573452dc1836976.png" alt="两端并行的 echo()"></p> <p>如图，设 <code>chin</code>、<code>chout</code> 均为全局变量。P1 程序输入 x，但由于 <code>chin</code> 被 P2 改变，P1 输出的是 y。</p> <p>解决方法：控制对共享资源的访问，使得一个进程的功能和输出结果与执行速度无关。</p> <p>于是，我们需要从进程的交互方式入手。不同的交互方式，并发控制问题不一样。</p> <h4 id="进程间的交互方式"><a href="#进程间的交互方式" class="header-anchor">#</a> 进程间的交互方式</h4> <p>进程间的关系：</p> <ul><li>竞争</li> <li>通过共享合作</li> <li>通过通信合作</li></ul> <h5 id="进程间的竞争资源"><a href="#进程间的竞争资源" class="header-anchor">#</a> 进程间的竞争资源</h5> <ul><li>进程间不知道彼此的存在</li> <li>进程竞争使用同一资源时，它们之间会发生冲突</li> <li>这类资源如：I/O设备、存储器、处理器、时钟</li></ul> <p>进程竞争资源时，并发控制面临三个问题：<strong>互斥、死锁、饥饿</strong></p> <h5 id="进程间通过共享合作"><a href="#进程间通过共享合作" class="header-anchor">#</a> 进程间通过共享合作</h5> <ul><li>多个进程共享一个变量、共享文件或数据库</li> <li>一个进程的结果可能取决于从另一个进程获得的信息</li> <li>进程知道其他进程也可能共享同一个数据，因此必须合作</li></ul> <p>进程通过共享合作时，并发控制面临四个问题：<strong>互斥、死锁、饥饿、数据一致性</strong>（比上面多一个数据一致性）</p> <h5 id="进程间通过通信合作"><a href="#进程间通过通信合作" class="header-anchor">#</a> 进程间通过通信合作</h5> <ul><li>进程间通过通信完成同步和协调彼此活动</li> <li>一个进程的结果可能取决于从另一个进程获得的信息</li> <li>通信可由各种类型的消息组成，发送或接收消息的原语由操作系统或程序设计语言提供</li> <li>不涉及对共享资源的访问</li></ul> <p>进程通过通信合作时，并发控制面临两个问题：<strong>死锁、饥饿</strong></p> <h3 id="互斥"><a href="#互斥" class="header-anchor">#</a> 互斥</h3> <h3 id="互斥的要求-访问临界区的原则"><a href="#互斥的要求-访问临界区的原则" class="header-anchor">#</a> 互斥的要求（访问临界区的原则）</h3> <ul><li>空闲让进：如临界区空闲，则有进程申请就立即进入</li> <li>忙则等待：每次只允许一个进程处于临界区（互斥）</li> <li>有限等待：保证进程在有限时间内能进入临界区(不会死锁或饥饿)</li> <li>让权等待：进程在临界区不能长时间阻塞等待某事件</li></ul> <p>本课程将从五个方面介绍互斥的实现，分别为<a href="#%E4%BA%92%E6%96%A5%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95">软件方法</a>、<a href="#%E4%BA%92%E6%96%A5%EF%BC%9A%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95">硬件方法</a>、<a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a>、<a href="#%E7%AE%A1%E7%A8%8B">管程</a>、<a href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92">消息传递</a>。</p> <h3 id="互斥-软件方法"><a href="#互斥-软件方法" class="header-anchor">#</a> 互斥：软件方法</h3> <ul><li>通过在进入区设置、检查一些<strong>标志</strong>来判断是否有进程在临界区</li> <li>若已有进程在临界区，则在进入区通过循环检查进行等待</li> <li>进程离开临界区后在退出区修改标志</li></ul> <h4 id="初步设想-轮换使用临界区"><a href="#初步设想-轮换使用临界区" class="header-anchor">#</a> 初步设想——轮换使用临界区</h4> <p>使用 <code>turn</code> 变量实现轮换使用临界区。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 共享的全局变量</span>
<span class="token keyword">int</span> turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">// 进程 P0 的代码</span>
<span class="token function">P0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//进入区</span>
    <span class="token comment">// 进程P0的临界区代码;  //临界区</span>
    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">//退出区</span>
    <span class="token comment">// 进程P0的其它代码    //剩余区</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//进程 P1 的代码</span>
<span class="token function">P1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//进入区</span>
    <span class="token comment">// 进程P1的临界区代码;  //临界区</span>
    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment">//退出区</span>
    <span class="token comment">// 进程P1的其它代码    //剩余区</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>严格轮换，实现了<strong>互斥</strong>访问</li> <li>在临界区外出错/被终止也会影响其他进程的执行</li> <li><strong>忙等</strong>（一切需要 <code>while(true)</code> 的代码均是忙等）</li> <li>**违反了“空闲让进”**原则</li></ul> <p>看不懂加粗词的读者请往上搜索其定义。</p> <h4 id="第一次改进-设置临界区状态标志"><a href="#第一次改进-设置临界区状态标志" class="header-anchor">#</a> 第一次改进——设置临界区状态标志</h4> <p>使用 <code>flag[2]</code> 标记临界区的状态标志，发现对方的 <code>flag</code> 为 <code>false</code> 则进入临界区。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 共享的全局变量,标志临界区是否可用</span>
<span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       

<span class="token comment">// 进程 P0 的代码</span>
<span class="token function">P0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//进入区</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 进程P0的临界区代码;  //临界区</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment">//退出区</span>
    <span class="token comment">// 进程P0的其它代码    //剩余区</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//进程 P1 的代码</span>
<span class="token function">P1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//进入区</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 进程P1的临界区代码;  //临界区</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment">//退出区</span>
    <span class="token comment">// 进程P1的其它代码    //剩余区</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>忙等</li> <li>**违反了“忙则等待”**原则，互斥访问未实现（如果两段代码同时执行各自的 <code>while</code> 和各自的 <code>flag[i]=true</code>，二者会同时进入临界区）</li></ul> <h4 id="第二次改进-预先表明进入临界区的态度"><a href="#第二次改进-预先表明进入临界区的态度" class="header-anchor">#</a> 第二次改进——预先表明进入临界区的态度</h4> <p>仍然使用 <code>flag[2]</code> 标记临界区的状态标志，但先修改自己的 <code>flag</code>，再查询对方的 <code>flag</code>，最后进入临界区。</p> <p>这个方法实现了互斥，但如果双方同时执行到 <code>while</code>，会死锁。当然，仍然存在忙等。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>boolean flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//共享的全局变量</span>

<span class="token comment">// 进程P0</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                 <span class="token comment">//进入区</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//进入区</span>
    <span class="token comment">// 进程P0的临界区代码；           //临界区</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">//退出区</span>
    <span class="token comment">//进程P0的其它代码               //剩余区</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 进程P1</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                 <span class="token comment">//进入区</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//进入区</span>
    <span class="token comment">// 进程P1的临界区代码；           //临界区</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">//退出区</span>
    <span class="token comment">//进程P1的其它代码               //剩余区</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="第三次改进-谦让"><a href="#第三次改进-谦让" class="header-anchor">#</a> 第三次改进——谦让</h4> <p>上面的问题是因为修改了自己的 <code>flag</code> 然后死等对方的 <code>flag</code>，等不到就一直等，结果两个人互等。</p> <p>这次改成，等不到就暂时释放自己的 <code>flag</code>，等一会后再改回来。</p> <p>这个方案实现了互斥，且未死锁，但是有长时间僵持的可能性（这是因为可能相互谦让）。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>boolean flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">//共享的全局变量</span>

<span class="token comment">//进程P0</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                 
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              
        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>             <span class="token comment">//谦让</span>
        <span class="token comment">//随机延迟一小段时间；</span>
        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//进程P0的临界区代码；             //临界区</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                 <span class="token comment">//退出区</span>
    <span class="token comment">//进程P0的其它代码                 //剩余区</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//进程P1</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                 
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              
        flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>             <span class="token comment">//谦让</span>
        <span class="token comment">//随机延迟一小段时间；</span>
        flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//进程P1的临界区代码；             //临界区</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                 <span class="token comment">//退出区</span>
    <span class="token comment">//进程P1的其它代码                 //剩余区</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="dekker-互斥算法-flag-冲突时根据-turn-裁定"><a href="#dekker-互斥算法-flag-冲突时根据-turn-裁定" class="header-anchor">#</a> Dekker 互斥算法—— flag 冲突时根据 turn 裁定</h4> <p>为回避刚才相互谦让的问题，Dekker 算法<strong>使用 <code>turn</code> 来裁定，当双方的 <code>flag</code> 冲突的时候，应该谁先访问</strong>。同时，当一方访问完临界区后，需将 <code>turn</code> 和 <code>flag</code> 都让出去。</p> <p>这个算法实现了互斥、无死锁，但仍然为忙等。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>boolean flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">//共享的全局变量</span>
<span class="token keyword">int</span> turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment">//共享的全局变量</span>

<span class="token comment">// 进程P0</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                 <span class="token comment">//进入区</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span>  <span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token comment">//等待</span>
            flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>                              <span class="token comment">//进入区</span>
    <span class="token comment">// 进程P0的临界区代码；           //临界区</span>
    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment">//将 turn 让出去</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">//退出区</span>
    <span class="token comment">// 进程P0的其它代码              //剩余区</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 进程P1</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                 <span class="token comment">//进入区</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span>  <span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token comment">//等待</span>
            flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>                              <span class="token comment">//进入区</span>
    <span class="token comment">// 进程P1的临界区代码；           //临界区</span>
    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                       <span class="token comment">//将 turn 让出去</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">//退出区</span>
    <span class="token comment">// 进程P1的其它代码              //剩余区</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="peterson-互斥算法-先把-turn-让给对方"><a href="#peterson-互斥算法-先把-turn-让给对方" class="header-anchor">#</a> Peterson 互斥算法——先把 turn 让给对方</h4> <p>Dekker 在 <code>flag</code> 冲突时才使用 <code>turn</code> 裁定，而 Peterson 互斥算法，就是在开始的时候直接先把 <code>turn</code> 让给对方，再判断对面是不是拥有 <code>turn==i</code> 和 <code>flag[i]</code> 二者。</p> <p>Peterson 算法较 Dekker 算法的显著优点是算法更简洁，对应的代码行数更短。</p> <p>这个算法实现了互斥、无死锁，但仍然为忙等。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>boolean flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment">//共享的全局变量</span>
<span class="token keyword">int</span> turn<span class="token punctuation">;</span>                              <span class="token comment">//共享的全局变量</span>
<span class="token comment">//进程P0</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token comment">//进入区</span>
    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment">//进入区</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//进入区</span>
    <span class="token comment">// 进程P0的临界区代码；             //临界区</span>
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                   <span class="token comment">//退出区</span>
    <span class="token comment">// 进程P0的其它代码                //剩余区</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//进程P0</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token comment">//进入区</span>
    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                          <span class="token comment">//进入区</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//进入区</span>
    <span class="token comment">// 进程P1的临界区代码；             //临界区</span>
    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                   <span class="token comment">//退出区</span>
    <span class="token comment">// 进程P1的其它代码                //剩余区</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <p>对于软件方法：</p> <ul><li>始终不能解决“忙等”现象</li> <li>实现互斥比较困难</li> <li>通常能实现两个进程的互斥，很难控制多进程互斥</li> <li>算法设计需非常小心，否则可能出现死锁、互斥失败等</li></ul> <p>以上算法中，Dekker 和 Peterson 算法都较好地在软件方法上实现了两进程互斥。</p> <h3 id="互斥-硬件方法"><a href="#互斥-硬件方法" class="header-anchor">#</a> 互斥：硬件方法</h3> <p>硬件方法如下：</p> <ul><li>中断禁用</li> <li>机器指令
<ul><li>compare &amp; swap</li> <li>Exchange</li></ul></li></ul> <h4 id="中断禁用"><a href="#中断禁用" class="header-anchor">#</a> 中断禁用</h4> <p>中断禁用（屏蔽中断）可用于单处理器系统。通过禁用中断，避免进程切换，简单粗暴地实现了互斥访问。</p> <p>其缺点有：</p> <ul><li>无法响应其他外部请求，且无法切换进程，执行效率明显下降</li> <li>在多处理器环境不能实现互斥（多个进程在多个处理器下并行执行）</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    disable interrupt    <span class="token comment">//屏蔽中断</span>
    critical section     <span class="token comment">//临界区</span>
    enable interrupt     <span class="token comment">//启用中断</span>
    remainder            <span class="token comment">//其余部分</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="专用机器指令"><a href="#专用机器指令" class="header-anchor">#</a> 专用机器指令</h4> <p>在多处理器环境中，几个处理器共享访问公共主存。处理器表现出一种对等关系，不存在主/从关系（对称多处理器）。</p> <p>处理器之间没有支持互斥的中断机制。因此，处理器的设计者提出了一些<strong>机器指令</strong>，用于保证两个动作的<strong>原子性</strong>（如在一个周期中对一个存储器单元的读和写）。</p> <p>这些动作在一个指令周期中执行，不会被打断，不会受到其他指令的干扰。</p> <h4 id="compare-swap-指令"><a href="#compare-swap-指令" class="header-anchor">#</a> compare &amp; swap 指令</h4> <p>比较和交换指令 <code>compare &amp; swap</code> 用于比较一个内存单元的值和一个测试值，如果相等，则发生交换。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">compare_and_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>word<span class="token punctuation">,</span> <span class="token keyword">int</span> testval<span class="token punctuation">,</span> <span class="token keyword">int</span> newval<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> oldval <span class="token operator">=</span> <span class="token operator">*</span>word<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>oldval <span class="token operator">==</span> testval<span class="token punctuation">)</span> <span class="token operator">*</span>word <span class="token operator">=</span> newval<span class="token punctuation">;</span>
    <span class="token keyword">return</span> oldval<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该指令总是返回旧内存值。因此，如果返回值与测试值相同，则表示该内存单元已被更新。</p> <p>这个原子指令由两部分组成：比较内存单元值和测试值；值相同时产生交换。整个比较和交换功能按原子操作执行，即它不接受中断。</p> <p>这个指令的另一个版本返回一个布尔值：交换发生时为真，否则为假。几乎所有处理器家族（x86、IA64、sparc 和 IBMz 系列等）都支持该指令的某个版本，且多数操作系统都利用该指令支持并发。</p> <p>下面是操作系统使用 <code>compare_and_swap</code> 实现并发互斥的一个方案。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> bolt<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 一共只有一个 0，所有进程可以用手里的 1 尝试换 0 。哪个进程抢到了 0 就该谁执行</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bolt<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入区</span>
        <span class="token comment">// 临界区代码</span>
        bolt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//退出区</span>
        <span class="token comment">// 剩余区代码</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    bolt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">parbegin</span><span class="token punctuation">(</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token function">P</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻塞主程序，初始化并行过程 P1, P2, ..., Pn；全部终止之后，才恢复主程序的执行</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="exchange-指令"><a href="#exchange-指令" class="header-anchor">#</a> Exchange 指令</h4> <div class="language-pascal extra-class"><pre class="language-pascal"><code><span class="token keyword">procedure</span> exchange<span class="token punctuation">(</span><span class="token keyword">var</span> r<span class="token punctuation">:</span> <span class="token keyword">register</span><span class="token punctuation">;</span> <span class="token keyword">var</span> m<span class="token punctuation">:</span> memory<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">begin</span>
        temp <span class="token operator">:=</span> m<span class="token punctuation">;</span>
        m <span class="token operator">:=</span> r<span class="token punctuation">;</span>
        r <span class="token operator">:=</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">end</span>
</code></pre></div><p>下面是操作系统使用 <code>exchange</code> 实现并发互斥的一个方案。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> bolt<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 一共只有一个 0，所有进程可以用手里的 1 尝试换 0 。哪个进程抢到了 0 就该谁执行</span>
        <span class="token keyword">do</span> <span class="token function">exchange</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>keyi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bolt<span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>keyi <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 临界区代码</span>
        bolt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//退出区</span>
        <span class="token comment">// 剩余区代码</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    bolt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">parbegin</span><span class="token punctuation">(</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token function">P</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻塞主程序，初始化并行过程 P1, P2, ..., Pn；全部终止之后，才恢复主程序的执行</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="信号量"><a href="#信号量" class="header-anchor">#</a> 信号量</h3> <p><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a>、<a href="#%E7%AE%A1%E7%A8%8B">管程</a> 都是提供互斥的方案。</p> <h4 id="引言"><a href="#引言" class="header-anchor">#</a> 引言</h4> <p><img src="/images/8540d09d2e2391ee2dcaffa1f06bd6249fce199f32e8d2eef095e6308adfb6ed.png" alt="交通信号灯：红灯停，绿灯行"></p> <p>信号量实现互斥与同步的基本原理：</p> <blockquote><p>两个或多个进程可以通过传递信号进行合作：迫使进程在某个位置暂时停止执行（阻塞），直到它收到一个可以“向前推进”的信号（被唤醒）。</p></blockquote> <p>实现信号灯作用的变量被称为信号量。</p> <h4 id="定义"><a href="#定义" class="header-anchor">#</a> 定义</h4> <p>信号量 <code>Semaphore</code> 可视为一个值为整数的变量。具有三个操作：</p> <ol><li>一个信号量可以初始化为非负数</li> <li><code>semWait</code> （<code>Wait</code>或<code>P</code>）操作使信号量的值减少1，若值变为负数，则阻塞执行 <code>semWait</code> 操作的进程</li> <li><code>semSignal</code>（<code>Signal</code>或<code>V</code>）操作使信号量的值增加1，若值小于等于零，则被 <code>semWait</code> 阻塞的进程解除阻塞</li></ol> <p>除了这三个操作外，没有其他方法可以检查或操作信号量。</p> <p>顺便，<code>P</code> 和 <code>V</code> 并称为 <strong>PV 操作</strong>。</p> <h4 id="分类"><a href="#分类" class="header-anchor">#</a> 分类</h4> <p>信号量分为二元信号量（信号量的值只能是0或1）和计数信号量（非二元信号量/一般信号量）</p> <p><img src="/images/af9fa20e66ced9ec46fdad7a1ccd207ff3b3c00d14c9675e9ef52d78c113e615.png" alt="二元信号量的定义及semWait和semSignal原语操作"></p> <p><img src="/images/8f97b4afca5956a37022e92c2315cb0b0c38a8ecb5e6b249909d540f8c0ae645.png" alt="一般信号量的定义及semWait和semSignal原语操作"></p> <p>上述二者都使用队列来组织等待信号量的进程。</p> <hr> <ul><li>强信号量：进程以FIFO方式从队列里移除</li> <li>弱信号量：未规定阻塞进程从队列里移除的顺序</li></ul> <p>(强)信号量机制示例：设进程A、B、C依赖于进程D的结果，s初始为1，表示D的一个结果可用</p> <p><img src="/images/8719bcfa4699bcee38a167bc1505cada877bfcec336836266021b6ff99af67c7.png" alt="(强)信号量机制示例"></p> <h4 id="信号量解决互斥问题"><a href="#信号量解决互斥问题" class="header-anchor">#</a> 信号量解决互斥问题</h4> <p>使用信号量能解决互斥问题，只需要给需要互斥的区域加一个信号量 <code>s</code>，访问前 <code>P</code>，访问后 <code>V</code> 即可。</p> <p><img src="/images/16a9e14b1c640c447d22076e920783b08dafd881b1496596c4405e5e0c8965f7.png" alt="信号量解决互斥问题"></p> <hr> <p>例：进程A、B、C访问受信号量lock保护的共享资源</p> <p><img src="/images/24011105c84c961249f67876ea2b4817f4eab6c700518a5c27468b1cba984fa0.png" alt="进程A、B、C访问受信号量lock保护的共享资源"></p> <h4 id="信号量的实现"><a href="#信号量的实现" class="header-anchor">#</a> 信号量的实现</h4> <p><code>P</code> 和 <code>V</code> 应作为<a href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD" target="_blank" rel="noopener noreferrer">原语<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>实现。即，任意时刻只能有一个进程用 <code>P</code> 和 <code>V</code> 来操作控制信号量。</p> <p>一种方案是用硬件或固件实现。另一种方案是采用硬件指令支持来保证进程互斥使用 <code>P</code> 和 <code>V</code> 操控信号量。</p> <p><img src="/images/76d8ddcfef5ecd86acdbd2133a2dec731b5f431b926eb0b0a645edbeade87dd9.png" alt="信号量的两种可能实现（左为compare&amp;swap，右为中断禁用）"></p> <hr> <p>上例中，共享资源数量为 1。进一步地，可扩展为共享资源数量为多个或共享资源允许多个进程同时访问的情况：</p> <p>在任何时候，信号量里 <code>count</code> 值可以解释如下：</p> <ul><li><code>s.count ≥ 0</code> 时，<code>s.count</code> 表示执行 <code>P(s)</code> 操作而不被阻塞的进程数（可看作可用资源数）。这种情形信号量可支持同步与互斥。</li> <li><code>s.count &lt; 0</code>时，<code>s.count</code> 表示阻塞在 <code>s.queue</code> 队列上的进程数。</li></ul> <h3 id="四大经典同步问题"><a href="#四大经典同步问题" class="header-anchor">#</a> 四大经典同步问题</h3> <ul><li><a href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者/消费者</a></li> <li><a href="#%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98">理发师</a></li> <li><a href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">读/写者</a></li> <li><a href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐</a></li></ul> <h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="header-anchor">#</a> 生产者/消费者问题</h3> <p>生产者与消费者问题：</p> <ul><li>一个或多个生产者产生数据并放入缓冲</li> <li>每次只能有一个消费者从缓冲中取出数据（互斥）</li> <li>任何时候只能由一个生产者或消费者访问缓冲（互斥）</li></ul> <p>需解决同步问题：</p> <ul><li>保证缓冲区满时，生产者不会往缓冲区中增加数据</li> <li>保证缓冲区空时，消费者不能从缓冲区中取走数据</li></ul> <p>-- Dijkstra</p> <p><img src="/images/10c373b09e0731c98b2b73a97001f7fe8290dee321951e9608d4f4ed8100d172.png" alt="程序框图"></p> <p>生产者/消费者问题使用信号量的一个实现如下：</p> <div class="language-verilog extra-class"><pre class="language-verilog"><code><span class="token comment">/*program bounded_buffer*/</span>
<span class="token keyword">const</span> sizeofbuffer <span class="token operator">=</span>…<span class="token punctuation">;</span>   <span class="token comment">/*  缓冲区大小  */</span>
<span class="token keyword">var</span> s <span class="token punctuation">:</span> <span class="token function">semaphore</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 用以互斥的信号量s，初始化为1 */</span>
    n <span class="token punctuation">:</span> <span class="token function">semaphore</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 表示资源的信号量n，表征数据单元数量，初始化为0 */</span> 
    e <span class="token punctuation">:</span> <span class="token function">semaphore</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token operator">=</span> sizeofbuffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 表示资源的信号量e，表征空存储单元数量 */</span>

procedure producer <span class="token punctuation">;</span>                procedure consumer <span class="token punctuation">;</span>
<span class="token keyword">begin</span>                               <span class="token keyword">begin</span>      
    <span class="token keyword">repeat</span>                              <span class="token keyword">repeat</span> 
        <span class="token comment">/*produce a item*/</span>                  <span class="token function">semWait</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">semWait</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token function">semWait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">semWait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">/*get a item*/</span>； 
        <span class="token comment">/*store a item*/</span>                    <span class="token function">semSignal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">semSignal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token function">semSignal</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">semSignal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>；                      <span class="token comment">/*consume a item*/</span>
    <span class="token keyword">forever</span>                             <span class="token keyword">forever</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>                                <span class="token keyword">end</span><span class="token punctuation">;</span>

<span class="token keyword">begin</span>    <span class="token comment">/* 主程序 */</span>
    parbegin   producer <span class="token punctuation">;</span> consumer <span class="token punctuation">;</span> parend
<span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre></div><p>上段代码使用了三个信号量：</p> <ul><li><code>s</code>：表示生产者、消费者之间的互斥</li> <li><code>e</code>：表示空间资源量（放满了产品，就没有空间了）</li> <li><code>n</code>：表示产品资源量</li></ul> <p>很有意思的是，生产者、消费者是对偶的关系。生产者需要空间，生产产品；消费者需要产品，“生产”空间。所以最简单的生产者/消费者问题中，二者的代码是很类似的。</p> <hr> <p>注意：</p> <ol><li>应先申请资源信号量，再申请互斥信号量，顺序不能颠倒，否则可能导致死锁！（由于所有生产者、消费者共用一个互斥信号量，拿到了就得赶紧用，不然别人都会等你。或者说，<strong>互斥信号量应该是最后申请的信号量</strong>）</li></ol> <p><img src="/images/cc09b9cba740f3b4f1820f4dfaf67b8164c08a9338d920954104edd0a7cb28b6.png" alt="可能出现死锁"></p> <ol start="2"><li>释放信号量的顺序应该是“先申请的后释放”。如果 <code>producer</code> 改为先释放 <code>n</code> 再释放 <code>s</code>，被阻塞在 <code>P(n);</code> 的消费者接收到 <code>n</code> 以后可能会被再次阻塞在 <code>P(s)</code>。</li></ol> <div class="language-verilog extra-class"><pre class="language-verilog"><code><span class="token comment">// 错误的 producer 示例</span>
procedure producer <span class="token punctuation">;</span>                procedure consumer <span class="token punctuation">;</span>
<span class="token keyword">begin</span>                               <span class="token keyword">begin</span>      
    <span class="token keyword">repeat</span>                              <span class="token keyword">repeat</span> 
        <span class="token comment">/*produce a item*/</span>                  <span class="token function">semWait</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">semWait</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token function">semWait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">semWait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">/*get a item*/</span>； 
        <span class="token comment">/*store a item*/</span>                    <span class="token function">semSignal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">semSignal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token function">semSignal</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">semSignal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>；                      <span class="token comment">/*consume a item*/</span>
    <span class="token keyword">forever</span>                             <span class="token keyword">forever</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>                                <span class="token keyword">end</span><span class="token punctuation">;</span>
</code></pre></div><ol start="3"><li>对于同一个信号量的 <code>wait</code> 与 <code>signal</code> 操作，既可以出现在同一个进程中，也可以出现在不同进程中（如 <code>n</code> 和 <code>e</code>）。</li> <li>但是，对任何信号量的 <code>wait</code> 与 <code>signal</code> 操作必须配对。</li> <li><code>wait</code>与<code>signal</code>语句不能颠倒顺序，<code>wait</code>语句一定先于<code>signal</code>语句执行，对吗？</li></ol> <p>不对，应为：在进入临界区前必须先执行<code>wait</code>操作，退出临界区后必须执行<code>signal</code>操作。对于同步信号量而言，既有可能先执行<code>wait</code>操作，也有可能先执行<code>signal</code>操作。</p> <h4 id="示例一"><a href="#示例一" class="header-anchor">#</a> 示例一</h4> <ul><li>桌子上有一只盘子，最多可以放入 <code>N (N&gt;0)</code> 个水果；</li> <li>爸爸随机向盘中放入苹果或桔子。儿子只吃盘中的桔子，女儿只吃盘中的苹果；</li> <li>只有盘子中水果数目小于 <code>N</code> 时，爸爸才可以向盘子中放水果；</li> <li>仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果；</li> <li>每次只能放入或取出一个水果，且不允许多人同时使用盘子。</li></ul> <p>用信号量机制实现爸爸、儿子和女儿之间的同步与互斥活动，并说明所定义信号量的含义。要求用伪代码描述。</p> <hr> <p>分析：</p> <ul><li>一个生产者和两个消费者被连接到大小为 <code>N</code> 的缓冲区上；</li> <li>盘子是一互斥资源（不能同时访问），故设置访问盘子的互斥信号量 <code>mutex</code>；</li> <li>爸爸、儿子因为桔子的放入与取出而同步，设置产品资源信号量<code>orange</code>；</li> <li>爸爸、女儿因为苹果的放入与取出而同步，设置产品资源信号量<code>apple</code>；</li> <li>爸爸、儿子、女儿因为共享盘子空间，设置空间资源信号量<code>empty</code>。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment">//盘子操作互斥信号量</span>
semaphore apple <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> orange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">//苹果、桔子放入、取出的资源信号量</span>
semaphore empty <span class="token operator">=</span> N<span class="token punctuation">;</span>                       <span class="token comment">//盘子中可放入的水果数目</span>

<span class="token function">father</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result<span class="token operator">=</span><span class="token function">prepare_fruit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//准备水果，result为水果类型</span>
        <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//盘子中可放入的水果数目减1</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//互斥访问盘子</span>
        put a fruit on the <span class="token function">plate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将一个水果放入盘子</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//恢复访问盘子</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> apple<span class="token punctuation">)</span>               <span class="token comment">//准备的水果为苹果</span>
            <span class="token function">V</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">//允许女儿取苹果</span>
        <span class="token keyword">else</span>                               <span class="token comment">//准备的水果为桔子</span>
            <span class="token function">V</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">//允许儿子取桔子</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//判断是否可取桔子</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//互斥访问盘子</span>
        get an orage from <span class="token function">plate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//取桔子</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//恢复访问盘子</span>
        <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//盘子中可放入的水果数目加1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">daughter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//判断是否可取苹果</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//互斥访问盘子</span>
        get an apple from <span class="token function">plate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//取苹果</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//恢复访问盘子</span>
        <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//盘子中可放入的水果数目加1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>P()</code> 等价于 <code>wait()</code>，<code>V()</code> 等价于 <code>signal()</code>，后面就使用 <code>P</code> 和 <code>V</code> 了。</p> <hr> <p>有意思的是，如果将原题的 <code>N</code> 改为 1，即盘子只有一个容量，就不需要 <code>mutex</code> 互斥信号量了，因为不会出现一边爸爸在放水果，另一边儿子/女儿在吃的情况。</p> <p>下面的例二就是这种情况，可以省下一个 <code>mutex</code> 信号量。</p> <h4 id="示例二"><a href="#示例二" class="header-anchor">#</a> 示例二</h4> <ul><li>桌子上有一只盘子，爸爸负责向盘中放苹果，妈妈负责向盘中放桔子；</li> <li>儿子只吃盘中的桔子，女儿只吃盘中的苹果；</li> <li>只有盘子为空时，爸爸或妈妈才可以向盘子中放入一个水果；</li> <li>仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果。</li></ul> <p>请用信号量机制实现爸爸、妈妈、儿子和女儿之间的同步与互斥活动，并说明所定义信号量的含义。要求用伪代码描述。</p> <hr> <p>分析：</p> <ul><li>两个生产者和两个消费者被连接到大小为1的缓冲区上；</li> <li>盘子是一互斥访问的空间资源，故设置资源信号量<code>plate</code>；</li> <li>爸爸、女儿因为苹果的放入与取出而同步，设置产品资源信号量<code>apple</code>；</li> <li>妈妈、儿子因为桔子的放入与取出而同步，设置产品资源信号量<code>orange</code>。</li> <li>这里不需要 <code>mutex</code> 信号量，原因在示例一中提到了。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore plate <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment">//是否允许向盘子放入水果</span>
semaphore apple <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> orange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">//盘子中是否有苹果、桔子</span>

<span class="token function">dad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        prepare an apple<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//互斥向盘子放水果</span>
        put an apple on the plate<span class="token punctuation">;</span>         <span class="token comment">//将苹果放入盘中</span>
        <span class="token function">V</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//允许取苹果</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">mom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        prepare an orange<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//互斥向盘子放水果</span>
        put an orange on the plate<span class="token punctuation">;</span>        <span class="token comment">//将桔子放入盘中</span>
        <span class="token function">V</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//允许取桔子</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//互斥取水果</span>
        get an orange from the plate<span class="token punctuation">;</span>      <span class="token comment">//从盘中取出桔子</span>
        <span class="token function">V</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//允许向盘中放入水果</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">daughter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//互斥取水果</span>
        get an apple from the plate<span class="token punctuation">;</span>       <span class="token comment">//从盘中取出苹果</span>
        <span class="token function">V</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//允许向盘中放入水果</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="示例三"><a href="#示例三" class="header-anchor">#</a> 示例三</h4> <ul><li>桌子上有一只盘子，最多可以放入2个水果；</li> <li>爸爸负责向盘中放苹果，妈妈负责向盘中放桔子，女儿负责取出并消费水果；</li> <li>放入者和取出者不允许同时使用盘子（两个生产者可以同时访问盘子）；</li> <li>当且仅当盘子中同时存在苹果和桔子时，女儿才从盘子中取出并消费水果。</li></ul> <p>请用信号量机制实现爸爸、妈妈和女儿之间的同步与互斥活动，并说明所定义信号量的含义。要求用伪代码描述。</p> <hr> <p>分析：</p> <p>由题意，盘子上最多只能出现一个苹果（要是出现两个苹果，那就没地方放桔子了）和一个桔子。因此，可以把盘子“分为”两个盘子，一个是用来放苹果的盘子，一个是用来放桔子的盘子。</p> <p>这样做以后，又可以省下 <code>mutex</code> 信号量，其原因和示例二省下 <code>mutex</code> 的原因相同。</p> <ul><li>两个生产者和一个消费者被连接到大小为2的缓冲区上</li> <li>盘子中是否可以放入苹果，设置空间资源信号量<code>empty_apple</code>；</li> <li>盘子中是否可以取出苹果，设置产品资源信号量<code>apple</code>；</li> <li>盘子中是否可以放入桔子，设置空间资源信号量<code>empty_orange</code>；</li> <li>盘子中是否可以取出桔子，设置产品资源信号量<code>orange</code>。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore apple <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> orange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">//盘子中是否有苹果、桔子</span>
semaphore empty_apple <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> empty_orange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//盘子是否可放入苹果、桔子</span>

<span class="token function">dad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        prepare an apple<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>empty_apple<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//盘子中是否可放入苹果</span>
        put an apple on the plate<span class="token punctuation">;</span>              <span class="token comment">//将一个苹果放入盘子</span>
        <span class="token function">V</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">//允许女儿取苹果</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">mom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        prepare an orange<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>empty_orange<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//盘子中是否可放入桔子</span>
        put an orange on the plate<span class="token punctuation">;</span>             <span class="token comment">//将一个桔子放入盘子</span>
        <span class="token function">V</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">//允许女儿取桔子</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token function">daughter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">//盘子中是否有苹果</span>
        <span class="token function">P</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">//盘子中是否有桔子</span>
        get an apple <span class="token operator">and</span> an orange from <span class="token function">plate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取水果</span>
        <span class="token function">V</span><span class="token punctuation">(</span>empty_apple<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//盘子中可以放入苹果</span>
        <span class="token function">V</span><span class="token punctuation">(</span>empty_orange<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//盘子中可以放入桔子</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="示例四"><a href="#示例四" class="header-anchor">#</a> 示例四</h4> <p>女儿负责画画，爸爸、妈妈负责欣赏。女儿在白板上画完一幅画后，请爸爸、妈妈均欣赏过一遍后，再创作新画，依次重复。请用信号量机制实现女儿、爸爸和妈妈之间的同步与互斥活动，并说明所定义信号量的含义。要求用伪代码描述。</p> <blockquote><p>另一种描述方法：一个生产者进程和两个消费者进程共享大小为1的缓冲，当且仅当缓冲为空时，生产者进程负责放入数据，当且仅当缓冲有数据时，消费者读数据，只有当两个消费者都读取数据后，生产者才能删除原有数据并继续生产下一个数据。</p></blockquote> <hr> <p>分析：</p> <p>此题和示例三类似：示例三中，两个生产者的产品被一个消费者同时消费后才能继续生产；此题中，一个生产者的产品同时被两个消费者消费后才能继续生产。</p> <p>解决的方案也类似，将这幅画“分为”给爸爸看的话和给妈妈看的画，分别设置空间资源量和产品资源信号量。</p> <ul><li>爸爸是否欣赏过，设置空间资源信号量<code>empty_dad</code>；</li> <li>爸爸是否可以欣赏，设置产品资源信号量<code>full_dad</code>；</li> <li>妈妈是否欣赏过，设置空间资源信号量<code>empty_mom</code>；</li> <li>妈妈是否可以欣赏，设置产品资源信号量<code>full_mom</code>。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore empty_dad <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> empty_mom <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">//爸爸、妈妈是否已看过女画的新画</span>
semaphore full_dad <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> full_mom <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">//是否存在可供爸爸、妈妈看的新画</span>


<span class="token function">daughter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>empty_dad<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//爸爸是否看过</span>
        <span class="token function">P</span><span class="token punctuation">(</span>empty_mom<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//妈妈是否看过</span>
        draw a <span class="token keyword">new</span> picture on the whiteboard<span class="token punctuation">;</span>   <span class="token comment">//画一幅新画</span>
        <span class="token function">V</span><span class="token punctuation">(</span>full_dad<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">//爸爸可以看了</span>
        <span class="token function">V</span><span class="token punctuation">(</span>full_mom<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">//妈妈可以看了</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token function">dad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>full_dad<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">//白板上是否存在没有看过的画</span>
        enjoy the picture on the whiteboard<span class="token punctuation">;</span>    <span class="token comment">//看画</span>
        <span class="token function">V</span><span class="token punctuation">(</span>empty_dad<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//爸爸已看过新画</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">mom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>full_mom<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">//白板上是否存在没有看过的画</span>
        enjoy the picture on the whiteboard<span class="token punctuation">;</span>    <span class="token comment">//看画</span>
        <span class="token function">V</span><span class="token punctuation">(</span>empty_mom<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//妈妈已看过新画</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="读者-写者问题"><a href="#读者-写者问题" class="header-anchor">#</a> 读者/写者问题</h3> <p>问题描述：</p> <blockquote><p>多个进程访问一个共享数据区（可为文件、内存空间、寄存器）。其中若干读进程只能读数据，若干写进程只能写数据。</p></blockquote> <blockquote><p>为数据库、文件、内存区及一组寄存器等的数据访问问题建立了一个通用模型。<br>
示例——联网售票系统、12306
在该系统中，数据的查询和更新非常频繁，不可避免会出现多个进程试图查询或修改（读/写）其中某一条数据的情形。</p></blockquote> <ul><li>问题的三种角色：
<ul><li>读进程</li> <li>写进程</li> <li>共享数据</li></ul></li> <li>问题的三个条件：
<ul><li>同时读</li> <li>同时写</li> <li>互斥读写</li></ul></li></ul> <p>读者/写者问题和生产者/消费者问题的区别：</p> <ol><li>读/写者的数据可多次读，生产/消费者的数据消费完后就没有了</li> <li>读者彼此不互斥，消费者彼此互斥</li></ol> <h4 id="读者优先"><a href="#读者优先" class="header-anchor">#</a> 读者优先</h4> <p>思想：</p> <ul><li>一旦有读者正在读数据，则允许随后的读者进入读数据</li> <li>只有当全部读者退出，才允许写者进入写数据</li> <li>导致写者饥饿</li></ul> <p>变量设置:</p> <ul><li><code>wsem</code>：互斥信号量，用于Writers间互斥、Writers和Readers互斥</li> <li><code>readcount</code>：统计正在同时读数据的Readers个数</li> <li><code>x</code>：对变量readcount互斥算术操作</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> readcount<span class="token operator">=</span><span class="token number">0</span>；
semaphore x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> wsem<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 思考：这句 if 能不能放到下一行的 V(x) 之后？</span>
        <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        READ<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcount<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        WRITE<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>算法核心：<code>wsem</code> 就像是一道防线，每次只会放一个人进去。所有的 Writers 会受其控制；但对于 Readers，仅当里面没有 Readers 的时候才会受其控制。</p> <p>思考：不可以。对 <code>readcount</code> 的读写操作都需要拿到互斥量。反例就是，如果进程 A 写完 <code>readcount</code> 以后释放 <code>x</code>，准备读 <code>readcount</code> 时被 OS 中断，OS 转而调度 B 进程修改了 <code>readcount</code>，之后 A 进程读到的值就不是原先 A 写的值。</p> <hr> <p>考虑如下进程序列(设序列中从右到左为进程先后到达顺序)，哪种情况下可能存在写者饥饿</p> <ol><li>R R R</li> <li>W W W</li> <li>R W</li> <li>R R W</li> <li>R R W R</li> <li>W W R</li> <li>W R R W</li></ol> <p>第五个存在<strong>写者饥饿</strong>，因为由于 W 前正在读操作，W 后的 R 可以插队到 W 之前。</p> <h4 id="公平优先"><a href="#公平优先" class="header-anchor">#</a> 公平优先</h4> <p>这个就比之前的复杂了。</p> <p>这个算法的核心思想是：连续的 Reader 可以同时读，但是 Reader 不允许插队到 Writer 之前（读者优先就是读者插队导致了写着饥饿）。</p> <p>变量设置：</p> <ul><li><code>wrsem</code>：互斥信号量，确定Writer 、Reader请求顺序</li> <li><code>wsem</code>：互斥信号量，用于Writers间互斥，Reader互斥Writers</li> <li><code>readcount</code>：统计同时读数据的Readers个数</li> <li><code>x</code>：对变量readcount互斥算术操作</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> readcount<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> semaphore x<span class="token operator">=</span>l<span class="token punctuation">,</span> wrsem<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> wsem<span class="token operator">=</span>l<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>wrsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readercount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>readercount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>wrsem<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 思考 1：这句能放在第五行 P(wrsem) 之后吗？</span>
        READ<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readercount<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>readercount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>wrsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        WRITE<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>wrsem<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 思考 2：这句不能放在 WRITE 之前吗？</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>第一道防线：<code>wrsem</code>，W、R均要排队，保证公平</li> <li>第二道防线：<code>wsem</code>（拦所有 W 和第一个 R）</li> <li>系统保证，一、二道防线之间最多只有一个人</li> <li>当某 R 进入第一道防线后，若第二道防线内没人或只有 R，则可以进入，否则需 <code>P(wsem)</code></li> <li>当某 W 进入第一道防线后，仅若第二道防线内没人，才可以进入，否则需 <code>P(wsem)</code></li> <li>当某 R 进入第二道防线后，会把第一道防线打开</li> <li>当某 W 进入第二道防线后，不会打开第一道防线；只有当 W 走的时候才会打开两道防线</li></ul> <hr> <p>思考 1：不可以。否则如果这个 R 后面是一个 W，W 可能（由于系统调度的原因）抢先完成 <code>P(wrsem) P(wsem)</code> 并开始写，之后 R 开始执行 <code>if (readercount == 1) P(wsem);</code>，最后就是结果这个 W 比 R 先做任务。</p> <p>思考 2：从原理上说是可以的。原算法中，某 W 进入第二道防线后，不会打开第一道防线；修改以后，W 进入第二道防线以后就会打开第一道防线。但考虑到接下来进入第一道防线的 W/R 仍然需要等待第二道防线，和修改之前没有区别，修改后还会导致这个 W/R 被二次阻塞，所以从效率上说，不推荐修改。</p> <hr> <p>考虑从右到左先后到达顺序的进程序列：R, R, W, R, R……</p> <h4 id="写者优先"><a href="#写者优先" class="header-anchor">#</a> 写者优先</h4> <p>这个似乎比上面那个还复杂。</p> <p>这个算法的思想是，当 Writers 正在写时，其他 W 可以插队到 R 之前排队。</p> <p>变量设置：</p> <ul><li><code>wsem</code>：互斥信号量，用于Writers间互斥，Reader互斥Writers</li> <li><code>readcount</code>：统计同时读数据的Readers个数</li> <li><code>x</code>：对变量readcount互斥算术操作</li> <li><code>rsem</code>：互斥信号量，当至少有一个写者申请写数据时互斥新的读者进入读数据。</li> <li>第一个写者受rsem影响，一旦有第一个写者，后续写者不受rsem其影响。但是读者需要在rsem上排队。</li> <li><code>writecount</code>：用于控制rsem信号量</li> <li><code>y</code>：对变量writecount互斥算术操作</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> readcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> writecount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
semaphore x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> wsem<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> rsem<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span>；
        READ<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcount<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        writecount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>writecount<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        WRITE<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        writecount<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>writecount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>第一道防线：<code>rsem</code>，拦所有 R 和第一个 W</li> <li>第二道防线：<code>wsem</code>，拦所有 W 和第一个 R</li> <li>当某 W 进入第一道防线，后面的 W 均可进入第一防线，所有 R 均被拦住</li> <li>当某 R 进入第一道防线，如果是进入的第一个 R 则需要拿到 <code>wsem</code> 不让后面的 W 写；随后放开第一道防线 <code>rsem</code>，让后面的 W/R 进入
<ul><li>如果进入的是 R，则可以进入第二道防线，一起读，顺便释放 <code>rsem</code> 再放一个人进来；</li> <li>如果进入的是 W，则之后的 W 均不需要等待第一道防线；对于第二道防线，需要等待最后一个 R <code>wsem</code> 才能进入。</li></ul></li></ul> <hr> <p>设每个序列最右为队首：</p> <ol><li>R R W R</li> <li>R R W</li> <li>W R R W</li> <li>W R R R R</li></ol> <p>对于第四个，即使是写者优先，W 仍然需要等待四个 R 读完才能写。</p> <h4 id="写者优先改进"><a href="#写者优先改进" class="header-anchor">#</a> 写者优先改进</h4> <p>于是，又提出了写者优先改进，其在写者优先的基础上只加了第六行 <code>P(z);</code> 和第十三行 <code>V(z);</code>。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> readcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> writecount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
semaphore x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> wsem<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> rsem<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span>；
        <span class="token function">V</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
        READ<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readcount<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        writecount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>writecount<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        WRITE<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>wsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        writecount<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>writecount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>rsem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>z</code> 只对 <code>reader</code> 起作用，使得只能有一个 R 在 <code>rsem</code> 上排队（而这个 R 手上拿了 <code>z</code>），其余 R 均需在 <code>z</code> 上排队；这样，在 <code>rsem</code> 上排队的 W 前面最多只会出现一个 R，而避免了在 <code>rsem</code> 上形成长队列（指 R 的长队列）。</p> <h4 id="示例一-2"><a href="#示例一-2" class="header-anchor">#</a> 示例一</h4> <p>有一座东西方向的独木桥，<strong>每次只能有一人通过</strong>，且不允许行人在桥上停留。东、西两端各有若干行人在等待过桥。请用P、V操作来实现东西两端行人过桥问题。</p> <p>这个例子只允许一个人在桥上，即所有人都是写者。就是一个最基础的人人之间均互斥。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//互斥信号量</span>

<span class="token keyword">void</span> <span class="token function">east_west</span><span class="token punctuation">(</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//互斥其他人过桥</span>
        <span class="token comment">//行人从东向西过桥</span>
        <span class="token function">V</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//允许其他人过桥</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">west_east</span><span class="token punctuation">(</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//互斥其他人过桥</span>
        <span class="token comment">//行人从西向东过桥</span>
        <span class="token function">V</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//允许其他人过桥</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="示例二-2"><a href="#示例二-2" class="header-anchor">#</a> 示例二</h4> <p>有一座东西方向的独木桥，<strong>同一方向的行人可连续过桥</strong>。当某一方向有行人过桥时，另一方向行人必须等待。桥上没有行人过桥时，任何一端的行人均可上桥。请用 PV 操作来实现东西两端人过桥问题。</p> <p>同方向行人可连续过桥，可以把这群人看做读者。那么，哪个方向是读者呢？谁先上谁就是读者，妙啊！</p> <ul><li><code>x</code>：互斥信号量，用于读者互斥写者</li> <li><code>countA</code>、<code>countB</code>：统计读者数目（同时在桥上的行人数目）</li> <li><code>mutexA</code>、<code>mutexB</code>：对变量<code>countA</code>、<code>countB</code>互斥算术操作</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> countA<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> countB<span class="token operator">=</span><span class="token number">0</span>；
semaphore x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> mutexA<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> mutexB<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">east_west</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutexA<span class="token punctuation">)</span><span class="token punctuation">;</span>
        countA<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>countA<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">V</span><span class="token punctuation">(</span>mutexA<span class="token punctuation">)</span><span class="token punctuation">;</span>
        walk across the bridge from east to west<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutexA<span class="token punctuation">)</span><span class="token punctuation">;</span>
        countA<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>countA<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutexA<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">west_east</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutexB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        countB<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>countB<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">V</span><span class="token punctuation">(</span>mutexB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        walk across the bridge from west to east<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutexB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        countB<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>countB<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutexB<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>只有当一个人是这个方向上第一个上桥的人，他才需要等待 <code>x</code>，就能保证第一个上桥的那个方向的其他人也能上桥，而反方向的人就得等这些人走完桥。</p> <h4 id="示例三-2"><a href="#示例三-2" class="header-anchor">#</a> 示例三</h4> <p>有一座东西方向的独木桥，同一方向的行人可连续过桥。当某一方向有行人过桥时，另一方向行人必须等待。桥上没有行人过桥时，任何一端的行人均可上桥。出于安全考虑，**独木桥的最大承重为4人，即同时位于桥上的行人数目不能超过4。**请用 PV 操作来实现东西两端人过桥问题。</p> <p>这个简单，在示例四中加一个初始化为 4 的信号量 <code>count</code> 就行。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> countA<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> countB<span class="token operator">=</span><span class="token number">0</span>；
semaphore x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> mutexA<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> mutexB<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">east_west</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutexA<span class="token punctuation">)</span><span class="token punctuation">;</span>
        countA<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>countA<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">V</span><span class="token punctuation">(</span>mutexA<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        walk across the bridge from east to west<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutexA<span class="token punctuation">)</span><span class="token punctuation">;</span>
        countA<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>countA<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutexA<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">west_east</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutexB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        countB<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>countB<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">V</span><span class="token punctuation">(</span>mutexB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        walk across the bridge from west to east<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutexB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        countB<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>countB<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutexB<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="理发师问题"><a href="#理发师问题" class="header-anchor">#</a> 理发师问题</h3> <p>理发店有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客，则理发师睡觉。当一个顾客到来时，他必须叫醒理发师，如果理发师正在理发时又有顾客到来，则如果有空椅子可坐，他就坐下来等。如果没有空椅子，他就离开。</p> <p><img src="/images/c267c6150e925ad9e1eca3ccdea35ea9b75e5c4b52e1bcf47e0233d8492ea805.png" alt="理发师和顾客工作流程"></p> <p>就是注意各种状态的信号量，按照流程图话就完事了。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> n_customer<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">//店里的顾客,含正在理发的人数</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//waiting的互斥信号量</span>
semaphore bchair <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">//理发椅的个数</span>
semaphore wchair <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>   <span class="token comment">//空椅子的个数</span>
semaphore ready <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//是否有顾客准备好</span>
semaphore finish <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//理发师是否完成理发</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cobegin <span class="token function">baber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">customer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> coend <span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">baber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">//理发师进程</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//有顾客准备好了</span>
        <span class="token comment">// 理发</span>
        <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//允许其他顾客理发</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">customer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//互斥waiting变量的操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n_customer <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token comment">//店里顾客数没达上限</span>
    <span class="token punctuation">{</span>
        n_customer<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">//店里顾客数增1</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//允许waiting变量的操作</span>
        <span class="token function">P</span><span class="token punctuation">(</span>wchair<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//找一个空椅子坐下</span>
        <span class="token function">P</span><span class="token punctuation">(</span>bchair<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//再找理发椅坐下</span>
        <span class="token function">V</span><span class="token punctuation">(</span>wchair<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//释放一个空椅子</span>
        <span class="token function">V</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//该顾客准备好了</span>
        <span class="token function">P</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//等待理发师完成理发</span>
        <span class="token function">V</span><span class="token punctuation">(</span>bchair<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//离开理发椅</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//互斥waiting变量的操作</span>
        n_customer<span class="token operator">--</span><span class="token punctuation">;</span>   <span class="token comment">//等待顾客数减1</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//允许waiting变量的操作  </span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 离开</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <p>理发师睡觉问题的类似问题：</p> <p>某银行提供一个服务窗口和10个供顾客等待的座位。顾客到达银行时，若有空座位，则到取号机上领取一个号，等待叫号。取号机每次仅允许一位顾客使用。当营业员空闲时，通过叫号选取一位顾客，并为其服务。顾客和营业员的活动过程描述如下：</p> <div class="language-c extra-class"><pre class="language-c"><code>cobegin<span class="token punctuation">{</span>    
    process 顾客i<span class="token punctuation">{</span>从取号机上获取一个号码<span class="token punctuation">;</span> 等待叫号<span class="token punctuation">;</span> 获取服务<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    process 营业员<span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>叫号<span class="token punctuation">;</span> 为顾客服务<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>请添加必要的信号量和 PV 操作，实现上述过程中的互斥与同步。要求写出完成的过程，说明信号量的含义并赋初值。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//互斥使用取号机的信号量</span>
semaphore empty <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment">//空座位的数量信号量</span>
semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//已占座位的数量信号量</span>
semaphore service <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//等待叫号信号量</span>

process 顾客i
<span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//从取号机获得一个号；</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//等待叫号</span>
<span class="token punctuation">}</span>

process 营业员
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//叫号</span>
        <span class="token comment">//为顾客服务;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>都比较简单，较之前的生产者/消费者和读者/写者问题简单了很多。</p> <h3 id="管程"><a href="#管程" class="header-anchor">#</a> 管程</h3> <p><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a>、<a href="#%E7%AE%A1%E7%A8%8B">管程</a> 都是提供互斥的方案。</p> <h4 id="管程的引入"><a href="#管程的引入" class="header-anchor">#</a> 管程的引入</h4> <p>信号量可以高效的实现进程间互斥与同步，但是信号量的 PV 操作可能分散在整个程序中，使用难度高。</p> <p>管程 <code>monitor</code> 是一个程序设计语言结构，采用了集中式的进程同步方法，提供了与信号量同样的功能，但更易于控制。</p> <p>很多程序设计语言都支持管程，如 Pascal、Java 等。</p> <h4 id="管程的概念"><a href="#管程的概念" class="header-anchor">#</a> 管程的概念</h4> <p>一个管程定义了一个共享数据结构和能为并发进程所执行（在该数据结构上）的一组操作/过程，这组操作能同步进程、改变管程中的数据。</p> <p>共享数据结构是对系统中共享资源的抽象。对该共享数据结构的操作则定义为一组过程，通过调用这些过程实现对共享资源的申请、释放和其它操作</p> <p><strong>管程 = 局部数据 + 过程 + 初始化序列</strong></p> <h4 id="管程的特点"><a href="#管程的特点" class="header-anchor">#</a> 管程的特点</h4> <ol><li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问</li> <li>一个进程通过调用管程的一个过程进入管程</li> <li>在任何时候，<strong>只能有一个进程在管程中执行</strong>（互斥），调用管程的任何其它进程都被阻塞，以等待管程可用。</li> <li>若由于某种原因，一个正在管程中执行的进程必须阻塞，该如何处理？——释放管程，供其它进程使用</li></ol> <p>如果管程内的数据结构代表了共享资源,则通过管程提供了对资源的<strong>互斥</strong>访问机制。</p> <h4 id="用管程实现进程同步"><a href="#用管程实现进程同步" class="header-anchor">#</a> 用管程实现进程同步</h4> <p>管程通过使用<strong>条件变量</strong>提供对进程同步的支持。条件变量包含在管程中，只能在管程中访问。</p> <p>操作条件变量的两个函数：</p> <ol><li><code>cwait(c)</code>：调用进程的执行在条件 <code>c</code> 上阻塞，管程可供其它进程使用。</li> <li><code>csignal(c)</code>：恢复在条件 <code>c</code> 上阻塞的一个进程，若不存在阻塞进程，则什么都不做。</li></ol> <p>这里的 <code>cwait</code> 和 <code>csignal</code> 作用于条件变量,与作用于信号量的 <code>wait</code> 和 <code>signal</code> 不同。</p> <p>所以条件变量是什么呢？继续往后看。</p> <h4 id="管程的结构"><a href="#管程的结构" class="header-anchor">#</a> 管程的结构</h4> <p><img src="/images/7b106b9b49cc7da5036214fea142460175c9d9665fa13e373229669fa88d6ea6.png" alt="管程的结构"></p> <h4 id="生产者-消费者问题的管程解决方法"><a href="#生产者-消费者问题的管程解决方法" class="header-anchor">#</a> 生产者/消费者问题的管程解决方法</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/* program producerconsumer */</span>
monitor boundedbuffer<span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer <span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token comment">/* space for N items */</span>
<span class="token keyword">int</span> nextin<span class="token punctuation">,</span> nextout<span class="token punctuation">;</span>                    <span class="token comment">/* buffer pointers */</span>
<span class="token keyword">int</span> count<span class="token punctuation">;</span>                              <span class="token comment">/* number of items in buffer */</span>
cond notfull<span class="token punctuation">,</span> notempty<span class="token punctuation">;</span>                 <span class="token comment">/* condition variables for synchronization */</span>

<span class="token keyword">void</span> <span class="token function">append</span> <span class="token punctuation">(</span><span class="token keyword">char</span> X<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token punctuation">)</span> <span class="token function">cwait</span><span class="token punctuation">(</span>notfull<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* buffer is full; avoid overflow */</span>
    buffer<span class="token punctuation">[</span>nextin<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
    nextin <span class="token operator">=</span> <span class="token punctuation">(</span>nextin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>                            <span class="token comment">/* one more item in buffer */</span>
    <span class="token function">csignal</span><span class="token punctuation">(</span>notempty<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">/* resume any waiting consumer */</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">take</span> <span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">cwait</span><span class="token punctuation">(</span>notempty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* buffer is empty; avoid underflow */</span>
    x <span class="token operator">=</span> buffer<span class="token punctuation">[</span>nextout<span class="token punctuation">]</span><span class="token punctuation">;</span>
    nextout <span class="token operator">=</span> <span class="token punctuation">(</span>nextout <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>
    count<span class="token operator">--</span><span class="token punctuation">;</span>                            <span class="token comment">/* one fewer item in buffer */</span>
    <span class="token function">csignal</span><span class="token punctuation">(</span>notfull<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">/* resume any waiting producer */</span>
<span class="token punctuation">}</span>

<span class="token comment">/* monitor body */</span>
<span class="token punctuation">{</span>
    nextin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> nextout <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* buffer initially empty */</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> x<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        <span class="token function">produce</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> consumer
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> x<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">take</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">consume</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>     
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> main
<span class="token punctuation">{</span>
    <span class="token function">parbegin</span> <span class="token punctuation">(</span>producer<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看完以后还没有弄懂 hhhh 所以就照搬教材上的话了：</p> <blockquote><p>生产者可以通过管程中的过程 <code>append</code> 向缓冲区中增加字符，它不能直接访问 <code>buffer</code>。该过程首先检查条件 <code>notfull</code>，以确定缓冲区是否还有可用空间。如果没有，执行管程的进程在这个条件上被阻塞。其他的某个进程(生产者或消费者)现在可以进入管程。此后，当缓冲区不再满时，被阻塞进程可以从队列中移出，重新激活并恢复处理。向缓冲区中放置一个字符后，该进程发送 <code>notempty</code> 条件信号。对消费者函数也可以进行类似的描述。
这个例子表明，与信号量相比较，管程担负的责任不同。对于管程，它构造了自己的互斥机制：生产者和消费者不可能同时访问缓冲区；但是，程序员必须把适当的<code>cwait</code>和<code>csignal</code>原语放在管程中，以防止进程向一个满缓冲区中存放数据项，或从一个空缓冲区中取数据项。而在使用信号量的情况下，执行互斥和同步都是程序员负责。
注意在图5.16中，进程执行<code>csignal</code>函数后立即退出管程，若在过程最后未发生<code>csignal</code>，建议发送该信号的进程被阻塞，从而使管程可用，并放入队列中直到管程空闲。此时，一种可能是把阻塞进程放到入口队列中，这样它就必须与其他还未进入管程的进程竞争。但是，由于在 <code>csignal</code> 函数上阻塞的进程已在管程中执行了部分任务，因此使它们优先于新进入的进程是很有意义的，这可通过建立一条独立的紧急队列来实现，如图5.15 所示。并发 Pascal 是使用管程的一种语言，它要求 <code>csignal</code> 只能作为管程过程中执行的最后一个操作出现。
若没有进程在条件 <code>x</code> 上等待，<code>csignal(x)</code>的执行将不会产生任何效果。</p></blockquote> <blockquote><p>而对于信号量，在管程的同步函数中可能会产生错误。例如，若省略 <code>boundedbuffer</code> 管程中的任何一个 <code>csignal</code> 函数，则进入相应条件队列的进程将被永久阻塞。<strong>管程优于信号量之处在于，所有的同步机制都被限制在管程内部</strong>，因此不但易于验证同步的正确性，而且易于检测出错误。此外，若一个管程被正确地编写，则所有进程对受保护资源的访问都是正确的；而对于信号量，只有当所有访问资源的进程都被正确地编写时，资源访问才是正确的。</p></blockquote> <h3 id="消息传递"><a href="#消息传递" class="header-anchor">#</a> 消息传递</h3> <p>进程交互时，需要满足两个基本要求：</p> <ol><li>同步：为实现互斥，进程间需要同步</li> <li>通信：为实现合作，进程间需要交换信息</li></ol> <p>消息传递提供了上述两方面的功能，并可工作在分布式系统、共享内存的多处理器和单处理器系统中。</p> <h4 id="消息传递的通信原语"><a href="#消息传递的通信原语" class="header-anchor">#</a> 消息传递的通信原语</h4> <p>消息传递有两条通信原语：</p> <ul><li><code>Send(destination,message)</code>：进程以消息的形式给指定的进程（目标）发送信息</li> <li><code>Receive(source,message)</code>：进程通过接收原语receive接收消息，接收原语中指明源进程和消息</li></ul> <h4 id="消息格式"><a href="#消息格式" class="header-anchor">#</a> 消息格式</h4> <p><img src="/images/196a1319f2647655485bac76db3dc3a5d80aba192a697f947977c39f12f87bad.png" alt="消息格式"></p> <p>有点像计算机网络中的报文。</p> <h4 id="消息传递问题中的同步"><a href="#消息传递问题中的同步" class="header-anchor">#</a> 消息传递问题中的同步</h4> <p>只有发送进程发送消息，接收进程才能收到消息。</p> <p>发生进程调用发送原语时，有两种可能：发送进程发送消息后，要么阻塞直到这个消息被目标进程收到；要么不阻塞。</p> <p>当一个进程调用接收原语时，也两种可能：若已经有消息到达，则接收者接收消息并继续执行；若没有消息到达，接收者要么阻塞等待，要么放弃接收，继续执行。</p> <p>基于发送者/接收者的两种策略的组合，就产生了消息传递的三种同步方式，如下。</p> <h4 id="消息传递的三种同步方式"><a href="#消息传递的三种同步方式" class="header-anchor">#</a> 消息传递的三种同步方式</h4> <p>阻塞发送，阻塞接收：</p> <ul><li>发送者和接受者都阻塞，直到完成消息投递</li> <li>有时被称为会合 <code>rendezvous</code></li> <li>考虑了进程间的紧密同步</li></ul> <p>不阻塞发送，阻塞接收：</p> <ul><li>发送者不阻塞，但是接收者阻塞直到请求的消息到达</li> <li>最有效的一种组合</li> <li>允许发送者可以尽快的向目的发送一条或多条消息</li> <li>例如，如一个服务进程给其他进程提供服务或资源</li></ul> <p>不阻塞发送，不阻塞接收：</p> <ul><li>不要求任何一方等待</li></ul> <h4 id="通信原语确定来源、目标的方式"><a href="#通信原语确定来源、目标的方式" class="header-anchor">#</a> 通信原语确定来源、目标的方式</h4> <h5 id="直接寻址"><a href="#直接寻址" class="header-anchor">#</a> 直接寻址</h5> <ul><li><code>Send</code> 原语包含目标进程的标识号</li> <li><code>Receive</code> 原语有两种处理方式：显式的指明源进程，对于处理并发进程的合作有效；或不可能指定源进程，如打印机服务进程，采用隐式寻址，接收到消息时将源地址保存下来。</li></ul> <h5 id="间接寻址"><a href="#间接寻址" class="header-anchor">#</a> 间接寻址</h5> <ol><li>消息被发送到一个共享的数据结构，该结构由暂存消息的队列（被称为信箱）构成</li> <li>发送进程往信箱发送消息，接收进程从信箱取走消息</li></ol> <p>这种方法提供了对消息使用的灵活性。</p> <p><img src="/images/d097b869948ec65f5c225e53973b8a5193f42db00e615d26e29793fdca6e5920.png" alt="间接寻址发送者和接收者之间的关系"></p> <h4 id="使用消息传递实现互斥"><a href="#使用消息传递实现互斥" class="header-anchor">#</a> 使用消息传递实现互斥</h4> <ul><li>多个并发执行的发送进程和接收进程共享一个邮箱 <code>box</code>，且 <code>box</code> 的初始状态为仅包含一条“空消息”（进入临界区的令牌）；</li> <li>采用“不阻塞发送，阻塞接收”方式传递消息；</li> <li>若邮箱中存在一条消息，则允许一个进程进入临界区。</li> <li>若邮箱为空，则表明有一个进程位于临界区，其它试图进入临界区的进程必须阻塞。</li> <li>只要保证邮箱中最多只有一条消息，就能保证只允许一个进程进入临界区，从而实现进程互斥使用临界资源。</li></ul> <p>有点像信号量的 <code>PV</code> 操作。 或者说，消息传递可以实现信号量。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/* program mutualexclusion */</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token comment">/*  进程数  */</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">create_mailbox</span><span class="token punctuation">(</span>box<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 创建邮箱 */</span>
    <span class="token function">send</span><span class="token punctuation">(</span>box<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 初始化，向邮箱发送一条空消息 */</span>
    <span class="token function">parbegin</span><span class="token punctuation">(</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> …<span class="token punctuation">,</span> <span class="token function">P</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    message msg<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">receive</span><span class="token punctuation">(</span>box<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* 从邮箱接收一条消息 */</span>
        <span class="token operator">&lt;</span>临界区<span class="token operator">&gt;</span><span class="token punctuation">;</span>
        <span class="token function">send</span><span class="token punctuation">(</span>box<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">/*　将消息发回到邮箱　*/</span>
        <span class="token operator">&lt;</span>其余部分<span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="使用消息传递实现生产者-消费者问题"><a href="#使用消息传递实现生产者-消费者问题" class="header-anchor">#</a> 使用消息传递实现生产者/消费者问题</h4> <p>既然消息传递可以实现信号量，那么就可以按照<a href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">信号量的方式</a>实现生产者/消费者问题。</p> <p>使用两个邮箱 <code>mayconsume</code> 和 <code>mayproduce</code>，大小均为 <code>capacity</code>。</p> <table><thead><tr><th>Mayproduce</th> <th>Mayconsume</th></tr></thead> <tbody><tr><td>该邮箱起初填满空消息（即允许生产的令牌）</td> <td>生产者产生的数据作为消息发送到该信箱（即允许消费的令牌）</td></tr> <tr><td>只要该邮箱有消息，生产者就可生产</td> <td>只要该邮箱有数据消息，消费者就可消费</td></tr> <tr><td>每次生产前取一条空消息，之后生产数据，并将数据作为消息发至mayconsume邮箱</td> <td>每次消费前，取一条消息，消费后，向mayproduce发送一条空消息</td></tr> <tr><td>消费者的每次消费使得该邮箱中的空消息数增加</td> <td>生产者的每次生产使得该邮箱的消息数增加</td></tr> <tr><td>类似于空间资源信号量</td> <td>类似于产品资源信号量</td></tr></tbody></table> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> capacity　<span class="token operator">=</span>  <span class="token comment">/* 缓冲区容量  */</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">create_mailbox</span><span class="token punctuation">(</span>mayproduce<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">create_mailbox</span><span class="token punctuation">(</span>mayconsume<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> capacity<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">send</span><span class="token punctuation">(</span>mayproduce<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化信箱     </span>
    <span class="token function">parbegin</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    message pmsg<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">receive</span><span class="token punctuation">(</span>mayproduce<span class="token punctuation">,</span> pmsg<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        pmsg  <span class="token operator">=</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">send</span><span class="token punctuation">(</span>mayconsume<span class="token punctuation">,</span> pmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> consumer <span class="token punctuation">{</span>
    message cmsg<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">receive</span><span class="token punctuation">(</span>mayconsume<span class="token punctuation">,</span> cmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">consume</span><span class="token punctuation">(</span>cmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">send</span><span class="token punctuation">(</span>mayproduce<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>     
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>和<a href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">前面的代码</a>一对比才发现，这里并没有实现互斥信号量 <code>n</code>。emmm 可能是在 <code>produce()</code> 函数里手动或自动实现了互斥吧，或者这里并不要求生产者彼此互斥。</p> <h2 id="二-4-进程管理-进程死锁"><a href="#二-4-进程管理-进程死锁" class="header-anchor">#</a> 二(4) 进程管理：进程死锁</h2> <p><img src="/images/c56f0d9734b420eaed57636afda09d53405d7876193c0a7e8df8b472d5730093.png" alt="生活中的死锁现象"></p> <h3 id="死锁的原理"><a href="#死锁的原理" class="header-anchor">#</a> 死锁的原理</h3> <p>下面两个进程并行可能导致死锁：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">_P</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token keyword">void</span> <span class="token function">_Q</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>               <span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">P</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">P</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//...           //...  </span>
    <span class="token function">V</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">V</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">V</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>               <span class="token punctuation">}</span>
</code></pre></div><p>下图为描述该过程的示意图：</p> <p><img src="/images/e4e3509290b1ec956dbddc011ef26de3bbb15e76a341b0bf27d5506fe33e3fd3.png" alt="死锁示意图"></p> <h4 id="死锁的定义"><a href="#死锁的定义" class="header-anchor">#</a> 死锁的定义</h4> <p>死锁定义：一组相互竞争系统<strong>资源</strong>或进行通信的进程间的永久阻塞。</p> <ul><li>当一组进程中的每个进程都在等待某事件，而只有同组进程中阻塞的其他进程能够促发该事件时，死锁发生</li> <li>死锁是永久性的，且无有效的解决方案</li></ul> <h4 id="资源的分类"><a href="#资源的分类" class="header-anchor">#</a> 资源的分类</h4> <ul><li>一次仅供一个进程安全使用且不因使用而耗尽的资源，如处理器、I/O通道、内存和外存、设备，以及诸如文件、数据库和信号量之类的数据结构之类的</li> <li>可消耗资源是指可被创建（生产）和销毁（消耗）的资源，如中断、信号、消息和I/O缓冲中信息</li></ul> <h4 id="死锁的示例"><a href="#死锁的示例" class="header-anchor">#</a> 死锁的示例</h4> <p><img src="/images/072465fe89681a34bd2f1f388c3d7c005e0ef5ed68b1815b668986c0bdd0d7e4.png" alt="两个进程竞争可重用资源示例"></p> <p><img src="/images/5563d230707dd14bfec6541b2fdac657542c5d4538337828447cc4815cb4d813.png" alt="竞争可重用资源可能引起死锁"></p> <p>例中，P1和P2请求主存，假设可分配的空间为200KB。P1和P2执行到第二条语句时死锁发生。</p> <hr> <p><img src="/images/e34fcb191df45cfa1ede8eedf765dd28635d8d8e30abe22f7bb335014f7f79d6.png" alt="竞争可消耗资源可能引起死锁"></p> <p>例中，当Receive阻塞时死锁发生。</p> <hr> <p><img src="/images/89fcffc51577c4e9ce0af95b7da67eb24e6392a8d3f67129b8ec4c19f7caafbd.png" alt="资源分配图"></p> <p>用资源分配图表示死锁。其中圆形为进程，方形为资源，方形中的黑点数为资源数。</p> <hr> <p><img src="/images/56b8482df35143a430a039395b8d0a4cf63968b7b55a9e8a91d926fd15f4796f.png" alt="循环等待"></p> <p>存在进程和资源的环（<strong>循环等待</strong>），导致死锁。</p> <h4 id="死锁的条件"><a href="#死锁的条件" class="header-anchor">#</a> 死锁的条件</h4> <p>死锁的必要条件：</p> <ul><li>互斥：一次只有一个进程可以使用一个资源</li> <li>占用且等待：当进程等待其他资源时，继续占有已经分配的资源</li> <li>不可抢占：不能强行抢占进程已经占有的资源</li></ul> <p>死锁的充分条件（其他教材上说这是第四个必要条件）：</p> <ul><li>循环等待：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源</li></ul> <h4 id="死锁的解决方法"><a href="#死锁的解决方法" class="header-anchor">#</a> 死锁的解决方法</h4> <p>针对这些条件，解决办法有：</p> <ul><li><a href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2">死锁预防</a>：禁止四个条件的任意一个条件发生</li> <li><a href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D">死锁避免</a>：允许前三个条件，进行动态检查</li> <li><a href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4">死锁检测与解除</a>：不限制资源访问或约束进程行为，而是检测死锁的存在并尝试解除</li></ul> <h3 id="死锁的预防"><a href="#死锁的预防" class="header-anchor">#</a> 死锁的预防</h3> <p>我们分析死锁的四个条件，并尝试禁止任意一个发生：</p> <ol><li>互斥：不能禁止（OS：亲，必须互斥的）</li> <li>占有且等待：要求进程一次性请求所有资源，并阻塞这个进程直到所有资源请求能够满足</li></ol> <ul><li>低效：进程可能会阻塞很长时间（实际上，只要有一部分资源，它就能够执行）；分配给进程的另一部分资源可能很长时间内不会被使用</li> <li>可能事先不知进程所需的全部资源</li></ul> <ol start="3"><li>不可抢占：占有资源的进程申请其他资源时若被拒绝，则释放最初的资源；或操作系统要求另一个进程释放资源</li></ol> <ul><li>只有在资源状态容易保存和恢复情况下，这种方法才实用</li></ul> <ol start="4"><li>循环等待：定义一个请求资源的顺序</li></ol> <ul><li>系统把所有资源按类型进行线性排队，如 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>R</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>&lt;</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_i, R_j, R_k (i&lt;j&lt;k)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></li> <li>所有进程对资源的请求必须严格按资源序号递增的顺序提出（即，如果同时需要 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">R_1, R_3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，必须先申请 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>）</li> <li>低效，原因类似于“占有且等待”（进程可能有了 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">R_3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 能继续执行，但它必须先申请 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 才能申请 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">R_3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>）</li></ul> <h3 id="死锁的避免"><a href="#死锁的避免" class="header-anchor">#</a> 死锁的避免</h3> <p>死锁避免允许三个必要条件，并进行动态检查：</p> <ul><li>检查进程的资源申请</li> <li>若分配后系统可能发生死锁，则不予分配（阻塞）</li> <li>需要预知资源的请求</li></ul> <p>有两种拒绝方法：</p> <ul><li>资源分配拒绝：不允许该资源分配</li> <li>进程启动拒绝：不启动该进程</li></ul> <h4 id="资源分配拒绝-银行家算法"><a href="#资源分配拒绝-银行家算法" class="header-anchor">#</a> 资源分配拒绝——银行家算法</h4> <ul><li><p>银行家算法（类似于银行决定是否允许贷款的原理），由 Dijkstra 提出</p></li> <li><p>思想：当用户申请一组资源时，系统必须做出判断：如果把这些资源分出去，系统是否还处于<strong>安全状态</strong>。若是，就可以分配这些资源；否则，暂时不分配，阻塞进程。</p></li> <li><p>系统状态：当前给进程分配资源的情况</p></li> <li><p>安全状态指至少有一个资源分配序列（Px, Py, …, Pz，安全序列）不会导致死锁，所有进程Px, Py, …, Pz 能够运行结束</p></li></ul> <h5 id="例"><a href="#例" class="header-anchor">#</a> 例</h5> <p>矩阵的定义：</p> <ul><li>Claim matrix <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span>：每个进程提前声明需要的资源量。进程执行中申请的资源量不得超过 C。</li> <li>Allocation matrix <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>：已分配给每个进程的资源量。</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>−</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">C-A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>：每个进程还可以申请的资源量。</li> <li>Resource vector <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></span>：OS 总的资源量。</li> <li>Available vector <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></span>：OS 目前的剩余资源量。也等于 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></span> 减去 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span> 的每一行。</li></ul> <p><img src="/images/52cd56dd323ab2a9fab80b687f152a1bba20922db7d99a7af34add32f0fc7510.png" alt="图1"></p> <p>先执行 P2。</p> <p><img src="/images/06dd0c339e0ecace519e2732d90b5e3137b9dfc683982a05c60ca6399316e240.png" alt="图2"></p> <p>这一步以后 P1、P3、P4 均可被执行。这里选择执行 P1。</p> <p><img src="/images/36da5d3e46560421453a8eb8e01e54ad0abf292c80aff021d2fcb99267926de9.png" alt="图3"></p> <p>这一步选择执行 P3。当然 P4 也是可以的。</p> <p><img src="/images/b25b8602ef23eab5a40bb3159081d2ef03032344d5468bc49a5df2753517147f.png" alt="周4"></p> <p>最后执行 P4。</p> <p>由上可得，该例的一个安全序列为：P2、P1、P3、P4。</p> <p>需要注意的是，这个过程是系统预先模拟出来的，而不是真实分配以后得到的。只有模拟出了安全状态，OS 才会真正进行分配。</p> <h5 id="例二"><a href="#例二" class="header-anchor">#</a> 例二</h5> <p><img src="/images/cd765b13269e58fdba4d97382370c5ba016dd75aa95f09cdbb84f87ccbd13d14.png" alt="不安全状态示例"></p> <p>如图，在 (a) 的状态下，P1 请求 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 0, 1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。如果系统分配了，系统将进入不安全状态。</p> <h5 id="思考"><a href="#思考" class="header-anchor">#</a> 思考</h5> <ol><li>安全序列是否唯一？否</li> <li>安全状态是否一定没有死锁发生？</li></ol> <blockquote><p>若系统处于安全状态，且按照某个安全序列分配资源，则一定不会出现死锁。<br>
并非所有不安全状态都是死锁状态（比如前例中 P1 释放 1 个 R1 和 R3，后来再次需要这些资源，系统变成安全状态）<s>但是这句话的逻辑似乎有点奇怪</s><br>
当系统进入不安全状态以后，便可能进入死锁状态</p></blockquote> <ol start="3"><li>避免死锁的实质在于：如何避免系统进入不安全状态</li></ol> <h4 id="资源分配算法总结"><a href="#资源分配算法总结" class="header-anchor">#</a> 资源分配算法总结</h4> <p>算法的步骤如下：</p> <ol><li>判断需求的合理性（若 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">allocated</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span></span> + <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">request</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span></span> &gt; <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">claim</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span></span> 则不合理）</li> <li>尝试分配，定义新状态</li> <li>判断新状态的安全性（银行家算法）</li> <li>若安全则分配；若不安全则阻塞进程并还原状态</li></ol> <p><img src="/images/fc414b09568e23414554ceb0ee9b545c2808176e191418fd04928cf773c15663.png" alt="资源分配算法 伪代码"></p> <p><img src="/images/c06aef002ddf569cd54afb91064568d5b4bb8a38f2974752d9af6ec12897a599.png" alt="银行家算法 伪代码"></p> <h4 id="死锁避免总结"><a href="#死锁避免总结" class="header-anchor">#</a> 死锁避免总结</h4> <p>死锁避免的优点：</p> <ul><li>无须进行（死锁预防中的）抢占和回滚进程</li> <li>比起死锁预防，限制少</li></ul> <p>死锁避免的使用限制：</p> <ul><li>必须事先声明每个进程请求的最大资源</li> <li>进程必须是独立的，它们执行顺序没有同步的要求</li> <li>分配资源的数量必须是固定的</li> <li>占有资源时，进程不能退出（进程退出会导致计算结果失效）</li></ul> <h3 id="死锁检测与解除"><a href="#死锁检测与解除" class="header-anchor">#</a> 死锁检测与解除</h3> <p>死锁预防策略很保守：强加约束限制访问资源。而死锁检测则相反：只要有可能，就给进程分配其所请求的资源。</p> <h4 id="死锁检测"><a href="#死锁检测" class="header-anchor">#</a> 死锁检测</h4> <p>对死锁的检测可以频繁的发生在每次资源请求时；也可以少检测，如定时检测，或系统资源利用率下降时检测，具体取决于死锁发生的可能性。</p> <p>优点：可尽早检测死锁；算法相对简单。<br>
缺点：频繁检测会消耗处理器时间。</p> <h4 id="死锁检测算法"><a href="#死锁检测算法" class="header-anchor">#</a> 死锁检测算法</h4> <p>死锁检测算法在银行家算法的变量基础上增加了：</p> <ul><li>Request matrix <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span></span>：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Q_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>表示进程 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 请求 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span> 类资源的数量</li></ul> <p>算法步骤：为未死锁的应用打标记。（约定资源种数用 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span> 表示）</p> <ol><li>标记在 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Allocation</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></span> 矩阵中一行全为零的进程；</li> <li>初始化一个临时向量 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span></span>，令 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span></span> 等于 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Available</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span></span> 向量；</li> <li>查找是否存在进程 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>：当前未被标记，且满足 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span></span> 的第 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 行小于等于 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span></span>（即对所有的 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \leq k \leq m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>≤</mo><msub><mi>W</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">Q_{ik} \leq W_k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>。若找不到这样的行，终止算法；</li> <li>若找到这样的行，标记进程 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>，并把 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mi>l</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Allcation</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></span> 矩阵中的相应行加到 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span></span> 中，即对所有 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \leq k \leq m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>, 令 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>k</mi></msub><mo>=</mo><msub><mi>W</mi><mi>k</mi></msub><mo>+</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_k = W_k+A_{ik}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>。然后返回 3。</li></ol> <p>当且仅当最终有未标记进程时，才存在死锁，未标记的进程都是死锁的。</p> <hr> <p>看起来很像是银行家算法！</p> <ul><li>银行家算法在 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>−</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">C-A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span> 矩阵中寻找是否小于当前资源量 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><msub><mi>t</mi><mi>a</mi></msub><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">currrent_available</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span></span> 的行向量，如果有则将进程加入安全序列，并使 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><msub><mi>t</mi><mi>a</mi></msub><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">currrent_available</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span></span> 增加该进程的 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Allocation</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></span> 量。</li> <li>死锁检测在 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span></span> 矩阵中寻找是否小于当前资源量 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span></span> 的行向量，如果有则标记进程，并使 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span></span> 增加该进程的 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Allocation</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span></span> 量。</li></ul> <p>区别在于，银行家算法是按进程可能申请的最多资源进行计算，所以能避免死锁发生，对应的资源分配策略会很严格；<br>
死锁检测算法是对进程正在申请的资源进行计算，所以检测的是死锁，对应的资源分配策略会比较松。</p> <h4 id="例题"><a href="#例题" class="header-anchor">#</a> 例题</h4> <p><img src="/images/ff55bf1c8dcbc38c6dc7db84b3b161fa29b4b6f208c4bfee49b94948b79e592f.png" alt="例题"></p> <ol><li>先标记还未分配的 P4；</li> <li>令 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W = A = (0,0,0,0,1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>；</li> <li>注意到 Q 的第三列小于 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span></span>，标记 P3，并更新 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W=(0,0,0,1,1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>；</li> <li>P1、P2 无法被标记，死锁。</li></ol> <h4 id="通过化简资源分配图进行死锁检测"><a href="#通过化简资源分配图进行死锁检测" class="header-anchor">#</a> 通过化简资源分配图进行死锁检测</h4> <ol><li>在资源分配图中，找出其全部请求都能满足的进程节点 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，消去 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 所有的请求边和分配边，使之成为孤立的结点。</li> <li>重复步骤 1，直至无法化简为止。</li></ol> <p><img src="/images/7ef939fa0522a7d0e08b93f52112b4910d960cd2379cd5f757c0401883b01fce.png" alt="资源分配图的化简示例"></p> <p>可完全简化图：能消去图中所有的边，使所有的进程结点都成为孤立结点的资源分配图（如上图、右下图）。</p> <p>当资源分配图是不可完全化简时，存在死锁（如左下图）。</p> <p><img src="/images/dcb761577bf4ac040ceab57882dadb3ad40e77208bc81b674eb8cf4990dbb2f1.png" alt="左图出现死锁 右图未死锁"></p> <h4 id="死锁的解除"><a href="#死锁的解除" class="header-anchor">#</a> 死锁的解除</h4> <p>检测到死锁后，需要按照某种可能的策略来解除。给出以下三个方法，以及三个方法下的不同策略。</p> <ol><li>撤消进程：撤消所有死锁进程，或连续撤消死锁进程直到不再存在死锁</li> <li>回退：把进程回退到前面定义的某些检查点，并重新启动所有进程</li> <li>抢占：连续抢占资源直到不再存在死锁</li></ol> <p>取消哪些进程、抢占哪些进程的资源呢？——选择原则：目前为止消耗处理器时间少，或输出少，或分配资源少，或剩余时间长，或优先级最低的进程</p> <h3 id="死锁解决办法总结"><a href="#死锁解决办法总结" class="header-anchor">#</a> 死锁解决办法总结</h3> <p><img src="/images/26ab50c0555833e66c2f3c24f308bbd70b3adc77cfe90934ccea3b2a0a8f42b8.png" alt="死锁解决办法总结（英文）"></p> <p><img src="/images/faeb31dcfe95b8761714585514ea66d5ceafb8b2d5c109aae3c457d4254ed6a0.png" alt="死锁解决办法总结（中文）"></p> <h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="header-anchor">#</a> 哲学家就餐问题</h3> <p>1965年，Dijkstra出了一道同步考试题：假设有五台计算机都试图访问五份共享的磁带驱动器。后来，这个问题被Hoare重新表述为哲学家就餐问题。这个问题可以用来解释死锁和资源耗尽。</p> <p><s>Dijkstra 怎么这么强（捶桌）.jpg</s></p> <ul><li>5 个哲学家围坐一张餐桌</li> <li>5 只餐叉间隔摆放</li> <li>思考或进餐</li> <li>进餐时必须同时拿到两边的餐叉</li> <li>思考时将餐叉放回原处</li> <li>两个哲学家不能同时使用同一把叉子</li> <li>避免死锁和饥饿</li></ul> <p><img src="/images/62ecf6a9c6907ae8346ae6295928f6b295b557a12688fa487166467dcbf64d21.png" alt="哲学家就餐问题图"></p> <h4 id="方案一-先左后右-可能死锁"><a href="#方案一-先左后右-可能死锁" class="header-anchor">#</a> 方案一 先左后右，可能死锁</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore fork<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cobegin <span class="token punctuation">{</span><span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>coend<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        think<span class="token punctuation">;</span>                  <span class="token comment">//思考</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//拿起左边的叉子</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//拿起右边的叉子</span>
        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//放回左边的叉子</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//放回右边的叉子</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>显然，可能导致死锁。</p> <h4 id="方案二-先左后右-失败后随机等待一段时间-可能活锁"><a href="#方案二-先左后右-失败后随机等待一段时间-可能活锁" class="header-anchor">#</a> 方案二 先左后右，失败后随机等待一段时间，可能活锁</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore fork<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cobegin <span class="token punctuation">{</span><span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>coend<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        think<span class="token punctuation">;</span>                              <span class="token comment">//思考</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">//拿起左边的叉子</span>
        <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//若右边的叉子被占用，则放下左边叉，等待一段随机时间后再拿</span>
        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//放回左边的叉子</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//放回右边的叉子</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="方案三-资源分级"><a href="#方案三-资源分级" class="header-anchor">#</a> 方案三 资源分级</h4> <p>就是死锁预防中打破循环等待的方法。</p> <p>为资源（这里是餐叉）分配一个偏序（partial order）或者分级（hierarchy）的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。</p> <h5 id="资源分级方案一-先低后高"><a href="#资源分级方案一-先低后高" class="header-anchor">#</a> 资源分级方案一 先低后高</h5> <ul><li>为餐叉编号</li> <li>就餐前，先取用编号较低的餐叉，再取用编号较高的餐叉</li> <li>就餐毕，先放下编号较高的餐叉，再放下编号较低的餐叉</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore fork<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cobegin <span class="token punctuation">{</span><span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>coend<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//思考</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">)</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//先左后右</span>
        <span class="token keyword">else</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//先右后左</span>
        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">)</span>
            <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先右后左</span>
        <span class="token keyword">else</span>
            <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先左后右</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="资源分级方案二-奇先左偶先右"><a href="#资源分级方案二-奇先左偶先右" class="header-anchor">#</a> 资源分级方案二 奇先左偶先右</h5> <ul><li>为哲学家编号</li> <li>奇数号的哲学家必须首先拿左边的餐叉</li> <li>偶数号的哲学家必须首先拿右边的餐叉</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore fork<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cobegin <span class="token punctuation">{</span><span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>coend<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//思考</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//先左后右</span>
        <span class="token keyword">else</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//先右后左</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="方案四-服务生方法"><a href="#方案四-服务生方法" class="header-anchor">#</a> 方案四 服务生方法</h5> <ul><li>教授需要经过服务生允许以后才能吃饭</li> <li>只允许有四个人同时进餐</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code>semaphore fork<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> room <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cobegin <span class="token punctuation">{</span><span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>coend<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        think<span class="token punctuation">;</span>                   <span class="token comment">//思考</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>room<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//占据就餐位置</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//拿起左边的叉子</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//拿起右边的叉子</span>
        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//放回左边的叉子</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>fork<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//放回右边的叉子</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>room<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//释放就餐位置</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="引申-and-型信号量集-不做要求"><a href="#引申-and-型信号量集-不做要求" class="header-anchor">#</a> 引申：And 型信号量集（不做要求）</h5> <p>哲学家就餐问题的引申：And型信号量集
在一个原语中申请需要的多个临界资源，要么全部分，要么一个都不分配。
AND型信号量集P原语为Swait(Simultaneous Wait)，V原语为Ssignal(Simultaneous Signal)。
Swait(S1, S2, …, Sn)
Ssignal(S1, S2, …, Sn)
思考：采用and型信号量解决哲学家就餐问题</p> <h5 id="管程解决方案"><a href="#管程解决方案" class="header-anchor">#</a> 管程解决方案</h5> <p><a href="#%E7%AE%A1%E7%A8%8B">管程</a></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>monitor dining_controller<span class="token punctuation">;</span>
cond ForkReady<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> fork<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">get_forks</span><span class="token punctuation">(</span><span class="token keyword">int</span> pid<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> pid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token punctuation">(</span>pid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 获取左边的叉子</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fork<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token function">cwait</span><span class="token punctuation">(</span>ForkReady<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fork<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">//获取右边的叉子</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fork<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token function">cwait</span><span class="token punctuation">(</span>ForkReady<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fork<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">release_forks</span><span class="token punctuation">(</span><span class="token keyword">int</span> pid<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> pid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token punctuation">(</span>pid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 释放左边的叉子</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span>ForkReady<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果没有人在等待这个叉子</span>
        fork<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">csignal</span><span class="token punctuation">(</span>ForkReady<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 让被阻塞在这里的进程继续</span>

    <span class="token comment">// 释放右边的叉子</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span>ForkReady<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//如果没有人在等待这个叉子</span>
        fork<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">csignal</span><span class="token punctuation">(</span>ForkReady<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 让被阻塞在这里的进程继续</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">get_forks</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">release_forks</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为什么采用管程方法不会发生死锁？因为在管程中被阻塞的进程会释放已有的资源，即不会出现抓着左叉子等右叉子的现象。</p> <h2 id="三-1-内存管理-基本内存管理"><a href="#三-1-内存管理-基本内存管理" class="header-anchor">#</a> 三(1) 内存管理：基本内存管理</h2> <p><img src="/images/47c5784f04c60be372034ab757aa15ddb08de78a8e317806607e8b0af0cb430b.png" alt="计算机存储体系"></p> <h3 id="程序的加载和链接"><a href="#程序的加载和链接" class="header-anchor">#</a> 程序的加载和链接</h3> <p>高级语言的源代码转化为进程的 3 个基本步骤：</p> <ul><li>编译：<code>用户源代码</code> -&gt; 经<code>编译程序 (Compiler)</code> -&gt; <code>若干目标模块</code></li> <li>链接：<code>一组目标模块 + 它们需要的库函数</code> -&gt; 经<code>链接程序 (Linker)</code> -&gt; <code>完整的加载模块</code></li> <li>加载（装入）：<code>加载模块</code> -&gt; 由<code>加载程序 (Loader)</code> -&gt; <code>装入内存</code></li></ul> <p>简单的认为：</p> <ul><li>编译负责：模块内变量名 -&gt; 逻辑地址</li> <li>链接负责：模块间变量名 -&gt; 逻辑地址</li> <li>加载负责：程序逻辑地址 -&gt; 物理地址（装入内存）</li></ul> <p><img src="/images/d8a34190335cbda8b6e6abc2bb0483d33353f161102b54d8700824bf01950f94.png" alt="链接和加载场景"></p> <p>为表达清晰起见，首先介绍只涉及一个程序模块时的加载任务，因为这时不需要链接。介绍完加载后再聊多个模块的链接任务。</p> <h4 id="加载的任务"><a href="#加载的任务" class="header-anchor">#</a> 加载的任务</h4> <ol><li>将可加载模块装入内存</li> <li>地址<strong>重定位</strong>：将执行文件中的逻辑地址转化为内存物理地址的过程</li></ol> <h4 id="加载方式分类-地址映射建立方式"><a href="#加载方式分类-地址映射建立方式" class="header-anchor">#</a> 加载方式分类（地址映射建立方式）</h4> <ul><li>绝对加载方式：编译使用绝对地址</li> <li>可重定位加载（静态重定位）方式：编译使用相对地址，加载时确定绝对地址</li> <li>运行时加载（动态重定位）方式：执行时确定绝对地址</li></ul> <h5 id="绝对加载方式"><a href="#绝对加载方式" class="header-anchor">#</a> 绝对加载方式</h5> <ul><li>程序中的逻辑地址与实际内存地址完全相同，无需修改</li> <li>在编译时就确定程序将驻留在内存中的具体位置</li> <li>编译程序产生绝对地址的目标代码</li> <li>为了便于程序的修改,对程序采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址</li></ul> <p><img src="/images/57d1503734dc7c77b6493ade5a5341c8d655548526d80899aee2ecbcd037ef73.png" alt="绝对加载方式示例"></p> <hr> <p>优点：</p> <ul><li>实现简单</li></ul> <p>缺点：</p> <ul><li>程序每次必须装入同一内存区</li> <li>程序员必须事先了解内存的使用情况，根据内存情况确定程序的逻辑地址</li> <li>不适于多道程序系统（多个程序的绝对内存地址可能冲突）</li></ul> <h5 id="可重定位加载方式-静态重定位"><a href="#可重定位加载方式-静态重定位" class="header-anchor">#</a> 可重定位加载方式（静态重定位）</h5> <ul><li>编译时采用相对地址，即编译器假设是加载到从零开始的内存位置</li> <li>加载程序根据加载的位置将逻辑地址转换为物理地址（重定位）</li> <li><strong>静态重定位技术</strong>：地址映射在程序加载时进行，以后不再更改程序地址</li></ul> <p><img src="/images/b1a802c352abefd7be4b239220e29c5cefab6a051cf38c9f38f75bd44beff66f.png" alt="静态重定位加载方式示例"></p> <hr> <p>优点：易实现，无需硬件支持</p> <p>缺点：程序重定位后不能移动，不能重新分配内存，不利于内存的有效利用</p> <h5 id="运行时加载-动态重定位-方式"><a href="#运行时加载-动态重定位-方式" class="header-anchor">#</a> 运行时加载（动态重定位）方式</h5> <ul><li>程序的地址转换不是在加载时进行，而是在程序<strong>运行到相应代码</strong>时动态进行</li> <li><strong>需要硬件支持</strong>：重定位寄存器，用于保存程序在内存中的起始地址</li> <li>通过重定位寄存器内的起始物理地址和指令/数据的逻辑地址计算其物理地址</li></ul> <p><img src="/images/cc989bbc6c735efb0e27131fd2456af1fb8afddf840f280239522c66fd952c46.png" alt="运行时加载示例"></p> <p>优点：</p> <ul><li>程序不必连续存放在内存中，可分散存储，可移动</li> <li>（如动态链接库 <code>dll</code>）便于共享</li> <li>有利于紧凑、碎片问题的解决</li> <li>主流方式</li></ul> <p>缺点：</p> <ul><li>需要硬件支持，对应的软件算法比较复杂</li> <li>同一地址，可能多次转换</li></ul> <h5 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h5> <ul><li>绝对加载
<ul><li>编译时执行地址绑定</li> <li>编译时就知道进程将在内存中的驻留地址，生成绝对代码。即在可执行文件中记录内存地址，加载时直接定位在该内存地址</li> <li>如果将来开始地址发生变化，就必须重新编译代码</li></ul></li> <li>静态重定位加载
<ul><li>加载时执行静态地址重定位</li> <li>系统根据内存当时的使用情况，决定将目标代码放在内存的什么位置</li> <li>不允许程序在内存中移动</li></ul></li> <li>动态执行时加载
<ul><li>执行过程中执行动态地址重定位</li> <li>支持执行时进程在内存中移动</li></ul></li></ul> <h4 id="链接的任务"><a href="#链接的任务" class="header-anchor">#</a> 链接的任务</h4> <ol><li><code>一组目标模块</code> -&gt; <code>一个包含完整程序和数据模块的加载模块</code>，传递给加载器</li> <li>地址<strong>重定位</strong>：在每个目标模块中，可能有到其他模块的地址访问。链接器创建一个单独的加载模块，它把所有目标模块逐个链接起来。</li></ol> <h4 id="链接方式-链接的时机"><a href="#链接方式-链接的时机" class="header-anchor">#</a> 链接方式（链接的时机）</h4> <ul><li>静态链接(Static linking)</li> <li>加载时动态连接(Load-time Dynamic Linking)</li> <li>运行时动态链接(Runtime Dynamic Linking)</li></ul> <h5 id="静态链接"><a href="#静态链接" class="header-anchor">#</a> 静态链接</h5> <p>程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块（执行模块），以后不再拆开。</p> <p>两个问题：</p> <ul><li>相对地址的修改：由编译程序产生的所有目标模块中，使用的都是相对地址，其起始地址都为0，在链接成一个加载模块时修改模块的相对地址</li> <li>变换外部引用地址：将每个模块中所用的外部调用符号也都变换为相对地址。</li></ul> <p><img src="/images/bb46b7e9ff37eb9e56f27a50db0f25e5c2636bc0ee9554b4b1cf611a694b2910.png" alt="静态链接方式示意图"></p> <p>缺点：</p> <ul><li>不利于代码共享：每个应用都含有目标模块的拷贝（A、D 都需要 C 模块时，C 会在内存中出现两次）</li> <li>不利于模块的独立升级：每次对某个目标模块的修改升级，都要打开整个加载模块</li> <li>可能链接一些不会执行的模块，浪费存储空间和处理机时间。如 A 的代码为 <code>if (cond) {call B;} else {call C;}</code>，B、C 都会被链接，但不会被都执行。</li></ul> <h5 id="加载时动态链接"><a href="#加载时动态链接" class="header-anchor">#</a> 加载时动态链接</h5> <p>待加载的模块在加载内存时，如果该模块中有到外部模块的引用，加载程序将查找这些模块并加载内存，并把这些引用修改为相对应用程序模块开始处的相对地址。</p> <p>优点：</p> <ul><li>便于各个模块的独立升级</li> <li>便于实现模块的共享</li></ul> <p>缺点</p> <ul><li>可能链接一些不会执行的模块，浪费存储空间和处理机时间（同<a href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5">静态链接</a>）</li> <li>模块加载后不能移动位置</li></ul> <h5 id="运行时动态链接"><a href="#运行时动态链接" class="header-anchor">#</a> 运行时动态链接</h5> <ul><li>在<strong>程序执行中需要某目标模块时</strong>，由操作系统去找到该模块并将之加载内存，随后把它链接到调用者模块上</li> <li>如 Windows 的 DLL</li></ul> <p>优点：</p> <ul><li>凡在执行过程中未被用到的目标模块，不会被调入内存和被链接到加载模块上
<ul><li>不仅可加快程序的加载过程，而且可节省大量的内存空间</li></ul></li> <li>支持分段系统</li></ul> <h4 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h4> <table><thead><tr><th>地址映射时间</th> <th>加载方式</th> <th>链接方式</th></tr></thead> <tbody><tr><td>加载前（编译/链接时）</td> <td>绝对加载</td> <td>静态链接</td></tr> <tr><td>加载时</td> <td>可重定位加载/静态重定位</td> <td>加载时动态链接</td></tr> <tr><td>运行时</td> <td>运行时加载/动态重定位</td> <td>运行时动态链接</td></tr></tbody></table> <p>讲了一通概念，乱乱的。这个似乎不是很重要，讲得不详细。主要是为后面铺路吧。</p> <h3 id="内存管理的需求"><a href="#内存管理的需求" class="header-anchor">#</a> 内存管理的需求</h3> <ul><li>重定位</li> <li>保护</li> <li>共享</li> <li>逻辑组织</li> <li>物理组织</li></ul> <h4 id="重定位"><a href="#重定位" class="header-anchor">#</a> 重定位</h4> <p>重定位 <code>relocation</code>（HTTP 的重定向是 <code>redirect</code> 233）</p> <p>OS 需要把活动进程换入或换出内存，但进程换入时若要放置在与换出前相同的区域，会存在诸多困难。因此需要将进程重定位到内存的不同区域。</p> <ul><li>操作系统需要知道进程控制信息、栈和入口点位置</li> <li>处理器需要处理程序内部的内存访问，处理<strong>跳转指令、数据访问指令</strong>的地址转换</li></ul> <h4 id="保护"><a href="#保护" class="header-anchor">#</a> 保护</h4> <ul><li>进程以外的其他进程中的程序不能未经授权地访问（进行读操作或写操作）该进程的内存单元</li> <li>程序在内存中的位置不可预测</li> <li>需要既支持重定位，也支持保护的机制</li> <li>处理器硬件必须具备这个能力</li></ul> <h4 id="共享"><a href="#共享" class="header-anchor">#</a> 共享</h4> <ul><li>多个进程正在执行同一程序时，允许每个进程访问该程序的同一个副本，要比让每个进程有自己独立的副本更有利</li> <li>需要既支持重定位也支持共享的机制</li></ul> <h4 id="逻辑组织"><a href="#逻辑组织" class="header-anchor">#</a> 逻辑组织</h4> <ul><li>内存被组织成线性（或一维）地址空间</li> <li>与此同时，程序按模块组织
<ul><li>可以独立编写和编译模块</li> <li>可以为不同的模块提供不同的保护级别（只读、只执行）</li> <li>模块可以被多个进程共享，与用户看待问题的方式一致</li></ul></li></ul> <p><a href="#%E5%88%86%E6%AE%B5">分段</a>可以满足该需求。</p> <h4 id="物理组织"><a href="#物理组织" class="header-anchor">#</a> 物理组织</h4> <p>在内存和外存之间完成移动信息的任务应该交给OS而不是程序员，因为：</p> <ul><li>不应让程序员负责管理内存</li> <li>供程序和数据使用的内存可能不足
<ul><li>覆盖 (overlaying) 允许不同的模块占用相同的存储空间，但编程耗时</li></ul></li> <li>程序员不知道可用空间的大小和位置</li></ul> <h3 id="内存分区"><a href="#内存分区" class="header-anchor">#</a> 内存分区</h3> <ul><li>内存管理的主要操作是处理器把程序加载内存中执行</li></ul> <table><thead><tr><th>内存管理技术</th> <th>使用</th></tr></thead> <tbody><tr><td>固定分区</td> <td>IBM   MFT</td></tr> <tr><td>动态分区</td> <td>IBM   MVT</td></tr> <tr><td>简单分页</td> <td>没有使用，但为虚存分页的基础</td></tr> <tr><td>简单分段</td> <td>没有使用，但为虚存分段的基础</td></tr> <tr><td>虚存分页</td> <td>现代操作系统广泛实际使用</td></tr> <tr><td>虚存分段</td> <td>现代操作系统广泛实际使用</td></tr></tbody></table> <p>内存管理包含虚拟内存的复杂方案，基于<strong>分段和分页</strong>两种基本技术</p> <h4 id="固定分区"><a href="#固定分区" class="header-anchor">#</a> 固定分区</h4> <ul><li>操作系统占据内存中某些固定部分，用户进程使用其余部分</li> <li>分区数量固定</li> <li>每个分区装入一个进程</li> <li>两种划分方式：分区大小相等和分区大小不等，如图：</li></ul> <p><img src="/images/6e8d6fcfbbde9283b1d909aa1a56d851d06363d2fd986497f0a50490bf753e99.png" alt="固定分区的两种划分方式"></p> <p>问题：</p> <ul><li>程序可能太大而不能放到一个分区中。此时，程序员必须使用覆盖技术设计程序，使得任何时候程序只需要有一部分放入内存</li> <li>内存的利用率非常低：很小的程序也必须占据一个完整分区</li> <li>由于装入的数据块小于分区大小，分区内部存在空间浪费，这种现象称作内部碎片</li></ul> <p><strong>内部碎片 (internal fragmentation) 就是分区内部的碎片</strong></p> <hr> <p>分区大小不等可以缓解上述问题，使内部碎片更小。</p> <p>但是，如果分区大小不等，就要考虑到放置算法，即把进程分配到分区的算法。</p> <p><img src="/images/a0b412bbce691fdd7e24af9c4a86b1d3b6f326521c79caf01d9830a4254e21dc.png" alt="分区大小不等时的放置算法"></p> <blockquote><p>最简单的方法是把每个进程分配到能够容纳它的<strong>最小分区</strong>中。在这种情况下，每个分区都需要维护一个调度队列，用于保存从这个分区换出的进程，如图 (a) 所示。这种方法的优点是，每个分区内部浪费的空间（内部碎片）最少。
尽管从单个分区的角度来看这种技术是最优的，但从整个系统来看它却不是最佳的。如果某个时刻，系统中没有大小在 12MB 到 16MB 之间的进程。此时，即使系统中有一些更小的进程本可以分配到 16MB 的分区中，但 16MB 的分区将仍会保持闲置。
因此，一种更可取的方法是为所有进程只提供一个队列，如图 (b) 。当需要把一个进程装入内存时，选择可以容纳该进程的<strong>最小可用分区</strong>。如果所有的分区都已被占据，则必须进行交换。</p></blockquote> <p>固定分区存在的问题：</p> <ul><li>分区的数量在系统生成阶段已经确定，因而限制了系统活动进程的数量</li> <li>小作业不能有效地利用分区空间</li></ul> <h4 id="动态分区"><a href="#动态分区" class="header-anchor">#</a> 动态分区</h4> <p>动态分区：分区大小和数量不固定；OS 总是分配与进程需求完全一致的空闲内存空间。</p> <p><img src="/images/c075749b41a51759362b666087b54dd2ad19ad4de3709e51737ad779f2078d4b.png" alt="动态分区的效果"></p> <p>如上图，动态分区虽然更灵活，但是会导致分区之间产生很多狭小的外部碎片（如 (h) 图中出现了 2 个 6M 和 1 个 4M 的碎片）。</p> <p><strong>外部碎片 (external fragmentation) 就是分区外部的碎片</strong></p> <hr> <p>于是有了紧凑技术 <code>Compaction</code>（又称为压缩）：</p> <ul><li>解决外部碎片问题的技术</li> <li>操作系统移动进程，使进程占用的空间连续、所有空闲空间连成一片</li> <li>但是紧凑费时，浪费处理器时间</li></ul> <h5 id="动态分区放置算法"><a href="#动态分区放置算法" class="header-anchor">#</a> 动态分区放置算法</h5> <h6 id="首次匹配-first-fit"><a href="#首次匹配-first-fit" class="header-anchor">#</a> 首次匹配 First Fit</h6> <ul><li>思想：从头开始扫描内存，选择大小足够的第一个可用块</li> <li>实现：要求空闲分区以地址递增的顺序链接，从链首开始查找</li> <li>评价：
<ul><li>简单，快速</li> <li>为大作业分配大的内存空间创造条件</li> <li>内存前端出现很多小的空闲分区，且每次查找都要经过这些分区</li></ul></li></ul> <h6 id="下次匹配-循环匹配-next-fit"><a href="#下次匹配-循环匹配-next-fit" class="header-anchor">#</a> 下次匹配/循环匹配 Next Fit</h6> <ul><li>思想：从上一次放置的位置开始扫描内存，选择下一个大小足够的可用块</li> <li>实现：空闲分区按地址从低到高排列（链接）</li> <li>评价：通常比首次匹配性能差
<ul><li>常常在内存末尾分配空间，能使空闲的分区分布均匀</li> <li>缺少大的空闲块，需要更多次数紧凑</li></ul></li></ul> <h6 id="最佳匹配-best-fit"><a href="#最佳匹配-best-fit" class="header-anchor">#</a> 最佳匹配 Best Fit</h6> <ul><li>思想：选择空间大小与需求最接近的空闲块分配</li> <li>实现：空闲分区按容量从小到大链接</li> <li>评价：通常性能是最差的
<ul><li>产生的外部碎片都很小</li> <li>内存中形成很多小到无法满足任何分配需求的块</li> <li>需要更频繁地紧凑</li></ul></li></ul> <h6 id="最差匹配-worst-fit"><a href="#最差匹配-worst-fit" class="header-anchor">#</a> 最差匹配 Worst Fit</h6> <ul><li>思想：选择最大的空闲分区分配</li> <li>实现：空闲分区按容量从大到小链接</li> <li>评价：
<ul><li>每次分配留下的空闲空间较大，便于再次利用</li> <li>大的空间不容易保留，对大作业不利</li></ul></li></ul> <h6 id="例题-2"><a href="#例题-2" class="header-anchor">#</a> 例题</h6> <p><img src="/images/5f8703f77500d3f038243a8c6c5acd4f1d754f24ef18cc12bac3bb494364c60e.png" alt="固定分区中的内存分配示例"></p> <hr> <p>操作系统采用动态分区存储管理技术。操作系统在低地址占用了100KB的空间，用户区主存从100KB处开始占用512KB。初始时，用户区全部为空闲，分配时截取空闲分区的低地址部分作为分配区。执行以下申请、释放操作序列：请求300KB、请求100KB、释放300KB、请求150KB、请求50KB、请求90KB。</p> <ol><li>采用首次适应算法时，主存中有哪些空闲分区？画出主存分布图，并指出空闲分区的首地址和大小。</li> <li>采用最佳适应算法时，主存中有哪些空闲分区？画出主存分布图，并指出空闲分区的首地址和大小。</li> <li>若随后又申请80KB，针对上述两种情况产生什么后果？说明了什么问题？</li></ol> <p><img src="/images/d5d12d15c51e90e944f9b038b86ffee645edf293f5d2a866bfc6795a1484f45b.png" alt="分区分配算法示例"></p> <h4 id="伙伴系统"><a href="#伙伴系统" class="header-anchor">#</a> 伙伴系统</h4> <ul><li>固定分区方案限制了活跃进程的数量。并且，如果分区大小与进程大小不匹配，则内存空间的利用率非常低</li> <li>动态分区方案维护复杂，并且引入了紧凑的额外开销</li> <li>折中方案：伙伴系统 <code>Buddy System</code></li></ul> <p>提出者：Donald E. Knuth</p> <h5 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h5> <p>最初，可用于分配的空间被视为一个大小为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span></span>的块。</p> <p>每次分配的块的大小为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>≤</mo><mi>K</mi><mo>≤</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">L \leq K \leq U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span></span>,  且</p> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">2^L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span></span></span></span></span></span></span></span> = 分配的最小块的大小</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span></span> =分配的最大块的大小</li> <li>通常， <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span></span> 是内存中整个可分配空间的大小</li></ul> <p><img src="/images/b7ea3474662d220b2c5c69566d3b17f46d798181e81f704bac1b19fcd7cbcafe.png" alt="伙伴系统示例"></p> <ul><li>释放 A 的时候，A 所在 64K 会和它的伙伴（从一个 128K 分裂出来的另一个 64K）进行合并，这就是所谓<strong>伙伴系统</strong></li> <li>释放的空间只能和自己的伙伴合并，即使另一个相邻空间也是同大小，也不会合并</li></ul> <p><img src="/images/960f6cf31af93ac94425a0bfc58c64f3d82e3a8e5f9f08a9ba874e9c33b94a7e.png" alt="伙伴系统的树状表示"></p> <h5 id="评价"><a href="#评价" class="header-anchor">#</a> 评价</h5> <ul><li>较为合理的折中方案，一定程度上克服了固定分区和动态分区的缺陷</li> <li>是一种有效方案</li> <li>UNIX 内核存储分配中使用了一种经过改进的伙伴系统</li></ul> <h4 id="重定位-2"><a href="#重定位-2" class="header-anchor">#</a> 重定位</h4> <p>概念：</p> <ul><li>逻辑地址 <code>Logical</code>：与当前数据在内存中的物理分配无关的访问地址，执行前要转换成物理地址</li> <li>相对地址 <code>Relative</code>：逻辑地址的特例，相对于某些已知点的存储单元</li> <li>物理地址 <code>Physical</code>/<code>Absolute</code>：内存中的实际地址</li></ul> <p><img src="/images/17d1be7b35c0eacf163b7a9e84d276d4ffcb71d20fbd57f9034e1beec54b67f3.png" alt="重定位的硬件支持"></p> <p>首地址经过 <code>Adder</code> 以后，还要进入 <code>Comparator</code> 判断是否有越界访问。</p> <h3 id="分页-重点-敲黑板"><a href="#分页-重点-敲黑板" class="header-anchor">#</a> 分页（重点，敲黑板）</h3> <h4 id="页和页框"><a href="#页和页框" class="header-anchor">#</a> 页和页框</h4> <ul><li>将内存划分成大小固定、相等、相对较小的块</li> <li>进程也划分成同样大小的块</li> <li><strong>页</strong> <code>Pages</code>：进程中的块</li> <li><strong>页框</strong> <code>Frames</code>：内存中的块</li> <li>不会有外部碎片（回忆内部碎片、外部碎片是什么？）</li></ul> <p><img src="/images/b402b4452bffe6f200b60c0eb1f7cd3ec64dd9754b0421e6cbc424c519d5af5a.png" alt="将进程的页装入内存的页框"></p> <p>注意 D 进程是<strong>离散存放</strong>（相对地，A、B、C是连续存放）的！</p> <p>由于存在离散存放的情况，地址转换需要操作系统提供页表支持。</p> <h4 id="页表"><a href="#页表" class="header-anchor">#</a> 页表</h4> <ul><li>页表是一种数据结构</li> <li>每个进程一个页表</li> <li>保存进程中每个页对应的页框</li> <li>处理器使用页表生成物理地址</li></ul> <p><img src="/images/ce4e868690737e0d36cc1b7dc60ef6690706c58c50ff32bb513033ceac61e839.png" alt="页表示例"></p> <p>每个进程的页表中，左边是页号，右边是页框号。</p> <h4 id="逻辑地址"><a href="#逻辑地址" class="header-anchor">#</a> 逻辑地址</h4> <ul><li>分页模式下，<strong>逻辑地址 = 页号 + 页内地址</strong></li></ul> <p><img src="/images/3d828887489817b7aaf79c5a34cbd3d9c1fc5428f8964731dfa2b8a74a5edd01.png" alt="32位机的分页存储系统逻辑地址结构示意图"></p> <p>从图中可以得出，页的大小为 4KB(<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span>B)。</p> <p><img src="/images/9320bacec4dd7762f4b2d5b292861b0c3a68c036d4f55f2b606c79ee7990568d.png" alt="逻辑地址转换示例"></p> <p>c 图是分段的内容，可以先不看。</p> <p>转换的实际情况可以看<a href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">地址转换</a>。</p> <hr> <p>若给定一个逻辑地址空间中的地址为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>，页面的大小为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></span>，则页号 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></span> 和页内地址 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span></span> 有以下关系：</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mi>A</mi><mi>L</mi></mfrac><mo stretchy="false">⌋</mo><mo separator="true">,</mo><mi>d</mi><mo>=</mo><mi>A</mi><mspace></mspace><mspace width="1em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext></mtext><mtext></mtext><mi>L</mi></mrow><annotation encoding="application/x-tex">P=\lfloor \frac{A}{L} \rfloor, d = A \mod L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">L</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace allowbreak"> </span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span></span></span></span></span></div></section><hr> <p>例题：某系统的页面大小为 1 KB，设 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mn>2170</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">A = 2170 B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">7</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span>，试计算其页号 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></span> 与页内地址 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span></span>。</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mn>2170</mn><mn>1024</mn></mfrac><mo stretchy="false">⌋</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mo>=</mo><mn>2170</mn><mspace></mspace><mspace width="1em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext></mtext><mtext></mtext><mn>1024</mn><mo>=</mo><mn>122</mn></mrow><annotation encoding="application/x-tex">P=\lfloor \frac{2170}{1024} \rfloor = 2, d = 2170 \mod 1024 = 122</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">1</span><span class="mord">7</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">7</span><span class="mord">0</span><span class="mspace allowbreak"> </span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">2</span></span></span></span></span></div></section><p><img src="/images/4d08253a150d844c271079d4e8c0693abe5a0f7968a9e98905fbc9e3ef520eb4.png" alt="逻辑地址到物理地址的转换"></p> <ol><li><code>逻辑地址高位</code> =&gt; <code>页号</code></li> <li>查页表，<code>页号</code> =&gt; <code>页框号</code></li> <li><code>页框号:逻辑地址低位</code> =&gt; <code>物理地址</code></li></ol> <h4 id="页表的存储"><a href="#页表的存储" class="header-anchor">#</a> 页表的存储</h4> <ul><li>页表存放在内存</li> <li>PCB 保存有页表的起始地址（PCB 和页表都是每个进程一个）</li> <li>页表寄存器存放当前运行进程的页表的起始地址</li></ul> <h4 id="例题-3"><a href="#例题-3" class="header-anchor">#</a> 例题</h4> <p>例题 1：</p> <ul><li>一个系统，内存容量共256K，存储块的大小为1K，共256块，编号为0～255。</li> <li>第0～4块为操作系统所使用；</li> <li>现有2个用户作业，作业1和作业2，其逻辑地址空间分别占2k和2.5k；</li> <li>进入系统后，按块的大小划分分别占2页和3页，分布如图。</li></ul> <p><img src="/images/8840be8253f7bdcbff3148168b95c41d3356b3b99d4cf948e7bc43a0fa45cff7.png" alt="分页情况"></p> <p>请完成作业 2 的 2500 的地址转换：</p> <p><img src="/images/e0e2bfa702829a34b042b97d32f1c6bd07ac7b794253431a689cba0e61839f13.png" alt="例题 地址转换"></p> <p>示意图：</p> <p><img src="/images/4555b744bc2ead56721cc3cc797b40d7eebd6b6bf70e0ac33d15b120db85ad58.png" alt="地址转换示意图"></p> <hr> <p>例题 2：</p> <ul><li>在普通分页存储管理系统中，逻辑地址的结构长度为18位，其中11~17表示页号，0~10位表示页内偏移量。若有一个作业的各页依次放入2、3、7号物理块，试问：逻辑地址1500应在几号页内?对应的物理地址是多少?</li></ul> <p>题解：</p> <ul><li>在页表中，有3个页表项，分别为(0,2)、(1,3)、(2,7)</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>页号</mtext><mo>=</mo><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mn>1500</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>11</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{页号}=int(1500/2^{11})=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">页号</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>页内偏移量</mtext><mo>=</mo><mn>1500</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext></mtext><mtext></mtext><msup><mn>2</mn><mn>11</mn></msup><mo>=</mo><mn>1500</mn></mrow><annotation encoding="application/x-tex">\text{页内偏移量}=1500 \mod 2^{11} = 1500</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">页内偏移量</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace allowbreak"> </span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span></span></li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>物理地址</mtext><mo>=</mo><mn>2</mn><mo>∗</mo><msup><mn>2</mn><mn>11</mn></msup><mo>+</mo><mn>1500</mn><mo>=</mo><mn>5596</mn></mrow><annotation encoding="application/x-tex">\text{物理地址}=2*2^{11}+1500=5596</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">物理地址</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">5</span><span class="mord">9</span><span class="mord">6</span></span></span></span></span></li></ul> <h4 id="评价-2"><a href="#评价-2" class="header-anchor">#</a> 评价</h4> <p>分页存储管理的优点：</p> <ul><li>存在页内碎片，但碎片相对较小，内存利用率较高</li> <li>实现了离散分配</li> <li>无外部碎片</li></ul> <p>分页存储管理的缺点：</p> <ul><li>需要专门的硬件支持，尤其是<a href="#%E8%BD%AC%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%BC%93%E5%86%B2%E5%8C%BA-tlb">快表</a></li> <li>不支持动态链接，不易实现共享（动态链接、共享是以模块为单位，而分页以页为单位，不会考虑到模块）</li></ul> <p>后面讲虚存的时候还会提到<a href="#%E5%88%86%E9%A1%B5">分页</a></p> <h3 id="分段"><a href="#分段" class="header-anchor">#</a> 分段</h3> <p>emmm 汇编</p> <ul><li>一个程序可以划分成几个段 <code>segments</code> <ul><li>段长度可以不等</li> <li>每个段都从 0 开始编址，并占用一段连续的地址空间</li> <li>有最大段长限制</li></ul></li> <li>逻辑地址两部分组成：段号+段内偏移量</li> <li>分段类似动态分区：分段使一个程序可以占据多个分区，且不必连续</li> <li>消除了内部碎片</li></ul> <h4 id="分段的性质"><a href="#分段的性质" class="header-anchor">#</a> 分段的性质</h4> <ul><li>分页对用户透明（用户不可见分页），分段对用户可见</li> <li>分段给程序员提供了组织程序和数据更方便的手段</li> <li>程序员或编译器将程序和数据划分到不同的段</li> <li>为实现模块化程序设计，程序和数据可能会进一步被划分成多个段</li> <li>不便：程序员或编译器需要清楚最大段长的限制</li></ul> <h4 id="逻辑地址-2"><a href="#逻辑地址-2" class="header-anchor">#</a> 逻辑地址</h4> <p>分段模式下，<strong>逻辑地址 = 段号 + 段内偏移</strong></p> <p><img src="/images/a38c43344c29d1d3d43e45bf1387cd296d91281deb0d3557645f46a8fbf00db7.png" alt="分段的逻辑地址结构"></p> <hr> <p>一个分段存储管理系统中，地址长度为32位，其中段号占8位，则最大段长是多少字节？</p> <p>应为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mn>8</mn></mrow></msup><mi>B</mi><mo>=</mo><mn>4</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{32-8}B=4 MB</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span>。</p> <h4 id="段表"><a href="#段表" class="header-anchor">#</a> 段表</h4> <p>段表记录逻辑段和物理段的对应情况。</p> <p><img src="/images/4b3099b8bc79b18eb0c954e48b11a261d8acd3443293462ce55e10ae0fb077a3.png" alt="段表"></p> <h4 id="逻辑地址转换示例"><a href="#逻辑地址转换示例" class="header-anchor">#</a> 逻辑地址转换示例</h4> <p>段的大小不等，导致逻辑地址和物理地址间没有简单的对应关系。地址转换需要经历以下步骤：</p> <ol><li>提取段号：逻辑地址最左侧的 n 位</li> <li>以段号为索引，查找段表中该段的起始物理地址</li> <li>逻辑地址最右侧 m 位为偏移量，偏移量与段长度比较，若偏移量&gt;段长，则地址无效</li> <li>物理地址：该段的起始物理地址+偏移量</li></ol> <p><img src="/images/2f14fdbc36011df9f0ee9de7240867be8f2bdd6b2c079b8639ad8138b65545d8.png" alt="逻辑地址转换示例"></p> <h4 id="评价-3"><a href="#评价-3" class="header-anchor">#</a> 评价</h4> <p>分段存储管理的优点：</p> <ul><li>便于程序模块化设计</li> <li>便于动态链接</li> <li>便于保护和共享</li> <li>无内部碎片</li></ul> <p>分段存储管理的缺点：</p> <ul><li>地址转换需要硬件的支持——段表寄存器</li> <li>分段的最大尺寸受到主存可用空间的限制</li> <li>有外部碎片</li></ul> <h4 id="分页、分段对比"><a href="#分页、分段对比" class="header-anchor">#</a> 分页、分段对比</h4> <blockquote><ol><li>页是信息的物理单位，<strong>分页的目的是实现离散分配，减少内存的外部碎片，提高内存的利用率</strong>。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组意义相对完整的信息。<strong>分段的目的是为了能更好地满足用户的需要。</strong></li> <li><strong>页的大小固定且由系统决定</strong>，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；<strong>而段的长度却不固定，决定于用户所编写的程序</strong>，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li> <li><strong>分页的作业地址空间是一维的</strong>，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而<strong>分段的作业地址空间则是二维的</strong>，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li> <li>分页存储管理系统不易实现“共享”和“运行时动态链接”，而分段系统易于实现**“共享”**。</li></ol></blockquote> <h2 id="三-2-内存管理-虚拟内存管理"><a href="#三-2-内存管理-虚拟内存管理" class="header-anchor">#</a> 三(2) 内存管理：虚拟内存管理</h2> <p>虚存的前提：</p> <ol><li>分页或分段的<strong>硬件</strong>支持</li> <li>操作系统必须有管理页或段在内存和辅存之间移动的<strong>软件</strong></li></ol> <h3 id="相关概念-3"><a href="#相关概念-3" class="header-anchor">#</a> 相关概念</h3> <ul><li><strong>虚拟内存</strong>：在存储分配机制中， 辅存可被看作主存的一部分来完成寻址。程序使用的地址与内存物理存储的地址不同，程序生成的地址会自动转换为物理地址。虚拟存储的大小受计算机系统寻址机制和可用辅存容量的限制，而不受主存实际大小限制</li> <li><strong>虚拟地址</strong>：在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主存的一部分那样。有时也称为逻辑地址</li> <li><strong>虚拟地址空间</strong>：分配给进程的虚拟存储</li> <li><strong>地址空间</strong>：用于某进程的内存地址范围</li> <li><strong>实地址</strong>：内存中存储位置的地址</li></ul> <h3 id="硬件和控制结构"><a href="#硬件和控制结构" class="header-anchor">#</a> 硬件和控制结构</h3> <p>分页和分段内存管理的两个基本特征：</p> <ol><li>进程中所有内存访问都是逻辑地址，这些逻辑地址会在运行时动态地转换为物理地址。</li> <li>一个进程可划分为许多块（页和段），在执行过程中，这些块不需要连续地位于内存中</li></ol> <p>若上述特征存在，则在一个进程执行过程中，该进程不需要所有页或所有段都在内存中。</p> <hr> <p>进程的执行过程：</p> <ul><li>操作系统仅读取包含程序开始处的一个或几个块进入内存</li> <li><strong>驻留集</strong>：任意时刻，进程驻留在内存的部分</li> <li>访问一个不在内存中的逻辑地址时（称为内存失效），产生一个中断：
<ul><li>操作系统把被中断的进程置为阻塞状态</li> <li>操作系统把该进程中包含引发内存失效的部分读入内存</li> <li>操作系统产生一个磁盘 I/O 读请求</li> <li>在执行磁盘 I/O 期间，操作系统调度另外一个进程运行</li> <li>磁盘 I/O 完成后产生中断，操作系统将相应的进程置于就绪状态</li></ul></li></ul> <hr> <p>提高系统资源利用率的方法：</p> <ol><li>内存中保留多个进程
<ul><li>每个进程仅装入了部分块</li> <li>任何时刻内存中的进程至少有一个处于就绪状态</li> <li>提高了处理器的利用率</li></ul></li> <li>进程可以比内存的全部空间还大
<ul><li>基于分页和分段的技术，操作系统和硬件只加载程序的一部分</li> <li>程序员面对的是一个巨大内存，大小与磁盘存储器相关</li></ul></li></ol> <hr> <table><thead><tr><th>实存储器（实存）</th> <th>虚拟内存（虚存）</th></tr></thead> <tbody><tr><td>主存, 实际的物理内存</td> <td>感觉更大的内存，且常分配在磁盘上</td></tr> <tr><td>更有效地支持并发，并能减轻用户对内存的严格限制</td> <td></td></tr></tbody></table> <hr> <p><img src="/images/36887c60f73fdc69d94b53d6e9e508a6a029878500080481e836647b3eb1e28c.png" alt="使用和不使用虚存技术下分页和分段的特点"></p> <h4 id="抖动和局部性原理"><a href="#抖动和局部性原理" class="header-anchor">#</a> 抖动和局部性原理</h4> <ul><li>进程只有部分块在内存，这样可在内存中保留更多进程</li> <li>操作系统必须“聪明”的管理这个方案</li> <li>当内存空间几乎被进程块占据时，每读取一块，必须把另一块换出，如果出现<strong>抖动</strong>，处理器的大部分时间都用于交换而非执行指令</li> <li>为了避免这种情况，操作系统试图根据最近的历史来猜测将来最可能用到的块</li></ul> <blockquote><p><strong>抖动</strong>：即将要用到的块被换出，系统又得很快将它取回，导致页面被频繁地换入换出，缺页率急剧增加</p></blockquote> <hr> <p>局部性原理：</p> <ul><li>存储器的访问呈簇性（簇 <code>cluster</code>：一组程序或数据的集合）
<ul><li>在很长一段时间内，使用的簇会发生变化</li> <li>但在很短的时间内，处理器基本上只与固定的簇打交道</li></ul></li> <li>描述了进程中程序和数据引用的集簇倾向</li> <li>在很短的时间内仅需要进程的一部分块</li> <li>对将来可能会访问的块进行猜测，以避免抖动</li></ul> <p>局部性原理表明虚存方案是可行的。</p> <h4 id="分页"><a href="#分页" class="header-anchor">#</a> 分页</h4> <ul><li>虚拟内存通常与使用分页的系统联系在一起</li> <li>每个进程都有自己的页表</li> <li>分页的虚存方案中，页表项变得更复杂</li></ul> <h5 id="页表项"><a href="#页表项" class="header-anchor">#</a> 页表项</h5> <p><img src="/images/cf97c3a964489d817d2addc873896c307eac9018e17bcae282e8da6f50355743.png" alt="页表项"></p> <ul><li>存在位 <code>P</code>：表明对应的页是否在内存</li> <li>页框号：若页在内存，则有对应的页框号</li> <li>修改位 <code>M</code>：表明相应页上次装入内存到现在是否修改过（若修改过，换出时要更新辅存上对应页；没修改就不用更新了）</li></ul> <h5 id="地址转换"><a href="#地址转换" class="header-anchor">#</a> 地址转换</h5> <p>其实也就是前面<a href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80">分页的地址转换</a>,只是这里加上了内存等硬件结构。</p> <ul><li>页表位于内存</li> <li>进程运行时，一个寄存器保存页表的起始地址</li> <li>虚拟地址的页号用于检索页表，查找对应页框号</li> <li>页框号与虚拟地址的偏移量结合起来形成物理地址</li></ul> <p><img src="/images/a8ecfb4c31004f28a49d2a712ff9588f2783c8bdd917a75e815e513c3af31cd8.png" alt="地址转换过程"></p> <hr> <p>例：某虚拟存储器的用户编程空间共32个页面，每页为1KB，内存为16KB。假定某时刻一用户页表中已调入内存的页面对应的物理块号如下表：</p> <table><thead><tr><th>页号</th> <th>物理块号</th></tr></thead> <tbody><tr><td>0</td> <td>5</td></tr> <tr><td>1</td> <td>10</td></tr> <tr><td>2</td> <td>4</td></tr> <tr><td>3</td> <td>7</td></tr></tbody></table> <p>逻辑地址 <code>0A5C</code>(<code>00010 1001011101</code>) 对应的物理地址为：<code>125C</code>(<code>0100 1001011101</code>)。</p> <h5 id="二级页表"><a href="#二级页表" class="header-anchor">#</a> 二级页表</h5> <p>每个进程一个页表，如果进程的逻辑地址空间大，则页表庞大。</p> <blockquote><p>例如，在 Vax 机中，每个进程虚存空间可达<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>=</mo><mn>2</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{31}=2GB</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span>，若每个页大小 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>9</mn></msup><mo>=</mo><mn>512</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">2^9=512B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span>，则需要 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span> 个页表项。</p></blockquote> <p>显然，采用这种方法来放置页表的内存空间太大。为克服这个问题，大多数虚拟内存方案都在<strong>虚存</strong>（而非实存）<strong>中保存页表</strong>。这意味着页表和其他页一样都服从分页管理。</p> <p>一个进程正在运行时，它的页表至少有一部分须在内存中，这一部分包括正在运行的页的页表项。</p> <p>一些处理器使用<strong>两级方案</strong>来组织大型页表。在这类方案中有一个页目录，其中的每项指向一个页表。这种方案也称为<strong>二级页表</strong>。</p> <hr> <p>示例：32位地址的两级页表</p> <ul><li>页尺寸为 4KB</li> <li>虚拟地址空间为 4GB，由 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span>页组成</li> <li>每个页表项 4 字节，可计算得页表大小总共需要 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>B</mi><mo>×</mo><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>4</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">4B \times 2^{20} = 4MB</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span></li> <li>页表空间需 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>M</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>4</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">4MB/4KB=2^{10}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span> 页存储，因此可保留在虚存中，并建立根页表来索引
根页表包含 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span>个页表项，占用 4KB 内存</li></ul> <p><img src="/images/f021e463a93563643d4569406344abf6464cb4ce1a60e31ec30f578b7af76129.png" alt="32位地址的两级页表"></p> <p><img src="/images/c076664d68320309d6685a7a976a88725a2a492da30dce0e2aa4db21316594c2.png" alt="两级分页的逻辑地址结构，及地址映射示意图"></p> <hr> <p>例题 1：某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span> 字节，页表项大小为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span> 字节。逻辑地址空间大小为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span></span> 页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是多少？</p> <blockquote><p>这类计算题需要注意的是几个等量关系：</p> <ul><li>第二级页表也是页，所以<strong>页大小</strong>既指后面存数据的页面的大小，也指存页表项的二级页表的大小</li> <li>而页目录就不是页了</li> <li>如果页目录的长度为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></span> 项，且一个页表的最大长度为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></span> 页，则一个进程可以有 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">XY</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></span> 页</li></ul></blockquote> <p>回到题目，这个题有两种解法：</p> <p>解法 1：</p> <ul><li>一个二级页表能存的页表项数 = 页大小 / 一个页表项的大小 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><msup><mn>2</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">= 2^{10}/2 = 2^9</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></span> 个</li> <li>所以，二级页表的总数 = 总逻辑页数 / 一个二级页表能存的页表项数 = <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^7</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></li> <li>页目录的表项数 = 二级页表的总数 = <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^7</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></li></ul> <p>解法 2：</p> <ul><li>二级页表总的项数 = 总逻辑页数 = <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span></span></li> <li>二级页表总的大小 = 总表项数 * 页表项大小 = <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>17</mn></msup></mrow><annotation encoding="application/x-tex">2^{17}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></span></li> <li>二级页表的总数 = 总的大小 / 一个二级页表能存的大小（换言之，页大小） = <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^7</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></li> <li>页目录的表项数 = 二级页表的总数 = <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^7</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></li></ul> <p>头晕的时候做这题就很容易晕掉。</p> <hr> <p>两级分页中的地址转换：</p> <ol><li>虚拟地址（逻辑地址）结构中分离出根页表号（如图8.3例虚拟地址前10位）</li> <li>检索根页表，查找关于用户页的页表项</li> <li>如果不在内存，产生一次缺页中断</li> <li>若在内存，用虚拟地址中间页号（如前例虚拟地址中间10位）检索用户页表，查找对应的页表项</li> <li>得到页框号，和页内偏移量一起形成物理地址</li></ol> <p><img src="/images/a6dc374bdd2d6069fd5a819fb5e68c6b04de1e4caee094ba44a4cfbc41a7b71b.png" alt="二级页表地址转换示意图"></p> <hr> <p>例题 2：80x86 硬件分页地址，32位逻辑地址空间、4KB页面、4B页表项，如何将逻辑地址 <code>0x20021406</code> 转换为物理地址？</p> <ul><li>页面大小 4KB，所以最后 12 位为页内偏移量</li> <li>一个二级页表的页表项数 = 页面大小/页表项大小 = 1KB，所以中间 10 位为页号</li> <li>剩下前面的 32-10-12=10 位就是页表页号了</li></ul> <p><code>0x20021406 = 0010000000 0000100001 010000000110</code></p> <ul><li>顶级页表字段 <code>0x80</code>，用于选择顶级页表的第<code>0x80</code>表项，指向二级页表</li> <li>二级页表字段 <code>0x21</code>，用于选择二级页表的第<code>0x21</code>表项，指向逻辑地址所在页框</li> <li>页内偏移地址字段 <code>0x406</code>，逻辑地址在页框内的偏移量</li></ul> <hr> <p><img src="/images/bd971f52944ca88a028917817855f9ee4f6692e3faa39e98a4a17b99a52eeb49.png" alt="例题 3 图"></p> <p>例题 3：在例题 2 和上面的表结构中，求逻辑地址 <code>4197721</code> （注意没有 <code>0x</code>，是十进制）的物理地址？</p> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4197721</mn><mo>=</mo><mn>1024</mn><mo>∗</mo><msup><mn>2</mn><mn>12</mn></msup><mo>+</mo><mn>3417</mn></mrow><annotation encoding="application/x-tex">4197721 =  1024 * 2^{12} + 3417</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mord">9</span><span class="mord">7</span><span class="mord">7</span><span class="mord">2</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">4</span><span class="mord">1</span><span class="mord">7</span></span></span></span></span></li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn><mo>=</mo><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mn>10</mn></msup><mo>+</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1024 = 1 * 2^{10} + 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></li></ul> <table><thead><tr><th style="text-align:center;">页目录号</th> <th style="text-align:center;">页号</th> <th style="text-align:center;">页内偏移</th></tr></thead> <tbody><tr><td style="text-align:center;">1</td> <td style="text-align:center;">0</td> <td style="text-align:center;">3417</td></tr></tbody></table> <ul><li>顶级页表字段为 1，用于选择顶级页表的第 1 表项，指向二级页表 202</li> <li>二级页表字段 0，用于选择二级页表的第 0 表项，指向逻辑地址所在页框 505
页内偏移地址字段 3417，逻辑地址在页框内的偏移量
物理地址：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>505</mn><mo>∗</mo><msup><mn>2</mn><mn>12</mn></msup><mo>+</mo><mn>3417</mn><mo>=</mo><mn>2071897</mn></mrow><annotation encoding="application/x-tex">505 * 2^{12} + 3417 = 2071897</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">4</span><span class="mord">1</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">7</span><span class="mord">1</span><span class="mord">8</span><span class="mord">9</span><span class="mord">7</span></span></span></span></span></li></ul> <h5 id="多级页表"><a href="#多级页表" class="header-anchor">#</a> 多级页表</h5> <p>对于某些机器，二级页表也可能非常大；可采用多级页表，对外层页表再进行分页，如三级页表。</p> <ul><li>会增加额外的存储空间。</li> <li>页表的级数越多，地址转换过程越复杂，转换的速度也越慢。</li></ul> <h5 id="倒置页表"><a href="#倒置页表" class="header-anchor">#</a> 倒置页表</h5> <p>上面的页表均使用页号作为索引，也就是说，有多少项虚拟页，就需要多少页表项；每个进程都需要有这么多页表项（即，<strong>页表大小和虚拟页数成正比</strong>），而实际的物理存储页数并没有这么多，不需要这么多页表项，导致严重的空间浪费。</p> <p>于是发明了<strong>倒置页表（倒排页表）</strong>。页表结构称为“倒排”的原因是，它使用页框号而非虚拟页号来索引页表项（如下图）。另外，所有进程共用一张表倒排页表，因此无论有多少进程、支持多少虚拟页，<strong>页表大小只与物理页数成正比</strong>，只需要实存中的一个固定部分。</p> <p>虚拟地址的页号部分使用一个简单的散列函数映射到散列表中，哈希值指向倒排页表。</p> <p><img src="/images/5d111ee5811302eafa78da384d6ff306376127c9a786ed3d6e5648e9b318bb0b.png" alt="倒排页表结构"></p> <p>使用时，计算出的散列函数会和每一个页号匹配（啊这 似乎有点慢），匹配到了的下标 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 即是页框号。如果没匹配到，会通过链指针跳到下面一项。</p> <h5 id="转换检测缓冲区-快表"><a href="#转换检测缓冲区-快表" class="header-anchor">#</a> 转换检测缓冲区（快表）</h5> <p>对于一级页表，每次虚存访问都可能会引起两次物理地址访问：一次取相应的页表项，另一次取需要的数据。</p> <p>为了克服这个问题，大多数虚拟内存方案都为页表项使用了一个特殊的高速缓存，称为转换检测缓冲区 <code>TLB</code> (translation lookaside buffer，快表)。TLB 包含最近用过的页表项。</p> <hr> <p>具有快表的地址转换流程：</p> <ol><li>给定一个虚拟地址，处理器首先检查 TLB</li> <li>若命中，即页表项在TLB中，检索页框号形成物理地址</li> <li>若未命中，即页表项不在TLB中，检索进程页表，查找相应页表项
<ul><li>若“存在位”已置位，页位于内存，用页框号+偏移量形成物理地址</li> <li>若“存在位”未置位，页不在内存，产生缺页中断 (page fault)，装入所需页，更新页表</li></ul></li></ol> <p>上面的描述中有三种情况：</p> <ol><li>页表项在 TLB 中，此时数据一定在内存中（正确性如何证明？可能和后面的换出算法有关）</li> <li>页表项不在 TLB 中，但数据在内存中</li> <li>页表项不在 TLB 中，数据也不在内存中</li></ol> <p><img src="/images/4015c10629b269a1ec775f0fd94a5329aa43950685319da8e42d6179cce54a27.png" alt="具有快表的地址转换示意图"></p> <p><img src="/images/1d1d92faf6314df73aa23f53579d80a2b8e047a43d19d3702a78e7dfeab1a0ca.png" alt="具有快表的地址转换流程图"></p> <p>页表更新后需要回到出错指令，可能是因为中断恢复以后需要执行指令。</p> <hr> <p>注意到在地址转换示意图中，处理器对 TLB 的查询是同时进行多项匹配的，<strong>这叫关联映射</strong>，需要硬件支持。</p> <hr> <p>更复杂的是 TLB 和 CPU 高速缓存协同的相关操作。</p> <ul><li>页表项：可能在TLB中，也可能在内存或磁盘中</li> <li>被访问的字：可能在高速缓存中，也可能在内存或磁盘中</li></ul> <p><img src="/images/d23911904040b4399ae1cbe1dafee2c4fac560d0aa777bf803bb6ddefc990968.png" alt="TLB 和 CPU 高速缓存协同"></p> <ol><li>用页号查询 TLB 或页表，找到页框号</li> <li>用页框号和偏移量组合成实地址，然后查询缓存或内存，得到值</li></ol> <h5 id="页尺寸"><a href="#页尺寸" class="header-anchor">#</a> 页尺寸</h5> <blockquote><p>页尺寸是一个重要的硬件设计决策，它需要考虑多方面的因素。<br>
其中一个因素是内部碎片。显然，页越小，内部碎片的总量越少。为优化内存的使用，通常希望减少内部碎片；另一方面，页越小，每个进程需要的页的数量就越多，意味着更大的页表。对于多道程序设计环境中的大程序，这意味着活动进程有一部分页表在虚存而非内存中。因此，一次内存访问可能产生两次缺页中断：第一次读取所需的页表部分，第二次读取进程页。<br>
另一个因素是基于大多数辅存设备的物理特性，希望页尺寸比较大，从而实现更有效的数据块传送。</p></blockquote> <hr> <p>两个有意思的图：</p> <blockquote><p>缺页率：发生缺页的次数与总访问次数的比值。
P：进程大小
W：工作集大小
N：进程的总页数</p></blockquote> <p><img src="/images/341df0463c46f2e468de12b735d092424af0af2c90972da269cd7a3246a3538b.png" alt="缺页率与分配页框数的关系（页尺寸一定）"></p> <p>上图表明，对固定的页尺寸，内存中的页框数增加时，缺页率下降。</p> <p>这个很好理解，内存变大了能存下更多的东西，换出的频率会更低。</p> <p><img src="/images/2c54ddb9022c763299f70d497de3c7cbe54cb794e1e9d1c454c44f2dfa1b3284.png" alt="缺页率与页尺寸的关系"></p> <p>上图表明，页尺寸很小时，缺页率低；页尺寸增加时，缺页率增加；页尺寸较大时，缺页率下降。</p> <p>前面一段是由于局部性原理，内存利用率高，换出少，缺页率会较低，当尺寸变大时，局部性原理被削弱（一页包含的单元可能很多都不是最近需要访问的了），换出多，缺页率增高；但当页尺寸大到一页包含整个进程时，不会发生缺页中断。</p> <hr> <p><img src="/images/28ae11964b3c61149c38cfcfa699f196905b6b9dcce15babf0a4811db484663e.png" alt="页尺寸示例"></p> <hr> <p>页尺寸的设计问题与物理内存的大小和程序大小有关。当内存空间变大时，应用程序使用的地址空间也相应增长。这在应用程序变得越来越复杂的个人计算机上最为明显。</p> <p>大型程序中所用的当代程序设计技术可能会降低进程的局部性：</p> <ul><li>面向对象技术：对小程序和数据的引用会分散在不同的对象中</li> <li>多线程应用：指令流会突然变化，引用分散在内存中</li></ul> <h4 id="分段-2"><a href="#分段-2" class="header-anchor">#</a> 分段</h4> <h5 id="内容回顾"><a href="#内容回顾" class="header-anchor">#</a> 内容回顾</h5> <blockquote><p>分段：</p> <ul><li>允许程序员把内存视作由多个地址空间或段组成</li> <li>段大小不等，可以动态变化</li> <li>内存访问时：段号+段内偏移量</li> <li>优点：
<ul><li>简化了对不断增长的数据结构的处理</li> <li>允许程序独立地改变或重新编译</li> <li>有助于进程间的共享</li> <li>有助于保护</li></ul></li></ul></blockquote> <h5 id="段表项"><a href="#段表项" class="header-anchor">#</a> 段表项</h5> <p>段表项类似于<a href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9">页表项</a>，只是多了一个长度。</p> <p><img src="/images/3e1372f91637cbd019e219369d2d6615cf6c9e2e6b0b8027726571275d930d4f.png" alt="页表项"></p> <h5 id="地址转换-2"><a href="#地址转换-2" class="header-anchor">#</a> 地址转换</h5> <ul><li>逻辑地址=段号+段内偏移量，寄存器存储段表地址</li> <li>根据段表地址和段号查找段表，找到相应段在内存中的基地址</li> <li>得到物理地址=基地址+段内偏移量</li></ul> <p>分段和分页的<a href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">地址转换</a>类似。</p> <p><img src="/images/a1f335ce5888cef3d4e3129256beb5d5b0c8bd96d3b756111ace2e998a66f471.png" alt="地址转换"></p> <h4 id="段页式"><a href="#段页式" class="header-anchor">#</a> 段页式</h4> <p>用户的地址空间被程序员<strong>划分为许多段</strong>，<strong>每段划分为许多固定大小的页</strong>：</p> <p>分段：</p> <ul><li>对程序员可见</li> <li>支持数据结构增长（段长可变）</li> <li>支持共享和保护</li></ul> <p>分页：</p> <ul><li>对程序员透明</li> <li>消除外部碎片</li> <li>有效利用内存</li></ul> <p>结合二者，就出现了段页式。</p> <h5 id="段页式的逻辑地址"><a href="#段页式的逻辑地址" class="header-anchor">#</a> 段页式的逻辑地址</h5> <ul><li>用户地址空间被程序员划分成若干段，每段划分成若干页</li> <li>程序员的角度：逻辑地址 = 段号:段内偏移量</li> <li>系统的角度：段内偏移量 = 页号:页内偏移量</li></ul> <h5 id="段表和页表"><a href="#段表和页表" class="header-anchor">#</a> 段表和页表</h5> <ul><li>每个进程一个段表</li> <li>每个段一个页表</li> <li>段表项：含段长和对应页表的起始地址</li> <li>页表项：含页框号、存在位P、修改位M等</li></ul> <p><img src="/images/b45d99f3c60fe1d19fa6e4bb12cd0cd066babbae5f1b7aff89dc095d80938e1f.png" alt="段表和页表"></p> <h5 id="地址转换-3"><a href="#地址转换-3" class="header-anchor">#</a> 地址转换</h5> <p><strong>虚拟地址</strong>（逻辑地址） = <strong>段号 : 页号 : 偏移量</strong></p> <ol><li>寄存器存放段表起始地址</li> <li>根据段表起始地址和段号查找段表，得到对应段的页表起始地址</li> <li>根据页表起始地址和页号查找页表，得到页框号</li> <li>页框号和偏移量构成物理地址</li></ol> <p><img src="/images/6f76d29cca282ed490f1f39922a4fe04c3282ae14cb6e9cfd7771d43dc084b3c.png" alt="段页式的地址转换"></p> <hr> <p>例题 1：32 位逻辑地址，段最大大小为 16 KB，页大小为 4KB，问地址中各部分长度。</p> <p>段号 18 位 + 页号 2 位 + 偏移量 14 位</p> <hr> <p>在段页式系统中（不考虑缓存、TLB 等），为了获得一条指令或数据，至少需访问几次内存？</p> <ul><li>第一次，访问段表，从中获得该段的页表首址；</li> <li>第二次，访问页表，从中取出逻辑地址指定的页面所在的页框号，并将该页框号和页内偏移量相加，形成物理地址；</li> <li>第三次，根据物理地址，取出对应存储单元的指令或数据。</li> <li>所以至少三次（如果发生缺页中断，次数会大于三）</li></ul> <h4 id="保护和共享"><a href="#保护和共享" class="header-anchor">#</a> 保护和共享</h4> <p>分段有助于实现保护和共享机制</p> <ul><li>保护：每个段都包括一个长度和一个基地址，可以控制非法访问</li> <li>共享：一个段可以在多个进程的段表中被引用，实现共享</li></ul> <p>示例：</p> <blockquote><p>一个多用户系统，可同时接纳 40 个用户，每个都执行一个文本编辑程序 (Text Editor)。如果文本编辑程序有 160 KB 的代码和另外 40 KB 的数据区，则总共需有 8000KB 的内存空间来支持 40 个用户。如果 160 KB的代码是可重入的(Reentrant，即能被共享)，在内存中只需保留一份文本编辑程序的副本，此时所需的内存空间仅为 1760 KB(40×40+160)，而不是 8000 KB。</p></blockquote> <hr> <p>分页中的共享：假定每个页面 4KB，160KB 的共享代码需要 40 个页面，每个进程需要 40 个页表项来存储相应信息。</p> <p><img src="/images/4f368755621020bb0728114eaaafbcfd2efa4b912affa657287111c48cf2d91e.png" alt="分页中的共享"></p> <hr> <p>分段中的共享：共享部分作为一个段，每个进程仅需一个段表项来存放共享段信息。</p> <p><img src="/images/2e13321ce17a73b2a3416793bdd26d3af9d7b6019ecb98d26aaf397ea0266276.png" alt="分段中的共享"></p> <hr> <p>下图说明了这类系统能实现的保护关系的类型。</p> <p><img src="/images/79f47532316dfb3d41cf5350f60b5a9490b4a8d13712df30ffcf50aec63e3e64.png" alt="系统能实现的保护关系的类型"></p> <h3 id="操作系统软件"><a href="#操作系统软件" class="header-anchor">#</a> 操作系统软件</h3> <p>内存管理设计的三个基本选择：</p> <ul><li>是否使用虚拟技术</li> <li>使用分页还是分段，或二者同用</li> <li>为各种存储管理特征采用的算法（本节主题）</li></ul> <hr> <p>为实现虚拟内存，操作系统需要考虑的策略（软件方面）：</p> <ul><li>读取策略
<ul><li>请求调页 (Demand Paging)</li> <li>预调页 (Prepaging)</li></ul></li> <li>放置策略
<ul><li>驻留在内存中的位置</li></ul></li> <li>置换策略
<ul><li>基本算法
<ul><li>最优 (OPT)</li> <li>最近最少使用 (LRU)</li> <li>先进先出 (FIFO)</li> <li>时钟 (CLOCK)</li></ul></li> <li>页缓冲</li></ul></li> <li>驻留集管理
<ul><li>驻留集大小
<ul><li>固定</li> <li>可变</li></ul></li> <li>置换范围
<ul><li>全局</li> <li>局部</li></ul></li></ul></li> <li>清除策略
<ul><li>请求式清除 (Demand)</li> <li>预约式清除 (Precleaning)</li></ul></li> <li>负载控制
<ul><li>多道程序度（系统并发度）</li></ul></li></ul> <h4 id="读取策略"><a href="#读取策略" class="header-anchor">#</a> 读取策略</h4> <p>决定某页何时进入内存。</p> <ul><li>请求调页（Demand Paging，按需调页）
<ul><li>仅在引用页面时，才把相应的页面调入内存</li> <li>进程首次启动时，会发生很多缺页中断</li> <li>局部性原则表明，大多数将来访问的页面都是最近读取的页面，一段时间后，缺页中断会降低到很低的水平。</li></ul></li> <li>预调页（Prepaging）
<ul><li>额外读取所缺页面以外的页面</li> <li>考虑大多数辅助储设备的特性：寻道、旋转延迟等</li> <li>若进程的页面连续存储在辅存中，则一次读取多个页面会更有效</li> <li>如果额外读取的页面未使用，则低效</li></ul></li></ul> <h4 id="放置策略"><a href="#放置策略" class="header-anchor">#</a> 放置策略</h4> <ul><li>确定进程驻留在内存中的位置</li> <li>分段系统中的重要设计内容，如首次匹配、循环匹配等</li> <li>分页或段内分页中，放置策略无关紧要，因为硬件以相同的效率执行地址转换功能</li> <li>对于非一致存储访问 (NUMA，NonUniform Memeory Access, NUMA)，需要自动放置策略</li></ul> <h4 id="置换策略-重点"><a href="#置换策略-重点" class="header-anchor">#</a> 置换策略（重点）</h4> <p>页面置换涉及的问题：具体淘汰哪个页面用以置换</p> <p>置换策略 (Replacement policy)：读取新页时，如何选择内存中要淘汰的页面</p> <ul><li>目标：最近最不可能访问的页面</li> <li>置换策略越精细，实现它的硬件和软件开销就越大</li></ul> <h5 id="页框锁定"><a href="#页框锁定" class="header-anchor">#</a> 页框锁定</h5> <ul><li>当页框被锁定时，当前存储在该页框中的页面不能被置换</li> <li>操作系统内核和重要的数据结构保存在锁定的页框中</li> <li>I/O缓冲区和时间要求严格的区域也可能保存在锁定的页框中</li> <li>通过将锁定位与每个页框相关联来实现锁定</li></ul> <h5 id="几种基本的置换算法"><a href="#几种基本的置换算法" class="header-anchor">#</a> 几种基本的置换算法</h5> <ul><li>最佳 (Optimal, OPT，理想算法)</li> <li>最近最少使用 (Least recently used, LRU)</li> <li>先进先出 (First-in-first-out , FIFO)</li> <li>时钟 (Clock)</li></ul> <p>评价置换算法的重要指标：</p> <p>缺页率——给定时间内，发生缺页的次数与访问总次数的比值</p> <h5 id="最佳-opt"><a href="#最佳-opt" class="header-anchor">#</a> 最佳 (OPT)</h5> <ul><li>置换下次访问距当前时间最长的页面</li> <li>理想算法（不可实现），缺页率最少</li></ul> <p><img src="/images/7924ebfaae3bba0e4b996e2d72658f9bb4fe267fb7ed1401242666578995247e.png" alt="OPT 算法示例"></p> <p>F表示所分配的页框在初始填满后产生缺页中断。</p> <h5 id="最近最少使用-lru"><a href="#最近最少使用-lru" class="header-anchor">#</a> 最近最少使用 (LRU)</h5> <ul><li>置换内存中最长时间未引用的页面</li> <li>根据局部性原理，这也是最近最不可能访问的页面</li> <li>难以实施
<ul><li>每页添加最近访问时间戳——开销大</li> <li>建立链表——开销大</li></ul></li></ul> <p><img src="/images/897bb3ec4c4993f3f511a233238fc38bb64fc0377398345eeb18490e04cacbcc.png" alt="LRU 算法示例"></p> <h5 id="先进先出-fifo"><a href="#先进先出-fifo" class="header-anchor">#</a> 先进先出 (FIFO)</h5> <ul><li>将分配给进程的页框视为循环缓冲区</li> <li>页面以循环方式删除——简单的置换策略</li> <li>置换驻留在内存中时间最长的页面</li></ul> <p><img src="/images/b8060fb28d32c6683ac43b2360e0650739038d0123f7677b370c032f5078a52a.png" alt="FIFO 算法示例"></p> <h5 id="时钟-clock"><a href="#时钟-clock" class="header-anchor">#</a> 时钟 (CLOCK)</h5> <ol><li>每个页框关联一个使用位</li> <li>当页面首次加载到内存中或被引用时，使用位设置为1</li> <li>用于置换的候选页框集视作一个循环缓冲区</li> <li>发生缺页中断时，检查表针指向页面，如果使用位为 0，则新页面替换之,<strong>表针前移一个位置</strong>；如果使用位为 1，则清 0，表针前移一个位置。重复上述过程。</li> <li>注意：命中时表针不移动，而是将根据第二条，将命中位的使用位设为 1</li></ol> <p><img src="/images/66aed996e35a95ce9b1f5614ebc9ce7b24cd191cbc2c617973cc1768ee5281ef.png" alt="时钟算法 图"></p> <p>这个算法类似于 FIFO，但不同的是，在时钟策略会跳过刚访问过的页框。</p> <hr> <p>示例 1：页 727 进入内存前，需要选择一个页置换。<br>
从指针当前位置开始，顺时针移动，最后选择页556置换。</p> <p><img src="/images/63a83a5d22bb82e246c49c1593987983b53b4b0d881df8f67713df65994f2e2d.png" alt="时钟算法示例 1"></p> <p><img src="/images/2f39b20e29a1d38ffdba5277cab6bfc3245605448cd036270d7cc60a6d5ad757.png" alt="时钟算法示例 2"></p> <p>图中 <code>*</code> 表示 <code>use=1</code>。注意第 5 步时，时钟实际上转了一圈，将所有点标记为 <code>use=0</code> 后，替换掉了第一个 <code>2</code>。</p> <hr> <p>例题：假设系统为某进程分配了3个页框，其页面走向如下：7   0   1   2   0   3   0   4，求采用CLCOK页面淘汰算法，在初始3个页框装满后缺页中断的次数。</p> <p><img src="/images/289aebf7bc8952f1c75fad92775905ecacf3367a4976e3136c65468279c53270.png" alt="例题模拟"></p> <p>共三次缺页。</p> <h5 id="置换算法比较"><a href="#置换算法比较" class="header-anchor">#</a> 置换算法比较</h5> <p><img src="/images/a783975a4beca2a40898c077dcceb2381ff4450ee215bc053624667dafac207d.png" alt="几种置换算法比较（固定分配，局部置换）"></p> <h5 id="改进-clock-算法"><a href="#改进-clock-算法" class="header-anchor">#</a> 改进 Clock 算法</h5> <p>在Clock算法基础上，优先置换最近未访问、未修改（如果这块内存被修改了，换出时就涉及到写硬盘操作）页面。</p> <p>每个页框处于下列情形之一（u:访问位，m:修改位）：</p> <ul><li>1类(u=0, m=0)：最近未被访问，又未被修改，最佳淘汰页。</li> <li>2类(u=0, m=1)：最近未被访问，但已被修改页。</li> <li>3类(u=1, m=0)：最近已被访问，但未被修改。</li> <li>4类(u=1, m=1)：最近已被访问且被修改，最不应淘汰页。</li></ul> <p>2 和 3 类选择谁先淘汰呢？其实先淘汰谁都是可以的。根据 LRU 的原则，我们优先选择 2 进行淘汰。</p> <hr> <p>算法流程：</p> <ol><li>从指针当前位置开始扫描，这次扫描对使用位不作任何修改，选择遇到的第一个页框 (u=0,m=0) 置换；——会置换掉 <code>u=0, m=0</code></li> <li>若第 1 步失败，重新扫描，选择遇到的第一个 (u=0,m=1) 的页框置换。这一过程中，将使每个扫描过的页框u置0；——会置换掉 <code>u=0, m=1</code></li> <li>若第 2 步失败，则再次重新扫描，重复第 1 步；——会置换掉 <code>u=1, m=0</code></li> <li>若第 3 步失败，则再次重新扫描，重复第 2 步；——会置换掉 <code>u=1, m=1</code></li></ol> <p>改进型时钟置换算法实现简单，性能比较理想，被广泛采用（如早期 Linux）。（后来 Linux 使用类 LRU 算法）</p> <h5 id="页缓冲"><a href="#页缓冲" class="header-anchor">#</a> 页缓冲</h5> <ul><li>置换的页，如果被修改过，就得写回辅存，代价较大。</li> <li>在内存中采用页缓冲，提高了分页性能，并允许使用更简单的页面替换策略（如 FIFO）。</li></ul> <p>置换的页面：</p> <ul><li>未修改，放入空闲页链表（由可用来存放读入页的一系列页框构成）尾部</li> <li>已修改，放入修改页链表（已修改页按簇、成批写回磁盘会更快）尾部</li></ul> <p>页缓冲的一个作用是起了类似于磁盘的高速缓存的功能。若进程访问在页缓冲的页，该页就可以被直接放到驻留集中。</p> <p>（可是为什么要拿一部分内存来作页缓冲，而不是直接把这部分内存加到进程里呢？可能是因为页缓冲是全局的，而不是每个进程都有一个）</p> <p>除此之外，页缓冲的修改页链表还有一个作用，就是使已修改的页按簇写回，大大减少了 I/O。这便是和<a href="#%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5">清除策略</a>的联动。</p> <h5 id="置换策略和高速缓存大小"><a href="#置换策略和高速缓存大小" class="header-anchor">#</a> 置换策略和高速缓存大小</h5> <p>对于较大的高速缓存，替换页会对性能产生影响：如果选择替换的页在高速缓存中，则该高速缓存块及内存中所对应的页将失效。</p> <p>在使用页缓冲的系统中，可以使用页缓冲区中的<strong>页放置策略</strong>来提高高速缓存性能。</p> <p>大多数操作系统通过从页缓冲区中选择任意页框来放置高速缓存中需置换的页，但如果使用细致的页放置策略，能减少 10%~20% 的高速缓存失效。</p> <p>具体的高速缓存结构、页放置策略超出了本书的范围。</p> <h4 id="驻留集管理"><a href="#驻留集管理" class="header-anchor">#</a> 驻留集管理</h4> <p><a href="#%E7%A1%AC%E4%BB%B6%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">驻留集定义</a></p> <h5 id="分配和置换"><a href="#分配和置换" class="header-anchor">#</a> 分配和置换</h5> <p>驻留集管理设计到了分配和置换。</p> <ol><li>页框分配，即给每个活动进行分配多少个页框
<ul><li>分配给每个进程的内存越小，可以驻留在内存中的进程越多</li> <li>若一个进程在内存中的页面少，则缺页率相对较高</li> <li>给进程分配的页框数超出一定大小后，由于局部性原理，缺页率下降到稳定水平</li></ul></li> <li>置换范围，即计划置换的页集局限于产生缺页的进程本身，还是内存内的所有进程</li></ol> <hr> <p>分配和置换算法</p> <ul><li>固定分配：在内存中为每个进程提供固定数量的页框</li> <li>可变分配：允许分配给每个进程的页框数在进程的生命周期内变化</li> <li>局部置换：仅在该进程的驻留页中选择置换对象</li> <li>全局置换：在整个内存中选择置换对象，只要不是锁定的页，都可以作为候选页</li></ul> <p>两两组合就有如下情况：</p> <table><thead><tr><th>组合</th> <th>局部置换</th> <th>全局置换</th></tr></thead> <tbody><tr><td>固定分配</td> <td>分配给进程的页框数固定；从分配给该进程的页框中选择被置换的页</td> <td>此方案逻辑上不存在</td></tr> <tr><td>可变分配</td> <td>为了保存进程的工作集，分配给进程的页框数不时变化；从分配给该进程的页框中选择被置换的页</td> <td>从内存中所有可用页框中选择被置换的页；进程驻留集大小不断变化</td></tr></tbody></table> <h6 id="固定分配-局部置换"><a href="#固定分配-局部置换" class="header-anchor">#</a> 固定分配，局部置换</h6> <ul><li>需要事先确定分配给一个进程的页框数量</li> <li>如果给进程分配的数量太少，将会产生较高的缺页率</li> <li>如果给进程分配的数量太多，内存中只有较少的程序，增加处理器空闲时间（时间用于交换）</li></ul> <h6 id="可变分配-全局置换"><a href="#可变分配-全局置换" class="header-anchor">#</a> 可变分配，全局置换</h6> <ul><li>最容易实现的方法，在很多操作系统里采用</li> <li>操作系统维护一个<strong>空闲页框列表</strong></li> <li>当缺页中断发生时，一个空闲页框分配给缺页的进程</li> <li>如果没有空闲页框，操作系统必须选择一个内存中的页框（没有锁定，没有被内核占用）作为置换对象</li> <li>如果选择置换对象不当，将容易再次产生缺页中断，使用页缓冲可以缓解这个问题</li></ul> <h6 id="可变分配-局部置换"><a href="#可变分配-局部置换" class="header-anchor">#</a> 可变分配，局部置换</h6> <ul><li>当一个新进程装入内存时，分配一定数量的页框作为它的驻留集</li> <li>当缺页中断发生时，从进程驻留集中选择一页用于置换</li> <li>不时重新评估进程的页框分配情况，增加或减少分配的页框，以提高整体性能</li></ul> <p>这种组合的关键要素：</p> <ul><li>决定驻留集大小的原则</li> <li>驻留集大小变化的时机</li></ul> <p>于是产生了工作集的概念。尽管真正的工作集策略很难实现，但它可作为比较各种策略的标准。</p> <h5 id="工作集"><a href="#工作集" class="header-anchor">#</a> 工作集</h5> <p>定义：进程在虚拟时刻为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span></span>、参数为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">Δ</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span></span> 的工作集 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(t, Δ)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span></span></span></span></span>，表示该进程在 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span></span> 时刻，过去的 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">Δ</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span></span> 个虚拟时间单位（即 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mi mathvariant="normal">Δ</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>t</mi><mo>−</mo><mi mathvariant="normal">Δ</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">t-Δ+1, t-Δ+2, ..., t</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span></span></span></span></span> 时刻）被访问到的页的集合。</p> <p>虚拟时刻的定义是靠进程访问内存的次数实现：例如进程一系列的内存访问为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>…</mo><mi>r</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(1),r(2),…r(i)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span>， <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(i)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span> 表示第 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 次对内存页的访问，对应的虚拟时间为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>,<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span>,…<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>。</p> <p><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">Δ</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span></span> 为给定的虚拟时刻时，进程的窗口大小。</p> <p>显然，虚拟时刻窗口越大，则工作集越大。即：</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⊇</mo><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(t, \Delta+1) \supseteq W(t, \Delta)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊇</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Δ</span><span class="mclose">)</span></span></span></span></span></div></section><hr> <p>如下为一个工作集的示例。</p> <p><img src="/images/b7920729631fd56f498e74d5889e1a921200ab46e6d5c4ae56b88b21d087b462.png" alt="工作集示例"></p> <hr> <p>对于固定的 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">Δ</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span></span> ，工作集大小随时间变化的情况：<strong>稳定阶段和快速变化阶段交替出现</strong>。这是因为局部性原理。</p> <p><img src="/images/83616be563b9674b8ad740204a805c8db027dc863c50cf4e7fa077a4d107b6a5.png" alt="工作集大小随时间变化的情况"></p> <hr> <p>工作集的概念可用于指导有关驻留集大小的策略：</p> <ol><li>根据工作集来决定驻留集的大小</li> <li>周期性的从驻留集中移去不在工作集中的页（近似 LRU）</li> <li>只有驻留集包含工作集时，才执行进程</li></ol> <p>这种策略很有吸引力，因为它采用了一个公认的原理——局部性原理，并利用该原理设计了一个可以减少缺页中断的内存管理策略。遗憾的是，工作集策略仍然存在许多问题:</p> <ol><li>工作集大小随时间变化</li> <li>给每个进程测量工作集不现实</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">Δ</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span></span> 最优值未知</li></ol> <p>所以产生了近似工作集策略（代表性算法：PFF，VSWS）：</p> <ul><li>用缺页率指导驻留集</li> <li>缺页率低于某个阈值时，减小驻留集</li> <li>缺页率超过某个阈值时，增加驻留集</li></ul> <h5 id="例题-4"><a href="#例题-4" class="header-anchor">#</a> 例题</h5> <p>设某计算机的逻辑地址空间和物理地址空间均为 64KB，按字节编址。若某进程最多需要 6 页存储空间，页的大小为 1KB。操作系统采用固定分配局部置换为此进程分配 4 个页框，如下表所示。</p> <p><img src="/images/11485e679996330f27f95b2c49a9a704fb061f5528b933a041fee569fc125cfa.png" alt="页表 &amp; 时钟置换算法图"></p> <p>若该进程执行到 260 时刻时，要访问逻辑地址为 17CAH 的数据，请回答：</p> <ol><li>该逻辑地址对应的页号是多少？</li> <li>若采用先进先出 (FIFO) 置换算法，该逻辑地址对应的物理地址是多少？要求给出计算过程。</li> <li>若采用时钟 (CLOCK) 置换算法，该逻辑地址对应的物理地址是多少？要求给出计算过程（设搜索下一页的指针沿着顺时针方向移动，且当前指向 2 号页框，所有页框 <code>use</code> 标志均为 1，如上图所示）</li></ol> <hr> <ol><li>1KB 页号意味着 17CAH 的后十位为页内偏移地址，前 6 位（000101B，<strong>5</strong>）为页号（故需要置换）</li> <li>FIFO 应该换掉最早装入的 7 号页框。故换入后，页框号为 7，物理地址为 7 拼接 17CAH 的后十位，为 <strong>1ECAH</strong>。</li> <li>根据时钟算法，程序会查找一圈，将四个页框依次标记为 <code>use=0</code>；然后遍历到 2，淘汰掉 2 号页框并换入。物理地址为 2 拼接 17CAH 的后十位，为 <strong>0BCAH</strong>。</li></ol> <h5 id="平均访问时间"><a href="#平均访问时间" class="header-anchor">#</a> 平均访问时间</h5> <p>若缺页率为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>，内存的访问时间为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span></span></span></span></span>，发生缺页时的访问时间为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">da</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span></span></span></span></span>，则平均访问时间为：</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>m</mi><mi>a</mi><mo>+</mo><mi>p</mi><mo>∗</mo><mi>d</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">(1-p)*ma+p*da</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span></span></span></span></span></div></section><p>就是一个简单的已知概率算期望。</p> <p>发生缺页时访问时间 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">da</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span></span></span></span></span> 的构成：</p> <ul><li>缺页中断服务时间</li> <li>页面写出时间（若需置换）</li> <li>页面调入时间—— 20ms（寻道时间+旋转时间+数据传送时间）</li> <li>重新访问内存指令时间</li></ul> <p>由于 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span></span></span></span></span> 很小（&lt;10ns），因此很低的缺页率也会导致很大的平均访问时间。</p> <hr> <p>例题 1：</p> <p>假设内存的访问时间为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">10ns</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span></span>，发生缺页的访问时间为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>21</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">21ms</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span></span>，若因为缺页而出现的性能降低不超过 10%，则缺页率的最大数值为多少？</p> <p>下降 10% 的有效访问时间应不超过 10*(1+10%)=11ns</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn><mo>≥</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>10</mn><mo>+</mo><mn>21</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo>∗</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">11 \geq (1-p)*10+21*10^6*p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span></div></section><p>解得 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>8</mn></mrow></msup></mrow><annotation encoding="application/x-tex">p \leq 5 \times 10^{-8}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span></span>。</p> <p>可见很低的缺页率也会导致很大的平均访问时间。</p> <hr> <p>例题 2：</p> <p>请求分页管理系统中，假设某进程的页表内容如下：</p> <p><img src="/images/8dd60ca1107eff2e6a3849d342bcad2bc383fa4286725422ecdab47d1ad829e7.png" alt="某进程的页表"></p> <p>页面大小为 4 KB，一次内存的访问时间是 100ns，一次快表 (TLB) 的访问时间是 10ns，更新快表的时间为 20ns，处理一次缺页的平均时间为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>ns (只更新页表，不更新快表)，进程的驻留集大小固定为 2，采用最近最少使用置换算法 (LRU) 和局部淘汰策略。假设：① TLB 初始为空；② 有效位为 0 表示页面不在内存。</p> <p>设有虚地址访问序列 2BEAH、1CADH、2242H，问：</p> <ol><li>依次访问上述三个虚地址，各需要多少时间？</li> <li>基于上述访问序列，虚地址 1CADH、2242H 的物理地址是多少？</li></ol> <hr> <p>页大小为 4 KB，故页内偏移占后 12 位。三次访问的页号分别为 2、1、2。</p> <p>第一问计算访问时间，访问流程可参考 <a href="#%E8%BD%AC%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88%E5%BF%AB%E8%A1%A8%EF%BC%89">转换检测缓冲区（快表）</a> 中的流程图，如下。</p> <p><img src="/images/1d1d92faf6314df73aa23f53579d80a2b8e047a43d19d3702a78e7dfeab1a0ca.png" alt="具有快表的地址转换流程图"></p> <ol><li>访问第 2 页：访问 TLB + 访问页表（访问内存） + 更新 TLB + 访问页面（访问内存） = 230ns</li> <li>访问第 1 页：访问 TLB + 访问页表（访问内存） + 处理缺页 + 访问 TLB + 访问页表（访问内存） + 更新 TLB + 访问页面（访问内存）= 100000340ns</li> <li>再次访问第 2 页：访问 TLB + 访问页面（访问内存）= 110ns</li></ol> <p>第二问，在访问 1CADH 时发生缺页，根据 LRU 和局部淘汰策略，<strong>将把 0 页换出</strong>，故更新后，1 页的页框号将为 CA2H。1CADH 的物理地址为 <code>CA2CADH</code>；2242H 的物理地址为 <code>B2F242H</code>。</p> <h4 id="清除策略"><a href="#清除策略" class="header-anchor">#</a> 清除策略</h4> <p>清除策略用于确定何时将修改过的页写回辅存。</p> <ul><li>按需清除 (Demand cleaning)：只有当该页被置换时，才写回辅存。但缺页中断后，需进行两次页传送（<code>写回原页</code> 和 <code>读入新页</code>），降低处理器利用率</li> <li>预清除 (Precleaning)：将修改的多页在被置换前，成批写回辅存。但预先写回辅存的页，在置换前可能又会被修改，使得预清除意义不大</li></ul> <p>一种较好的方法是<strong>结合<a href="#%E9%A1%B5%E7%BC%93%E5%86%B2">页缓冲技术</a>的按需清除</strong>：去掉了 <code>写回原页</code> 和 <code>读入新页</code> 的成对关系。当页被置换时，不立即将该页写回磁盘，而是加入页缓冲；页缓冲就负责在某个时刻将修改的页成批写回辅存。</p> <h4 id="加载控制"><a href="#加载控制" class="header-anchor">#</a> 加载控制</h4> <p>加载控制决定驻留在内存中的进程的数量，这称为<strong>多道程序度</strong> (<code>multiprogramming level</code>，也称系统并发度)。</p> <p>加载控制对于有效的内存管理来讲非常重要：</p> <ul><li>内存驻留的进程太少 <code>-&gt;</code> 所有进程都阻塞的概率变大 <code>-&gt;</code> 大量时间花在交换上</li> <li>内存驻留的进程太多 <code>-&gt;</code> 平均每个进程的驻留集变小 <code>-&gt;</code> 不够用 <code>-&gt;</code> 频繁缺页中断 <code>-&gt;</code> 抖动</li></ul> <p><img src="/images/d886d871e2adae3e47dbf668c7f3f32e0a50c3068a472ee5a5f95fa51d56b82a.png" alt="多道程序度对处理器利用率的影响"></p> <hr> <p>一种思路是 <strong>L=S 准则</strong> (Denning 1980)：发生缺页的平均时间 L 等于处理缺页故障的平均时间 S，此时处理器的利用率最大。</p> <p>（相当于处理完一个缺页后，刚好下一个缺页发生了）</p> <p>另一种思路是监测 Clock 置换算法中指针扫描的速度：</p> <ul><li>速度低，缺页率低，增加多道程序度</li> <li>速度高，缺页率高或多道程序度高，降低多道程序度</li></ul> <hr> <p>进程挂起系统并发度减小时，一个或多个当前驻留进程须被挂起 (换出)。可以有下面 6 种选择方式:</p> <ul><li>最低优先级进程</li> <li>缺页中断的进程</li> <li>最后被激活的进程</li> <li>具有最小驻留集的进程</li> <li>最大空间的进程</li> <li>具有最大剩余执行时间的进程</li></ul> <h2 id="四-i-o-管理与磁盘调度"><a href="#四-i-o-管理与磁盘调度" class="header-anchor">#</a> 四 I/O 管理与磁盘调度</h2> <h2 id="五-文件系统"><a href="#五-文件系统" class="header-anchor">#</a> 五 文件系统</h2> <h3 id="概述-2"><a href="#概述-2" class="header-anchor">#</a> 概述</h3> <h4 id="文件"><a href="#文件" class="header-anchor">#</a> 文件</h4> <p>文件是用户或系统创建的数据集。从用户的角度来看，文件是操作系统的重要组成部分</p> <p>文件拥有的理想属性：</p> <ul><li>长期存在（文件存储在硬盘或其它辅存中，用户退出系统时文件不会消失）</li> <li>可在进程间共享（文件有名字，具有允许受控共享的相关访问权限）</li> <li>结构（文件可以组织成为层次结构或更复杂的结构，以反映文件之间的关系）</li></ul> <h4 id="文件系统"><a href="#文件系统" class="header-anchor">#</a> 文件系统</h4> <p>文件系统是提供存储数据的手段，且提供一系列对文件进行操作的功能接口（创建、删除、打开、关闭、读、写等）。</p> <p>文件系统还会为文件维护一组属性（所有者、创建时间、修改时间等）。</p> <h4 id="文件结构"><a href="#文件结构" class="header-anchor">#</a> 文件结构</h4> <p>讨论文件时通常要用到如下 4 个术语：</p> <ul><li><strong>域</strong>：基本数据单元。包含一个值（如雇员的名字、日期、传感器读取的值），定长或变长</li> <li><strong>记录</strong>：域的集合，可视为应用程序的一个单元。如雇员记录，，其中包含域：名字、工作名、雇用日期等。</li> <li><strong>文件</strong>：一组相似记录的集合，可被用户和应用程序视为一个实体。文件通过名字访问，且访问控制通常在文件级实施</li> <li><strong>数据库</strong>：相关数据的集合，元素中存在明确关系。数据库供不同应用程序使用。</li></ul> <h4 id="文件管理系统"><a href="#文件管理系统" class="header-anchor">#</a> 文件管理系统</h4> <p>文件管理系统需满足以下目标：</p> <ul><li>满足数据管理要求和用户需求</li> <li>保证文件中的数据有效</li> <li>优化性能</li> <li>为各种类型的存储设备提供 I/O 支持</li> <li>最大限度地减少丢失或破坏数据的可能性</li> <li>为用户进程提供标准 I/O 接口例程集</li> <li>在多用户系统中为多个用户提供 I/O 支持</li></ul> <p>第一条中，用户需求的最小范围应包含：</p> <p>用户能够：</p> <ol><li>创建、删除、读取和修改文件</li> <li>受控地访问其他用户的文件</li> <li>允许进行哪些类型的访问</li> <li>以适合问题的形式重组文件</li> <li>在文件间移动数据</li> <li>备份文件，且在文件遭到破坏时恢复文件</li> <li>通过名字而非数字标识符访问自己的文件</li></ol> <h5 id="文件系统架构"><a href="#文件系统架构" class="header-anchor">#</a> 文件系统架构</h5> <p><img src="/images/aaac90395df46d6c7c76edd608f6db4b3f4e4707dc3f68909c29e58c9c2cdf56.png" alt="文件系统架构"></p> <ul><li>设备驱动
<ul><li>最底层</li> <li>直接与外围设备（或它们的控制器或通道）通信</li> <li>负责启动设备上的 I/O 操作</li> <li>处理 I/O 请求的完成</li> <li>通常视为操作系统的一个组成部分</li></ul></li> <li>基本文件系统
<ul><li>称为物理 I/O 层</li> <li>与计算机外部环境的基本接口</li> <li>处理在磁盘间或磁带系统间的数据块</li> <li>关注数据块在辅存的放置位置</li> <li>关注数据块在内存缓冲区的放置位置</li> <li>通常视为操作系统的一个组成部分</li></ul></li> <li>基本I/O管理程序
<ul><li>负责所有文件I/O的初始化和终止</li> <li>维护处理设备I/O，调度和文件状态的控制结构</li> <li>选择要执行I/O的设备</li> <li>关注调度磁盘和磁带访问以优化性能</li> <li>I/O缓冲区的指定和辅存的分配</li> <li>通常视为操作系统的一个组成部分</li></ul></li> <li>逻辑I/O
<ul><li>使用户和应用程序能够访问记录</li> <li>提供一种通用的记录I/O能力</li> <li>维护文件基本数据</li></ul></li> <li>访问方法
<ul><li>文件系统中与用户最近的一层</li> <li>提供应用程序和文件系统以及保存数据的设备之间的标准接口</li> <li>不同的访问方法反映了不同的文件结构以及访问和处理数据的不同方式</li></ul></li></ul> <p>???</p> <h5 id="文件管理功能"><a href="#文件管理功能" class="header-anchor">#</a> 文件管理功能</h5> <ul><li>用户和应用程序通过文件操作与文件系统交互，通过目录确定文件的位置。</li> <li>授权用户以特定的方式访问特定的文件；</li> <li>用户通过文件操作函数，基于字符流／或记录来操作文件；</li> <li>系统对文件的I/O是以块为单位，基于块来完成输入／输出；</li> <li>操作系统需要为文件在磁盘上分配空闲块，同时还需要管理空闲空间。</li></ul> <p><img src="/images/6b498d40421b1a0918ab5b86900280ed462881f5da0a002508453ae8da213eb4.png" alt="文件管理的要素"></p> <p>？？？</p> <h3 id="文件的组织和访问-重点"><a href="#文件的组织和访问-重点" class="header-anchor">#</a> 文件的组织和访问（重点）</h3> <p><strong>文件组织</strong> (file  organization) 指文件中记录的逻辑结构，由用户访问记录的方式确定。</p> <p>选择文件组织的 5 个重要原则：</p> <ul><li>快速访问</li> <li>易于修改</li> <li>节约存储空间</li> <li>维护简单</li> <li>可靠性</li></ul> <p>原则的优先级取决于使用文件的应用程序。</p> <p>五种基本文件组织：</p> <ul><li>堆</li> <li>顺序文件</li> <li>索引顺序文件</li> <li>索引文件</li> <li>直接或散列文件</li></ul> <h4 id="堆文件"><a href="#堆文件" class="header-anchor">#</a> 堆文件</h4> <ul><li>最简单的文件组织形式</li> <li>按照到达的顺序收集数据</li> <li>每条记录由一串数据组成</li> <li>目的是积累大量数据并保存</li> <li>通过穷举查找方法检索记录</li></ul> <p><img src="/images/e097ad767ac04bda19c4a764d85e95421febdf8c934d3b5bc314d3d7d1d8e1d8.png" alt="堆文件"></p> <h4 id="顺序文件"><a href="#顺序文件" class="header-anchor">#</a> 顺序文件</h4> <ul><li>最常见的文件组织形式</li> <li>记录有固定的格式</li> <li>所有记录的长度都相同：每个域的位置、长度等相同</li> <li>每个记录中有一个<strong>关键域</strong>，唯一标识这个记录</li> <li>记录按照关键域存储和排序</li> <li>通常用于批处理应用中</li> <li>可以很容易地存储在磁盘和磁带</li></ul> <p><img src="/images/074d2a733535a7e00cba4c9acabd812d138f7bf6515943d85b407fe4a7f0a92d.png" alt="顺序文件"></p> <h4 id="索引顺序文件"><a href="#索引顺序文件" class="header-anchor">#</a> 索引顺序文件</h4> <ul><li>保留顺序文件的关键特征：记录按照关键域组织</li> <li>增加了<strong>支持随机访问</strong>的索引和<strong>溢出文件</strong></li> <li>索引提供快速接近目标的查找能力</li> <li>溢出文件类似日志文件，要往文件中插入记录时，可以将其放在溢出文件中，并由主文件中它(即所插入记录)的前一个记用指针指向它</li> <li>可按批处理方式合并溢出文件</li> <li>索引可以有多级，类似于多级页表</li></ul> <p><img src="/images/52963cc100f4745ef41ae391c12ce60df792ac2f9276c9a3280129a0d7e41387.png" alt="索引顺序文件"></p> <p>索引文件：</p> <ul><li>只能通过索引访问记录</li> <li>可以使用变长度记录</li> <li>完全索引包含主文件中每条记录的索引项</li> <li>部分索引只包含有感兴趣域的记录的索引项</li> <li>主要用于信息及时性要求比较严格且很少对所有数据进行处理的应用程序</li></ul> <p><img src="/images/ee609aaa5a86eba80ebb101718189fc4233623749a621be91db73a4b22d89bdf.png" alt="索引文件"></p> <h4 id="直接文件或散列文件"><a href="#直接文件或散列文件" class="header-anchor">#</a> 直接文件或散列文件</h4> <ul><li>直接访问磁盘中任意一个地址已知的数据块</li> <li>使用基于关键字的散列</li> <li>典型应用场景：
<ul><li>快速访问；</li> <li>固定长度的记录</li> <li>一次只访问一条记录</li></ul></li> <li>例子:
<ul><li>目录</li> <li>价格表</li> <li>调度</li> <li>名字列表</li></ul></li></ul> <h3 id="文件目录"><a href="#文件目录" class="header-anchor">#</a> 文件目录</h3> <p>文件目录里每个文件项包含的信息：</p> <ul><li>基本信息</li> <li>地址信息</li> <li>访问控制信息</li> <li>使用信息</li></ul> <h3 id="硬链接"><a href="#硬链接" class="header-anchor">#</a> 硬链接</h3> <p>硬链接目录不允许目录链接，防止目录套娃（ggd）</p> <h3 id="文件分配方法-重点"><a href="#文件分配方法-重点" class="header-anchor">#</a> 文件分配方法（重点）</h3></div> <hr role="separator" aria-orientation="horizontal" class="ma-4 v-divider theme--light"> <div data-v-54a1e472><script src="https://giscus.app/client.js" async="async" service="giscus" data-repo="lyh543/blog-comments" data-repo-id="R_kgDOHIb2Zg" data-category="Announcements" data-category-id="DIC_kwDOHIb2Zs4COh2z" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" data-v-54a1e472></script></div></div></div></article></div> <!----></container> <div class="v-dialog__container"><button type="button" role="button" aria-haspopup="true" aria-expanded="false" class="v-btn v-btn--bottom v-btn--is-elevated v-btn--fab v-btn--fixed v-btn--has-bg v-btn--right v-btn--round theme--dark v-size--default primary"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-information-variant theme--dark"></i></span></button><!----></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2024</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0525e26f.js" defer></script><script src="/assets/js/37.26ee27a3.js" defer></script>
  </body>
</html>
