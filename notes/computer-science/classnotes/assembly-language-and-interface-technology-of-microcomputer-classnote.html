<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>汇编语言与微机接口技术 课程笔记 | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/theme/favicon.png">
    <link rel="alternate" type="application/rss+xml" href="https://blog.lyh543.cn/rss.xml" title="小灰灰灰灰的博客 RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://blog.lyh543.cn/feed.atom" title="小灰灰灰灰的博客 Atom Feed">
    <link rel="alternate" type="application/json" href="https://blog.lyh543.cn/feed.json" title="小灰灰灰灰的博客 JSON Feed">
    <meta name="description" content="授课老师：廖建明老师
教材：《微机原理与接口技术》(第4版). 吴宁,乔亚男主编. 清华大学出版社
参考教材:《汇编语言程序设计》. 廖建明主编.清华大学出版社

第一章 微型计算机基础概论

计算机的工作原理

计算机中的指令执行过程：取指令 -&gt; 指令译码 -&gt; 读取操作数 -&gt; 执行命令 -&gt; 存放结果

![计算机基本组成结构](/images/2b125ce68 ...">
    
    <link rel="preload" href="/assets/css/0.styles.94ecd5c7.css" as="style"><link rel="preload" href="/assets/js/app.0113cb43.js" as="script"><link rel="preload" href="/assets/js/31.26e285be.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.94ecd5c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><div class="container"><div class="row justify-center"><div class="col-sm-9 col-12"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><div class="v-card v-sheet theme--light"><div class="container"><div itemprop="articleBody" class="markdown-body content__default"><ul><li>授课老师：廖建明老师</li> <li>教材：《微机原理与接口技术》(第4版). 吴宁,乔亚男主编. 清华大学出版社</li> <li>参考教材:《汇编语言程序设计》. 廖建明主编.清华大学出版社</li></ul> <h2 id="第一章-微型计算机基础概论"><a href="#第一章-微型计算机基础概论" class="header-anchor">#</a> 第一章 微型计算机基础概论</h2> <h3 id="计算机的工作原理"><a href="#计算机的工作原理" class="header-anchor">#</a> 计算机的工作原理</h3> <p>计算机中的指令执行过程：取指令 -&gt; 指令译码 -&gt; 读取操作数 -&gt; 执行命令 -&gt; 存放结果</p> <p><img src="/images/2b125ce6885b6eddbe43b0c1b94ea20d5b0f18a475587854d4bda793f548e73f.png" alt="计算机基本组成结构"></p> <p>指令的顺序工作方式和并行流水线工作方式</p> <ul><li>冯 • 诺依曼计算机的工作原理：
<ul><li>存储程序工作方式</li> <li>运算器为核心</li></ul></li> <li>特点：
<ul><li>存储程序，共享数据，顺序执行；</li> <li>属于顺序处理机，适于确定的算法和数值处理。</li></ul></li> <li>不足：
<ul><li>与存储器间有大量数据交互，对总线要求很高；</li> <li>执行顺序由程序决定，对大型复杂任务较难处理；</li> <li>以运算器为核心，处理效率较低；
由PC控制执行顺序，难以进行真正的并行处理。</li></ul></li></ul> <p>非冯 • 诺依曼计算机：并行性</p> <h3 id="微机系统组成"><a href="#微机系统组成" class="header-anchor">#</a> 微机系统组成</h3> <ul><li>微处理器：<strong>运算器单元+控制器单元+寄存器单元+内部总线</strong>，具有CPU全部功能的大规模集成电路芯片。</li> <li>微型机：<strong>微处理器+内存+I/O接口+系统总线+电源+输入/输出设备+外存设备</strong></li> <li>微机系统：<strong>微型机+系统软件+应用软件</strong></li></ul> <h2 id="第二章-微处理器"><a href="#第二章-微处理器" class="header-anchor">#</a> 第二章 微处理器</h2> <h3 id="_8086-8088-特点、工作模式"><a href="#_8086-8088-特点、工作模式" class="header-anchor">#</a> 8086/8088 特点、工作模式</h3> <p>特点：并行流水线、内存空间分段管理、多处理器系统</p> <p>工作模式：最小（单处理器，不必接总线控制器）/最大（多处理器，需总线控制器）</p> <p><img src="/images/7ad14e65b5c37de1842d043b016c76a8d3bd32ce0a7851e280bdc84c13ebcb99.png" alt="最小模式下的总线连接示意图"></p> <p><img src="/images/155a118f5171dbabacdf915d12b68eaa987f1b740a9d36ddda8463d00aebb92e.png" alt="最大模式下的总线连接示意图"></p> <p>工作模式选择：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>N</mi><mi mathvariant="normal">/</mi><mover accent="true"><mrow><mi>M</mi><mi>X</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">MN/\overline{MX}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>引脚</p> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>N</mi><mi mathvariant="normal">/</mi><mover accent="true"><mrow><mi>M</mi><mi>X</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">MN/\overline{MX}=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span>：最大模式</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>N</mi><mi mathvariant="normal">/</mi><mover accent="true"><mrow><mi>M</mi><mi>X</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">MN/\overline{MX}=1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>：最小模式</li></ul> <h3 id="_8086-8088-引线及功能"><a href="#_8086-8088-引线及功能" class="header-anchor">#</a> 8086/8088 引线及功能</h3> <h4 id="地址线和数据线"><a href="#地址线和数据线" class="header-anchor">#</a> 地址线和数据线</h4> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>D</mi><mn>0</mn><mo>−</mo><mi>A</mi><mi>D</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">AD0-AD7</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">7</span></span></span></span></span>：低 8 位地址和低 8 位数据信号（分时复用）。传送地址时单向，传送数据时双</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>8</mn><mo>−</mo><mi>A</mi><mn>15</mn></mrow><annotation encoding="application/x-tex">A8-A15</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord">1</span><span class="mord">5</span></span></span></span></span>：8位地址信号</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mn>16</mn><mo>−</mo><mi>A</mi><mn>19</mn><mi mathvariant="normal">/</mi><mi>S</mi><mn>3</mn><mo>−</mo><mi>S</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">A16-A19/S3-S6</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">1</span><span class="mord">9</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">6</span></span></span></span></span>：高4位地址信号，与状态信号分时复用</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>W</mi><mi>R</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{WR}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>：写信号</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>R</mi><mi>D</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{RD}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>：读信号</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>O</mi><mi mathvariant="normal">/</mi><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">IO/\overline{M}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>：访问内存/访问接口</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>D</mi><mi>E</mi><mi>N</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{DEN}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>：低电平有效时，数据总线上数据有效，允许进行读/写操作</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>T</mi><mi mathvariant="normal">/</mi><mover accent="true"><mi>R</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">DT/\overline{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>(Data Transmit/ Receive)：为“1”时 CPU 向存储器或 I/O 传送，否则为反向</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>L</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">ALE</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></span>：地址锁存信号，当其为高时表示地址线上地址有效。一般用它将地址锁存到一个锁存器中</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>E</mi><mi>S</mi><mi>E</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">RESET</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span>：复位信号。当其为高时将完成CPU内部复位。复位后CPU内部寄存器的值如下表</li></ul> <p><img src="/images/6496134227c8788122f9189f659d55960174a1226f8bdb7595368e5b24ee7f3d.png" alt="复位后 CPU 的内部寄存器状态"></p> <p><img src="/images/400c11160d21c24a4001d80071e2fef1906a764604fe8d687d74affc03defa92.png" alt="例题"></p> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>E</mi><mi>A</mi><mi>D</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">READY</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></span>：外部同步控制输入信号，高电平有效（8088 与内存/外设之间在一个总线周期内的时钟配合信号）</li></ul> <h4 id="中断请求和响应信号"><a href="#中断请求和响应信号" class="header-anchor">#</a> 中断请求和响应信号</h4> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">INTR</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></span>：可屏蔽中断请求输入端</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>M</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">NMI</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span></span>： 非屏蔽中断请求输入端</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>：中断响应输出端</li></ul> <h4 id="总线保持信号"><a href="#总线保持信号" class="header-anchor">#</a> 总线保持信号</h4> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>O</mi><mi>L</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">HOLD</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span></span>：总线保持请求信号输入端。当 CPU 以外的其他设备要求占用总线时，通过该引脚向 CPU 发出请求（外设 -&gt; CPU）</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>L</mi><mi>D</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">HLDA</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">A</span></span></span></span></span>：总线保持响应信号输出端。CPU 对 HOLD 信号的响应信号（CPU -&gt; 外设）</li></ul> <h3 id="_8088-和-8086-cpu-引线的差异"><a href="#_8088-和-8086-cpu-引线的差异" class="header-anchor">#</a> 8088 和 8086 CPU 引线的差异</h3> <ul><li>数据总线宽度不同
<ul><li>8088的外部总线宽度是8位，8086为16位。</li></ul></li> <li>访问存储器和I/O控制的信号含义不同
<ul><li>8088——<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>O</mi><mi mathvariant="normal">/</mi><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">IO/\overline{M}=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span> 表示访问内存；</li> <li>8086——<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>O</mi></mrow><mo stretchy="true">‾</mo></mover><mi mathvariant="normal">/</mi><mi>M</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\overline{IO}/M=1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span> 表示访问内存。</li></ul></li></ul> <h3 id="_8088-8086-内部结构"><a href="#_8088-8086-内部结构" class="header-anchor">#</a> 8088/8086 内部结构</h3> <ul><li>执行单元 EU</li> <li>总线接口单元 BIU</li></ul> <p><img src="/images/cafe7330e111a3f1db574ccbf7a1fcd0f4a47c03fd9cb14a0f846ce6a3066737.png" alt="8086CPU结构"></p> <p>执行单元 EU</p> <ul><li>组成：
<ul><li>ALU</li> <li>8 个通用寄存器</li> <li>1 个标志寄存器</li> <li>EU 部分的控制电路</li></ul></li> <li>功能：
<ul><li>指令译码</li> <li>指令执行</li> <li>暂存中间运算结果</li> <li>保存运算结果特征</li></ul></li></ul> <p>总线接口单元 BIU</p> <ul><li>组成：
<ul><li>地址加法器</li> <li>4 个段寄存器</li> <li>指令指针 IP</li> <li>总线控制逻辑</li></ul></li> <li>功能：
<ul><li>从内存中取指令到指令队列（指令队列是并行流水线工作的基础）</li> <li>负责与内存或 I/O 接口之间的数据传送</li> <li>在执行转移程序时，BIU 清除指令队列，从指定的新地址取指令，并立即传给执行单元执行</li></ul></li></ul> <h3 id="_8088-8086-内部寄存器"><a href="#_8088-8086-内部寄存器" class="header-anchor">#</a> 8088/8086 内部寄存器</h3> <ul><li>16 位寄存器
<ul><li>8个通用寄存器</li> <li>4个段寄存器</li> <li>2个控制寄存器</li></ul></li></ul> <h4 id="通用寄存器"><a href="#通用寄存器" class="header-anchor">#</a> 通用寄存器</h4> <ul><li>数据寄存器：AX、BX、CX、DX
<ul><li>AX 分为 <code>AH:AL</code>，以此类推</li> <li>AX: Add</li> <li>BX: Base 基址寄存器</li> <li>CX: Count 计数</li> <li>DX: Data
<ul><li>在间接寻址的 I/O 指令中存放 I/O 端口地址</li> <li>在 32 位乘除法运算时，存高 16 位数</li></ul></li></ul></li> <li>地址指针寄存器：SP、BP
<ul><li>SP: Stack Pointer 栈顶的偏移地址</li> <li>BP: Base Pointer 基址指针寄存器，访问内存时存放内存单元的偏移地址
<ul><li>BX BP 作为通用寄存器，二者均可用于存放数据</li> <li>作为基址寄存器，用 BX 表示所寻找的数据在数据段；用 BP 则表示数据在堆栈段</li></ul></li></ul></li> <li>变址寄存器 <code>Index Register</code>：SI、DI 存放数据在内存中的地址
<ul><li>SI (Source Index)：源</li> <li>DI (Destination Index)：目标</li></ul></li></ul> <h4 id="控制寄存器"><a href="#控制寄存器" class="header-anchor">#</a> 控制寄存器</h4> <ul><li>IP (Instruction Pointer)：指令指针寄存器，其内容为下一条要执行指令的偏移地址</li> <li>FLAGS：CF、SF、AF、PF、OF、ZF、IF、TF、DF
<ul><li>CF (Carry Flag)：进位标志位</li> <li>SF (Signal Flag)：符号标志位</li> <li>AF (Auxility Flag)：辅助 CF。若 Bit3 向 Bit4 有进位(借位)，<code>AF=1</code> <ul><li><strong>Bit 号从 0 开始，用中文描述就是第四位向第五位有进位。</strong></li> <li>**在 16 位加法中，AF 仍然是 Bit3 向 Bit4 进位的结果。**详见 <a href="https://stackoverflow.com/questions/36492553/how-to-set-auxiliary-flag-for-16bits-binary-addition" target="_blank" rel="noopener noreferrer">assembly - how to set auxiliary flag for 16bits binary addition - Stack Overflow<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li>PF (Parity Flag)：奇偶标志位，运算结果的低 8 位中 <code>1</code> 的个数为偶数时 <code>PF=1</code></li> <li>OF (Overflow Flag)：溢出标志位</li> <li>ZF (Zero Flag)：零标志位</li> <li>TF (Trap Flag)：陷阱标志位，<code>TF=1</code> 使 CPU 处于单步执行指令</li> <li>IF (Interrupt Flag)：允许中断标志位</li> <li>DF (Direction Flag)：方向标志位。在数据串操作时确定操作的方向。</li></ul></li></ul> <p><img src="/images/a52f6b563d277084286fabdc71037dc19a5d732c34de36e070670376d34ef179.png" alt="例题"></p> <h4 id="段寄存器"><a href="#段寄存器" class="header-anchor">#</a> 段寄存器</h4> <ul><li>作用：用于存放相应逻辑段的段基地址</li> <li>8086/8088 内存中逻辑段的类型：代码段、数据段、附加段、堆栈段</li> <li>8086/8088 内存中逻辑段的数量
<ul><li>最多为 64K 个</li> <li>程序中同时可以使用4个段，分别由CS、DS、ES和SS四个段寄存器指示。</li></ul></li> <li>CS (Code Segment)：代码段寄存器，存放代码段的段基地址。</li> <li>DS (Data Segment)：数据段寄存器，存放数据段的段基地址。</li> <li>ES (Extended Segment)：附加段寄存器，存放数据段的段基地址。</li> <li>SS (Stack Segment)：堆栈段寄存器，存放堆栈段的段基地址。</li></ul> <p><img src="/images/98680035b5a29445842f7489e2f5bfc56cebba8a27c8b951523eca8fae9fcf61.png" alt="段寄存器"></p> <h3 id="_8088-8086-存储器组织"><a href="#_8088-8086-存储器组织" class="header-anchor">#</a> 8088/8086 存储器组织</h3> <p>内存地址分为物理地址、逻辑地址。</p> <p>物理地址：8086/8088 CPU有 20 根地址线，它可以产生 20 位的地址码，寻址范围为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^20</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span></span>，即 1 兆字节空间。</p> <p>字单元：任何两个相邻字节单元构成，16 bits</p> <ul><li>子单元地址：字节较小地址</li> <li>存放规则：<strong>小端</strong></li></ul> <p><img src="/images/0b6da650308dced8aadba7cd9c0fed64fd1c1ec9ee3231a82918654770f4a920.png" alt="例题"></p> <ul><li>32-bit 逻辑地址 = 16-bit 段基地址 <code>:</code>（拼接） 16-bit 段内地址</li> <li>20-bit 物理地址：16-bit 段基地址 <code>*16+</code> 16-bit 偏移地址
<ul><li>段首的偏移地址 = <code>0000H</code></li></ul></li></ul> <p><img src="/images/468d81f9a1623be2e0ff52fa5f0910af4f05b6e3ec0bf0d92df5611edcdad93c.png" alt="例题"></p> <h4 id="_8086-8088-的存储器段结构的特点"><a href="#_8086-8088-的存储器段结构的特点" class="header-anchor">#</a> 8086/8088 的存储器段结构的特点</h4> <ol><li>段大小 &lt;= 64KB</li> <li>段首地址为一个小节的首地址</li></ol> <ul><li>小节：每 16 Bytes 为一小节</li> <li>小节的首地址最低位为 <code>0000</code></li></ul> <ol start="3"><li>逻辑段在物理上可能是：可邻接的、间隔的、部分重叠的或完全重叠的</li> <li>在任一时刻，一个程序只能访问4个<a href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">当前段</a>中的内容</li></ol> <p><img src="/images/637600cc1fa7d7355b08efe783b6db99f560352a79bdad2cc637429962eeecfe.png" alt="例题"></p> <h4 id="逻辑地址、物理地址转换"><a href="#逻辑地址、物理地址转换" class="header-anchor">#</a> 逻辑地址、物理地址转换</h4> <p><strong>物理地址 = 段基地址 &lt;&lt; 4 + 偏移地址</strong></p> <p><img src="/images/5f6126651c2f92a12a399a23042e32e90604a3789775ee239e68fd6f8b9ef288.png" alt="例题"></p> <h4 id="堆栈"><a href="#堆栈" class="header-anchor">#</a> 堆栈</h4> <p>堆栈：</p> <ul><li>特定的存储区，访问该存储区一般需要按照专门的规则进行操作</li> <li>主要用于暂存数据以及在过程调用或处理中断时保存断点信息</li> <li>一般分为<strong>专用堆栈存储器</strong>和<strong>软件堆栈</strong> <ul><li>专用堆栈存储器：按堆栈的工作方式专门设计的存储器</li> <li>软件堆栈：由程序设计人员用软件在内存中划出的一块存储区作为堆栈来使用。8086/8088采用这种方式。
堆栈组成：</li></ul></li> <li><strong>栈底</strong>：固定，是<strong>堆栈存储区最大地址单元</strong></li> <li><strong>栈顶</strong>：浮动，是<strong>最后存入信息的存储单元</strong></li> <li>栈顶指针 SP：指示栈顶单元</li> <li>数据在堆栈中以字（16 bits）为单位小端存放</li> <li><strong>初始化时，SP = 栈底 + 2 = 堆栈长度</strong></li> <li>堆栈长度 &lt;= 64KB</li> <li>SP 始终表示堆栈段基址与栈顶之间的距离</li> <li>程序设置多个堆栈段</li></ul> <p><img src="/images/64c036d835f462697d02fab06b3524811e1605b5cd80c872d5aef524a496b8e4.png" alt="堆栈"></p> <p><img src="/images/3232f210c17ae3c8dcf5384bf31e3a457ab22a7a88caa61a1c862f07d3c62488.png" alt="例题"></p> <h3 id="_8088-系统总线"><a href="#_8088-系统总线" class="header-anchor">#</a> 8088 系统总线</h3> <p>总线 <code>Bus</code>：是一组<strong>导线</strong>和相关的<strong>控制、驱动电路</strong>的集合，它是计算机系统各部件之间<strong>传输地址、数据和控制信息</strong>的通道。</p> <p>分类：</p> <ul><li>地址总线 AB</li> <li>数据总线 DB</li> <li>控制总线 CB</li></ul> <p><img src="/images/77fefbfe1c701322f95e03a68a9212d17f7de87ad156678cc4add7ee1d9b6665.png" alt="最小模式下的系统总线"></p> <p>最小模式下不需要 8288 总线控制器，而最大模式下需要。</p> <ul><li>8282：锁存器，连接地址线（因为要和数据线复用，所以要配合 ALE 将地址存进锁存器）</li> <li>8284：时钟发生器</li> <li>8286：双向总线驱动器，连接（内外部的）数据总线</li></ul> <p><img src="/images/99150753542d61ed4eb265a6a2dd0cd31be1d9d30ddc3bbfbf4ed264a76d7563.png" alt="最大模式下的系统总线"></p> <ul><li>8288：总线控制器，支持 CPU</li></ul> <h4 id="总线时序、总线周期"><a href="#总线时序、总线周期" class="header-anchor">#</a> *****总线时序、总线周期</h4> <ul><li>时序：CPU各引脚信号在时间上的关系</li> <li>总线周期：CPU 完成一次访问内存(或I/O接口)操作所需要的时间
<ul><li>一个总线周期至少包括 4 个时钟周期</li></ul></li></ul> <p><img src="/images/64806a8d406e61c0d8767705627eb3d62880eb95146547c02b9069fa3f1e3081.png" alt="8088最小模式下的读周期"></p> <ul><li>T1上 输出地址</li> <li>T1下 锁地址</li> <li>T2 输出状态，设置 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>R</mi><mi>D</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{RD}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>、<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>D</mi><mi>E</mi><mi>N</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{DEN}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></li> <li>T3 输入数据</li> <li>T4 复位，关状态输出</li></ul> <p>但这个状态在最小模式中没有用，在最大模式中才会用到（</p> <p><img src="/images/b548bde2652a6b919ff10a3ca85fbe324b33efbaf64d64fe059b59982ee3c548.png" alt="8088最小模式下的写周期"></p> <p>写的区别除了 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>W</mi><mi>R</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{WR}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>、<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>T</mi><mi mathvariant="normal">/</mi><mover accent="true"><mi>R</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">DT/\overline{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span>、外，还有 AD 线在地址输出结束后必须立即进行数据输出。</p> <h3 id="ia-32-微处理器和工作方式"><a href="#ia-32-微处理器和工作方式" class="header-anchor">#</a> IA-32 微处理器和工作方式</h3> <p>Intel公司将 80286 之后的 80X86 32 位微处理器称为 IA(Intel Architecture)-32 结构（现在是 AMD64）</p> <h4 id="ia-32-微处理器历史"><a href="#ia-32-微处理器历史" class="header-anchor">#</a> IA-32 微处理器历史</h4> <p>应该不是重点，所以就比较略了。</p> <h5 id="_80286"><a href="#_80286" class="header-anchor">#</a> 80286</h5> <ul><li>实地址模式、虚地址保护模式</li> <li>CPU 被分为：
<ul><li>总线部件 <code>BU</code></li> <li>地址部件 <code>AU</code></li> <li>执行部件 <code>EU</code></li> <li>指令部件 <code>IU</code></li></ul></li></ul> <h5 id="_80386"><a href="#_80386" class="header-anchor">#</a> 80386</h5> <ul><li>实地址模式、保护模式和虚拟 8086 模式</li> <li>CPU 被分为：
<ul><li>总线接口单元 <code>BIU</code></li> <li>指令预取单元 <code>IPU</code></li> <li>指令译码单元 <code>IDU</code></li> <li>执行单元 <code>EU</code></li> <li>分段单元 <code>SU</code></li> <li>分页单元 <code>PU</code></li></ul></li> <li>分页存储</li></ul> <h5 id="_80486"><a href="#_80486" class="header-anchor">#</a> 80486</h5> <ul><li>突发传送方式（成块数据传送）</li></ul> <h5 id="pentium"><a href="#pentium" class="header-anchor">#</a> Pentium</h5> <ul><li>与80X86系列微处理器兼容</li> <li>RISC型超标量结构（处理器包含多个指令单元和指令流水线）</li> <li>高性能浮点运算器</li> <li>双重分离式高速缓存（分离指令缓存和数据缓存）</li> <li>64位数据总线</li> <li>分支指令预测</li> <li>常用指令固化与微代码改进（把常用的指令改用硬件实现，而不使用微程序方式）</li> <li>系统管理方式程序 <code>SMM</code>（电源管理、为操作系统和正在运行的程序提供安全性）</li></ul> <h4 id="ia-32-主要寄存器"><a href="#ia-32-主要寄存器" class="header-anchor">#</a> IA-32 主要寄存器</h4> <p>通用寄存器：8 个 32 位通用寄存器</p> <p><img src="/images/053fb371fb6454e749e0b163a18e8e20a4f10f5ceb7a3dd32f021e19c821f50f.png" alt="通用寄存器"></p> <p>指令指针和标志寄存器：</p> <p><img src="/images/48c324c8082d27de0d88346a4f03c24cb3b9da3e5e30b1b3f1a265a52aeb198c.png" alt="指令指针和标志寄存器"></p> <p>段寄存器和系统地址寄存器：</p> <p><img src="/images/185bcf860d26194ac5ff1dcc95bc396fdec6ee583de45f5150c77e8e38bfd9f5.png" alt="段寄存器和系统地址寄存器"></p> <p>控制寄存器：</p> <p><img src="/images/97454c165ea943f277fbbf346f091226dd54d155a0678fdd453919ae592e4780.png" alt="控制寄存器"></p> <h4 id="ia-32-处理器工作方式"><a href="#ia-32-处理器工作方式" class="header-anchor">#</a> IA-32 处理器工作方式</h4> <h5 id="实模式"><a href="#实模式" class="header-anchor">#</a> 实模式</h5> <ul><li>兼容 8086</li> <li>32条地址线中只有低20条地址线起作用，可寻址1MB的物理地址空间</li> <li>无多任务处理</li></ul> <h5 id="保护模式"><a href="#保护模式" class="header-anchor">#</a> 保护模式</h5> <ul><li>32条地址可寻址4GB的物理存储器空间</li> <li>支持虚拟存储器功能。每个任务运行可以有16K个段，每个段最大为4GB，一个任务最大可使用64TB虚拟地址空间</li> <li>程序运行分为4个特权等级，操作系统核心运行在最高特权级0，用户程序运行在最低特权级3</li></ul> <h5 id="虚拟-8086-模式"><a href="#虚拟-8086-模式" class="header-anchor">#</a> 虚拟 8086 模式</h5> <ul><li>在虚拟8086方式下，IA-32微处理器总体上是工作在保护虚地址方式，支持多用户多任务操作系统。其中，有的任务可以工作在虚拟8086方式，运行DOS应用程序。</li></ul> <h5 id="保护模式下的存储器访问"><a href="#保护模式下的存储器访问" class="header-anchor">#</a> 保护模式下的存储器访问</h5> <p><img src="/images/2fbb6ff64908cc7b0d609d1ba77d9a3353734cdcb4e49274614eceb091f15273.png" alt=""> <img src="/images/d857aaca3e3dff84edbd0a230fe994898971b8d736b5cf940ef3848e12988443.png" alt=""> <img src="/images/9b4089dedd698d5d3c336282839346d84df2928f47f32a7e9eec7da59bfed41d.png" alt="">
![]](/images/aa43a063892450e1db26d246ecfdcb8633f71176b8c300c906f4fc07370f17d3.png)
<img src="/images/a4d3d11ebac6286de0ea91217c9941d71fce115a37ebc3c65a91302fe8cda623.png" alt=""> <img src="/images/c298ac75a7755956f0b65e0222ade4838590cb5b0a50fbe9c0f103803996a4c7.png" alt=""> <img src="/images/313ab77109d17290d961fac8dab9a4dca36e1ab3282568bcecea8c4949e1b12f.png" alt=""> <img src="/images/9d6ae3513ebf9224b7268780a93e05b6b4a1d70762be0212b6e991f7934fc20a.png" alt=""></p> <h3 id="本章小结"><a href="#本章小结" class="header-anchor">#</a> 本章小结</h3> <p><img src="/images/f7908757260263ea785a2ea08addf225754d8b67ea31c51c5dd02b93306dce11.png" alt="本章小结"></p> <p>8088 相关知识：</p> <ul><li>地址线、数据线、控制线若干</li> <li>16 位寄存器（各个的中文？）
<ul><li>8个通用寄存器：AX、BX、CX、DX、SP、BP、SI、DI</li> <li>4个段寄存器：CS、DS、ES、SS</li> <li>2个控制寄存器：IP、FLAGS (CF、SF、AF、PF、OF、ZF、IF、TF、DF)</li></ul></li> <li>存储器
<ul><li>32-bit 逻辑地址 = 16-bit 段基地址 <code>拼接</code> 16-bit 段内地址</li> <li>20-bit 物理地址：16-bit 段基地址 <code>*16+</code> 16-bit 偏移地址</li></ul></li> <li>堆栈：栈底固定，为地址最大值；以字为单位</li></ul> <h2 id="第三章-指令系统"><a href="#第三章-指令系统" class="header-anchor">#</a> 第三章 指令系统</h2> <h3 id="概述-略"><a href="#概述-略" class="header-anchor">#</a> 概述（略）</h3> <h3 id="寻址方式"><a href="#寻址方式" class="header-anchor">#</a> 寻址方式</h3> <p>这里讲的是 8086 的寻址方式，《计算机组成原理》讲的是 MIPS 的，因此会有区别。</p> <p>除了立即寻址、寄存器寻址、隐含寻址，其余寻址方式都是得到 <code>偏移地址</code> 以后 <code>+16*段地址</code> 得出，并且这些方式都会加 <code>[ ]</code>。</p> <h4 id="立即寻址"><a href="#立即寻址" class="header-anchor">#</a> 立即寻址</h4> <p><img src="/images/81aee00541b6ed26f57a285dfca95ed8bfc39ea105dbbbebf22a990d8eb52243.png" alt="立即寻址"></p> <h4 id="寄存器寻址"><a href="#寄存器寻址" class="header-anchor">#</a> 寄存器寻址</h4> <p><img src="/images/080823908581cf98753c95657c5977caa9527af6badf435488b8a85f259ebf59.png" alt="寄存器寻址"></p> <h4 id="直接寻址"><a href="#直接寻址" class="header-anchor">#</a> 直接寻址</h4> <p>偏移地址 = 立即数</p> <p><img src="/images/cd909019497371be41e17abadc1a7d8a5d78f524873fe4445d3ecb2ddea1148d.png" alt="直接寻址"></p> <ul><li>直接寻址下，存储器操作数的长度由指令中另一个操作数的长度决定。如 <code>MOV [1234H], CX</code> <code>MOV CL, [1234H]</code></li> <li>直接寻址方式下，操作数的段地址默认为数据段
<ul><li>但允许段重设，即由指令定义段，说明数据存放在其他逻辑段中</li> <li><code>MOV AX, ES:[1200H]</code> 指令将 <code>ES:[1200H]</code> 的数存入 <code>AX</code></li> <li>这种情况称为段超越，所加的段寄存器叫段前缀</li></ul></li></ul> <h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="header-anchor">#</a> 寄存器间接寻址</h4> <p>偏移地址 = 寄存器值</p> <p><img src="/images/4a158b764ea4be17e2ce448671ea8b29a4fcf7f42685e7e20c2466b98e9c7bab.png" alt="寄存器间接寻址"></p> <ul><li>“偏移地址”只能来自于间址寄存器(BX, BP, SI, DI)
<ul><li>间址寄存器必须为 16-bit registers</li></ul></li> <li>“段地址”取决于基址寄存器
<ul><li><strong>BX, SI, DI -&gt; DS</strong></li> <li><strong>BP -&gt; SS</strong></li> <li>但允许段超越</li></ul></li></ul> <p>记忆上，就记 BP <code>base pointer</code> 作用类似于 SP <code>stack pointer</code>，都是用来指栈的某个位置。其余都是指 DS。</p> <h4 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="header-anchor">#</a> 寄存器相对寻址</h4> <p>偏移地址 = 寄存器值 + 立即数</p> <ul><li>寄存器值同样来自于 BX、BP、SI 或 DI</li></ul> <h4 id="基址-变址寻址"><a href="#基址-变址寻址" class="header-anchor">#</a> 基址-变址寻址</h4> <p>偏移地址 = 基址寄存器值 + 变址寄存器值</p> <ul><li>“段地址”取决于基址寄存器
<ul><li><strong>BX -&gt; DS</strong></li> <li><strong>BP -&gt; SS</strong>（在计算题中，不要无脑使用 <code>DS</code> 作段地址！！！BP 需要使用 SS）</li></ul></li> <li>常用于一维数组</li></ul> <p><img src="/images/81f301c50d50d3cab2d8782fbef2224215544487edc8c2f1a6b1ba875d45eef0.png" alt="例"></p> <h4 id="基址-变址-相对寻址"><a href="#基址-变址-相对寻址" class="header-anchor">#</a> 基址-变址-相对寻址</h4> <p>偏移地址 = 基址寄存器值 + 变址寄存器值 + 立即数</p> <ul><li>段地址同上</li> <li>常用于二维数组</li></ul> <p><img src="/images/50517c34007f40bc1e32bd967274f7cae5a7056bc92b41a514d7ae2edecea51e.png" alt="例"></p> <h4 id="五种寻址方式的总结"><a href="#五种寻址方式的总结" class="header-anchor">#</a> 五种寻址方式的总结</h4> <p><img src="/images/9495b586ce3ba38f7e4915566d352552ccdb4f13299c0f77c495008bc6e56b58.png" alt="五种寻址方式的总结"></p> <p>除立即寻址、寄存器寻址、隐含寻址外，其余都是计算得到偏移地址，然后在 <strong>BIU 中的地址加法器</strong>运算（<code>+16*基地址</code>）得到物理地址。</p> <h4 id="隐含寻址"><a href="#隐含寻址" class="header-anchor">#</a> 隐含寻址</h4> <p>指令中隐含了一个或两个操作数的地址，即操作数在默认的地址中。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MUL <span class="token register variable">BL</span>
<span class="token comment">; AX = AL * BL</span>
</code></pre></div><h3 id="数据传送指令"><a href="#数据传送指令" class="header-anchor">#</a> 数据传送指令</h3> <h4 id="通用数据传送"><a href="#通用数据传送" class="header-anchor">#</a> 通用数据传送</h4> <p>注意：<strong>该类指令的执行对标志位不产生影响</strong></p> <h5 id="一般数据传送指令-mov"><a href="#一般数据传送指令-mov" class="header-anchor">#</a> 一般数据传送指令 MOV</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV dest, src
<span class="token comment">; 读取 src 并保存到 dest</span>
</code></pre></div><p>注意事项：</p> <ul><li>各 FLAGS 一般不作为操作数在指令中出现</li> <li>两操作数长度必须相同</li> <li><a href="#offset-%E8%BF%90%E7%AE%97%E7%AC%A6"><code>OFFSET</code></a>、<a href="#seg-%E8%BF%90%E7%AE%97%E7%AC%A6"><code>SEG</code></a> 等运算符得到的值可视为立即数</li> <li>某些方向是不能传输数据的，具体看图</li></ul> <p><img src="/images/19dd0bb079591ffd2724c014246374d23fbad8fd1a3863a1d2d895ca61b35062.png" alt="MOV指令的传送方向示意图"></p> <p>可以用两条记忆：</p> <ol><li>立即数和 <code>CS</code> 不能做 <code>dest</code>（显然）</li> <li>立即数和段寄存器如果想传送到别的段寄存器，必须经过通用寄存器中转。</li></ol> <p>顺便一提，立即数可以不经过寄存器、直接传入存储器。但由于立即数的长度不定，可能需要显式指明存储器的长度，如 <code>MOV BYTE PTR[BX], 233H</code>。参见 <a href="#PTR-%E8%BF%90%E7%AE%97%E7%AC%A6">PTR 运算符</a>。</p> <hr> <p>例题：判断下列指令的正确性：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AL</span>, <span class="token register variable">BX</span>             <span class="token comment">; 错误，长度不一致</span>
MOV  <span class="token register variable">AX</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span><span class="token number">05H</span>        <span class="token comment">; 对</span>
MOV  <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span><span class="token operator">[</span><span class="token register variable">BP</span><span class="token operator">]</span>, <span class="token register variable">AX</span>       <span class="token comment">; 错误，同时使用两个基址寄存器</span>
MOV  <span class="token register variable">DS</span>, <span class="token number">1000H</span>          <span class="token comment">; 错误，常数不能直接送段寄存器</span>
MOV  <span class="token register variable">DX</span>, <span class="token number">09H</span>            <span class="token comment">; 对，立即数位数不够，会自动补齐</span>
MOV  <span class="token operator">[</span><span class="token number">1200H</span><span class="token operator">]</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>      <span class="token comment">; 错误，dst 和 src 不能同时为存储器</span>
MOV  <span class="token register variable">AX</span>, <span class="token register variable">CS</span>             <span class="token comment">; 对</span>
MOV  <span class="token register variable">DS</span>, <span class="token register variable">CS</span>             <span class="token comment">; 错误，段寄存器之间不能传送</span>
</code></pre></div><p>例：将符号“*”的ASCII码2AH送入内存数据段中以变址指针DI所指的单元再偏移100个字节单元中：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV <span class="token register variable">AL</span>, <span class="token string">'*'</span>
MOV <span class="token number">100</span><span class="token operator">[</span><span class="token register variable">DI</span><span class="token operator">]</span>, <span class="token register variable">AL</span>
</code></pre></div><h5 id="堆栈操作指令-push-pop"><a href="#堆栈操作指令-push-pop" class="header-anchor">#</a> 堆栈操作指令 PUSH POP</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>PUSH OPRD
<span class="token comment">; 压栈</span>
POP OPRD
<span class="token comment">; 出栈</span>
</code></pre></div><p>注意事项：</p> <ul><li>堆栈操作以字为单位，<strong>故操作数必为 16 位</strong></li> <li>操作数不能是立即数</li> <li>操作数可以来自寄存器或存储器
<ul><li>若为存储器操作数，需要声明为字存储单元</li></ul></li> <li>不能 POP 到 CS，这是上面的知识</li> <li>PUSH 顺序是从高地址向低地址，看下图</li></ul> <p><img src="/images/4cdfa19a2e508875f011987428fe17c8a5942632dc0454993f043e233e66c906.png" alt="压栈过程"></p> <p><img src="/images/3e47c7ad9897cd201bca3cb98b632a54d0726fed5bf6e84033770d34eaeb9f3d.png" alt="出栈过程"></p> <h5 id="交换指令-xchg"><a href="#交换指令-xchg" class="header-anchor">#</a> 交换指令 XCHG</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; XCHG REG/MEM, REG/MEM</span>
XCHG  <span class="token register variable">AX</span>, <span class="token register variable">BX</span>
XCHG  <span class="token operator">[</span><span class="token number">2000</span><span class="token operator">]</span>, <span class="token register variable">CL</span>
</code></pre></div><p>注意事项：</p> <ul><li>两操作数至少有一个是寄存器操作数</li> <li>不允许使用段寄存器</li></ul> <h5 id="字位扩展指令-cbw-cwd"><a href="#字位扩展指令-cbw-cwd" class="header-anchor">#</a> 字位扩展指令 CBW CWD</h5> <ul><li>将带符号数的符号位 (0/1) 扩展 <code>Convert</code> 到高位；</li> <li>零操作数指令，采用隐含寻址，隐含的操作数为 AX 或者 “AX与DX”</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>CBW
<span class="token comment">; 将 AL 的符号位扩展到 AH (Convert Byte to Word)</span>
<span class="token comment">; 若 AL 最高位=1，则执行后 AH = FFH</span>
<span class="token comment">; 若 AL 最高位=0，则执行后 AH = 00H</span>
</code></pre></div><div class="language-nasm extra-class"><pre class="language-nasm"><code>CWD
<span class="token comment">; 将 AX 符号位扩展到 DX (Convert Word to Doubleword)</span>
<span class="token comment">; 若 AX 最高位=1，则执行后 DX = FFFFH</span>
<span class="token comment">; 若 AX 最高位=0，则执行后 DX = 0000H</span>
</code></pre></div><p>判断以下指令执行结果：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV <span class="token register variable">AL</span>, <span class="token number">44H</span>
CBW
<span class="token comment">; AX = 0044H</span>

MOV <span class="token register variable">AX</span>, <span class="token number">0AFDEH</span>
CWD
<span class="token comment">; DX = 0000H</span>

MOV  <span class="token register variable">AL</span>，<span class="token number">86H</span>
CBW
<span class="token comment">; AX = FF86H</span>
</code></pre></div><h4 id="输入输出指令-in-out"><a href="#输入输出指令-in-out" class="header-anchor">#</a> 输入输出指令 IN OUT</h4> <ul><li>专门面向I/O端口操作的指令</li> <li>输入指令：<code>IN acc, PORT</code></li> <li>输出指令：<code>OUT PORT, acc</code></li> <li><code>PORT</code> 为端口地址，<code>acc</code> 为累加寄存器 AL 或 AX</li></ul> <p>可以认为指令的第一个参数是目的地址 <code>dest</code>，这和 <code>MOV</code> 保持一致。</p> <p><code>PORT</code> 的寻址方式：</p> <ul><li>直接寻址
<ul><li>端口地址为 8 位时，指令中直接给出 8 位端口地址</li> <li>可寻址 256 个端口</li></ul></li> <li>间接寻址
<ul><li>端口地址为 16 位时，指令中的端口地址必须由 DX 指定</li> <li>可寻址 64K 个端口</li></ul></li></ul> <p>例：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>IN <span class="token register variable">AX</span>, <span class="token number">80H</span>

MOV <span class="token register variable">DX</span>, <span class="token number">2400H</span>
IN <span class="token register variable">AL</span>, <span class="token register variable">DX</span>

OUT <span class="token number">35H</span>, <span class="token register variable">AX</span>
</code></pre></div><h4 id="地址传送指令-lea-lds-les"><a href="#地址传送指令-lea-lds-les" class="header-anchor">#</a> 地址传送指令 LEA LDS LES</h4> <h5 id="取偏移地址指令-lea"><a href="#取偏移地址指令-lea" class="header-anchor">#</a> 取偏移地址指令 LEA</h5> <p>LEA (Load Effective Address)：将一个存储单元的 16 位偏移地址取出送 16 位通用寄存器（常为间址寄存器）。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>LEA REG, MEM
</code></pre></div><p>类似于 <code>MOV</code>，但 <code>MOV</code> 取的是存储器值，而 <code>LEA</code> 取的是存储器的偏移地址。</p> <p><img src="/images/8fe69e6b5caee4cf1b7ed605fa1c7c1173a0d5ab42f9bf0526e616fa68d19ee9.png" alt="MOV 和 LEA 对比"></p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV <span class="token register variable">SI</span>, DATA1
<span class="token comment">; 这里的 DATA1 是变量</span>
<span class="token comment">; SI = DATA1 中的内容</span>

LEA <span class="token register variable">SI</span>, DATA1
<span class="token comment">; SI = DATA1 的偏移地址</span>

MOV <span class="token register variable">BX</span>, <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>
<span class="token comment">; BX = BX 作为偏移地址对应的值</span>

LEA <span class="token register variable">BX</span>, <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>
<span class="token comment">; BX 不变</span>
</code></pre></div><p>变量的知识见<a href="#%E5%8F%98%E9%87%8F">变量</a>。</p> <p>看起来 <code>LEA</code> 有点蠢，但其是有存在意义的：当寻址方式比较复杂（如<a href="#%E5%9F%BA%E5%9D%80-%E5%8F%98%E5%9D%80-%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80">基址-变址-相对寻址</a>），<code>LEA</code> 能一行获取其地址，但 <code>MOV</code> 指令则不行，因为 <code>MOV</code> <a href="https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction" target="_blank" rel="noopener noreferrer">What's the purpose of the LEA instruction? - Stack Overflow<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>一道简单的例题：将数据段中首地址为 MEM1 的 50 字节的数据传送到同一逻辑段首地址为 MEM2 的区域存放。</p> <p><img src="/images/d28ed269b600f75c3d3596cf6fd508f4d27b6668606c7e3ca96cbdec4290ecd3.png" alt="流程图"></p> <p>代码如下：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>      LEA <span class="token register variable">SI</span>, MEM1
      LEA <span class="token register variable">DI</span>, MEM2
      MOV <span class="token register variable">CL</span>, <span class="token number">50</span>
<span class="token label function">NEXT:</span> MOV <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
      MOV <span class="token operator">[</span><span class="token register variable">DI</span><span class="token operator">]</span>, <span class="token register variable">AL</span>
      INC <span class="token register variable">SI</span>
      INC <span class="token register variable">DI</span>
      DEC <span class="token register variable">CL</span>
      JNZ NEXT
      HLT           <span class="token comment">; halt，暂停执行</span>
</code></pre></div><p><s>眼睛：我没学会</s> <s>脑子：我也没学会</s></p> <p>看不懂就下来再看看。</p> <p><code>LEA</code> 不访问存储器，而下面的 <code>LDS</code>、<code>LES</code> 要访问存储器。</p> <h5 id="装入地址指针指令-lds-les"><a href="#装入地址指针指令-lds-les" class="header-anchor">#</a> 装入地址指针指令 LDS LES</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>LDS DEST, SRC
LES DEST, SRC
</code></pre></div><p>作用：把 <code>SRC</code> 存储单元开始的 4 个字节单元的内容送入 <code>DEST</code> 通用寄存器和段寄存器 <code>DS</code>（LDS指令）或 <code>ES</code>（LES指令）</p> <ul><li>低 16 位送 <code>DEST</code>，一般是送 <code>SI</code> 或 <code>DI</code></li> <li>高 15 位送 <code>DS</code>/<code>ES</code></li></ul> <p><img src="/images/ffe42aec65bbfba62190672930bf7d56bc382215b41cbbd5cd4b2e2d22ea5c62.png" alt="例题"></p> <p>执行后，<code>SI=0020H</code>，<code>DS=5030H</code>。</p> <h4 id="标志位操作指令"><a href="#标志位操作指令" class="header-anchor">#</a> 标志位操作指令</h4> <h5 id="lahf-sahf"><a href="#lahf-sahf" class="header-anchor">#</a> LAHF SAHF</h5> <ul><li>LAHF (Load Flags to AH)：将 FLAGS 的低 8 位装入 AH</li></ul> <p><img src="/images/b5c6d77b0f09db79bc86f1f25cb8cb26b0528094b205b42684cc7b04bbe67b2a.png" alt="LAHF"></p> <ul><li>SAHF (Save Flags to AH)：执行与LAHF相反的操作</li></ul> <h5 id="pushf-popf"><a href="#pushf-popf" class="header-anchor">#</a> PUSHF POPF</h5> <ul><li>PUSHF：将 FLAGS 压栈</li> <li>POPF：将栈顶弹出给 FLAGS</li></ul> <h3 id="算术运算类指令"><a href="#算术运算类指令" class="header-anchor">#</a> 算术运算类指令</h3> <h4 id="标志位影响"><a href="#标志位影响" class="header-anchor">#</a> 标志位影响</h4> <p>这类指令的执行大多对状态标志位会产生影响。</p> <blockquote><p>参考：http://www5.zzu.edu.cn/qwfw/info/1044/2483.htm<br>
教材上并没有写 <code>AND</code> 指令会改变 <code>SF</code> 等，然后练习题考了hhhhh，真离谱</p></blockquote> <table><thead><tr><th>影响标志位</th> <th>影响六个 (<code>CF</code>, <code>SF</code>, <code>AF</code>, <code>ZF</code>, <code>PF</code>, <code>OF</code>)</th> <th>影响五个 (不影响 <code>CF</code>)</th> <th>影响五个 (不影响 <code>AF</code>)</th> <th>影响两个 (<code>CF</code>, <code>OF</code>)</th> <th>影响一个 (<code>CF</code>)</th> <th>不影响</th></tr></thead> <tbody><tr><td>指令</td> <td><code>ADD/ADC/SUB/SBB/NEG/CMP</code>, <code>CMPS/SCAS</code></td> <td><code>INC/DEC</code></td> <td><code>AND/OR/XOR/TEST</code>, <code>SAL/SAR/SHL/SHR</code></td> <td><code>MUL/IMUL</code></td> <td><code>ROL/ROR/RCL/RCR</code></td> <td><code>DIV/IDIV</code> <code>NOT</code>, <code>MOV</code>, <code>IN/OUT</code></td></tr></tbody></table> <h4 id="加法"><a href="#加法" class="header-anchor">#</a> 加法</h4> <p>加法指令对操作数的要求与 MOV 指令基本相同：</p> <blockquote><ol><li>源操作数可以是通用寄存器、存储单元或立即数</li> <li>目的操作数只能是通用寄存器或存储单元，不能是立即数</li> <li>二者不能同时来自存储器。</li></ol></blockquote> <h5 id="带符号加法-add"><a href="#带符号加法-add" class="header-anchor">#</a> 带符号加法 ADD</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>ADD OPRD1, OPRD2
<span class="token comment">; OPRD1 = OPRD1 + OPRD2</span>
</code></pre></div><p>目的地址依旧是第一个，类似于 <code>MOV</code>。</p> <ul><li><code>ADD</code> 指令的执行对全部 6 个状态标志位都产生影响</li></ul> <p>例：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV <span class="token register variable">AL</span>, <span class="token number">78H</span>
ADD <span class="token register variable">AL</span>, <span class="token number">99H</span>
<span class="token comment">; 试写出指令执行后的结果</span>
</code></pre></div><p><img src="/images/d9203225ce9f68a97b811f0b7a0036e74a9aa84c55827106925f29e9ffe02b03.png" alt="结果及标志位"></p> <h5 id="带进位加法-adc"><a href="#带进位加法-adc" class="header-anchor">#</a> 带进位加法 ADC</h5> <p>ADC (ADd with Carry) 可用于实现多字节数（大数）相加。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>ADC OPRD1, OPRD2
<span class="token comment">; OPRD1 = CF + OPRD1 + OPRD2</span>
</code></pre></div><p>例：求两个大数的和，两个数的长度为 20 字节，首地址为 <code>M1</code> 和 <code>M2</code>。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>      LEA <span class="token register variable">SI</span>, M1
      LEA <span class="token register variable">DI</span>, M2
      MOV <span class="token register variable">CX</span>, <span class="token number">20</span>
      CLC           <span class="token comment">; 使 CF = 0</span>
<span class="token label function">NEXT:</span> MOV <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
      ADC <span class="token operator">[</span><span class="token register variable">DI</span><span class="token operator">]</span>, <span class="token register variable">AL</span>
      INC <span class="token register variable">SI</span>        <span class="token comment">; SI、DI 自增</span>
      INC <span class="token register variable">DI</span>
      DEC <span class="token register variable">CX</span>        <span class="token comment">; CX 自减</span>
      JNZ NEXT      <span class="token comment">; Jump if（当运算结果） Not Zero</span>
      HLT
</code></pre></div><h5 id="自增-inc"><a href="#自增-inc" class="header-anchor">#</a> 自增 INC</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>INC OPRD
<span class="token comment">; OPRD = OPRD + 1</span>
</code></pre></div><ul><li><code>OPRD</code> 可以来自存储器，不能来自段寄存器或立即数</li> <li><code>INC</code> 指令执行不影响 <code>CF</code> 标志，只影响其他五个</li></ul> <p>为什么 <code>INC</code>（以及 <code>DEC</code>）不影响 <code>CF</code> 标志呢？据 <a href="https://stackoverflow.com/questions/13435142/why-do-the-inc-and-dec-instructions-not-affect-the-carry-flag-cf" target="_blank" rel="noopener noreferrer">Stack Overflow<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，这并不是为了节省成本，而是为了循环的 <code>i++</code> 等不会影响到 <code>CF</code> 标志位。上段 <code>ADC</code> 处举的例子就很好的说明了这一点：如果 <code>INC</code> 改变了 <code>CF</code>，程序必须在每次完成 <code>ADC</code> 后存储 <code>CF</code> 的状态，否则就会被 <code>INC</code> 覆盖，代码会麻烦得多。</p> <h4 id="减法"><a href="#减法" class="header-anchor">#</a> 减法</h4> <h5 id="带符号减法-sub"><a href="#带符号减法-sub" class="header-anchor">#</a> 带符号减法 SUB</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>SUB OPRD1, OPRD2
<span class="token comment">; OPRD1 = OPRD1 - OPRD2</span>
</code></pre></div><ul><li><code>SUB</code> 指令的执行对全部 6 个状态标志位都产生影响（同 <code>ADD</code>）</li></ul> <h5 id="带借位减法-sbb"><a href="#带借位减法-sbb" class="header-anchor">#</a> 带借位减法 SBB</h5> <p>类似于 <code>ADC</code>：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>SBB OPRD1, OPRD2
<span class="token comment">; OPRD1 = OPRD1 - OPRD2 - CF</span>
</code></pre></div><p>SBB (SuBtraction with Borrow)：指令格式、对操作数的要求、对标志位的影响与 <code>SUB</code> 指令完全一样</p> <h5 id="自减-dec"><a href="#自减-dec" class="header-anchor">#</a> 自减 DEC</h5> <p>类似于 <code>INC</code>：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DEC OPRD
<span class="token comment">; OPRD = OPRD-1</span>
</code></pre></div><ul><li><code>OPRD</code> 不能是段寄存器或立即数</li> <li><code>DEC</code> 不影响 <code>CF</code></li></ul> <p>例 1：实现一个计数循环程序，下面的代码正确吗？</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>     MOV <span class="token register variable">AL</span>, <span class="token number">10H</span>
<span class="token label function">LOP:</span> DEC <span class="token register variable">AL</span>
     JNC LOP <span class="token comment">; Jump if Not CF</span>
<span class="token comment">; 错误！ DEC 不影响 CF</span>
<span class="token comment">; 程序会执行一次后停止（如果原来 CF = 1）</span>
<span class="token comment">; 或死循环 （如果原来 CF = 0）</span>
</code></pre></div><p>例 2 是一个两层的嵌套循环：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>       MOV <span class="token register variable">BL</span>, <span class="token number">2</span>
<span class="token label function">NEXT1:</span> MOV <span class="token register variable">CX</span>, <span class="token number">0FFFFH</span>
<span class="token label function">NEXT2:</span> DEC <span class="token register variable">CX</span>
       JNZ NEXT2
       DEC <span class="token register variable">BL</span>
       JNZ NEXT1
       HLT
</code></pre></div><h5 id="求补-neg"><a href="#求补-neg" class="header-anchor">#</a> 求补 NEG</h5> <ul><li><code>NEG</code> 将影响六个标志位</li> <li>当且仅当操作数为 0 时，<code>CF</code> = 0，结果不变（仍为 0）</li> <li>当且仅当字节操作数为 -128 (80H) 或字操作数为 -32768 (8000H) 时，OF = 1，结果不变（仍为 -128 或 -32768）</li></ul> <h5 id="比较-cmp"><a href="#比较-cmp" class="header-anchor">#</a> 比较 CMP</h5> <p>只影响六个标志位，不会存储结果。常接 <code>JNZ</code> <code>JNC</code> 等语句实现条件跳转。</p> <p>两个数大小比较：</p> <table><thead><tr><th><code>CMP AX, BX</code></th> <th>无符号数</th> <th>有符号数</th></tr></thead> <tbody><tr><td><code>AX=BX</code></td> <td><code>ZF=0</code></td> <td><code>ZF=0</code></td></tr> <tr><td><code>AX&gt;BX</code></td> <td><code>CF=0, ZF=0</code></td> <td><code>OF=SF, ZF=0</code></td></tr> <tr><td><code>AX&lt;BX</code></td> <td><code>CF=1, ZF=0</code></td> <td><code>OF!=SF, ZF=0</code></td></tr> <tr><td>可相关判断指令</td> <td><code>JA</code> <code>JAE</code> <code>JB</code> <code>JBE</code></td> <td><code>JG</code> <code>JGE</code> <code>JL</code> <code>JLE</code></td></tr></tbody></table> <p>例题：在 20 个无符号数中找出最大的数，并将其存放在 MAX 单元中。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>      LEA <span class="token register variable">BX</span>, MAX
      LEA <span class="token register variable">SI</span>, BUF
      MOV <span class="token register variable">CL</span>, <span class="token number">20</span>
      MOV <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>   <span class="token comment">; AL 保存目前的最大值</span>
<span class="token label function">NEXT:</span> INC <span class="token register variable">SI</span>
      CMP <span class="token register variable">Al</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
      JNC GOON       <span class="token comment">; CF=0 转移</span>
      MOV <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>   <span class="token comment">; 将更大的 [SI] 放进 AL</span>
<span class="token label function">GOON:</span> DEC <span class="token register variable">CL</span>
      JNZ NEXT
      MOV <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>, <span class="token register variable">AL</span>
      HLT
</code></pre></div><h4 id="乘法"><a href="#乘法" class="header-anchor">#</a> 乘法</h4> <ul><li>运算结果长度是乘数的两倍，即 <code>8位-&gt;16位</code>，<code>16位-&gt;32位</code></li> <li>一个乘数和计算结果使用隐含寻址，隐含的是存放被乘数的累加寄存器 <code>AL</code> 或 <code>AX</code>，及存放结果的 <code>AX</code> 或 <code>DX</code></li> <li>乘法只影响 <code>OF</code>、<code>CF</code>；若运算结果的高半部分是无效数值，则 <code>OF=CF=0</code>，否则 <code>OF=CF=1</code> <ul><li>考虑 8 位乘 8 位，结果仍可以用 8 位存储的情况，此时 <code>OF=CF=0</code></li> <li>对于无符号乘法，当且仅当高半部分为全 0， <code>OF=CF=1</code></li> <li>对于有符号乘法，当且仅当高半部分为低半部分的符号扩展，<code>OF=CF=1</code></li> <li>若有符号乘法结果为 <code>00000000 11111111</code>，高半部分不是符号扩展，<code>CF=OF=0</code>。若在后续步骤只看后半部分，会导致原来的正值被（错误地）识别为负值</li></ul></li></ul> <h5 id="无符号乘法-mul"><a href="#无符号乘法-mul" class="header-anchor">#</a> 无符号乘法 MUL</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MUL OPRD
<span class="token comment">; 字节运算：AX = AL * OPRD</span>
<span class="token comment">; 字运算：  DX:AX = AX * OPRD</span>
</code></pre></div><ul><li><code>OPRD</code> 不能是立即数</li> <li>若结果高半部（<code>AH</code> 或 <code>DX</code>）是全 0（不是有效数值），则 <code>CF=OF=0</code>，否则 <code>CF=OF=1</code></li></ul> <h5 id="带符号乘法-imul"><a href="#带符号乘法-imul" class="header-anchor">#</a> 带符号乘法 IMUL</h5> <p><code>IMUL</code> (sIgned MULtiply) 除了操作数是带符号外，其余与 <code>MUL</code> 指令相同。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>IMUL OPRD
</code></pre></div><ul><li>若结果高半部（<code>AH</code> 或 <code>DX</code>）是低半部的符号扩展（不是有效数值），则 <code>CF=OF=0</code>，否则 <code>CF=OF=1</code></li></ul> <h4 id="除法"><a href="#除法" class="header-anchor">#</a> 除法</h4> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 无符号除法   </span>
DIV OPRD

<span class="token comment">; 有符号除法</span>
IDIV OPRD
</code></pre></div><ul><li>指令要求被除数是除数的双倍字长</li> <li>若 <code>OPRD</code> 是 8 bits
<ul><li>执行：<code>AX/OPRD</code></li> <li><code>AL</code> = 商</li> <li><code>AH</code> = 余数</li></ul></li> <li>若 <code>OPRD</code> 是 16 bits
<ul><li>执行：<code>DX:AX/OPRD</code></li> <li><code>AX</code> = 商</li> <li><code>DX</code> = 余数</li></ul></li></ul> <p>简而言之，就是高位存余数，低位存商。记忆的方法，可以想：平时更常用除法而不是求模，低位存储的结果就可以直接进行下一步运算。</p> <p>除法指令常和 <code>CBW</code> 或 <code>CWD</code> 配合使用。</p> <h4 id="bcd-码调整指令"><a href="#bcd-码调整指令" class="header-anchor">#</a> BCD 码调整指令</h4> <p><img src="/images/6939376970e09f4138063eaf1684ec0cbc84518c32bc2a5ddd5887720210c590.png" alt=""> <img src="/images/f07b55addce64725145a23c41700eebda4947fd3721354d4acc6add68c3dd409.png" alt=""> <img src="/images/1adbd5c08e7d6d1bda5ecb588ec10f9b5336c76828a436559717805bc257daa2.png" alt=""> <img src="/images/94be973a6bca8a5c4e9684c58647f5c8fcd2fedd3c59edb4e74313467885cc6a.png" alt=""></p> <h5 id="六条指令"><a href="#六条指令" class="header-anchor">#</a> 六条指令</h5> <ul><li>DAA <code>Decimal Adjust after Addition</code>，<code>Decimal</code> 即每四位表示一个 BCD 码，又称压缩型、组合型</li> <li>AAA <code>ASCII Adjust after Addition</code>，<code>ASCII</code> 即每八位表示一个 BCD 码，又称非压缩型、非组合型</li></ul> <p>剩下的就自己看 PPT 吧。</p> <p><img src="/images/bd0316766dff088131e68526c6658ead27fded89940d1a7c47c07c92997b7cb9.png" alt="AAA"></p> <p><img src="/images/3849fdd05eb1310ef96832659f42117a2362526db23505a9de8c4c85d484a986.png" alt="DAA"></p> <p><img src="/images/6f8e1b39a294933b0e68842cb8dc194101e0882ea306bf8e143aef5010fdfbdc.png" alt="AAS"></p> <p><img src="/images/b15ffa24b50b4f9c459af9d08005db823240d56561f862202c7a2eb2c98e4020.png" alt="DAS"></p> <p><img src="/images/da6d82146b31d23b717d154aa8e7ed05a0dcf6f6bf83a75d18f7f33bbb73b2a3.png" alt="AAM"></p> <p><img src="/images/f7fccda5f91e455fe65b190e30756a698a4cd77a49b8289e2c7568ff5b7a338a.png" alt="AAD"></p> <h3 id="逻辑运算和移位指令"><a href="#逻辑运算和移位指令" class="header-anchor">#</a> 逻辑运算和移位指令</h3> <h4 id="逻辑运算"><a href="#逻辑运算" class="header-anchor">#</a> 逻辑运算</h4> <ul><li>逻辑运算指令对操作数的要求大多与MOV指令相同</li> <li><code>NOT</code> 运算指令要求操作数不能是立即数</li> <li>除 <code>NOT</code> 运算指令外，其余指令的执行都只会影响 <code>OF</code> 和 <code>CF</code>（使 <code>OF=CF=0</code>）。<code>NOT</code> 指令不不影响标志位</li></ul> <h5 id="与-and"><a href="#与-and" class="header-anchor">#</a> 与 AND</h5> <p>语法上类似于 <code>ADD</code>。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>AND  OPRD1, OPRD2
<span class="token comment">; 两操作数按位相“与”，结果送目标地址 OPRD1</span>
</code></pre></div><p>例：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 实现两操作数按位相与的运算</span>
AND  <span class="token register variable">BL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>

<span class="token comment">; 使目标操作数的某些位不变，某些位清零</span>
AND  <span class="token register variable">AL</span>, <span class="token number">0FH</span>

<span class="token comment">; 在操作数不变的 情况下使 CF 和 OF 清零</span>
AND  <span class="token register variable">AX</span>, <span class="token register variable">AX</span>
</code></pre></div><p>例 2：从地址为 <code>3F8H</code> 端口中读入一个字节数，如果该数 bit1 位为 1，则将 <code>DATA</code> 为首地址的一个字输出到 <code>38FH</code> 端口，否则就不能进行数据传送。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>      LEA <span class="token register variable">SI</span>, DATA
      MOV <span class="token register variable">DX</span>, <span class="token number">3F8H</span>
<span class="token label function">WAIT:</span> IN <span class="token register variable">AL</span>, <span class="token register variable">DX</span>
      AND <span class="token register variable">AL</span>, <span class="token number">02H</span>
      JZ WAIT       <span class="token comment">; ZF=1转移</span>
      MOV <span class="token register variable">DX</span>, <span class="token number">38FH</span>
      MOV <span class="token register variable">AX</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
      OUT <span class="token register variable">DX</span>, <span class="token register variable">AX</span>
</code></pre></div><h5 id="或-or"><a href="#或-or" class="header-anchor">#</a> 或 OR</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>OR OPRD1, OPRD2
<span class="token comment">; 两操作数按位相“或”，结果送目标地址 OPRD1</span>
</code></pre></div><p>例题：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 实现两操作数 相“或”的运算</span>
OR <span class="token register variable">AX</span>, <span class="token operator">[</span><span class="token register variable">DI</span><span class="token operator">]</span>
<span class="token comment">; 使某些位不变，某些位置“1”</span>
OR <span class="token register variable">CL</span>, <span class="token number">0FH</span>
<span class="token comment">; 在不改变操作数的情况下使 OF=CF=0</span>
OR <span class="token register variable">AX</span>, <span class="token register variable">AX</span>
</code></pre></div><h5 id="非-not"><a href="#非-not" class="header-anchor">#</a> 非 NOT</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>NOT OPRD
<span class="token comment">; 操作数按位取反再送回原地址</span>
</code></pre></div><ul><li>操作数不能是立即数</li> <li>对标志位无影响</li></ul> <p>例：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>NOT BYTE PTR<span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>
</code></pre></div><p>这里的 <code>BYTE PTR</code> 是强制转换，见<a href="#PTR-%E8%BF%90%E7%AE%97%E7%AC%A6">PTR 运算符</a>。</p> <h5 id="异或-xor"><a href="#异或-xor" class="header-anchor">#</a> 异或 XOR</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>XOR OPRD1, OPRD2
<span class="token comment">; 两操作数按位相“异或”，结果送目标地址 OPRD1</span>
</code></pre></div><p>例：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>XOR <span class="token register variable">BL</span>, <span class="token number">80H</span>  <span class="token comment">; 将 BL 的最高位变反</span>
XOR <span class="token register variable">AX</span>, <span class="token register variable">AX</span>   <span class="token comment">; 将 AX 清零</span>
</code></pre></div><p>注意，<code>XOR AX, AX</code> 的效果等价于 <code>MOV AX, 0</code>，但：</p> <ul><li>前者会使 <code>OF</code>=<code>CF</code>=0</li> <li>前者的字节码更短</li> <li>前者在旧的架构上速度会更快（新架构就没必要了）</li> <li>参见 <a href="https://stackoverflow.com/questions/26645676/xor-ax-ax-when-loading-segment-register" target="_blank" rel="noopener noreferrer">xor ax, ax when loading segment register - Stack Overflow<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h5 id="测试-与-test"><a href="#测试-与-test" class="header-anchor">#</a> 测试（与） TEST</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>TEST OPRD1, OPRD2
<span class="token comment">; 执行“与”运算，运算的结果影响标志位，但不送回目标地址</span>
<span class="token comment">; 常用于测试某些位的状态</span>
</code></pre></div><p>例题：从地址为 <code>3F8H</code> 的端口中读入一个字节数，当该数的 bit1， bit3， bit5 位同时为 1 时，则从 <code>38FH</code> 端口将 DATA 为首地址的一个字输出，否则就从端口重新输入。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>      LEA  <span class="token register variable">SI</span>, DATA
      MOV  <span class="token register variable">DX</span>, <span class="token number">3F8H</span>
<span class="token label function">WAIT:</span> IN  <span class="token register variable">AL</span>, <span class="token register variable">DX</span>
      <span class="token comment">; ...</span>
      <span class="token comment">; ...</span>
      MOV  <span class="token register variable">DX</span>, <span class="token number">38FH</span>
      MOV  <span class="token register variable">AX</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
      OUT  <span class="token register variable">DX</span>, <span class="token register variable">AX</span>
</code></pre></div><p><code>; ...</code> 部分的代码可以有三个版本：</p> <p>使用三次 <code>TEST</code>：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>TEST <span class="token register variable">AL</span>, <span class="token number">02H</span>
JZ WAIT       <span class="token comment">; ZF=1转移</span>
TEST <span class="token register variable">AL</span>, <span class="token number">08H</span>
JZ WAIT
TEST <span class="token register variable">AL</span>, <span class="token number">20H</span>
JZ WAIT
</code></pre></div><p>使用 <code>AND</code> 后 <code>CMP</code>：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>AND <span class="token register variable">AL</span>, <span class="token number">2AH</span>
CMP <span class="token register variable">AL</span>, <span class="token number">2AH</span>
JNZ WAIT
</code></pre></div><p>使用 <code>AND</code> 后 <code>XOR</code>：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>AND <span class="token register variable">AL</span>, <span class="token number">2AH</span>
XOR <span class="token register variable">AL</span>, <span class="token number">2AH</span>
JNZ WAIT
</code></pre></div><h4 id="移位指令"><a href="#移位指令" class="header-anchor">#</a> 移位指令</h4> <h5 id="算术左移-sal-逻辑左移-shl"><a href="#算术左移-sal-逻辑左移-shl" class="header-anchor">#</a> 算术左移 SAL 逻辑左移 SHL</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 算术左移 (Shift Arithmetic Left) 指令，视为有符号数</span>
SAL OPRD, <span class="token number">1</span>
SAL OPRD, <span class="token register variable">CL</span>

<span class="token comment">; 逻辑左移指令，视为无符号数</span>
SHL OPRD, <span class="token number">1</span>
SHL OPRD, <span class="token register variable">CL</span>
</code></pre></div><p><code>CL</code> 是 <code>CX</code> 寄存器的低 8 位。</p> <p><img src="/images/5d244f81043fbffb79a752c98e4480efa41ab9585c8cd0e27c0e7f3fe3e7ca20.png" alt="SAL 和 SHL"></p> <p>二者实际上就是一条指令，都是最低位补 0，最高位移到 <code>CF</code>。</p> <h5 id="算术右移-sar-逻辑右移-shr"><a href="#算术右移-sar-逻辑右移-shr" class="header-anchor">#</a> 算术右移 SAR 逻辑右移 SHR</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 算术右移指令，视为有符号数</span>
SAR OPRD, <span class="token number">1</span>
SAR OPRD, <span class="token register variable">CL</span>

<span class="token comment">; 逻辑右移指令，视为无符号数   </span>
SHR OPRD, <span class="token number">1</span>
SHR OPRD, <span class="token register variable">CL</span>
</code></pre></div><p><img src="/images/46007672f8e2139fa723af128b6b5f41941975311881900e46d6e8d2926b7d9f.png" alt="SAR 和 SHR"></p> <p>移出的数送 CF，移入 0 （算术右移）或符号位（逻辑右移）。</p> <h5 id="不带-cf-的循环移位-rol-ror"><a href="#不带-cf-的循环移位-rol-ror" class="header-anchor">#</a> 不带 CF 的循环移位 ROL ROR</h5> <p><code>RO</code> 取自 <code>Rotate</code>。</p> <p>二者都是在原数上循环移位，同时移出的数送 CF。见下。</p> <h5 id="带-cf-的循环移位-rcl-rcr"><a href="#带-cf-的循环移位-rcl-rcr" class="header-anchor">#</a> 带 CF 的循环移位 RCL RCR</h5> <p>二者都是 CF 作为移入的数，移出的数再送 CF。</p> <p><img src="/images/71d57c3c15f9f63ab17f8b1613b7570bac1fd1a32e057d04e2d545424d0c86d1.png" alt="循环移位"></p> <p>循环移位可用于：</p> <ul><li>用于对某些位状态的测试</li> <li>高位部分和低位部分的交换</li> <li>与非循环移位指令一起组成32位或更长字长数的移位</li></ul> <p>例：对从存储单元 M 开始的三字数据执行左移一位。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>SAL M, <span class="token number">1</span>
RCL M<span class="token operator">+</span><span class="token number">2</span>, <span class="token number">1</span>
RCL M<span class="token operator">+</span><span class="token number">4</span>, <span class="token number">1</span>
</code></pre></div><p><img src="/images/5cc3b593d59435947e0ba5e9ffee706d873d9e7a0031d7f506015b64c36384cf.png" alt="示例"></p> <p>例 2：将 1000H 开始存放的 4 个压缩 BCD 码转换为 ASCII 码存放到 3000H 开始的单元中去。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>      MOV <span class="token register variable">SI</span>, <span class="token number">1000H</span>
      MOV <span class="token register variable">DI</span>, <span class="token number">3000H</span>
      MOV <span class="token register variable">CX</span>, <span class="token number">4</span>
<span class="token label function">Next:</span> MOV <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
      MOV <span class="token register variable">BL</span>, <span class="token register variable">AL</span>      <span class="token comment">; 由于每个字节有 2 个 BCD 码，需处理两次，故备份一个在 BL</span>
      AND <span class="token register variable">AL</span>, <span class="token number">0FH</span>
      OR  <span class="token register variable">AL</span>, <span class="token number">30H</span>     <span class="token comment">; 处理 AL 的后四位</span>
      MOV <span class="token operator">[</span><span class="token register variable">DI</span><span class="token operator">]</span>, <span class="token register variable">AL</span>
      INC <span class="token register variable">DI</span>          <span class="token comment">; 目的地地址 ++</span>
      MOV <span class="token register variable">AL</span>, <span class="token register variable">BL</span>
      PUSH <span class="token register variable">CX</span>         <span class="token comment">; 对 CX （用于计数剩余字节）备份</span>
      MOV <span class="token register variable">CL</span>, <span class="token number">4</span>       <span class="token comment">; 此处的 CL 为右移次数</span>
      SHR <span class="token register variable">AL</span>, <span class="token register variable">CL</span>      <span class="token comment">; 处理 AL 的前四位</span>
      OR  <span class="token register variable">AL</span>, <span class="token number">30H</span>
      MOV <span class="token operator">[</span><span class="token register variable">DI</span><span class="token operator">]</span>, <span class="token register variable">AL</span>
      INC <span class="token register variable">DI</span>          <span class="token comment">; 目的地地址 ++</span>
      INC <span class="token register variable">SI</span>          <span class="token comment">; 源地址 ++</span>
      POP <span class="token register variable">CX</span>
      DEC <span class="token register variable">CX</span>
      JNZ Next
      HLT
</code></pre></div><h3 id="串操作指令"><a href="#串操作指令" class="header-anchor">#</a> 串操作指令</h3> <ul><li>针对数据块或字符串的操作</li> <li>实现存储器到存储器的数据传送（前面的所有命令都不能）</li></ul> <p>串操作指令及其功能：（<code>&lt;=&gt;</code>表示比较，<code>&lt;-</code> 表示数据存储）</p> <ul><li>串传送 <code>MOVS</code>：存储器  -&gt; 存储器</li> <li>串比较 <code>CMPS</code>：存储器 &lt;=&gt; 存储器</li> <li>串扫描 <code>SCAS</code>：存储器 &lt;=&gt; AL/AX</li> <li>串装入 <code>LODS</code>：存储器  -&gt; AL/AX</li> <li>串送存 <code>STOS</code>：存储器 &lt;-  AL/AX</li></ul> <h4 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h4> <ul><li>源串地址由 <code>DS:[SI]</code> 提供，目的串由 <code>ES:[DI]</code> 提供</li> <li>源串允许段（DS）重设，目的串不允许段（ES）重设。</li> <li>每次：
<ol><li>只处理串中的一个单元(字或字节)</li> <li>这些指令执行结束后，都会按 <code>DF</code> 决定的方向自动修改 <code>SI</code> 和/或 <code>DI</code>，使其指向下一个单元（按指令可分别处理字单元和字节单元）</li></ol></li> <li>地址修改方向由 DF 标志位决定：
<ul><li><code>DF = 0</code> =&gt; 增地址方向</li> <li><code>DF = 1</code> =&gt; 减地址方向</li></ul></li> <li>指令前面可加上<a href="#%E9%87%8D%E5%A4%8D%E5%89%8D%E7%BC%80">自动重复前缀</a>，实现自动重复执行串操作，重复执行次数由 <code>CX</code> 指定</li></ul> <h4 id="重复前缀"><a href="#重复前缀" class="header-anchor">#</a> 重复前缀</h4> <p>重复前缀：重复执行给定指令，每执行一次后，自动使 <code>CX-1=&gt;CX</code>，直至 <code>CX=0</code> 或其他条件</p> <ul><li>无条件重复
<ul><li><code>REP</code> =&gt; 若 <code>CX≠0</code> 则重复</li></ul></li> <li>条件重复
<ul><li><code>REPE</code>  相等重复 =&gt; 若 <code>CX≠0</code> 且 <code>ZF=0</code> 则重复</li> <li><code>REPZ</code>  为零重复（上一指令的别名）</li> <li><code>REPNE</code> 不相等重复 =&gt; 若 <code>CX≠0</code> 且 <code>ZF≠0</code> 则重复</li> <li><code>REPNZ</code> 不为零重复（上一指令的别名）
注意：<strong>重复前缀本身不改变标志位</strong></li></ul></li></ul> <h4 id="串操作指令流程"><a href="#串操作指令流程" class="header-anchor">#</a> 串操作指令流程</h4> <p><img src="/images/3ece5bd5b42862946c6175223499ee3b77fdc6cc7916ee57a572ceee0267d1bc.png" alt="串操作指令流程(以传送操作为例)"></p> <p>左边部分是串操作的初始化，右边的虚线框部分由串操作指令完成。</p> <h4 id="串传送指令-movs"><a href="#串传送指令-movs" class="header-anchor">#</a> 串传送指令 MOVS</h4> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOVS OPRD1(<span class="token register variable">ES</span>:<span class="token register variable">DI</span>), OPRD2(<span class="token register variable">DS</span>:<span class="token register variable">SI</span>)
MOVSB
MOVSW
</code></pre></div><ul><li>第一种格式中，<code>OPRD1</code> 为目标串地址，<code>OPRD2</code> 为源串地址（类似于 <code>MOV</code>）。两串的段地址允许使用默认值（<code>ES</code>、<code>DS</code>），<strong>源串</strong>也允许段重设</li> <li>二、三种格式下隐含了操作数地址（目标串 <code>ES:DI</code>、源串 <code>DS:SI</code>）</li> <li><code>MOVSB</code> 一次完成一个 Byte 的传送，<code>MOVSW</code> 一次完成一个 Word 的传送</li> <li>执行结束后，按 <code>DF</code> 决定的方向自动修改 <code>SI</code> 和 <code>DI</code>，使其指向下一个单元</li></ul> <p>例题：用串传送指令实现200个字节数据的传送：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>LEA  <span class="token register variable">SI</span>, MEM1
LEA  <span class="token register variable">DI</span>, MEM2
MOV  <span class="token register variable">CX</span>, <span class="token number">200</span>
CLD              <span class="token comment">; Clear Direction Flag: DF = 0</span>
REP  MOVSB
HLT
</code></pre></div><h4 id="串比较指令-cmps"><a href="#串比较指令-cmps" class="header-anchor">#</a> 串比较指令 CMPS</h4> <div class="language-nasm extra-class"><pre class="language-nasm"><code>CMPS OPRD1(<span class="token register variable">DS</span>:<span class="token register variable">SI</span>), OPRD2(<span class="token register variable">ES</span>:<span class="token register variable">DI</span>)
CMPSB
CMPSW
</code></pre></div><ul><li>和 <code>MOVS</code> 相同的是，后两个命令默认目标串 <code>ES:DI</code>、源串 <code>DS:SI</code></li> <li>和 <code>MOVS</code> 不同的是，<code>OPRD1</code> 为源串，<code>OPRD2</code> 为目标串（这和 <code>SUB</code>、<code>CMP</code> 相同）</li> <li>和 <code>CMP</code> 相同的是，执行 <code>OPRD1-OPRD2</code>，不改变操作数， 只改变标志位</li> <li>串比较指令常与条件重复前缀连用</li> <li>指令的执行不改变操作数，仅影响标志位</li> <li>执行结束后，按 <code>DF</code> 决定的方向自动修改 <code>SI</code> 和 <code>DI</code>，使其指向下一个单元</li></ul> <p>例：比较两组（200个字节）对应数据，找出第一个不同数据放入AL，其地址放入BX</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>      LEA  <span class="token register variable">SI</span>, MEM1
      LEA  <span class="token register variable">DI</span>, MEM2
      MOV  <span class="token register variable">CX</span>, <span class="token number">200</span>
      CLD
      REPE CMPSB     <span class="token comment">; 指令执行结束，可能是找到不同，也可能是完全相同</span>
      JZ   STOP
      DEC  <span class="token register variable">SI</span>        <span class="token comment">; 注意！</span>
      MOV  <span class="token register variable">AL</span>，<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
      MOV  <span class="token register variable">BX</span>，<span class="token register variable">SI</span>
<span class="token label function">STOP:</span> HLT
</code></pre></div><p>上述第 7 行的 <code>DEC SI</code> 说明：<strong>当前 <code>REPE CMPSB</code> 条件不满足时，也会执行 <code>SI++</code> <code>DI++</code> <code>CX--</code>，然后停止执行指令。</strong></p> <h4 id="串扫描指令-scas"><a href="#串扫描指令-scas" class="header-anchor">#</a> 串扫描指令 SCAS</h4> <div class="language-nasm extra-class"><pre class="language-nasm"><code>SCAS  OPRD(<span class="token register variable">ES</span>:<span class="token register variable">DI</span>)
SCASB
SCASW
</code></pre></div><ul><li>执行 <code>AX</code> （或 <code>AL</code>） - <code>OPRD</code>，结果不保存，只影响标志寄存器</li> <li>常用于在指定存储区域中寻找关键字</li> <li><code>OPRD</code> 为目标串，默认为 <code>ES:SI</code></li> <li>执行结束后，按 <code>DF</code> 决定的方向自动修改 <code>DI</code>，使其指向下一个单元</li></ul> <h4 id="串装入指令-lods"><a href="#串装入指令-lods" class="header-anchor">#</a> 串装入指令 LODS</h4> <div class="language-nasm extra-class"><pre class="language-nasm"><code>LODS  OPRD(<span class="token register variable">DS</span>:<span class="token register variable">SI</span>)
LODSB              <span class="token comment">; 存入 AL</span>
LODSW              <span class="token comment">; 存入 AX</span>
</code></pre></div><ul><li>用于将内存某个区域的数据串依次装入累加寄存器  AX/AL，以便进行处理</li> <li>不影响标志位</li> <li><code>LODS</code> 指令加重复前缀无意义（等价于 <code>LOAD</code> 最后一个有效值）</li> <li>执行结束后，按 <code>DF</code> 决定的方向自动修改 <code>SI</code>，使其指向下一个单元（这即是和 <code>MOV AL, [SI]</code> 的最大区别）</li></ul> <h4 id="串存储指令-stos"><a href="#串存储指令-stos" class="header-anchor">#</a> 串存储指令 STOS</h4> <div class="language-nasm extra-class"><pre class="language-nasm"><code>STOS  OPRD(<span class="token register variable">ES</span>:<span class="token register variable">DI</span>)
STOSB              <span class="token comment">; 将 AL 存入内存</span>
STOSW              <span class="token comment">; 将 AX 存入内存</span>
</code></pre></div><p>配合重复前缀，常用于将内存某个区域置同样的值。</p> <h4 id="串操作指令注意事项"><a href="#串操作指令注意事项" class="header-anchor">#</a> 串操作指令注意事项</h4> <p>注意事项：</p> <ul><li>需要定义附加段
<ul><li>目标操作数必须在附加段</li></ul></li> <li>需要设置数据的操作方向
<ul><li>确定 <code>DF</code> 的状态</li></ul></li> <li>源串和目标串指针分别为 <code>SI</code> 和 <code>DI</code></li> <li>串长度值必须由 <code>CX</code> 给出</li> <li>注意重复前缀的使用方法
<ul><li>传送类指令前加无条件重复前缀</li> <li>串比较类指令前加条件重复前缀，但前缀不影响 <code>ZF</code> 状态</li></ul></li></ul> <h3 id="程序控制指令"><a href="#程序控制指令" class="header-anchor">#</a> 程序控制指令</h3> <h4 id="程序的执行方向"><a href="#程序的执行方向" class="header-anchor">#</a> 程序的执行方向</h4> <ul><li>程序控制类指令的本质：<strong>控制程序的执行顺序</strong></li> <li>决定程序执行方向的因素：<code>CS</code>，<code>IP</code></li> <li>下条指令地址：<code>CS:[IP]</code></li> <li>修改 <code>CS</code>，程序转向另一个代码段执行</li> <li>修改 <code>IP</code>，程序转向本代码段内另一处执行</li></ul> <h4 id="转移指令-jmp"><a href="#转移指令-jmp" class="header-anchor">#</a> 转移指令 JMP</h4> <ul><li>转移指令修改 <code>CS</code> 和 <code>IP</code> 的值，实现程序转移</li> <li>分为无条件转移指令和有条件转移指令</li></ul> <h5 id="无条件转移指令"><a href="#无条件转移指令" class="header-anchor">#</a> 无条件转移指令</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>JMP  OPRD
</code></pre></div><h6 id="段内转移"><a href="#段内转移" class="header-anchor">#</a> 段内转移</h6> <ul><li>段内转移：目标地址为 16 位，赋值给 <code>IP</code></li> <li>段内直接转移：<code>OPRD/Label</code> 为<strong>立即数</strong>，<strong><code>IP &lt;= IP + Label</code></strong>（<code>Label</code> 被汇编为 8/16 位位移量）</li> <li>段内间接转移：<code>OPRD</code> 为<strong>寄存器或存储器</strong>，<strong><code>IP &lt;= OPRD</code></strong></li></ul> <p>例题：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>JMP  Next        <span class="token comment">; Next 为标号</span>
<span class="token comment">; 执行后 IP 到 Next 所在指令的地址</span>

JMP  <span class="token register variable">BX</span>          <span class="token comment">;  BX  = 1200H</span>
<span class="token comment">; 执行后 IP = 1200H</span>

JMP  <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>        <span class="token comment">; [BX] = 4312H</span>
<span class="token comment">; 执行后 IP = 4312H。</span>
</code></pre></div><p>关于 Label 的详细介绍可见<a href="#%E6%A0%87%E5%8F%B7">标号</a>。</p> <h6 id="段间转移-jmp-far"><a href="#段间转移-jmp-far" class="header-anchor">#</a> 段间转移 JMP FAR</h6> <ul><li>段间转移：目标地址为 32 位，赋值给 <code>CS:IP</code></li> <li>段内直接转移：<code>OPRD/Label</code> 为<strong>立即数</strong>，<code>CS:IP = Label</code>（<code>Label</code> 被汇编为 32 位地址）</li> <li>段间间接寻址：转移的目标地址由指令中的 32 位<strong>存储器</strong>单元给出</li></ul> <p>例：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>JMP  FAR Label      <span class="token comment">; 段内直接转移</span>
<span class="token comment">; CS:IP = Label</span>

JMP  DWORD PTR<span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>  <span class="token comment">; 段内间接寻址</span>
<span class="token comment">; IP = [BX]</span>
<span class="token comment">; CS = [BX+1]</span>
</code></pre></div><p>例 2：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">SI</span>，<span class="token number">1122H</span>
MOV  WORD PTR<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>，<span class="token number">0120H</span>
ADD  <span class="token register variable">SI</span>，<span class="token number">2</span>
MOV  WORD PTR<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>，<span class="token number">0122H</span>
JMP DWORD PTR<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">]</span>
<span class="token comment">; CS = 0122H, IP = 0120H</span>
</code></pre></div><p>注意第二行，将立即数存入 <code>[SI]</code> 指明的内存时，必须使用 <code>BYTE/WORD PTR</code> 显式指明立即数的长度是 8 位还是 16 位，因为立即数和 <code>[SI]</code> 的长度都是不一定的。寄存器值存入内存则不需要，因为寄存器隐式地给出了长度。参见 <a href="#PTR-%E8%BF%90%E7%AE%97%E7%AC%A6">PTR 运算符</a>。</p> <h5 id="条件转移指令"><a href="#条件转移指令" class="header-anchor">#</a> 条件转移指令</h5> <ul><li>在满足一定条件下，程序转移到目标地址继续执行</li> <li>条件转移指令均为<strong>直接寻址的段内短转移</strong>，即转移的位移量为 8 位补码表示，范围为：<strong>-128~+127</strong>
IP=IP+位移量</li></ul> <p>常见条件指令的应用：</p> <table><thead><tr><th>指令</th> <th>条件</th> <th>应用</th></tr></thead> <tbody><tr><td><code>JC/JNC</code></td> <td>判断<code>CF</code>的状态</td> <td>常用于比大小</td></tr> <tr><td><code>JZ/JNZ</code></td> <td>判断<code>ZF</code>的状态</td> <td>常用于循环体的结束判断</td></tr> <tr><td><code>JO/JNO</code></td> <td>判断<code>OF</code>的状态</td> <td>常用于有符号数溢出的判断</td></tr> <tr><td><code>JS/JNS</code></td> <td>判断<code>SF</code>的状态</td> <td></td></tr> <tr><td><code>JP/JNP</code></td> <td>判断<code>PF</code>的状态</td> <td>用于判断运算结果低8位中1的个数是否为偶数</td></tr> <tr><td>没有类似指令判断 <code>AF</code> 或 <code>DF</code> 的状态，只有上面五个</td> <td></td> <td></td></tr> <tr><td><code>JA/JAE/JB/JBE</code></td> <td>判断<code>CF</code>或<code>CF+ZF</code>的状态</td> <td>常用于无符号数的大小比较</td></tr> <tr><td><code>JG/JGE/JL/JLE</code></td> <td>判断<code>SF</code>、<code>OF</code>和<code>ZF</code>的状态</td> <td>常用于带符号数的大小比较</td></tr></tbody></table> <p>有关 <code>JA</code> <code>JG</code> 等的含义和用法请读者自行百度 / Google。</p> <p>例题：统计内存数据段中以 TABLE 为首地址的 100 个 8 位有符号数中正数、负数和零的个数。</p> <p><img src="/images/282107de057cb912c39b1e4280688ca798324e448b4123a35dec7d4355b2ddd1.png" alt="例题程序"></p> <h4 id="循环控制指令"><a href="#循环控制指令" class="header-anchor">#</a> 循环控制指令</h4> <ul><li>循环范围：以当前 <code>IP</code> 为中心的 <code>-128～+127</code> 范围内循环</li> <li>循环次数：由 <code>CX</code> 寄存器指定</li> <li>循环指令：<code>LOOP</code> <code>LOOPZ</code> <code>LOOPNZ</code></li></ul> <h5 id="无条件循环指令-loop"><a href="#无条件循环指令-loop" class="header-anchor">#</a> 无条件循环指令 LOOP</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>LOOP  LABEL
</code></pre></div><ul><li>操作：</li></ul> <ol><li><code>CX-1 =&gt; CX</code></li> <li><code>CX ≠ 0</code> 则转 <code>LABEL</code>，否则执行下条指令</li></ol> <p>也就是说，当 <code>CX = 1</code> 时执行 <code>LOOP</code> 则不会跳转，而是顺序执行。</p> <h5 id="有条件循环指令-loopz-loopnz-略"><a href="#有条件循环指令-loopz-loopnz-略" class="header-anchor">#</a> 有条件循环指令 LOOPZ LOOPNZ（略）</h5> <p><code>LOOPZ</code> 和 <code>LOOPNZ</code></p> <h4 id="过程调用指令-call"><a href="#过程调用指令-call" class="header-anchor">#</a> 过程调用指令 CALL</h4> <ul><li>用于调用一个子过程</li> <li>子过程由程序员预先设计并装入内存</li> <li>子过程执行结束后要返回原调用处</li> <li>重要概念：入口地址、断点，如图</li></ul> <p><img src="/images/75d5aab2e89484cb5e629d88f5b36a4574c3bd86224bbda12a5ec56bd0865b75.png" alt="入口地址和断点"></p> <p>调用指令的执行过程：</p> <ol><li>保护断点：将断点（调用指令的下一条指令的地址）压栈</li> <li>获取子过程的入口地址（子过程第一条指令的地址）</li> <li>执行子过程，含相应参数的保存及恢复</li> <li>恢复断点，返回原程序（将断点地址由堆栈弹出）</li></ol> <p>分为：</p> <ul><li>段内直接调用</li> <li>段内间接调用</li> <li>段间直接调用</li> <li>段间间接调用</li></ul> <h5 id="段内调用-call-near"><a href="#段内调用-call-near" class="header-anchor">#</a> 段内调用 CALL NEAR</h5> <p>由于被调用程序与调用程序在同一代码段，调用前只需保护断点的偏移地址。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>CALL  (NEAR)  PROC
</code></pre></div><p>执行过程：</p> <ul><li>断点压栈</li> <li><code>PROC =&gt; IP</code></li></ul> <p>例：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>CALL  TIMER           <span class="token comment">; 直接调用</span>

CALL  WORD  PTR<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>   <span class="token comment">; 间接调用，指明长度为 16 位，是段内调用</span>
<span class="token comment">; 执行后 IP = [SI], CS 不变</span>
</code></pre></div><h5 id="段间调用-call-far"><a href="#段间调用-call-far" class="header-anchor">#</a> 段间调用 CALL FAR</h5> <p>由于子过程与原调用程序不在同一代码段，调用前需保护断点的段基地址和偏移地址。</p> <p><strong>先将 <code>CS</code> 压栈，再压入 <code>IP</code>。</strong></p> <p>格式：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>CALL  FAR  PROC
</code></pre></div><p>例：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>CALL  FAR  TIMER

CALL  DWORD  PTR<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>    <span class="token comment">; 指明长度为 32 位，是段间调用</span>
<span class="token comment">; 执行后 IP = [SI]</span>
<span class="token comment">; CS = [SI+2]</span>
</code></pre></div><h5 id="返回指令-ret"><a href="#返回指令-ret" class="header-anchor">#</a> 返回指令 RET</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>RET
</code></pre></div><ul><li>从堆栈中弹出断点地址，返回原程序</li> <li>一般位于子程序的最后</li> <li>在格式上不区分段内或段间</li></ul> <h4 id="中断控制指令"><a href="#中断控制指令" class="header-anchor">#</a> 中断控制指令</h4> <h5 id="中断和过程调用的区别"><a href="#中断和过程调用的区别" class="header-anchor">#</a> 中断和过程调用的区别</h5> <ul><li>中断是随机事件或异常事件引起，调用则是事先已在程序中安排好</li> <li>响应中断请求不仅要保护断点地址，还要保护 <code>FLAGS</code> 内容</li> <li>调用指令在指令中直接给出子程序入口地址</li> <li>中断指令只给出中断向量码，入口地址则在中断向量码指向的中断向量表（内存单元）中</li></ul> <h5 id="中断指令-int"><a href="#中断指令-int" class="header-anchor">#</a> 中断指令 INT</h5> <p>中断指令，又称作软中断指令</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>INT  n
<span class="token comment">; n*4 为中断服务程序入口的偏移地址（段地址 = DS）</span>
<span class="token comment">; 8086 的中断向量表存放在内存最低的 1K 单元</span>
</code></pre></div><h5 id="中断指令的执行过程"><a href="#中断指令的执行过程" class="header-anchor">#</a> 中断指令的执行过程</h5> <ul><li>将 <code>FLAGS</code> 压入堆栈</li> <li>将 <code>INT</code> 指令的下一条指令的 <code>CS</code>、<code>IP</code> 压栈</li> <li>由 <code>n*4</code> 得到存放中断向量的地址</li> <li>将中断向量（中断服务程序入口地址）送 <code>CS</code> 和 <code>IP</code> 寄存器
<ul><li><code>CS = DS:[n*4]</code></li> <li><code>IP = DS:[n*4+2]</code></li></ul></li> <li>转入中断服务程序</li></ul> <p>下图中，左图为中断后的堆栈段，右图为数据段和代码段。</p> <p><img src="/images/5370d71c8a40900e23d1a12d8c5c48f6229a59dfb1504056cce3b0e71c180fc0.png" alt="中断指令的执行过程"></p> <p>例：</p> <p><code>[0084H] = 1123H</code>, <code>[0086H] = 2000H</code>。执行 <code>INT 21H</code> 后，</p> <ul><li><code>IP = [21H*4] = 1123H</code></li> <li><code>CS = [21H*4+2] = 2000H</code></li> <li>下一条指令在 <code>21123H</code></li></ul> <h5 id="溢出中断指令-into"><a href="#溢出中断指令-into" class="header-anchor">#</a> 溢出中断指令 INTO</h5> <p><code>INTO</code> 指令通常安排在有符号数加减运算指令之后判断是否发生溢出</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>INTO
</code></pre></div><ul><li>指令执行时检查 <code>OF</code> 标志：
<ul><li>若 <code>OF=1</code>，则启动一个类型为4的中断过程,即相当于执行指令: <code>INT 4</code></li> <li>若 <code>OF=0</code>，不做任何操作执行下一条指令</li></ul></li></ul> <h5 id="中断返回指令-iret"><a href="#中断返回指令-iret" class="header-anchor">#</a> 中断返回指令 IRET</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>IRET
</code></pre></div><ul><li>中断服务程序的最后一条指令，执行：
<ol><li>恢复断点</li> <li>恢复标志寄存器内容</li></ol></li></ul> <h4 id="处理器控制指令"><a href="#处理器控制指令" class="header-anchor">#</a> 处理器控制指令</h4> <p>主要分为：</p> <ul><li>对标志位的操作
<ul><li>对标志位操作都是无操作数指令</li> <li>可操作的标志位有 <code>CF</code>、<code>IF</code>和<code>DF</code></li></ul></li> <li>与外部设备的同步</li></ul> <table><thead><tr><th>常见指令</th> <th>作用</th></tr></thead> <tbody><tr><td><code>CLC</code> (clear CF)</td> <td>清除进位标志</td></tr> <tr><td><code>STC</code> (set CF)</td> <td>置1进位标志</td></tr> <tr><td><code>CMC</code> (complement CF)</td> <td>进位标志取反</td></tr> <tr><td><code>CLD</code></td> <td>清除方向标志</td></tr> <tr><td><code>STD</code></td> <td>置1方向标志</td></tr> <tr><td><code>CLI</code></td> <td>清除中断标志</td></tr> <tr><td><code>STI</code></td> <td>置1中断标志</td></tr></tbody></table> <h2 id="第四章-汇编语言程序设计"><a href="#第四章-汇编语言程序设计" class="header-anchor">#</a> 第四章 汇编语言程序设计</h2> <h3 id="汇编语言语句种类及其格式"><a href="#汇编语言语句种类及其格式" class="header-anchor">#</a> 汇编语言语句种类及其格式</h3> <p>汇编语言语句分为指令语句和伪指令语句。</p> <h4 id="指令语句"><a href="#指令语句" class="header-anchor">#</a> 指令语句</h4> <p>每一条指令语句在汇编时都要产生一个可供CPU执行的机器目标代码，它又叫可执行语句。</p> <p><img src="/images/20a5c3d0761cc76031f79f5614dfcd829e3fa595afa28c3ed9ec8e811e2b4855.png" alt="指令语句的一般格式"></p> <ul><li>指令助记符和操作数两个字段就是<a href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F">上一章——指令系统</a>介绍的指令</li> <li>标号是可选字段，后面必须跟 <code>:</code> <ul><li>主要用于控制程序执行顺序</li></ul></li> <li>注释字段为可选项，以分号 <code>;</code> 开始
<ul><li>它不会产生机器目标代码，不影响程序的功能</li> <li>注释可以加在指令的后面，也可以是整个语句行</li></ul></li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token label function">LABEL1:</span> ADD  <span class="token register variable">AX</span>, <span class="token register variable">BX</span>  <span class="token comment">;功能为AX&lt;=(AX)+(BX)</span>
<span class="token comment">; 后面的程序段将完成一次对存储器的访问</span>
</code></pre></div><h4 id="伪指令语句"><a href="#伪指令语句" class="header-anchor">#</a> 伪指令语句</h4> <ul><li>伪指令语句又叫命令语句，是指示性语句</li> <li>伪指令本身不产生自己的机器目标代码，它指示汇编程序对其后面的指令语句和伪指令语句如何处理</li></ul> <p><img src="/images/740e07dc751a8a621249923fc873f59e1eed613e8ef78cde4a10a5c13ab81c66.png" alt="伪指令语句的一般格式"></p> <h4 id="标识符"><a href="#标识符" class="header-anchor">#</a> 标识符</h4> <p>指令语句中的标号和伪指令语句中的符号名统称为标识符，它由若干个字符构成。</p> <p>标识符构成规则：</p> <ul><li>字符的个数为 1-31 个</li> <li>可以使用字母、数字、<code>@</code> 、 <code>_</code>或 <code>?</code></li> <li>不能以数字开头</li> <li>不能使用系统专用的保留字</li></ul> <h4 id="保留字"><a href="#保留字" class="header-anchor">#</a> 保留字</h4> <ul><li>CPU 中各寄存器名（如 <code>AX</code>、<code>CS</code> 等）</li> <li>指令助记符（如<code>MOV</code>、<code>ADD</code>）</li> <li>伪指令符（如<code>SEGMENT</code>、<code>DB</code>）</li> <li>表达式中的运算符（如<code>GE</code>、<code>EQ</code>）</li> <li>属性操作符（如<code>PTR</code>、<code>OFFSET</code>等）</li></ul> <h3 id="汇编语言数据"><a href="#汇编语言数据" class="header-anchor">#</a> 汇编语言数据</h3> <ul><li>数据：指令和伪指令语句中的操作数</li> <li>常用的数据形式有：<strong>常数</strong>、<strong>变量</strong>和<strong>标号</strong></li> <li>一个数据由<strong>数值</strong>和<strong>属性</strong>（比如是字节数据还是字数据）两部分构成</li></ul> <h4 id="常数"><a href="#常数" class="header-anchor">#</a> 常数</h4> <p>常数：经过汇编后其值已完全确定，并且在程序运行过程中不会改变。</p> <h5 id="常数的表示"><a href="#常数的表示" class="header-anchor">#</a> 常数的表示</h5> <ul><li>二进制数：以字母 <code>B</code> 结尾，如 <code>01001001B</code></li> <li>八进制数：以字母 <code>O</code> 或 <code>Q</code> 结尾，如<code>631Q</code> <code>254O</code></li> <li>十进制数：以字母 <code>D</code> 结尾，或者没有结尾字母。如 <code>2007D</code>、<code>2007</code></li> <li>十六进制数：以字母 <code>H</code> 结尾，如 <code>3FEH</code> <ul><li>如果常数的第一个数符为字母，为了与标识符区别，必须在其前面冠以数字 <code>0</code>，如<code>0F000H</code> 为 16 位常数</li></ul></li> <li>实数：如 <code>2.134E+10</code>。汇编源程序时会把实数转换为 4 字节、8 字节或 10 字节的二进制数形式存放。</li> <li>字符串常数：用引号（单引号或双引号）括起来的一个或多个字符，其值为这些字符的ASCII码
<ul><li>如 <code>'ABC'</code> 存储为 <code>41H 42H 43H</code></li> <li>其中 <code>41H</code> 在低地址，<code>43H</code> 在高地址，类似于 C 语言的 <code>char *</code></li></ul></li></ul> <h5 id="常数的作用"><a href="#常数的作用" class="header-anchor">#</a> 常数的作用</h5> <ol><li>作指令语句的源操作数</li> <li>在指令语句中作位移量</li> <li>在数据定义伪指令中使用</li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 1. 作指令语句的源操作数</span>
MOV  <span class="token register variable">AX</span>,  <span class="token number">0B2F0H</span>
ADD  <span class="token register variable">AH</span>,  <span class="token number">64H</span>

<span class="token comment">; 2. 在指令语句中作位移量</span>
MOV  <span class="token register variable">BX</span>, <span class="token number">32H</span> <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
MOV  <span class="token number">0ABH</span> <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>, <span class="token register variable">CX</span>
ADC  <span class="token register variable">DX</span>, <span class="token number">1234H</span><span class="token operator">[</span><span class="token register variable">BP</span><span class="token operator">]</span><span class="token operator">[</span><span class="token register variable">DI</span><span class="token operator">]</span>

<span class="token comment">; 3. 在数据定义伪指令中使用</span>
DB   <span class="token number">10H</span>
DW   <span class="token number">3210H</span>
</code></pre></div><h4 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h4> <p>变量：用来表示存放数据的存储单元，这些数据在程序运行期间可以被改变。</p> <p>程序中以变量名的形式来访问变量。<strong>变量名就是存放数据的存储单元地址</strong>。</p> <h5 id="变量的定义"><a href="#变量的定义" class="header-anchor">#</a> 变量的定义</h5> <p>定义变量：给变量在内存中分配一定的存储单元。也就是给这个存储单元赋与一个符号名，即变量名，同时还要将这些存储单元预置初置。</p> <p>定义变量使用数据定义伪指令 <code>DB</code>、<code>DW</code>、<code>DD</code>、<code>DQ</code> 和 <code>DT</code> 等。</p> <p>格式：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>VAR_DATA SEGMENT
DATA1 DB <span class="token number">12H</span>
<span class="token comment">; 变量名 + 数据定义伪指令 + 初值</span>
DATA2 DB <span class="token number">20H</span>, <span class="token number">30H</span>
DATA3 DW <span class="token number">5678H</span>
VAR_DATA ENDS
</code></pre></div><h5 id="变量的属性"><a href="#变量的属性" class="header-anchor">#</a> 变量的属性</h5> <ol><li>段属性（逻辑段）：上例 <code>DATA1</code> <code>DATA2</code> <code>DATA3</code> 均在 <code>VAR_DATA</code> 逻辑段</li> <li>偏移量属性（偏移地址）：上例 <code>DATA1</code> <code>DATA2</code> <code>DATA3</code> 的偏移量分别为 0, 1, 3</li> <li>类型属性，如下：</li></ol> <table><thead><tr><th>类型</th> <th>中文</th> <th>变量长度</th></tr></thead> <tbody><tr><td><code>DB</code></td> <td>Define Byte</td> <td>1 字节</td></tr> <tr><td><code>DW</code></td> <td>Define Word</td> <td>2 字节</td></tr> <tr><td><code>DD</code></td> <td>Define Doubleword</td> <td>4 字节</td></tr> <tr><td><code>DQ</code></td> <td>Define Quadword</td> <td>8 字节</td></tr> <tr><td><code>DT</code></td> <td>Define Tenbytes</td> <td>10 字节</td></tr></tbody></table> <h5 id="变量的预置"><a href="#变量的预置" class="header-anchor">#</a> 变量的预置</h5> <ol><li>数值表达式</li> <li><code>?</code> 表达式：表示预置任意内容（未赋初值）</li> <li>字符串表达式</li> <li><code>DUP</code> 表达式</li></ol> <h6 id="数值表达式"><a href="#数值表达式" class="header-anchor">#</a> 数值表达式</h6> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 1. 数值表达式</span>
DATA1  DB  <span class="token number">32</span>, <span class="token number">30H</span>
<span class="token comment">; DATA1 的内容为 32（20H）</span>
<span class="token comment">; DATA1+1 单元内容为30H</span>
</code></pre></div><h6 id="表达式"><a href="#表达式" class="header-anchor">#</a> ? 表达式</h6> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DA<span class="token operator">-</span>BYTE DB ?, ?, ?
<span class="token comment">; 表示让汇编程序分配三个字节存储单元</span>
<span class="token comment">; 这些存储单元的内容的值为任意（未赋初值）</span>
</code></pre></div><h6 id="字符串表达式"><a href="#字符串表达式" class="header-anchor">#</a> 字符串表达式</h6> <ul><li>字符串长度不超过 255 个字符</li> <li>使用 <code>DB</code> 伪指令，会对每个字符分配一个字节单元，从左到右将各字符的 ASCII 码以地址递增的顺序依次存放</li> <li>使用 <code>DW</code> 伪指令，可以给两个字符组成的字符串分配两个字节存储单元</li> <li>但需要注意的是，两个字符的存放顺序是前一个字符放在高地址，后一字符放低地址单元</li> <li>使用 <code>DD</code> 伪指令，只能给<strong>两个字符</strong>组成的字符串分配 <strong>4 个字节单元</strong></li> <li>两个字符存放在较低地址的两个字节单元中，存放顺序与 <code>DW</code> 伪指令相同</li> <li>而较高地址的两个字节单元存放 0</li> <li><code>DW</code> 和 <code>DD</code> 伪指令不能用两个以上字符构成的字符串赋初值</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 3. 字符串表达式</span>
STRING1  DB  <span class="token string">'ABCDEF'</span>
<span class="token comment">; 低地址到高地址依次为 'A' 'B' 'C' 'D' 'E' 'F'</span>

STRING2 DW <span class="token string">'AB'</span>, <span class="token string">'CD'</span>, <span class="token string">'EF'</span>
<span class="token comment">; 低地址到高地址依次为 'B' 'A' 'D' 'C' 'F' 'E'</span>

STRING3 DD, <span class="token string">'AB'</span>, <span class="token string">'CD'</span>
<span class="token comment">; 低地址到高地址依次为 'B' 'A' 0 0 'D' 'C' 0 0</span>
</code></pre></div><h6 id="dup-表达式"><a href="#dup-表达式" class="header-anchor">#</a> DUP 表达式</h6> <p>DUP 称为重复数据操作符。其格式为：<code>变量名 数据定义伪指令 重复次数 DUP(重复内容)</code>。</p> <p>如：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA_A DB <span class="token number">10H</span> DUP(?)
<span class="token comment">; 分配 16 个字节单元，不赋初值</span>

DATA_B DB <span class="token number">20H</span> DUP(<span class="token string">'AB'</span>)
<span class="token comment">; 分配 20H * 2 = 64 个字节单元，其内容为 'ABABAB'...</span>
</code></pre></div><p><strong>嵌套的 <code>DUP</code></strong>：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA_C DB <span class="token number">10H</span> DUP(<span class="token number">4</span> DUP(<span class="token number">2</span>), <span class="token number">7</span>)
<span class="token comment">; 重复 10H 个数字序列（2、2、2、2、7），共占用 10H*5 = 50H 字节</span>
</code></pre></div><p><code>DUP</code> 和 <code>DW</code> 组合时，每个 <code>重复内容</code> 占用两字节，例如：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA  DW <span class="token number">5</span>, <span class="token number">2</span> DUP(<span class="token number">1</span>, <span class="token number">2</span> DUP(<span class="token number">1</span>))
</code></pre></div><p>DW 所指向的内存单元（每字节）为 <code>5</code> <code>0</code> <code>1</code> <code>0</code> <code>1</code> <code>0</code> <code>1</code> <code>0</code> <code>1</code> <code>0</code> <code>1</code> <code>0</code> <code>1</code> <code>0</code>，共占用 14 字节。</p> <h6 id="地址表达式"><a href="#地址表达式" class="header-anchor">#</a> 地址表达式</h6> <p>该地址表达式为一<strong>变量名</strong>（或标号名），那么：</p> <ul><li>用伪指令 <code>DW</code> 定义则是用它的<strong>偏移量</strong>来初始化变量</li> <li>用伪指令 <code>DD</code> 定义则是用它的<strong>段基值和偏移量</strong>来初始化变量，且段基值存放在高字单元，偏移量存放在低字单元</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 设以下变量的段基址为 0915H，NUM 的偏移地址为 0004H</span>
NUM   DB <span class="token number">75H</span>
ARRAY DW <span class="token number">20H</span> DUP(<span class="token number">0</span>)

ADR1  DW NUM         <span class="token comment">; DW 时取 NUM 的偏移地址</span>
<span class="token comment">; ADR1 = 0004H</span>

ADR2  DD NUM         <span class="token comment">; DD 时取 NUM 的偏移地址（存入低字）和段基址（存入）</span>
<span class="token comment">; ADR2 = 0915 0004H</span>

ADR3  DW ARRAY<span class="token operator">[</span><span class="token number">2</span><span class="token operator">]</span>
<span class="token comment">; ADR3 = 0007H</span>
</code></pre></div><p>注意：变量不能出现在 <code>DB</code> 语句的右边，因为变量的偏移地址为 16 位，与 <code>DB</code> 定义的变量长度不匹配。</p> <p><img src="/images/b0511e29b7cdda8e6854a123995af5eb1ba0228928dc5157ff13bb2d0d100edd.png" alt="语句运行后的内存"></p> <p>注意，<code>ARRAY[2]</code> 这样的形式，等价于 <code>OFFSET(ARRAY)+2</code>。<strong>和 C 语言不同的是，[2] 不会根据是 DB 还是 DW 而使用不同的偏移量，而是一律偏移 2</strong>！可详见<a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a>。</p> <h6 id="以上表达式组成的序列"><a href="#以上表达式组成的序列" class="header-anchor">#</a> 以上表达式组成的序列</h6> <p>如下：</p> <div class="language- extra-class"><pre class="language-text"><code>NUM DB 2 DUP(1), 2 DUP(2, 'B'), '123', 1, 2, 3
; NUM 从低地址到高地址分别为 1 1 2 'B' 2 'B' '1' '2' '3' 1 2 3
</code></pre></div><h5 id="变量的使用"><a href="#变量的使用" class="header-anchor">#</a> 变量的使用</h5> <p>在指令语句中，<strong>直接引用变量名就是对其存储单元的内容进行存取</strong>。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DA1  DB <span class="token number">0FEH</span>
DA2  DW <span class="token number">52ACH</span>
DA3  DW <span class="token number">0</span>

MOV  <span class="token register variable">AL</span>, DA1   <span class="token comment">; 等价于 MOV  AL, 0FEH</span>
MOV  <span class="token register variable">BX</span>, DA2   <span class="token comment">; 等价于 MOV  BX, 52ACH</span>
MOV  DA3, <span class="token register variable">BX</span>   <span class="token comment">; 将 DA3 变量赋值 52ACH，注意二者大小需要对应</span>
<span class="token comment">; 变量是可以被重复赋值的</span>
</code></pre></div><ul><li><strong>伪指令语句中，<code>DATA2 DB DATA1</code> 为取 <code>DATA1</code> 地址</strong></li> <li><strong>指令语句中，<code>MOV AL, DATA1</code> 为取 <code>DATA1</code> 存储的值</strong></li></ul> <h4 id="符号和变量对比"><a href="#符号和变量对比" class="header-anchor">#</a> 符号和变量对比</h4> <table><thead><tr><th></th> <th>符号</th> <th>变量</th></tr></thead> <tbody><tr><td>可变与否</td> <td>类似于常量，不可变</td> <td>可变</td></tr> <tr><td>定义</td> <td><code>EQU</code> 或 <code>=</code></td> <td><code>DB</code> <code>DW</code> 等</td></tr> <tr><td>地址空间</td> <td>无</td> <td>有段基址、偏移地址</td></tr></tbody></table> <h4 id="标号"><a href="#标号" class="header-anchor">#</a> 标号</h4> <ul><li>标号 <code>label</code> 加在一条指令的前面，它就是该指令在内存的存放地址的符号表示，也就是指令地址的别名</li> <li>标号主要用在程序中需要改变程序的执行顺序时，用来标记转移的目的地</li> <li>下面代码的 <code>LAB</code> 和 <code>NEXT</code> 即为标号</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>      MOV  <span class="token register variable">CX</span>, <span class="token number">100</span>
<span class="token label function">LAB:</span>  MOV  <span class="token register variable">AX</span>, <span class="token register variable">BX</span>
      <span class="token comment">; ...</span>
      LOOP LAB
      JNE NEXT       <span class="token comment">;不为零转移</span>
      <span class="token comment">; ...</span>
<span class="token label function">NEXT:</span> <span class="token comment">; ...</span>
</code></pre></div><h5 id="标号的三个属性"><a href="#标号的三个属性" class="header-anchor">#</a> 标号的三个属性</h5> <ol><li>段属性 <code>SEG</code></li></ol> <p>它表示该标号所代表的地址在哪个逻辑段中，即段基值。</p> <ol start="2"><li>偏移量属性 <code>OFFSET</code></li></ol> <p>它表示该标号所代表的地址在段内与段起点间的字节数，即地址的偏移量。</p> <ol start="3"><li>距离属性（也叫类型属性）</li></ol> <p>它表示该标号可以被段内还是段间的指令调用。</p> <ul><li><code>NEAR</code>（近）：用作段内转移，即只能是与该标号所指指令同在一个逻辑段的其它指令才能使用它</li> <li><code>FAR</code>（远）：可以被非本段的转移和调用指令使用</li></ul> <p>标号的距离属性可以有两种方法来指定：</p> <p>(1) 隐含方式</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token label function">SUB1:</span> MOV  <span class="token register variable">AX</span>, <span class="token number">30H</span>
</code></pre></div><p><code>SUB1</code> 默认为 NEAR。</p> <p>(2) 用 <code>LABEL</code> 伪指令给标号指定距离属性</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>标号名 LABEL NEAR<span class="token operator">/</span>FAR
</code></pre></div><p>该语句要与指令语句连用，如下：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>SUB1_FAR LABEL FAR
<span class="token label function">SUB1:</span> MOV  <span class="token register variable">AX</span>, <span class="token number">30H</span>
</code></pre></div><p>上文中，<code>SUB1_FAR</code> 与 <code>SUB1</code> 两个标号具有相同的逻辑地址。但 <code>SUB1</code> 只能被本段调用，<code>SUB1_FAR</code> 可以被其它段的指令调用。</p> <h5 id="label-定义变量属性"><a href="#label-定义变量属性" class="header-anchor">#</a> LABEL 定义变量属性</h5> <p><code>LABEL</code> 伪指令还可以用于定义变量的属性，即改变一个变量的属性，如把字变量的高低字节作为字节变量来处理。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA_BYTE  LABEL  BYTE
DATA_WORD  DW  <span class="token number">20H</span>  DUP(?)
</code></pre></div><ul><li><code>DATA_BYTE</code> 与 <code>DATA_WORD</code> 具有相同的段基址和偏移量</li> <li><code>DATA_BYTE</code> 可以被用来存取一个字节数据，而 <code>DATA_WORD</code> 则不能</li></ul> <h3 id="符号定义语句"><a href="#符号定义语句" class="header-anchor">#</a> 符号定义语句</h3> <p>符号定义语句将常数或表达式等形式用某个指定的符号来表示。在 8086/8088 汇编语言中有两种符号定义语句，分别为等值语句 <code>EQU</code> 和等号语句 <code>=</code>。</p> <h4 id="等值语句-equ"><a href="#等值语句-equ" class="header-anchor">#</a> 等值语句 EQU</h4> <ul><li>格式：<code>符号名 EQU 表达式</code></li> <li>功能：用符号名来表示 <code>EQU</code> 右边的表达式。后面的程序中一旦出现该符号名，汇编程序将把它替换成该表达式。</li> <li>类似于 C 的 <code>#define</code></li></ul> <hr> <p><code>表达式</code>：</p> <ol><li>常数或数值表达式</li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code>COUNT  EQU  <span class="token number">5</span>
NUM    EQU  COUNT<span class="token operator">+</span><span class="token number">5</span>
</code></pre></div><ol start="2"><li>地址表达式</li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code>ADR1   EQU  <span class="token register variable">DS</span>:<span class="token operator">[</span><span class="token register variable">BP</span><span class="token operator">+</span><span class="token number">14</span><span class="token operator">]</span>
</code></pre></div><ol start="3"><li>变量名、寄存器名或指令助记符</li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code>CREG  EQU  <span class="token register variable">CX</span>   <span class="token comment">; 在后面的程序使用CREG就是使用CX</span>
CBD   EQU  DAA  <span class="token comment">; DAA为十进制调整指令</span>
</code></pre></div><p>注意，同一符号不能用 <code>EQU</code> 重复定义。</p> <h4 id="等号语句"><a href="#等号语句" class="header-anchor">#</a> 等号语句 =</h4> <p>格式：<code>符号名=表达式</code></p> <p>等号语句与等值语句具有类似的作用，二者的区别是：</p> <ul><li>等号语句可以对一个符号进行多次定义</li> <li>等号语句不能为助记符定义别名（诸如 <code>CBD=DAA</code> 是错误的）</li></ul> <p>等值语句与等号语句都不会为符号分配存储单元。所定义的符号没有段、偏离量和类型等属性。</p> <h3 id="表达式与运算符"><a href="#表达式与运算符" class="header-anchor">#</a> 表达式与运算符</h3> <p>表达式是指令或伪指令语句操作数的常见形式。它由常数、变量、标号等通过操作运算符连接而成。</p> <p><strong>任何表达式的值在程序被汇编的过程中进行计算确定，而不是到程序运行时才计算。</strong></p> <p>8086/8088宏汇编语言中的操作运算符非常丰富，可以分为以下五类。</p> <ul><li>算术运算符</li> <li>逻辑运算符</li> <li>关系运算符</li> <li>数值返回运算符</li> <li>属性修改运算符</li></ul> <h4 id="算术运算符"><a href="#算术运算符" class="header-anchor">#</a> 算术运算符</h4> <p>包含 <code>+</code>、<code>-</code>、<code>*</code>、 <code>/</code> 、<code>MOD</code>、<code>SHL</code>、<code>SHR</code>、<code>[ ]</code>。</p> <ol><li>运算符 <code>+</code> 和 <code>-</code> 也可作单目运算符，表示数的正负</li> <li>使用 <code>+</code>、<code>-</code>、<code>*</code> 和 <code>/</code> 运算符时，参加运算的数和运算结果都是<strong>整数</strong></li> <li><code>/</code> 运算为取商的整数部分，而 <code>MOD</code> 运算取除法运算的余数</li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code>NUM<span class="token operator">=</span><span class="token number">15</span><span class="token operator">*</span><span class="token number">8</span>       <span class="token comment">; NUM = 120</span>
NUM<span class="token operator">=</span>NUM<span class="token operator">/</span><span class="token number">7</span>      <span class="token comment">; NUM = 17</span>
NUM<span class="token operator">=</span>NUM MOD <span class="token number">3</span>  <span class="token comment">; NUM = 2</span>
NUM<span class="token operator">=</span>NUM<span class="token operator">+</span><span class="token number">5</span>      <span class="token comment">; NUM = 7</span>
NUM<span class="token operator">=</span><span class="token operator">-</span>NUM<span class="token operator">-</span><span class="token number">3</span>     <span class="token comment">; NUM = -10</span>
NUM<span class="token operator">=</span><span class="token operator">-</span>NUM<span class="token operator">-</span>NUM   <span class="token comment">; NUM = 20</span>
</code></pre></div><ol start="4"><li><code>SHR</code> 和 <code>SHL</code> 为逻辑移位运算符</li></ol> <p><code>SHR</code> 为右移，左边移出来的空位用 0 补入。
<code>SHL</code> 为左移，右边移出来的空位用 0 补入。</p> <p>移位运算符（如上）与<a href="#%E7%AE%97%E6%9C%AF%E5%B7%A6%E7%A7%BB-sal-%E9%80%BB%E8%BE%91%E5%B7%A6%E7%A7%BB-shl">移位指令</a>区别：</p> <ul><li>移位运算符的操作对象只能是某一具体的数（<strong>常数</strong>），在汇编（编译）时完成移位操作</li> <li>而移位指令是<strong>对一个寄存器或存储单元内容</strong>，在程序运行时执行移位操作</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>NUM<span class="token operator">=</span><span class="token number">11011011B</span>

MOV  <span class="token register variable">AX</span>, NUM SHL <span class="token number">1</span>   <span class="token comment">; AX=1 1011 0110B</span>
MOV  <span class="token register variable">BX</span>, NUM SHR <span class="token number">2</span>   <span class="token comment">; BX= 11 0110B</span>
ADD  <span class="token register variable">DX</span>, NUM SHR <span class="token number">6</span>   <span class="token comment">; DX = 11B</span>
</code></pre></div><ol start="5"><li>下标运算符 <code>[ ]</code> 具有相加的作用</li></ol> <p><code>MOV AX，DA_WORD[20H]</code> 等价于 <code>MOV AX，DA_WORD+20H</code>。</p> <p>不过，需要注意的是汇编的 <code>[ ]</code> 和 C 语言不同：</p> <blockquote><p>C 语言中，如果变量 <code>DA_WORD</code> 为 2 字节，<code>DA_WORD[20H]</code> 为 DA_WORD 偏移 20H*2 字节后的内容；而汇编中只是普通的加法，<code>DA_WORD[20H]</code> 为 DA_WORD 偏移 20H 字节后的内容。</p></blockquote> <p>以下语句均等价：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AX</span>, ARRAY<span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span><span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>  <span class="token comment">; 基址变址寻址</span>
MOV  <span class="token register variable">AX</span>, ARRAY<span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">+</span><span class="token register variable">SI</span><span class="token operator">]</span>
MOV  <span class="token register variable">AX</span>, <span class="token operator">[</span>ARRAY<span class="token operator">+</span><span class="token register variable">BX</span><span class="token operator">]</span><span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
MOV  <span class="token register variable">AX</span>, <span class="token operator">[</span>ARRAY<span class="token operator">+</span><span class="token register variable">SI</span><span class="token operator">]</span><span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>
MOV  <span class="token register variable">AX</span>, <span class="token operator">[</span>ARRAY<span class="token operator">+</span><span class="token register variable">BX</span><span class="token operator">+</span><span class="token register variable">SI</span><span class="token operator">]</span>
</code></pre></div><p>以下为错误语句：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AX</span>，ARRAY<span class="token operator">+</span><span class="token register variable">BX</span><span class="token operator">+</span><span class="token register variable">SI</span>
MOV  <span class="token register variable">AX</span>，ARRAY<span class="token operator">+</span><span class="token register variable">BX</span><span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
MOV  <span class="token register variable">AX</span>，ARRAY<span class="token operator">+</span>DA_WORD
</code></pre></div><h4 id="逻辑运算符"><a href="#逻辑运算符" class="header-anchor">#</a> 逻辑运算符</h4> <p>逻辑运算符有NOT、AND、OR和XOR等四个，它们执行的都是按位逻辑运算。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AX</span>，NOT <span class="token number">0F0H</span>       <span class="token comment">; 0FF0FH</span>
MOV  <span class="token register variable">AL</span>, NOT <span class="token number">0F0H</span>       <span class="token comment">; 0FH</span>
MOV  <span class="token register variable">BL</span>, <span class="token number">55H</span> AND <span class="token number">0F0H</span>   <span class="token comment">; 50H</span>
MOV  <span class="token register variable">BH</span>, <span class="token number">55H</span> OR <span class="token number">0F0H</span>    <span class="token comment">; 0F5H</span>
MOV  <span class="token register variable">CL</span>, <span class="token number">55H</span> XOR <span class="token number">0F0H</span>   <span class="token comment">; 0A5H</span>
</code></pre></div><h4 id="关系运算符"><a href="#关系运算符" class="header-anchor">#</a> 关系运算符</h4> <ul><li>关系运算符包括：<code>EQ</code>（等于）、<code>NE</code>（不等于）、<code>LT</code>（小于，less than）、 <code>LE</code>（小于等于）、<code>GT</code>（大于）、 <code>GE</code>（大于等于）</li> <li>关系运算符用来比较两个表达式的大小。比较的两个表达式必须同为<strong>常数</strong>或<strong>同一逻辑段中的变量</strong></li> <li>若是常量的比较，则按<strong>无符号数</strong>进行比较；若是变量的比较，则比较它们的<strong>偏移量</strong>的大小。</li> <li>关系运算的结果只能是<code>真</code>（<strong>全 1</strong>）或<code>假</code>（<strong>全 0</strong>）</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AX</span>，<span class="token number">0FH</span> EQ <span class="token number">1111B</span>  <span class="token comment">; AX = 0FFFF</span>
MOV  <span class="token register variable">BX</span>, <span class="token number">0FH</span> NE <span class="token number">1111B</span>  <span class="token comment">; BX = 0</span>

VAR  DW NUM LT <span class="token number">0ABH</span>    <span class="token comment">; 若符号常量 NUM 值小于 0ABH，则 DW=0FFFFH；否则为 0</span>
</code></pre></div><h4 id="数值返回运算符"><a href="#数值返回运算符" class="header-anchor">#</a> 数值返回运算符</h4> <p>该类运算符有 5 个，它们可以将变量或标号的某些特征值或存储单元地址的一部分提取出来。</p> <h5 id="seg-运算符"><a href="#seg-运算符" class="header-anchor">#</a> SEG 运算符</h5> <p>取变量或标号所在段的段基址。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 设 DATA 逻辑段段基址为 1FFEH</span>
DATA  SEGMENT
K1  DW  <span class="token number">1</span>，<span class="token number">2</span>
K2  DW  <span class="token number">3</span>，<span class="token number">4</span>
<span class="token comment">; ...</span>
MOV  <span class="token register variable">AX</span>, SEG  K1
MOV  <span class="token register variable">BX</span>, SEG  K2
</code></pre></div><p>两条 MOV 指令将被汇编为：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AX</span>, <span class="token number">1FFEH</span>
MOV  <span class="token register variable">BX</span>, <span class="token number">1FFEH</span>
</code></pre></div><h5 id="offset-运算符"><a href="#offset-运算符" class="header-anchor">#</a> OFFSET 运算符</h5> <p>该运算符的作用是取变量或标号在段内的偏移地址。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA SEGMENT
VAR1  DB  <span class="token number">20H</span> DUP(<span class="token number">0</span>)
VAR2  DW  <span class="token number">5A49H</span>
ADDR  DW  VAR2         <span class="token comment">; ADDR=20H</span>
<span class="token comment">; ...</span>
MOV  <span class="token register variable">BX</span>，VAR2          <span class="token comment">; BX=5A49H</span>
MOV  <span class="token register variable">SI</span>, OFFSET VAR2   <span class="token comment">; SI=20H</span>
MOV  <span class="token register variable">DI</span>, ADDR          <span class="token comment">; DI=20H</span>
MOV  <span class="token register variable">BP</span>，OFFSET ADDR   <span class="token comment">; BP=22H</span>
</code></pre></div><p>获取变量的偏移量还可以用指令 <code>LEA</code>。</p> <p>需要注意的是：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV <span class="token register variable">SI</span>, OFFSET DATA<span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>
<span class="token comment">; 错误，个人猜测是因为 OFFSET 只能取最简单的 *变量* 的偏移地址</span>

LEA <span class="token register variable">SI</span>, DATA<span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>
<span class="token comment">; 正确</span>
</code></pre></div><p>另外，<code>OFFSET</code> 和 <code>SEG</code> 的返回值可认为是立即数，不能直接 <code>MOV</code> 进 <code>DS</code>、<code>ES</code>（见<a href="#%E4%B8%80%E8%88%AC%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4-mov">MOV 指令</a>）。解决办法是经过 AX 中转。</p> <h5 id="type-运算符"><a href="#type-运算符" class="header-anchor">#</a> TYPE 运算符</h5> <p>作用：取变量或标号的类型属性，并用数字形式表示。对变量来说就是取它的字节长度。</p> <table><thead><tr><th>类型</th> <th>返回值</th></tr></thead> <tbody><tr><td>BYTE</td> <td>1</td></tr> <tr><td>WORD</td> <td>2</td></tr> <tr><td>DWORD</td> <td>4</td></tr> <tr><td>QWORD</td> <td>8</td></tr> <tr><td>TBYTE</td> <td>10</td></tr> <tr><td>NEAR 标号</td> <td>-1</td></tr> <tr><td>FAR 标号</td> <td>-2</td></tr></tbody></table> <div class="language-nasm extra-class"><pre class="language-nasm"><code>V1   DB   <span class="token string">'ABCDE'</span>
V2   DW   <span class="token number">1234H</span>, <span class="token number">5678H</span>
V3   DD   V2
<span class="token comment">; ...</span>
MOV  <span class="token register variable">AL</span>,  TYPE  V1     <span class="token comment">; AL = 1</span>
MOV  <span class="token register variable">CL</span>,  TYPE  V2     <span class="token comment">; CL = 2</span>
MOV  <span class="token register variable">CH</span>,  TYPE  V3     <span class="token comment">; CH = 4</span>
</code></pre></div><h5 id="length-运算符"><a href="#length-运算符" class="header-anchor">#</a> LENGTH 运算符</h5> <ul><li>该运算符用于取变量的长度</li> <li>如果变量是用重复数据操作符 <code>DUP</code> 说明的,则 <code>LENGTH</code> 运算取<strong>最外层 DUP</strong>的重复值。</li> <li>如果没有用 <code>DUP</code> 说明，则 <code>LENGTH</code> 运算返回值<strong>总是 1</strong>。</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>K1  DB   <span class="token number">10H</span> DUP(<span class="token number">0</span>)
K2  DB   <span class="token number">10H</span>，<span class="token number">20H</span>，<span class="token number">30H</span>，<span class="token number">40H</span>
K3  DW   <span class="token number">20H</span> DUP (<span class="token number">0</span>，<span class="token number">1</span>，<span class="token number">2</span> DUP(<span class="token number">0</span>))
K4  DB   <span class="token string">'ABCDEFGH'</span>
<span class="token comment">; ...</span>
MOV  <span class="token register variable">AL</span>,  LENGTH   K1   <span class="token comment">; (AL)=10H</span>
MOV  <span class="token register variable">BL</span>,  LENGTH   K2   <span class="token comment">; (BL)=1</span>
MOV  <span class="token register variable">CX</span>,  LENGTH   K3   <span class="token comment">; (CX)=20H</span>
MOV  <span class="token register variable">DX</span>,  LENGTH   K4   <span class="token comment">; (DX)=1</span>
</code></pre></div><p>从上例可以看出，<code>LENGTH</code> 并不能求得字符串变量的长度，还是需要<a href="#%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E8%AE%A1%E6%95%B0%E5%99%A8-%E4%B8%8E%E5%AE%9A%E4%BD%8D%E4%BC%AA%E6%8C%87%E4%BB%A4-ORG">$ 符号</a></p> <h5 id="size-运算符"><a href="#size-运算符" class="header-anchor">#</a> SIZE 运算符</h5> <ul><li>该运算符只能用于变量</li> <li><strong>SIZE = LENGTH * TYPE</strong></li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AL</span>，SIZE  K1     <span class="token comment">; (AL)=10H</span>
MOV  <span class="token register variable">BL</span>，SIZE  K2     <span class="token comment">; (BL)=1</span>
MOV  <span class="token register variable">CL</span>，SIZE  K3     <span class="token comment">; (CL)=20H*2=40H</span>
MOV  <span class="token register variable">DL</span>，SIZE  K4     <span class="token comment">; (DL)=1</span>
</code></pre></div><h4 id="属性修改运算符"><a href="#属性修改运算符" class="header-anchor">#</a> 属性修改运算符</h4> <p>这一类运算符用来对变量、标号或存储器操作数的类型属性进行修改或指定。</p> <h5 id="ptr-运算符"><a href="#ptr-运算符" class="header-anchor">#</a> PTR 运算符</h5> <ul><li>格式：<code>类型 PTR 地址表达式</code></li> <li>作用: 将地址表达式所指定的标号、变量或用其它形式表示的存储器地址的类型属性<strong>临时</strong>修改为“类型”所指的值</li> <li>类型：<code>BYTE</code>、<code>WORD</code>、<code>DWORD</code>、<code>NEAR</code> 或 <code>FAR</code></li> <li>这种修改是临时的，只在含有该运算符的语句内有效，类似于 C 语言 <code>(char)i</code> 强制转换。</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DA_BYTE  DB   <span class="token number">20H</span>  DUP(<span class="token number">0</span>)
DA_WORD  DW   <span class="token number">30H</span>  DUP(<span class="token number">0</span>)
<span class="token comment">; ...</span>
MOV  <span class="token register variable">AX</span>,  WORD PTR  DA_BYTE<span class="token operator">[</span><span class="token number">10</span><span class="token operator">]</span>
ADD  BYTE PTR  DA_WORD<span class="token operator">[</span><span class="token number">20</span><span class="token operator">]</span>, <span class="token register variable">BL</span>
INC  BYTE PTR  <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>
SUB  WORD PTR  <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>, <span class="token number">100</span>
JMP  FAR  PTR  SUB1 <span class="token comment">; 指明SUB1不是本段中的地址</span>

MOV  WORD PTR<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>，<span class="token number">0120H</span>
</code></pre></div><p>注意最后一行，将立即数存入 <code>[SI]</code> 指明的内存时，必须使用 <code>BYTE/WORD PTR</code> 显式指明立即数的长度是 8 位还是 16 位，因为立即数和 <code>[SI]</code> 的长度都是不一定的。寄存器值存入内存则不需要，因为寄存器隐式地给出了长度。</p> <h5 id="high-low-运算符"><a href="#high-low-运算符" class="header-anchor">#</a> HIGH/LOW 运算符</h5> <p>格式：<code>HIGH 表达式</code> <code>LOW 表达式</code></p> <p>用来将<strong>表达式的值</strong>分离出高字节和低字节。</p> <ul><li>如果表达式为一个常量，则将其分离成高 8 位和低 8 位</li> <li>如果表达式是一个地址（段基值或偏移量）时，则分离出它的高字节和低字节</li> <li><code>HIGH/LOW</code> 运算符<strong>不能分离寄存器、存储器单元或变量中的内容</strong>。</li> <li>分离变量的段基址、偏移量时，需要配合 <code>SEG</code> 和 <code>OFFSET</code>。这是符合“变量在伪指令中是偏移地址，在指令中是存储器中内容”的。</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token comment">; 设 DATA 段的段基址为 0926H</span>
DATA  SEGMENT
CONST EQU <span class="token number">0ABCDH</span>
DA1   DB  <span class="token number">10H</span> DUP(<span class="token number">0</span>)
DA2   DW  <span class="token number">20H</span> DUP(<span class="token number">0</span>)
DATA  ENDS
<span class="token comment">; ...</span>
MOV   <span class="token register variable">AH</span>, HIGH CONST         <span class="token comment">; AH = 0ABH</span>
MOV   <span class="token register variable">AL</span>, LOW  CONST         <span class="token comment">; AL = 0CDH</span>
MOV   <span class="token register variable">BH</span>, HIGH (OFFSET DA1)  <span class="token comment">; BH = 00H</span>
MOV   <span class="token register variable">BL</span>, LOW  (OFFSET DA2)  <span class="token comment">; BL = 10H</span>
MOV   <span class="token register variable">CH</span>, HIGH (SEG DA1)     <span class="token comment">; CH = 09H</span>
MOV   <span class="token register variable">CL</span>, LOW  (SEG DA2)     <span class="token comment">; CL = 26H</span>
</code></pre></div><h4 id="运算符的优先级"><a href="#运算符的优先级" class="header-anchor">#</a> 运算符的优先级</h4> <table><thead><tr><th>优先级别</th> <th>运算符</th></tr></thead> <tbody><tr><td>（最高）1</td> <td><code>LENGTH</code>, <code>SIZE</code>, <code>( )</code></td></tr> <tr><td>2</td> <td><code>PTR</code>, <code>OFFSET</code>, <code>SEG</code>, <code>TYPE</code>, <code>THIS</code></td></tr> <tr><td>3</td> <td><code>HIGH</code>, <code>LOW</code></td></tr> <tr><td>4</td> <td><code>*</code>, <code>/</code>, <code>MOD</code>, <code>SHR</code>, <code>SHL</code></td></tr> <tr><td>5</td> <td><code>+</code>, `-</td></tr> <tr><td>6</td> <td><code>EQ</code>, <code>NE</code>, <code>LT</code>, <code>LE</code>, <code>GT</code>, <code>GE</code></td></tr> <tr><td>7</td> <td><code>NOT</code></td></tr> <tr><td>8</td> <td><code>AND</code></td></tr> <tr><td>（最低）9</td> <td><code>OR</code>, <code>XOR</code></td></tr></tbody></table> <p>相同优先级别的操作，从左到右进行。</p> <h3 id="程序的段结构"><a href="#程序的段结构" class="header-anchor">#</a> 程序的段结构</h3> <p>8086/8088 将内存按逻辑段进行管理，不同的逻辑段可以用来存放不同目的的内容。</p> <p>在程序中使用四个段寄存器CS,DS,ES和SS来访问它们。</p> <p>在源程序中，使用伪指令来定义和使用这些逻辑段。</p> <h4 id="段定义伪指令-segment"><a href="#段定义伪指令-segment" class="header-anchor">#</a> 段定义伪指令 SEGMENT</h4> <p>伪指令 <code>SEGMENT</code> 和 <code>ENDS</code> 用于定义一个逻辑段，分别表示定义的开始与结束。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>段名  SEGMENT <span class="token operator">[</span>定位类型<span class="token operator">]</span> <span class="token operator">[</span>组合类型<span class="token operator">]</span> <span class="token operator">[</span><span class="token string">'类别名'</span><span class="token operator">]</span>
<span class="token comment">; ...</span>
<span class="token comment">; ...</span>
段名  ENDS
</code></pre></div><h5 id="段名"><a href="#段名" class="header-anchor">#</a> 段名</h5> <p>段名：由用户定义。</p> <h5 id="定义类型"><a href="#定义类型" class="header-anchor">#</a> 定义类型</h5> <p>定位类型：段的起始数据边界，即第一个可存放数据的位置（不是段基地址）。</p> <table><thead><tr><th>定位类型</th> <th>含义</th> <th>段的起始边界</th></tr></thead> <tbody><tr><td><code>PAGE</code></td> <td>该段从一个页面的边界开始</td> <td><code>xxxx xxxx xxxx 0000 0000</code></td></tr> <tr><td><code>PARA</code>（默认）</td> <td>该段从一个小节的边界开始</td> <td><code>xxxx xxxx xxxx xxxx 0000</code></td></tr> <tr><td><code>DWORD</code></td> <td>该段从一个双字的边界开始</td> <td><code>xxxx xxxx xxxx xxxx xx00</code></td></tr> <tr><td><code>WORD</code></td> <td>该段从一个偶数字节地址开始</td> <td><code>xxxx xxxx xxxx xxxx xxx0</code></td></tr> <tr><td><code>BYTE</code></td> <td>该段起始数据单元地址可以是任一地址值</td> <td><code>xxxx xxxx xxxx xxxx xxxx</code></td></tr></tbody></table> <p>定位类型为 <code>PAGE</code> 和 <code>PARA</code> 时，段的起始边界直接选用段基址，即它们是重合的。定位类型为 <code>DWORD</code>、<code>WORD</code> 和 <code>BYTE</code> 时，段的起始边界与段基址可能不同。</p> <h5 id="组合类型"><a href="#组合类型" class="header-anchor">#</a> 组合类型</h5> <p>组合类型说明符用来指定段与段之间的连接关系和定位。</p> <ul><li><code>默认</code>：未指定组合类型，表示本段与其它段无连接关系
<ul><li>在装入内存时，本段有自己的物理段，因此有自己的段基址</li></ul></li> <li><code>PUBLIC</code>：将该逻辑段接在前一逻辑段后面，形成新逻辑段
<ul><li>在满足定位类型的前提下，将与该段同名的段邻接在一起，形成一个新的逻辑段，共用一个段基址。段内的所有偏移量调整为相对于新逻辑段的段基址</li></ul></li> <li><code>COMMON</code>：产生一个覆盖段
<ul><li>在多个模块连接时，把该段与其它也用 <code>COMMON</code> 说明的同名段诉汇编程序，在处理置成相同的段基址，这样可达到共享同一存储区。共享存储区的长度由同名段中最大的段确定</li></ul></li> <li><code>STACK</code>：将该段作为栈使用
<ul><li>把所有同名段连接成一个连续段，且系统自动对 <code>SS</code> 段寄存器初始化为该连续段的段基址，并初始化堆栈指针 <code>SP</code></li> <li>用户程序中应至少有一个段用 <code>STACK</code> 说明，否则需要用户程序自己初始化 <code>SS</code> 和 <code>SP</code>。</li></ul></li> <li><code>AT</code> 表达式：手动指定段基址
<ul><li>表示本段可定位在表达式所指示的小节边界上</li> <li>表达式的值就是段基值</li></ul></li> <li><code>MEMORY</code>：本段在存储器中应定位在所有其它段之后的最高地址上
<ul><li>如果有多个用 <code>MEMORY</code> 说明的段，则只处理第一个用 <code>MEMORY</code> 说明的段，其余的被视为 <code>COMMON</code></li></ul></li></ul> <h5 id="类别名"><a href="#类别名" class="header-anchor">#</a> 类别名</h5> <p>类别名为某一个段或几个相同类型段设定类型名称。</p> <p>系统在进行连接处理时，把类别名相同的段存放在相邻的存储区，但段的划分与使用仍按原来的设定。</p> <p>类别名必须用单引号引起来。所用字符串可任意选定，但它不能使用程序中的标号、变量名或其它定义的符号。</p> <h5 id="示例"><a href="#示例" class="header-anchor">#</a> 示例</h5> <div class="language-nasm extra-class"><pre class="language-nasm"><code>STACK1   SEGMENT  PARA  STACK  <span class="token string">'STACK0'</span>
<span class="token comment">;......</span>
STACK1   ENDS

DATA1    SEGMENT  PARA  <span class="token string">'DATA'</span>
<span class="token comment">;......</span>
DATA1    ENDS

STACK2   SEGMENT  PARA  <span class="token string">'STACK0'</span>
<span class="token comment">;......</span>
STACK2   ENDS

CODE     SEGMENT  PARA  MEMORY
         ASSUME  <span class="token register variable">CS</span>:CODE,<span class="token register variable">DS</span>:DATA1,<span class="token register variable">SS</span>:STACK1
<span class="token label function">MAIN:</span>
<span class="token comment">;......</span>
CODE     ENDS
DATA2    SEGMENT  BYTE  <span class="token string">'DATA'</span>
<span class="token comment">;......</span>
DATA2    ENDS
         END  MAIN
</code></pre></div><p><img src="/images/53370a4fb2bf4b1da148c557821ee3a6fcf283ec757ff6f54c002257de0cc901.png" alt="该程序经LINK程序连接处理后装入内存的示意图"></p> <ul><li>在段定义中选用了 <code>PARA</code> 说明，则该段起始单元与前面已分配存储单元之间可能存在一些未使用的空白</li> <li><code>CODE</code> 段的组合类型为 <code>MEMORY</code>，因此被装入在其它段之后（最高地址）</li></ul> <h4 id="段寻址伪指令-assume"><a href="#段寻址伪指令-assume" class="header-anchor">#</a> 段寻址伪指令 ASSUME</h4> <p>ASSUME的作用是告诉汇编程序，在处理源程序时，定义的段与哪个段寄存器关联。</p> <p>ASSUME并不设置各个段寄存器的具体内容，段寄存器的值是在程序运行时设定的。所以，一般需要同时使用：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>ASSUME <span class="token register variable">DS</span>:段名

MOV <span class="token register variable">AX</span>, 段名
MOV <span class="token register variable">DS</span>, <span class="token register variable">AX</span>
</code></pre></div><p>一般格式：<code>ASSUME 段寄存器名: 段名, 段寄存器名:段名......</code></p> <ul><li>段寄存器名：<code>CS</code>, <code>DS</code>, <code>ES</code> 或 <code>SS</code></li> <li>段名：用 <code>SEGMENT/ENDS</code> 定义。</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA1  SEGMENT
VAR1   DB  <span class="token number">12H</span>
DATA1  ENDS

DATA2  SEGMENT
VAR2   DB  <span class="token number">34H</span>
DATA2  ENDS

CODE   SEGMENT
VAR3   DB  <span class="token number">56H</span>
       ASSUME  <span class="token register variable">CS</span>:CODE, <span class="token register variable">DS</span>:DATA1, <span class="token register variable">ES</span>:DATA2
<span class="token label function">START:</span>
       <span class="token comment">; .....</span>
       INC  VAR1
       INC  VAR2
       INC  VAR3
       <span class="token comment">; ......</span>
CODE   ENDS
       END START
</code></pre></div><p>例如上面程序中的 3 条 INC 指令：</p> <ul><li>第 1 条 INC 指令要访问的变量 VAR1 在逻辑段 DATA1 中，由于一般操作数寻址隐含使用的是 DS，而 DATA1 又正是与 DS 对应，所以指令 <code>INC VAR1</code> 就可以直接汇编成目标代码 <code>FE 06 0000</code></li> <li>第 2 条 INC 指令要访问的变量 VAR2 在逻辑段 DATA2 中，而 DATA2 是与 ES 对应的，要正确执行这条指令必须使用段前缀（即用 ES 替代 DS），因此汇编程序在汇编这条指令时就自动产生一个段前缀标记代码 26，所以指令 <code>INC VAR2</code> 在这个程序中汇编的目标代码为 <code>26 FE 06 0000</code></li> <li>与第 2条 INC 指令类似，第 3 条 INC 指令要访问的变量 VAR3 在逻辑段 CODE 中，指令汇编时自动产生一个段前缀标记代码 2E 表示用 CS 替代 DS，所以指令 <code>INC VAR3</code> 汇编的目标代码为 <code>2E FE 06 0000</code></li></ul> <p>可以使用关键字 <code>NOTHING</code> 将前面的设置删除。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>ASSUME  <span class="token register variable">ES</span>:NOTHING    <span class="token comment">; 删除前面对 ES 与某个定义段的关联</span>
ASSUME  NOTHING       <span class="token comment">; 删除全部 4 个段寄存器的设置</span>
</code></pre></div><hr> <p>但是 ASSUME 的存在意义依然有点奇怪：<code>DS</code> 被改为段基址以后，想知道 <code>DS</code> 和谁被关联了，读一下 <code>DS</code> 不就行了吗，为什么还要 <code>ASSUME</code> 呢？</p> <p>搜索了一下，大概明白了：</p> <blockquote><p><code>ASSUME</code> 是给汇编程序看的，而 <code>MOV AX, DATA</code> <code>MOV DS, AX</code> 是给 CPU 看的。</p></blockquote> <p>汇编的时候，代码还没在 CPU 里跑，自然是没法读取 <code>DS</code> 的，所以要通过 <code>ASSUME</code> 语句设定。</p> <h4 id="段寄存器的装入"><a href="#段寄存器的装入" class="header-anchor">#</a> 段寄存器的装入</h4> <p>从上面可以看出，要让一个段寄存器真正地指向某个逻辑段，一般需要两个步骤：</p> <ol><li>将段基值装入到该段寄存器</li> <li>将段和段基址建立关联（常用 <code>ASSUME</code> 语句实现）</li></ol> <h5 id="ds-和-es-的装入"><a href="#ds-和-es-的装入" class="header-anchor">#</a> DS 和 ES 的装入</h5> <p>下面是一个错误示范：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA1   SEGMENT
DBYTE1  DB  <span class="token number">12H</span>
DATA1   ENDS
DATA2   SEGMENT
DBYTE2  DB <span class="token number">14H</span> DUP(?)
DATA2   ENDS

CODE    SEGMENT
        ASSUME  <span class="token register variable">CS</span>:CODE, <span class="token register variable">DS</span>:DATA1
<span class="token label function">START:</span>  MOV  <span class="token register variable">AX</span>,DATA1
        MOV  <span class="token register variable">DS</span>,<span class="token register variable">AX</span>
        MOV  <span class="token register variable">AX</span>,DATA2
        MOV  <span class="token register variable">ES</span>,<span class="token register variable">AX</span>
        MOV  <span class="token register variable">AL</span>,DBYTE1    <span class="token comment">; 正确</span>
        MOV  DBYTE2<span class="token operator">[</span><span class="token number">2</span><span class="token operator">]</span>,<span class="token register variable">AL</span> <span class="token comment">; 错误，因为 ASSUME 指令中未指定 ES 与 DATA2 关联</span>
CODE   ENDS
</code></pre></div><p>使用逻辑段前需要进行两个步骤：</p> <ul><li>使用 <code>ASSUME ES: DATA2</code> 建立 <code>ES</code> 和 <code>DATA2</code> 的联系</li> <li>使用 <code>MOV AX,DATA2</code> <code>MOV ES,AX</code> 将 <code>DATA2</code> 段基址装入 <code>ES</code></li></ul> <p>如果已经将段基址装入了 <code>ES</code>，也可以临时指明段前缀：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">ES</span>:DBYTE2<span class="token operator">[</span><span class="token number">2</span><span class="token operator">]</span>,  <span class="token register variable">AL</span>
</code></pre></div><h5 id="ss-的装入"><a href="#ss-的装入" class="header-anchor">#</a> SS 的装入</h5> <p>在<a href="#%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B">段的组合类型</a>中提到，若将一个段声明为 <code>STACK</code>，系统会自动初始化 <code>SS</code> 和 <code>SP</code> 寄存器为对应的值。</p> <p>因此，<code>SS</code> 的装入有两种方法：</p> <ol><li>手动使用 <code>MOV</code> 装入 <code>SS</code> 和 <code>SP</code>，然后 <code>ASSUME SS:段名</code></li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA_STACK   SEGMENT
        DB   <span class="token number">40H</span> DUP(?)
       TOP   LABEL  WORD
DATA_STACK   ENDS

CODE         SEGMENT
       MOV   <span class="token register variable">AX</span>,DATA_STACK
       MOV   <span class="token register variable">SS</span>,<span class="token register variable">AX</span>
       MOV   <span class="token register variable">SP</span>,OFFSET TOP
</code></pre></div><p>上述例子中，<code>SS=DATA_STACK</code>，<code>SP=TOP=40H</code></p> <ol start="2"><li>定义段时使用 <code>STACK</code> 作为组合类型（系统自动装入 <code>SS</code> 和 <code>SP</code>），然后 <code>ASSUME SS:段名</code></li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code>STACK1  SEGMENT  PARA  STACK
        DB  <span class="token number">40H</span> DUP(?)
STACK1  ENDS

CODE    SEGMENT
        ASSUME  <span class="token register variable">CS</span>:CODE, <span class="token register variable">SS</span>:STACK1
</code></pre></div><p>上述例子中，<code>SS=STACK1</code>，<code>SP=40H</code></p> <h5 id="cs"><a href="#cs" class="header-anchor">#</a> CS</h5> <p>CPU在执行指令之前根据CS和IP的内容来从内存中取指令,即必须在程序执行之前装入CS和IP的值。因此,CS和IP的初始值就不能用可执行语句来装入。</p> <p>装入CS和IP一般有下面两种情况。</p> <ol><li>程序加载到主存时，由系统软件给CS和IP赋予初始值</li></ol> <p>结束伪指令格式：<code>END 起始地址</code></p> <ul><li>起始地址: 是一个标号或表达式，它必须是程序中第一条指令语句前所加的标号，如前文的 <code>END MAIN</code></li> <li>汇编源程序必须以END伪指令结束</li> <li>END伪指令指示源程序结束并指定程序运行时的第一条指令的地址（起始地址）</li> <li>起始地址段基址和偏移量被分别装入CS和IP中</li></ul> <div class="language- extra-class"><pre class="language-text"><code>CODE   SEGMENT
       ASSUME  CS:CODE,......
START:
; ...
CODE   ENDS
       END START
</code></pre></div><ol start="2"><li>程序运行期间，当执行某些指令时，CPU自动修改CS和IP，使它们指向新的代码段。</li></ol> <ul><li>执行段间过程调用CALL和段间返回指令RET；</li> <li>执行段间无条件转移指令JMP;</li> <li>响应中断及中断返回指令；</li> <li>执行硬件复位操作。</li></ul> <h5 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h5> <ul><li>修改 DS、ES：
<ol><li><code>MOV</code> + <code>ASSUME</code></li> <li><code>MOV</code> + 临时指明段基址 <code>ES:段名</code></li></ol></li> <li>修改 SS：
<ol><li>声明段为 <code>STACK</code> + <code>ASSUME</code></li> <li><code>MOV</code> + <code>ASSUME</code></li></ol></li></ul> <h3 id="过程定义伪指令-proc"><a href="#过程定义伪指令-proc" class="header-anchor">#</a> 过程定义伪指令 PROC</h3> <p>在程序设计过程中，常常将具有一定功能的程序段设计成一个子程序。在MASM宏汇编语言中，用过程 (PROCEDURE) 来构造子程序。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>过程名   PROC  <span class="token operator">[</span>NEAR<span class="token operator">/</span>FAR<span class="token operator">]</span>
        RET
过程名   ENDP
</code></pre></div><ul><li>过程名如同<a href="#%E6%A0%87%E5%8F%B7">标号</a>，具有段、偏移量和距离三个属性</li> <li>距离属性使用NEAR和FAR来指定，默认为NEAR</li></ul> <p>每一个过程中必须包含有返回指令RET，它控制CPU从过程中返回到调用该过程的主程序。</p> <h3 id="当前位置计数器-与定位伪指令-org"><a href="#当前位置计数器-与定位伪指令-org" class="header-anchor">#</a> 当前位置计数器 $ 与定位伪指令 ORG</h3> <p>汇编程序在汇编源程序时，每遇到一个逻辑段，就要为其设置一个位置计数器，用来记录该逻辑段中定义的每一个数据或每一条指令在逻辑段中的相对位置。</p> <p>可以使用 <code>$</code> 获取位置计数器的值。<code>$</code> 也被称为当前位置计数器。<code>$</code> 在使用上完全类似变量的使用。</p> <p>可以使用 <code>ORG</code> 改变位置计数器的值。</p> <div class="language- extra-class"><pre class="language-text"><code>DATA1     SEGMENT
          ORG  30H                ; 跳到 30H，即保留段的前 30H 字节
          DB1  DB  12H,34H        ; DB1 偏移量为 30H
          ORG  $+20H              ; $ = 32H，跳到 52H，即保留段的 32H~51H 字节
          STRING  DB  'ABCDEFGHI' ; STRING 偏移量为 52H
          COUNT   EQU   $-STRING  ; COUNT = 9，即 STRING 的长度
          DB2  DW  $              ; DB2 = $ = 自己的偏移量
          DB3  DB   $+20H         ; 错误，访问到了段外的内容
DATA1     ENDS

CODE      SEGMENT
          ASSUME  CS:CODE, ......
          ORG  12H
START:    MOV  AX,DATA
          MOV  DS,AX
CODE      ENDS
          END START
</code></pre></div><h3 id="dos-功能调用"><a href="#dos-功能调用" class="header-anchor">#</a> DOS 功能调用</h3> <ul><li>DOS操作系统为程序设计人员提供了可以直接调用的功能子程序</li> <li>调用这些子程序可以实现从键盘输入数据，将数据送显示器显示，打印机打印，以及磁盘操作等功能</li> <li>调用DOS功能需要用软中断指令 <code>INT 21H</code>，并在执行该指令之前，将调用的功能号送入寄存器 <code>AH</code> 中，有关的参量送指定的寄存器。</li></ul> <p>三步骤：</p> <ol><li>送入口参量到指定的寄存器</li> <li>送功能号到 AH</li> <li>执行 <code>INT 21H</code></li></ol> <h4 id="带显示的键盘输入-1号功能"><a href="#带显示的键盘输入-1号功能" class="header-anchor">#</a> 带显示的键盘输入（1号功能）</h4> <ul><li>该功能子程序将等待键盘输入，直到按下一个键</li> <li>将字符的ASCII码送入AL寄存器，并在屏幕上显示该字符</li> <li>如果是Ctrl-C组合键，则停止程序运行</li> <li>该功能调用无入口参量</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AH</span>，<span class="token number">01H</span>
INT  <span class="token number">21H</span>  
</code></pre></div><h4 id="不带显示的键盘输入-8号功能"><a href="#不带显示的键盘输入-8号功能" class="header-anchor">#</a> 不带显示的键盘输入（8号功能）</h4> <ul><li>该功能调用与1号功能的作用相似，区别是8号功能将不显示输入的字符</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AH</span>，<span class="token number">8</span>
INT  <span class="token number">21H</span>
</code></pre></div><h4 id="不带显示的键盘字符输入-7号功能"><a href="#不带显示的键盘字符输入-7号功能" class="header-anchor">#</a> 不带显示的键盘字符输入（7号功能）</h4> <p>该功能与8号功能相似，但对Ctrl-C组合键和TAB制表键无反应。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV <span class="token register variable">AH</span>，<span class="token number">7</span>
INT   <span class="token number">21H</span>
</code></pre></div><h4 id="字符串输入-0ah号功能"><a href="#字符串输入-0ah号功能" class="header-anchor">#</a> 字符串输入（0AH号功能）</h4> <ul><li>该功能调用可实现从键盘输入字符串，其长度 &lt;= 255个字符</li> <li>调用前，应在内存中建立输入缓冲区
<ul><li>缓冲区第一个字节是可输入的<strong>最大</strong>字符数+1</li> <li>第二个字节是系统在调用该功能时，自动填入的<strong>实际输入</strong>的字符个数</li> <li><strong>从第三个字节开始</strong>存放输入字符的ASCII码（见后面例子）</li></ul></li> <li>当用户输入回车键时，结束输入，并将回车键的ASCII码 <code>0DH</code> 作为最后一个字符送入缓冲区。但它不计入实际输入字符个数</li></ul> <p>入口参量：<code>DS</code> 和 <code>DX</code> 寄存器分别装入输入缓冲区的段基值和偏移量</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>CHAR_BUF DB <span class="token number">31H</span>       <span class="token comment">;缓冲区的最大长度</span>
         DB <span class="token number">0</span>         <span class="token comment">;存实际输入字符数</span>
         DB <span class="token number">31H</span> DUP(<span class="token number">0</span>)<span class="token comment">;输入缓冲区</span>
         <span class="token comment">; ......</span>
MOV <span class="token register variable">DX</span>,SEG CHAR_BUF   <span class="token comment">;如果DS已经指向CHAR_BUF所在</span>
MOV <span class="token register variable">DS</span>,<span class="token register variable">DX</span>             <span class="token comment">;数据段，则可以省去这两条指令</span>
MOV <span class="token register variable">DX</span>,OFFSET CHAR_BUF
MOV <span class="token register variable">AH</span>,<span class="token number">0AH</span>
INT <span class="token number">21H</span>
</code></pre></div><h4 id="字符显示-2号功能"><a href="#字符显示-2号功能" class="header-anchor">#</a> 字符显示（2号功能）</h4> <p>该功能实现在屏幕上显示单个字符。</p> <p>入口参量：<code>DL</code> 装入要显示字符的ASCII码。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">DL</span>, <span class="token string">'A'</span>
MOV  <span class="token register variable">AH</span>，<span class="token number">2</span>
INT  <span class="token number">21H</span>
</code></pre></div><h4 id="字符打印-5号功能"><a href="#字符打印-5号功能" class="header-anchor">#</a> 字符打印（5号功能）</h4> <p>该功能将字符送入打印机接口，实现单个字符的打印操作。</p> <p>入口参量：<code>DL</code> 装入打印字符的ASCII码</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">DL</span>，<span class="token string">'A'</span>
MOV  <span class="token register variable">AH</span>，<span class="token number">5</span>
INT  <span class="token number">21H</span>
</code></pre></div><h4 id="字符串显示-9号功能"><a href="#字符串显示-9号功能" class="header-anchor">#</a> 字符串显示（9号功能）</h4> <p>该功能实现将一个字符串显示到屏幕上。</p> <p>入口参数：</p> <ul><li>将待显示的字符串存放在一个数据缓冲区，字符串以符号“$”作为结束标志。</li> <li>将字符串的首址的段基值和偏移量分别送入 <code>DS</code> 和 <code>DX</code> 中</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>CHAR    DB  <span class="token string">'This is a test.'</span>, <span class="token number">0AH</span>, <span class="token number">0DH</span>, <span class="token string">'$'</span>
<span class="token comment">; ......</span>
MOV  <span class="token register variable">DX</span>, OFFSET CHAR
MOV  <span class="token register variable">AH</span>, <span class="token number">9</span>
INT  <span class="token number">21H</span>
</code></pre></div><h4 id="直接输入输出-6号功能"><a href="#直接输入输出-6号功能" class="header-anchor">#</a> 直接输入输出（6号功能）</h4> <p>该功能可以实现键盘输入，也可以实现屏幕显示操作。两种操作通过 <code>DL</code> 的内容确定。</p> <ul><li><code>(DL)=00~0FEH</code> 时，输出 <code>DL</code> 对应的字符。</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">DL</span>，<span class="token number">24H</span>  <span class="token comment">; $的ASCII码为24H</span>
MOV <span class="token register variable">AH</span>，<span class="token number">06</span>  
INT   <span class="token number">21H</span>     <span class="token comment">; 输出 $</span>
</code></pre></div><ul><li><code>(DL)=FFH</code> 时 ，从键盘输入字符</li></ul> <p>该功能不等待键盘输入，而是从键盘缓冲区中读取。读取的字符ASCII码送入AL中，如果缓冲区为空，则标志位ZF=1。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code><span class="token label function">WAIT:</span> MOV  <span class="token register variable">DL</span>，<span class="token number">0FFH</span>
      MOV  <span class="token register variable">AH</span>，<span class="token number">6</span>
      INT  <span class="token number">21H</span>
      JZ   WAIT
</code></pre></div><h4 id="读出系统日期-2ah号功能"><a href="#读出系统日期-2ah号功能" class="header-anchor">#</a> 读出系统日期（2AH号功能）</h4> <p>读出的日期信息放入指定的寄存器中：</p> <ul><li>CX：年（1980—2099）</li> <li>DH：月（1—12）</li> <li>DL：日（1—31）</li> <li>AL：星期（0—星期日，1—星期一……）</li></ul> <div class="language-nasm extra-class"><pre class="language-nasm"><code>YEAR     DW  ?
MONTH    DB  ?
DAY      DB  ?
； ......
MOV  <span class="token register variable">AH</span>,<span class="token number">2AH</span>
INT  <span class="token number">21H</span>
MOV  YEAR,<span class="token register variable">CX</span>
MOV  MONTH,<span class="token register variable">DH</span>
MOV  DAY,<span class="token register variable">DL</span>
</code></pre></div><h4 id="设置系统日期-2bh号功能"><a href="#设置系统日期-2bh号功能" class="header-anchor">#</a> 设置系统日期（2BH号功能）</h4> <p>该功能用来改变计算机CMOS中的系统日期。入口参数：</p> <ul><li>CX&lt;=年号（1980—2099）</li> <li>DH&lt;= 月号（1—12）</li> <li>DL&lt;= 日（1—31）</li></ul> <p>返回参数在AL中，成功设置，则返回 <code>(AL)=0</code>，否则 <code>(AL)=0FFH</code></p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">CX</span>,<span class="token number">2000</span>
MOV  <span class="token register variable">DH</span>,<span class="token number">11</span>
MOV  <span class="token register variable">DL</span>,<span class="token number">2</span>
MOV  <span class="token register variable">AH</span>,<span class="token number">2BH</span>
INT  <span class="token number">21H</span>
CMP  <span class="token register variable">AL</span>,<span class="token number">0</span>
JNE  ERROR <span class="token comment">;转出错处理</span>
</code></pre></div><h4 id="读出系统时间-2ch号功能"><a href="#读出系统时间-2ch号功能" class="header-anchor">#</a> 读出系统时间（2CH号功能）</h4> <p>执行该功能将获得系统的当前时间。返回的时间参数存放在指定的寄存器中：</p> <ul><li>CH：小时（0—23）</li> <li>CL：分（0—59）</li> <li>DH：秒（0—59）</li> <li>DL：百分秒（0—99）</li></ul> <h4 id="设置系统时间-2dh号功能"><a href="#设置系统时间-2dh号功能" class="header-anchor">#</a> 设置系统时间（2DH号功能）</h4> <p>调用该功能，将设定系统时间。其入口参量为：</p> <ul><li>CH：小时（0—23）</li> <li>CL：分（0—59）</li> <li>DH：秒（0—59）</li> <li>DL：百分秒（0—99）</li></ul> <p>该功能执行后返回时，如果调用成功，则（AL）=0。否则（AL）=0FFH</p> <h3 id="程序返回操作系统的方法"><a href="#程序返回操作系统的方法" class="header-anchor">#</a> 程序返回操作系统的方法</h3> <h4 id="在dos操作系统下运行"><a href="#在dos操作系统下运行" class="header-anchor">#</a> 在DOS操作系统下运行</h4> <p>在早期的计算机中使用DOS操作系统，系统运行为单一进程，为了让系统运行完用户的程序后，能够正确地返回到操作系统，需要在程序中加上一些必要的语句。</p> <p>一般有以下两种方法：</p> <ul><li>使用DOS系统功能调用实现返回</li> <li>使用程序段前缀PSP实现返回</li></ul> <h5 id="使用dos系统功能调用实现返回"><a href="#使用dos系统功能调用实现返回" class="header-anchor">#</a> 使用DOS系统功能调用实现返回</h5> <p>执行DOS功能调用4CH，控制用户程序结束，并返回DOS操作系统。</p> <p>在程序结束时，使用两条指令：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">AH</span>，<span class="token number">4CH</span>
INT  <span class="token number">21H</span>
</code></pre></div><p>程序结构如下：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA    SEGMENT
        <span class="token comment">; ……</span>
DATA    ENDS              <span class="token comment">;定义数据段</span>

STACK1  SEGMENT PARA STACK
        DW <span class="token number">20H</span> DUP (<span class="token number">0</span>)
STACK1  ENDS              <span class="token comment">;定义堆栈段</span>

CODE    SEGMENT
        ASSUME <span class="token register variable">CS</span>:CODE,<span class="token register variable">DS</span>:DATA,<span class="token register variable">SS</span>:STACK1
<span class="token label function">START:</span>                    <span class="token comment">;指令开始地址   </span>
        MOV <span class="token register variable">AX</span>,DATA
        MOV <span class="token register variable">DS</span>,<span class="token register variable">AX</span>         <span class="token comment">;初始化DS</span>
        <span class="token comment">; ……</span>
        MOV  <span class="token register variable">AH</span>, <span class="token number">4CH</span>
        INT  <span class="token number">21H</span>          <span class="token comment">;返回DOS操作系统</span>
CODE    ENDS
        END START         <span class="token comment">;汇编结束标志</span>
</code></pre></div><h5 id="使用程序段前缀psp实现返回"><a href="#使用程序段前缀psp实现返回" class="header-anchor">#</a> 使用程序段前缀PSP实现返回</h5> <ul><li>DOS系统将一个.EXE文件（可执行文件）装入内存时，在该文件的前面生成一个程序段前缀PSP <code>Program Segment Prefix</code>。</li> <li>PSP的长度为100H字节</li> <li>系统将DS和ES都指向PSP的开始</li> <li>CS指向该程序的代码段，即第一条可执行指令</li></ul> <p>PSP的开始是一条中断指令 <code>INT 20H</code>，执行该指令将终止用户程序，返回DOS系统。</p> <p><img src="/images/b237c483f0a8304575683dca5da0af1f86819bcce7de7a08f7fea94541f4d90e.png" alt="内存结构"></p> <p>为了使程序执行完后，正确返回DOS，需要做以下三个操作：</p> <ol><li>将用户程序编制成一个过程,类型为 <code>FAR</code></li> <li>将PSP的起始逻辑地址压栈,即将 <code>INT 20H</code> 指令的地址压栈</li> <li>在用户程序结尾处,使用一条 <code>RET</code> 指令。执行该指令将使保存在堆栈中的PSP的起始地址弹出到CS和IP中</li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA    SEGMENT
        <span class="token comment">;……</span>
DATA    ENDS         <span class="token comment">;定义数据段</span>

STACK1  SEGMENT PARA STACK
        DW <span class="token number">20H</span> DUP (<span class="token number">0</span>)
STACK1  ENDS         <span class="token comment">;定义堆栈段</span>

CODE    SEGMENT
        ASSUME <span class="token register variable">CS</span>:CODE,<span class="token register variable">DS</span>:DATA,<span class="token register variable">SS</span>:STACK1
MAIN    PROC  FAR    <span class="token comment">;设置为FAR过程</span>
        PUSH  <span class="token register variable">DS</span>     <span class="token comment">;为返回操作系统执行INT 20H 指令做准备</span>
        MOV  <span class="token register variable">AX</span>,<span class="token number">0</span>
        PUSH  <span class="token register variable">AX</span>     <span class="token comment">;立即数不能够作为操作数 </span>
        MOV  <span class="token register variable">AX</span>,DATA
        MOV  <span class="token register variable">DS</span>,<span class="token register variable">AX</span>   <span class="token comment">;初始化DS</span>
        <span class="token comment">; ......</span>
        RET          <span class="token comment">;返回操作系统</span>
MAIN    ENDP
CODE    ENDS
        END MAIN     <span class="token comment">;汇编结束标志</span>
</code></pre></div><h4 id="在windows操作系统下运行"><a href="#在windows操作系统下运行" class="header-anchor">#</a> 在Windows操作系统下运行</h4> <p>Windows系统下系统的运行为多进程方式，进程间切换由系统自动完成，即当用户的程序结束后使用 <code>HLT</code> 就自动返回操作系统。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA    SEGMENT
        <span class="token comment">; ......</span>
DATA    ENDS                <span class="token comment">;定义数据段</span>

STACK1  SEGMENT PARA STACK
        DW <span class="token number">20H</span> DUP (<span class="token number">0</span>)
STACK1  ENDS                <span class="token comment">;定义堆栈段</span>

CODE    SEGMENT
        ASSUME <span class="token register variable">CS</span>:CODE,<span class="token register variable">DS</span>:DATA,<span class="token register variable">SS</span>:STACK1
<span class="token label function">START:</span>                      <span class="token comment">;指令开始地址   </span>
        MOV <span class="token register variable">AX</span>,DATA
        MOV <span class="token register variable">DS</span>,<span class="token register variable">AX</span>           <span class="token comment">;初始化DS等</span>
        <span class="token comment">; ......</span>
        HLT                 <span class="token comment">;结束程序</span>
CODE    ENDS
        END START           <span class="token comment">;汇编结束标志</span>
</code></pre></div><h3 id="汇编语言程序应用实例"><a href="#汇编语言程序应用实例" class="header-anchor">#</a> 汇编语言程序应用实例</h3> <h4 id="顺序程序设计实例"><a href="#顺序程序设计实例" class="header-anchor">#</a> 顺序程序设计实例</h4> <p>例 1：利用学号查学生的数学成绩表</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>TITLE   TABLE       LOOKUP

DATA    SEGMENT
        TABLE   DB <span class="token number">81</span>, <span class="token number">78</span>, <span class="token number">90</span>, <span class="token number">64</span>, <span class="token number">85</span>, <span class="token number">76</span>, <span class="token number">93</span>, <span class="token number">82</span>, <span class="token number">57</span>, <span class="token number">80</span>
                DB <span class="token number">73</span>, <span class="token number">62</span>, <span class="token number">87</span>, <span class="token number">77</span>, <span class="token number">74</span>, <span class="token number">86</span>, <span class="token number">95</span>, <span class="token number">91</span>, <span class="token number">82</span>, <span class="token number">71</span>
        NUM     DB <span class="token number">8</span>
        MATH    DB ?
DATA    ENDS

STACK1  SEGMENT  PARA  STACK
        DW <span class="token number">20H</span>    DUP(<span class="token number">0</span>)
STACK1  ENDS

COSEG   SEGMENT
        ASSUME  <span class="token register variable">CS</span>:COSEG, <span class="token register variable">DS</span>:DATA, <span class="token register variable">SS</span>:STACK1
<span class="token label function">START:</span>  MOV  <span class="token register variable">AX</span>, DATA
        MOV  <span class="token register variable">DS</span>, <span class="token register variable">AX</span>               <span class="token comment">;装入DS</span>
        MOV  <span class="token register variable">BX</span>, OFFSET  TABLE    <span class="token comment">;BX指向表首址</span>
        XOR  <span class="token register variable">AH</span>, <span class="token register variable">AH</span>               <span class="token comment">;(AH)=0</span>
        MOV  <span class="token register variable">AL</span>, NUM          
        DEC  <span class="token register variable">AL</span>                   <span class="token comment">;实际学号是从1开始的</span>
        ADD  <span class="token register variable">BX</span>, <span class="token register variable">AX</span>               <span class="token comment">;BX加上学号指向要查的成绩</span>
        MOV  <span class="token register variable">AL</span>,<span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>              <span class="token comment">;查到成绩送AL</span>
        MOV  MATH, <span class="token register variable">AL</span>             <span class="token comment">;存结果</span>
        MOV  <span class="token register variable">AH</span>, <span class="token number">4CH</span>              <span class="token comment">;返回DOS</span>
        INT  <span class="token number">21H</span>
COSEG  ENDS
        END   START
</code></pre></div><h4 id="分支程序实例"><a href="#分支程序实例" class="header-anchor">#</a> 分支程序实例</h4> <h5 id="用比较-测试指令-条件转移指令实现分支"><a href="#用比较-测试指令-条件转移指令实现分支" class="header-anchor">#</a> 用比较/测试指令+条件转移指令实现分支</h5> <ul><li><code>CMP DEST，SRC</code>：做减法</li> <li><code>TEST DEST，SRC</code>：做与运算</li></ul> <p>例 2：数据段的ARY数组中存放有10个无符号数，试找出其中最大者送入MAX单元。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA    SEGMENT
        ARY  DB <span class="token number">17</span>，<span class="token number">5</span>，<span class="token number">40</span>，<span class="token number">0</span>，<span class="token number">67</span>，<span class="token number">12</span>，<span class="token number">34</span>，<span class="token number">78</span>，<span class="token number">32</span>，<span class="token number">10</span>
        MAX  DB ?
DATA    ENDS

STACK1  SEGMENT PARA STACK
        DW  <span class="token number">20H</span> DUP(<span class="token number">0</span>)
STACK1  ENDS

CODE    SEGMENT
        ASSUME <span class="token register variable">DS</span>:DATA <span class="token register variable">CS</span>:CODE <span class="token register variable">SS</span>:STACK1
<span class="token label function">START:</span>  MOV  <span class="token register variable">AX</span>, DATA
        MOV  <span class="token register variable">DS</span>, <span class="token register variable">AX</span>         <span class="token comment">;SI指向ARY的第一个元素</span>
        LEA  <span class="token register variable">SI</span>, ARY
        MOV  <span class="token register variable">CX</span>, <span class="token number">9</span>          <span class="token comment">;CX作次数计数器，遍历后九个元素</span>
        MOV  <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>       <span class="token comment">;取第一个元素到AL</span>
<span class="token label function">LOP:</span>    INC  <span class="token register variable">SI</span>             <span class="token comment">;SI指向后一个元素      </span>
        CMP  <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>       <span class="token comment">;比较两个数</span>
        JAE  BIGGER         <span class="token comment">;前元素≥后元素转移</span>
        MOV  <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>       <span class="token comment">;取较大数到AL</span>
<span class="token label function">BIGGER:</span> DEC  <span class="token register variable">CX</span>             <span class="token comment">;减1计数</span>
        JNZ  LOP            <span class="token comment">;未比较完转回去，否则顺序执行</span>
        MOV  MAX, <span class="token register variable">AL</span>        <span class="token comment">;存最大数</span>
        MOV  <span class="token register variable">AH</span>, <span class="token number">4CH</span>
        INT  <span class="token number">21H</span>
CODE  ENDS
        END   BEGIN
</code></pre></div><p>例 3：编写一程序，实现将存储器中的源数据块传送到目的数据块。</p> <p>需要注意的是，在存储器中两个数据块的存放有下列情况：两个数据块分离和有部分重叠。</p> <p>我们采用：当源块首地址 &lt; 目的块首地址时，从数据块末地址开始传送。反之，则从首地址开始传送。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>TITLE   DATA BLOCK MOVE

DATA    SEGMENT
        ORG  <span class="token operator">$</span><span class="token operator">+</span><span class="token number">20H</span>
        STRG  DB    <span class="token string">'ABCDEFGHIJ'</span>  <span class="token comment">; 数据块</span>
        LENG  EQU   <span class="token operator">$</span><span class="token operator">-</span>STRG        <span class="token comment">;数据块字节长度</span>
        BLOCK1 DW   STRG          <span class="token comment">;源块首址</span>
        BLOCK2 DW   STRG<span class="token operator">-</span><span class="token number">5</span>        <span class="token comment">;目的块首址</span>
DATA    ENDS

STACK1  SEGMENT STACK
        DW   <span class="token number">20H</span> DUP(<span class="token number">0</span>)
STACK1  ENDS

COSE    SEGMENT 
        ASSUME <span class="token register variable">CS</span>:COSE, <span class="token register variable">DS</span>:DATA, <span class="token register variable">SS</span>:STACK1
<span class="token label function">BEGIN:</span>  MOV  <span class="token register variable">AX</span>, DATA
        MOV  <span class="token register variable">DS</span>, <span class="token register variable">AX</span>
        MOV  <span class="token register variable">CX</span>, LENG      <span class="token comment">;设置计数器初值</span>
        MOV  <span class="token register variable">SI</span>, BLOCK1    <span class="token comment">;SI指向源块首址</span>
        MOV  <span class="token register variable">DI</span>, BLOCK2    <span class="token comment">;DI指向目的块首址 </span>
        CMP  <span class="token register variable">SI</span>,<span class="token register variable">DI</span>         <span class="token comment">;源块首址&gt;目的块首址吗？ </span>
        JA   TOP           <span class="token comment">;大于则转到TOP处，否则顺序执行</span>
        ADD  <span class="token register variable">SI</span>,LENG<span class="token operator">-</span><span class="token number">1</span>     <span class="token comment">;SI指向源块末址</span>
        ADD  <span class="token register variable">DI</span>,LENG<span class="token operator">-</span><span class="token number">1</span>     <span class="token comment">;DI指向目的块末址</span>
<span class="token label function">BOTTOM:</span> MOV  <span class="token register variable">AL</span>，<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>      <span class="token comment">;从末址开始传送</span>
        MOV  <span class="token operator">[</span><span class="token register variable">DI</span><span class="token operator">]</span>,  <span class="token register variable">AL</span>
        DEC  <span class="token register variable">SI</span>
        DEC  <span class="token register variable">DI</span>
        DEC  <span class="token register variable">CX</span>
        JNE  BOTTOM
        JMP  END1
<span class="token label function">TOP:</span>    MOV  <span class="token register variable">AL</span>,<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>       <span class="token comment">;从首址开始传送</span>
        MOV  <span class="token operator">[</span><span class="token register variable">DI</span><span class="token operator">]</span>,<span class="token register variable">AL</span>
        INC  <span class="token register variable">SI</span>
        INC  <span class="token register variable">DI</span>
        DEC  <span class="token register variable">CX</span>
        JNE  TOP
<span class="token label function">END1:</span>   MOV  <span class="token register variable">AH</span>, <span class="token number">4CH</span>
        INT  <span class="token number">21H</span>
COSE    ENDS
        END BEGIN
</code></pre></div><h5 id="用跳转表形成多路分支"><a href="#用跳转表形成多路分支" class="header-anchor">#</a> 用跳转表形成多路分支</h5> <p>当程序的分支数量较多时，采用跳转表的方法可以使程序长度变短。跳转表有两种构成方法：</p> <ul><li>跳转表用入口地址构成</li> <li>跳转表用无条件转移指令构成</li></ul> <h6 id="跳转表用入口地址构成"><a href="#跳转表用入口地址构成" class="header-anchor">#</a> 跳转表用入口地址构成</h6> <p>这种方法将所有入口地址存在一个变量数组中（称为跳转表），跳转前取出对应地址然后直接跳。</p> <p>例 4：设某程序有10路分支，试根据变量N的值（1~10），将程序转移到其中的一路分支去。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>TITLE   JUMP  TABLE  OF  ADDRESS
DATA    SEGMENT
        ATABLE   DW  BRAN1, BRAN2, BRAN3, ..., BRAN10
        N        DB  <span class="token number">3</span>
DATA    ENDS

STACK1  SEGMENT  PARA   STACK
        DW       <span class="token number">20H</span> DUP (<span class="token number">0</span>)
STACK1  ENDS

CODE    SEGMENT
        ASSUME   <span class="token register variable">CS</span>:CODE, <span class="token register variable">DS</span>:DATA, <span class="token register variable">SS</span>:STACK1
<span class="token label function">START:</span>  MOV  <span class="token register variable">AX</span>, DATA
        MOV  <span class="token register variable">DS</span>, <span class="token register variable">AX</span>
        XOR  <span class="token register variable">AH</span>, <span class="token register variable">AH</span>
        MOV  <span class="token register variable">AL</span>, N
        DEC  <span class="token register variable">AL</span>
        SHL  <span class="token register variable">AL</span>,<span class="token number">1</span>
        MOV  <span class="token register variable">BX</span>,OFFSET ATABLE  <span class="token comment">;BX指向表首址</span>
        ADD  <span class="token register variable">BX</span>,<span class="token register variable">AX</span>             <span class="token comment">;BX指向查表地址                       </span>
        MOV  <span class="token register variable">CX</span>,<span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>           <span class="token comment">;将N对应的分支入口地址送到CX中</span>
        JMP  <span class="token register variable">CX</span>                <span class="token comment">;转移到N对应的分支入口地址</span>
<span class="token label function">BRAN1:</span>  <span class="token comment">; ...</span>
        JMP      END1
<span class="token label function">BRAN2:</span>  <span class="token comment">; ...</span>
        JMP      END1
<span class="token label function">BRAN3:</span>  <span class="token comment">; ...</span>
        JMP      END1           
<span class="token label function">BRAN10:</span> <span class="token comment">; ...</span>
<span class="token label function">END1:</span>   MOV  <span class="token register variable">AH</span>,<span class="token number">4CH</span>
        INT  <span class="token number">21H</span>
CODE    ENDS
        END     START
</code></pre></div><h6 id="跳转表用无条件转移指令构成"><a href="#跳转表用无条件转移指令构成" class="header-anchor">#</a> 跳转表用无条件转移指令构成</h6> <p>跳转表的每一个项目就是一条无条件转移指令。这时跳转表是代码段中的一段程序。利用 <code>每一条 JMP 指令都是3字节编码</code>，可以在跳转表前计算出目标 JMP 指令的地址，然后跳转。</p> <p>例 4 的另一种写法。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>TITLE   JUMP TABLE OF INSTRUCTION
DATA    SEGMENT
        N  DB  <span class="token number">3</span>
DATA  ENDS

STACK1  SEGMENT PARA STACK
        DW  <span class="token number">20H</span> DUP(<span class="token number">0</span>)
STACK1  ENDS

CODE    SEGMENT
        ASSUME  <span class="token register variable">CS</span>:CODE, <span class="token register variable">DS</span>:DATA, <span class="token register variable">SS</span>:STACK1
<span class="token label function">START:</span>  MOV  <span class="token register variable">AX</span>,DATA
        MOV  <span class="token register variable">DS</span>,<span class="token register variable">AX</span>
        MOV  <span class="token register variable">BH</span>,<span class="token number">0</span>
        MOV  <span class="token register variable">BL</span>,N
        DEC  <span class="token register variable">BL</span>                <span class="token comment">;四条指令实现(N-1)*3</span>
        MOV  <span class="token register variable">AL</span>, <span class="token register variable">BL</span>            <span class="token comment">;每一条指令都是3字节编码</span>
        SHL  <span class="token register variable">BL</span>, <span class="token number">1</span>
        ADD  <span class="token register variable">BL</span>, <span class="token register variable">AL</span>
        ADD  <span class="token register variable">BX</span>, OFFSET ITABLE <span class="token comment">;BX指向查表地址    </span>
        JMP  <span class="token register variable">BX</span>                <span class="token comment">;转移到N对应的JMP指令</span>

<span class="token label function">ITABLE:</span> JMP  BRAN1             <span class="token comment">;JMP指令构成的跳转表</span>
        JMP  BRAN2             <span class="token comment">;每一条指令都是3字节的编码</span>
        JMP  BRAN3
        <span class="token comment">; ...</span>
        <span class="token comment">; ...</span>
        JMP  BRAN10

<span class="token label function">BRAN1:</span>  <span class="token comment">; ...</span>
        JMP  END1
<span class="token label function">BRAN2:</span>  <span class="token comment">; ...</span>
        JMP  END1
<span class="token comment">; ...</span>
<span class="token comment">; ...</span>
<span class="token label function">BRAN10:</span> <span class="token comment">; ...</span>

<span class="token label function">END1:</span>   MOV  <span class="token register variable">AH</span>,<span class="token number">4CH</span>
        INT  <span class="token number">21H</span>
CODE    ENDS
        END  START
</code></pre></div><h4 id="循环程序实例"><a href="#循环程序实例" class="header-anchor">#</a> 循环程序实例</h4> <h5 id="计数控制循环-循环次数已知"><a href="#计数控制循环-循环次数已知" class="header-anchor">#</a> 计数控制循环——循环次数已知</h5> <p>使用 CX 计数即可。</p> <p>例 5：设有两个数组X和Y，它们都有8个元素，其元素按下标从小到大的顺序存放在数据段中。试编写程序完成下列计算：</p> <div class="language- extra-class"><pre class="language-text"><code>Z1=X1+Y1   Z2=X2-Y2    Z3=X3+Y3 
Z4=X4-Y4   Z5=X5-Y5    Z6=X6+Y6
Z7=X7+Y7   Z8=X8-Y8
</code></pre></div><p>由于循环体中有“+”和“-”两种可能的运算，通过设置标志0(+)和1(-)来判断，低位表示低下标的运算。八个运算表达式由8位逻辑尺：<code>10011010B</code>来识别。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA    SEGMENT
        X       DB  <span class="token number">0A2H</span>,<span class="token number">7CH</span>,<span class="token number">34H</span>,<span class="token number">9FH</span>,<span class="token number">0F4H</span>,<span class="token number">10H</span>,<span class="token number">39H</span>,<span class="token number">5BH</span>
        Y       DB  <span class="token number">14H</span>,<span class="token number">05BH</span>,<span class="token number">28H</span>,<span class="token number">7AH</span>,<span class="token number">0EH</span>,<span class="token number">13H</span>,<span class="token number">46H</span>,<span class="token number">2CH</span>
        LEN     EQU <span class="token operator">$</span> <span class="token operator">-</span>Y
        Z       DB  LEN DUP(?)
        LOGR    DB  <span class="token number">10011010B</span>       <span class="token comment">;设置标志0(+)和1(-)来判断，低位表示低下标的运算</span>
DATA    ENDS

STACK0  SEGMENT PARA STACK
        DW  <span class="token number">20H</span> DUP(<span class="token number">0</span>)
STACK0  ENDS

COSEG   SEGMENT
        ASSUME <span class="token register variable">CS</span>:COSEG, <span class="token register variable">DS</span>:DATA, <span class="token register variable">SS</span>:STACK0
<span class="token label function">BEGIN:</span>  MOV  <span class="token register variable">AX</span>, DATA
        MOV  <span class="token register variable">DS</span>, <span class="token register variable">AX</span>
        MOV  <span class="token register variable">CX</span>, LEN        <span class="token comment">;初始化计数器</span>
        MOV  <span class="token register variable">SI</span>, <span class="token number">0</span>          <span class="token comment">;初始化指针</span>
        MOV  <span class="token register variable">BL</span>, LOGR       <span class="token comment">;初始化逻辑尺</span>
<span class="token label function">LOP:</span>    MOV  <span class="token register variable">AL</span>, X<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
        SHR  <span class="token register variable">BL</span>, <span class="token number">1</span>          <span class="token comment">;标志位送CF</span>
        JC   SUB1           <span class="token comment">;为1，转做减法</span>
        ADD  <span class="token register variable">AL</span>, Y<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>      <span class="token comment">;为0，做加法</span>
        JMP  RES
<span class="token label function">SUB1:</span>   SUB  <span class="token register variable">AL</span>, Y<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
<span class="token label function">RES:</span>    MOV  Z<span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>, <span class="token register variable">AL</span>      <span class="token comment">; 存结果</span>
        INC  <span class="token register variable">SI</span>             <span class="token comment">; 修改指针</span>
        LOOP LOP
        MOV  <span class="token register variable">AH</span>, <span class="token number">4CH</span>
        INT  <span class="token number">21H</span>
COSEG   ENDS
        END BEGIN
</code></pre></div><h5 id="条件控制循环-循环次数未知"><a href="#条件控制循环-循环次数未知" class="header-anchor">#</a> 条件控制循环——循环次数未知</h5> <p>根据条件控制使用 <code>JZ</code> <code>JL</code> <code>JG</code> 等语句进行跳转实现循环。</p> <p>例 6 编写一程序，将字单元 <code>VARW</code> 中含1的个数(含1的个数是指用二进制表示时,有多少个1)统计出来，存入CONT单元中。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA    SEGMENT
        VARW    DW   <span class="token number">1101010010001000B</span>
        CONT      DB   ?
DATA    ENDS

STACK1  SEGMENT PARA STACK
        DW  <span class="token number">20H</span> DUP(<span class="token number">0</span>)
STACK1  ENDS

CODE    SEGMENT
        ASSUME  <span class="token register variable">CS</span>:CODE, <span class="token register variable">DS</span>:DATA, <span class="token register variable">SS</span>:STACK1
<span class="token label function">BEGIN:</span>  MOV  <span class="token register variable">AX</span>, DATA
        MOV  <span class="token register variable">DS</span>, <span class="token register variable">AX</span>
        MOV  <span class="token register variable">CL</span>, <span class="token number">0</span>                  <span class="token comment">;初始值为0,统计1的个数</span>
        MOV  <span class="token register variable">AX</span>, VARW
<span class="token label function">LOP:</span>    EST  <span class="token register variable">AX</span>, <span class="token number">0FFFFH</span>             <span class="token comment">;测试（AX）是否为0</span>
        JZ   END0                   <span class="token comment">;为0，循环结束</span>
        JNS  SHIFT                  <span class="token comment">;判最高位，为0则转SHIFT</span>
        INC  <span class="token register variable">CL</span>                     <span class="token comment">;最高位为1，计数</span>
<span class="token label function">SHIFT:</span>  SHL  <span class="token register variable">AX</span>, <span class="token number">1</span>
        JMP  LOP
<span class="token label function">END0:</span>   MOV  CONT, <span class="token register variable">CL</span> <span class="token comment">;存结果</span>
        MOV  <span class="token register variable">AH</span>, <span class="token number">4CH</span>
        INT  <span class="token number">21H</span>
CODE    ENDS
        END  BEGIN
</code></pre></div><h3 id="ia-32-微处理器的指令与汇编语言结构简介"><a href="#ia-32-微处理器的指令与汇编语言结构简介" class="header-anchor">#</a> IA-32 微处理器的指令与汇编语言结构简介</h3> <h4 id="寻址方式-2"><a href="#寻址方式-2" class="header-anchor">#</a> 寻址方式</h4> <p>相对 8086 来说，IA-32 扩充了寄存器结构，采用了多种存储器管理方式 ，因此其寻址方式有了较大的增强。</p> <ol><li>允许使用 32 位的通用寄存器作寄存器间接寻址。例如：<code>MOV DX, [EBX]</code></li> <li>所有的32位通用寄存器均可作为基址寄存器使用；除 <code>ESP</code> 外的32位通用寄存器都能作为变址寄存器使用。</li></ol> <p>例如：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">EDX</span>, <span class="token operator">[</span><span class="token register variable">EDX</span><span class="token operator">+</span><span class="token number">16</span><span class="token operator">]</span>
MOV  <span class="token register variable">AX</span>, ADDR<span class="token operator">[</span><span class="token register variable">EBP</span><span class="token operator">]</span>
MOV  <span class="token register variable">EBX</span>, <span class="token operator">[</span><span class="token register variable">ESI</span><span class="token operator">]</span><span class="token operator">[</span><span class="token register variable">EAX</span><span class="token operator">]</span>
</code></pre></div><ol start="3"><li>32 位的变址寄存器可以乘上一个比例常数2、4和8，从而形成<code>比例变址</code>寻址方式、<code>基址-比例变址</code>寻址方式和<code>基址-比例变址-位移</code>寻址方式。</li></ol> <p><img src="/images/7d0d508021db8d4e0aabf5e5dcf1cf1a11249d16bbb4a84c9faa3cb226ac4f87.png" alt="寻址方式"></p> <p>上述三种情况可用如图公式表示。</p> <p>例如：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">EBX</span>, ADDR<span class="token operator">[</span><span class="token register variable">ESI</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">]</span>      <span class="token comment">; 比例变址寻址方式</span>
MOV  <span class="token register variable">EAX</span>, <span class="token operator">[</span><span class="token register variable">EDI</span><span class="token operator">*</span><span class="token number">4</span><span class="token operator">]</span><span class="token operator">[</span><span class="token register variable">EDX</span><span class="token operator">]</span>     <span class="token comment">; 基址比例变址寻址方式</span>
MOV  <span class="token register variable">EBX</span>, <span class="token operator">[</span><span class="token register variable">EDI</span><span class="token operator">*</span><span class="token number">8</span><span class="token operator">]</span><span class="token operator">[</span><span class="token register variable">EBP</span><span class="token operator">+</span><span class="token number">10</span><span class="token operator">]</span>  <span class="token comment">; 基址比例变址位移寻址方式</span>
</code></pre></div><h4 id="扩展的指令"><a href="#扩展的指令" class="header-anchor">#</a> 扩展的指令</h4> <p>IA-32微处理器对8086/8088的指令进行了扩展或新增了指令。所有指令的操作数可以是8位、16位或32位。</p> <p>下面列举其中部分新增的指令。</p> <h5 id="数据传送指令-2"><a href="#数据传送指令-2" class="header-anchor">#</a> 数据传送指令</h5> <h6 id="符号扩展-movsx-movzx"><a href="#符号扩展-movsx-movzx" class="header-anchor">#</a> 符号扩展：MOVSX MOVZX</h6> <p>格式：<code>MOVSX DEST, SRC</code> <code>MOVZX DEST, SRC</code></p> <ul><li>两种用法：
<ul><li><code>8 位寄存器/存储器 -&gt; 16/32 位寄存器</code></li> <li><code>16 位寄存器/存储器 -&gt; 32 位寄存器</code></li></ul></li> <li>MOVSX是带符号数扩展指令（符号填充），MOVZX是无符号数扩展指令（零填充）</li></ul> <p>例如：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOVSX  <span class="token register variable">ECX</span>, <span class="token register variable">AX</span>  <span class="token comment">; 将字扩充到双字</span>
MOVZX  <span class="token register variable">BX</span>, <span class="token register variable">AL</span>   <span class="token comment">; 将字节扩充到字</span>
</code></pre></div><h6 id="取偏移量-lfs-lgs-lss"><a href="#取偏移量-lfs-lgs-lss" class="header-anchor">#</a> 取偏移量 LFS LGS LSS</h6> <p>类似于 <a href="#%E8%A3%85%E5%85%A5%E5%9C%B0%E5%9D%80%E6%8C%87%E9%92%88%E6%8C%87%E4%BB%A4-lds-les"><code>LDS</code>、<code>LES</code></a>（<code>DEFG</code> 还行）</p> <p><code>LFS</code> 指令将 32 位的偏移量送目的寄存器，16 位的段选择子送 FS。</p> <p>其他两条指令类似，只是段寄存器变为GS和SS。</p> <h5 id="算术运算指令"><a href="#算术运算指令" class="header-anchor">#</a> 算术运算指令</h5> <p>新增了两种<a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B9%98%E6%B3%95-mul">乘法指令</a>，格式：</p> <div class="language- extra-class"><pre class="language-text"><code>IMUL  DEST, SRC 
; 将(SRC)与(DEST)相乘，将结果放在 DEST 中

IMUL  DEST, SRC1, SRC2
; 将(SRC1)与(SRC2)相乘，将结果放在 DEST 中
</code></pre></div><p>新增了两条<a href="#%E5%AD%97%E4%BD%8D%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4-cbw-cwd">扩展指令</a>。</p> <div class="language- extra-class"><pre class="language-text"><code>CWDE
; Convert Word to Doubleword
; 将AX的符号位扩展到EAX的高16位
; 加一个 E 与 CWD （扩展位放在 DX）以示区别

CDQ
; Convert Dooubleword to Quadword
; 将EAX的符号位扩展到EDX的所有32位
</code></pre></div><h5 id="逻辑运算与移位指令"><a href="#逻辑运算与移位指令" class="header-anchor">#</a> 逻辑运算与移位指令</h5> <ol><li>对于<a href="#%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4">移位指令</a>，当移位次数大于 1 时，允许使用立即数作为操作数。</li></ol> <p>例如，<code>SAL AX, 2</code></p> <ol start="2"><li>新增了 <code>SHLD</code> 与 <code>SHRD</code> 指令</li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code>SHLD  DEST, SRC, OPTR
<span class="token comment">; 对 DEST 左移 OPTR 位，移出的位依次进入 CF 标志位，DEST 空出的位由 SRC 的高位顺序移入。移位结束后SRC保持不变</span>

SHRD   DEST, SRC, OPTR
<span class="token comment">; 对 DEST 右移 OPTR 位，移出的位依次进入 CF 标志位，DEST 空出的位由 SRC 的低位顺序移入。移位结束后，SRC保持不变</span>
</code></pre></div><p>8086 的 <a href="#%E5%B8%A6-cf-%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D-rcl-rcr"><code>RCL</code> <code>RCR</code></a>只能移一次，空出的位由 <code>CF</code> 补。</p> <h5 id="堆栈操作指令"><a href="#堆栈操作指令" class="header-anchor">#</a> 堆栈操作指令</h5> <ol><li>PUSH允许立即数入栈</li></ol> <div class="language-nasm extra-class"><pre class="language-nasm"><code>PUSH  <span class="token number">0ABCDH</span>      <span class="token comment">;将16位立即数入栈</span>
PUSH  <span class="token number">0ABCD0000H</span>  <span class="token comment">;将32位立即数入栈  </span>
</code></pre></div><ol start="2"><li>新增两条PUSH指令</li></ol> <p><code>PUSHA</code> 指令将8个16位通用寄存器<code>AX、BX、CX、DX、SP、BP、SI与DI</code>一次性入栈。</p> <p><code>PUSHD</code> 指令将8个32位通用寄存器<code>EAX、EBX、ECX、EDX、ESP、EBP、ESI与EDI</code>一次性入栈。</p> <p>似乎是为了函数调用时保存所有寄存器值？</p> <ol start="3"><li>新增两条POP指令</li></ol> <p>与上面对应地：</p> <p><code>POPA</code>指令从栈顶弹出8个字数据分别送入<code>AX、BX、CX、DX、SP、BP、SI与DI</code>。</p> <p><code>POPD</code>指令从栈顶弹出8个双字数据分别送入<code>EAX、EBX、ECX、EDX、ESP、EBP、ESI与EDI</code>。</p> <h4 id="ia-32-汇编语言程序框架概述"><a href="#ia-32-汇编语言程序框架概述" class="header-anchor">#</a> IA-32 汇编语言程序框架概述</h4> <p>IA-32汇编语言程序设计的方法同前面介绍的16位指令程序设计基本相同。但在结构上有三点主要差异。</p> <ul><li>在开始处增加了方式选择；</li> <li>在段定义中增加了使用类型可选项；</li> <li>可以同时使用6个段。</li></ul> <h5 id="方式选择"><a href="#方式选择" class="header-anchor">#</a> 方式选择</h5> <p>方式选择伪指令用来确定微处理器工作模式和当前指令集。</p> <p><code>.8086</code>  -选择8086/8088指令集。这是汇编程序默认的方式。
<code>.286</code>    -选择80286实地址方式指令集
<code>.286P</code>  -选择80286保护方式
<code>.386</code>    -选择80386非保护方式指令集。
<code>.386P</code>  -选择80386保护方式</p> <h5 id="确定段的使用类型属性"><a href="#确定段的使用类型属性" class="header-anchor">#</a> 确定段的使用类型属性</h5> <p>IA-32的段定义格式：<code>段名 SEGMENT [定位类型] [组合类型] [类别名] [使用类型]</code>，较<a href="#%E6%AE%B5%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4-segment">8086</a>多了一个使用类型。</p> <p>使用类型: 有<code>USE16</code>和<code>USE32</code>两种取值，用来定义段寻址方式</p> <ul><li>USE16：8086/8088实地址方式，段基值16位，偏移量16位，最大段长64KB。该值为缺省值</li> <li>USE32：对应保护方式，段基值(段选择子)16位，偏移量32位，最大段长4GB。</li></ul> <h5 id="例题"><a href="#例题" class="header-anchor">#</a> 例题</h5> <p>例:  统计一个字数组中非负数的个数，结果保存在RESULT单元中。</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>.<span class="token number">386</span>
DATA 	SEGMENT	PARA	USE16
ARRAY	DW   <span class="token number">234</span>, <span class="token operator">-</span><span class="token number">87</span>, <span class="token number">65</span>, <span class="token number">0</span>, <span class="token number">23</span>, <span class="token operator">-</span><span class="token number">54</span>, <span class="token number">23</span>,<span class="token number">44</span>,<span class="token operator">-</span><span class="token number">54</span>, <span class="token number">0</span>
CNT	EQU	<span class="token operator">$</span><span class="token operator">-</span>ARRAY
RESULT	DW  ?
DATA	ENDS
STACK1	SEGMENT	PARA	STACK USE16	 
                       DW <span class="token number">100</span> DUP(?)
STACK1	ENDS
CODE     SEGMENT  PARA USE16
           ASSUME <span class="token register variable">CS</span>:CODE, <span class="token register variable">DS</span>:DATA, <span class="token register variable">SS</span>:STACK1     
<span class="token label function">BEGIN:</span>	MOV	<span class="token register variable">AX</span>, DATA
		MOV	<span class="token register variable">DS</span>, <span class="token register variable">AX</span>
                        LEA	<span class="token register variable">SI</span>, ARRAY
		MOV	<span class="token register variable">CX</span>, CNT<span class="token operator">/</span><span class="token number">2</span>
<span class="token label function">ACS:</span>	            LODSW
		BT  <span class="token register variable">AX</span>, <span class="token number">15</span> <span class="token comment">;386新增指令,将AX的第15位送CF </span>
		JC	NEXT
		INC	RESULT
<span class="token label function">NEXT:</span>	LOOP	ACS
		MOV	<span class="token register variable">AH</span>, <span class="token number">4CH</span>
		INT	<span class="token number">21H</span>
CODE	            ENDS
		END	BEGIN 		
</code></pre></div><p>bt是位操作指令：</p> <blockquote><p>指令的格式：BT/BTC/BTR/BTS Reg/Mem,Reg/Imm ;80386+<br>
位检测指令是把第一个操作数中某一位的值传送给标志位CF，具体的哪一位由指令的第二操作数来确定。
根据指令中对具体位的处理不同，又分一下几种指令：<br>
BT：把指定的位传送给CF；<br>
BTC：把指定的位传送给CF后，还使该位变反；<br>
BTR：把指定的位传送给CF后，还使该位变为0；<br>
BTS：把指定的位传送给CF后，还使该位变为1；<br>
例如：假设(AX)=1234H，分别执行下面指令。<br>
BT AX, 2 ;指令执行后，CF=1，(AX)=1234h<br>
BTC AX, 6 ;指令执行后，CF=0，(AX)=1274h<br>
BTR AX, 10 ;指令执行后，CF=0，(AX)=1234h<br>
BTS AX, 14 ;指令执行后，CF=0，(AX)=5234h</p></blockquote> <p>下面再看一个不像前面学的汇编语言的汇编语言程序：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>.<span class="token number">386</span>
.model flat, stdcall
<span class="token comment">;Include文件定义</span>
include windows.inc
include user32.inc
includelib user32.lib
include kernel32.inc
includelib kernel32.lib
<span class="token comment">;数据段</span>
. Data
Caption  db    <span class="token string">'A MessageBox !'</span>,<span class="token number">0</span>
Text         db    <span class="token string">'Hello, World !'</span>, <span class="token number">0</span>
<span class="token comment">;代码段</span>
.code
start：
        invoke MessageBox，NULL,offset Text, offset Caption,MB_OK
        invoke ExitProcess, NULL
end   start
</code></pre></div><p><img src="/images/7e67f011032c8059a82a1a9bbe901da19c3d9b41839e0183ba6ce30a8a5d1892.png" alt="程序执行结果"></p> <h2 id="第六章-输入输出及中断技术"><a href="#第六章-输入输出及中断技术" class="header-anchor">#</a> 第六章 输入输出及中断技术</h2> <h3 id="输入输出系统"><a href="#输入输出系统" class="header-anchor">#</a> 输入输出系统</h3> <h4 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h4> <p>输入输出系统：计算机系统中除 CPU 和内存储器之外的部分</p> <p>I/O系统分为：</p> <ul><li>输入输出设备</li> <li>输入输出接口</li> <li>输入输出软件</li></ul> <hr> <p>特点：</p> <ul><li>复杂性：输入输出设备、处理器、操作系统的复杂性</li> <li>异步性：工作速度和时序不一致</li> <li>实时性：控制的时效性。I/O系统保证处理器对不同设备的请求提供及时服务</li> <li>与设备无关性：接口的标准化，由操作系统屏蔽了设备的差异。</li></ul> <h4 id="i-o-接口系统及接口"><a href="#i-o-接口系统及接口" class="header-anchor">#</a> I/O 接口系统及接口</h4> <p>有关I/O系统的概念、特点，以及I/O接口的功能等，请参阅教材描述，自行学习。</p> <p>总体上，I/O接口应具备以下功能：</p> <ul><li>数据的缓冲与暂存</li> <li>信号电平与类型的转换</li> <li>增加信号的驱动能力</li> <li>对外设进行监测、控制与管理，中断处理</li></ul> <h4 id="i-o-端口"><a href="#i-o-端口" class="header-anchor">#</a> I/O 端口</h4> <ul><li>端口：接口中的寄存器</li> <li>端口的主要作用：信息的缓存</li> <li>端口类型：
<ul><li>数据端口：缓存输入和输出的数据</li> <li>状态端口：缓存需要输入的外设工作状态</li> <li>控制端口：缓存由系统输出的各种控制信息</li></ul></li></ul> <p><img src="/images/9839b6488c3a5f0fdc2cd36ef07594554b2cc8aa110d0fe8acfc88ee2098874a.png" alt="I/O端口"></p> <hr> <p>I/O系统中的接口和端口的地址：</p> <ul><li>每个接口为一个芯片，每个芯片有一个基地址。</li> <li>端口地址=芯片地址（高位地址）+片内地址</li></ul> <h4 id="i-o-端口的编址方式"><a href="#i-o-端口的编址方式" class="header-anchor">#</a> I/O 端口的编址方式</h4> <p>编址方式：</p> <ol><li>与内存统一编址</li> <li>独立编址</li></ol> <h5 id="i-o-端口与内存统一编址"><a href="#i-o-端口与内存统一编址" class="header-anchor">#</a> I/O 端口与内存统一编址</h5> <ul><li>指令及控制信号统一</li> <li>内存地址资源减少</li></ul> <p><img src="/images/dc8372e7eaeaafca1b994f440ada1df76883c05be18ea154e256a364202f89f3.png" alt="I/O端口与内存统一编址"></p> <h5 id="i-o-端口独立编址"><a href="#i-o-端口独立编址" class="header-anchor">#</a> I/O 端口独立编址</h5> <ul><li>内存地址资源充分利用</li> <li>能够应用于端口的指令较少</li></ul> <p><img src="/images/04a5da24c60a89319b7c54f614ab3dc8eb682b15e14745a4e57427666aac3b00.png" alt="I/O端口独立编址"></p> <h5 id="_8088-8086-的-i-o-端口编址"><a href="#_8088-8086-的-i-o-端口编址" class="header-anchor">#</a> 8088/8086 的 I/O 端口编址</h5> <ul><li>采用I/O端口<strong>独立编址</strong>方式(但地址线与存储器共用)</li> <li>地址线上的地址信号用<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>O</mi><mi mathvariant="normal">/</mi><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mi>M</mi></mrow><annotation encoding="application/x-tex">IO/\overline{M}M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></span>（<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>O</mi></mrow><mo stretchy="true">‾</mo></mover><mi mathvariant="normal">/</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\overline{IO}/M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></span>）来区分</li> <li>I/O操作只使用20根地址线中的<strong>16</strong>根：A15~A0</li> <li>可寻址的I/O端口数为<strong>64K(65536)个</strong></li> <li>I/O地址范围为<code>0</code>~<code>FFFFH</code></li></ul> <h4 id="i-o-地址译码"><a href="#i-o-地址译码" class="header-anchor">#</a> I/O 地址译码</h4> <p><img src="/images/f747740fead925288642a647078a01ebf2c3b1d2737872bef79e98f9e24f6b6c.png" alt="I/O地址译码"></p> <h5 id="全地址译码与部分地址译码"><a href="#全地址译码与部分地址译码" class="header-anchor">#</a> 全地址译码与部分地址译码</h5> <p>一个接口电路中可以有一个或多个端口。</p> <ol><li>全地址译码：</li></ol> <ul><li>全部16位I/O地址信号参与译码</li> <li>当接口中只有一个端口时， 16位地址线应全部参与译码，译码输出直接选择该端口中；</li> <li>当接口中有多个端口时，则16位地址线的高位参与译码（决定接口的基地址），低位直接输入到接口芯片，用于寻址接口中要访问的端口。</li></ul> <ol start="2"><li>部分地址译码：</li></ol> <ul><li>仅用部分地址（比如16位中低10位）信号参与译码</li> <li>含多个端口的接口，最低的几位直接连到接口芯片</li></ul> <p>I/O系统中，因地址资源丰富，多采用部分地址译码。</p> <p>看不出来有什么区别。</p> <h5 id="i-o地址译码例题"><a href="#i-o地址译码例题" class="header-anchor">#</a> I/O地址译码例题</h5> <p>例：某外设接口有 4 个端口，地址为 <code>2F0H——2F3H</code>，由 A15～A2 译码得到，而 A1、A0 用来区分接口中的 4 个端口。试画出该接口与系统的连接图。</p> <p>题目分析：</p> <ul><li>寻址端口的地址信号最多为 16bit，题中仅用 12bit 就能表示其地址——故采用部分地址译码</li> <li>该接口电路中含有4个端口，片内端口寻址需 2 位地址信号，其余 10 位为接口芯片地址，即片选地址信号。</li></ul> <p>地址范围：</p> <ul><li>xxxx 0010111100 00 (2F0H)</li> <li>......</li> <li>xxxx 0010111100 11 (2F3H)</li> <li>x 表示任意状态，图中无需接入；后两位表示片内地址</li></ul> <p><img src="/images/1240556340cdaece1b43f7e223ee5befc0ff0d418e94157150f46a38fccbe0a7.png" alt="译码电路图"></p> <p>最上面表示 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>O</mi><mi>R</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{IOR}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span> 和 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>O</mi><mi>W</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{IOW}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span> 至少有一个是 0（有效）时芯片有效，若都是 1 则芯片无效。</p> <h4 id="接口的基本构成"><a href="#接口的基本构成" class="header-anchor">#</a> 接口的基本构成</h4> <p><img src="/images/a284cc5dad4583c5e538a16a6c09edc6bc4154ef61f603d2fafae14f85d25a53.png" alt="接口的基本构成"></p> <ul><li>AB (Address Bus)</li> <li>DB (Data Bus)</li> <li>CB (Control Bus)</li> <li>数据输入/输出寄存器：暂存输入/输出的数据</li> <li>命令寄存器：存放控制命令（设定接口功能、工作参数和工作方式）</li> <li>状态寄存器：保存外设当前状态，以供CPU读取</li></ul> <h4 id="接口的类型及特点"><a href="#接口的类型及特点" class="header-anchor">#</a> 接口的类型及特点</h4> <ul><li>按传输信息的方向分类：
<ul><li>输入接口</li> <li>输出接口</li></ul></li> <li>按传输信息的类型分类：
<ul><li>数字接口</li> <li>模拟接口</li></ul></li> <li>按传输信息的方式分类：
<ul><li>并行接口</li> <li>串行接口</li></ul></li></ul> <hr> <p>接口特点：</p> <ul><li>输入接口：
<ul><li>要求对数据具有控制能力（允许数据送到数据线）</li> <li>常用三态门实现</li></ul></li> <li>输出接口：
<ul><li>要求对数据具有锁存能力（接收后保持数据不变）</li> <li>常用锁存器实现</li></ul></li></ul> <h3 id="简单接口电路"><a href="#简单接口电路" class="header-anchor">#</a> 简单接口电路</h3> <h4 id="三态门接口及-74ls244"><a href="#三态门接口及-74ls244" class="header-anchor">#</a> 三态门接口及 74LS244</h4> <p>三态：高电平、低电平、高阻态</p> <p><img src="/images/7ce02180ca3ba2af492a1dc13e662bc78cb01de84701038a1884efced123f6e3.png" alt="三态门接口"></p> <hr> <p>74LS244：</p> <ul><li>含8个三态门的集成电路芯片</li> <li>在外设具有数据保持能力时用来输入接口数据</li></ul> <p><img src="/images/fc780b8f56edacc1bcdc5bf6b34d6a18c4f2497b17714231874b28c0a453eb78.png" alt="74LS244"></p> <hr> <p>例题：编程判断图中的开关状态，若全闭合则转NEXT1，否则转NEXT2。</p> <p><img src="/images/f6b61d004f930cee755cb13cc7d467f931f9d26543c4f4f260af5dedace214d6.png" alt="例题图"></p> <p>注意到开关 K0~K7 的另一侧接了地。如果开关闭合，输入 I0~I7 应该为 0。反之为 1。</p> <p>由图可知对应的地址为：</p> <p>1000 0111 1111 11xx</p> <p>即 <code>83FCH~83FFH</code>。</p> <p>可以任选其中一个地址如 <code>83FCH</code> 作为该接口地址，编程如下：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV  <span class="token register variable">DX</span>, <span class="token number">83FCH</span>
IN   <span class="token register variable">AL</span>, <span class="token register variable">DX</span>
AND  <span class="token register variable">AL</span>, <span class="token number">0FFH</span>      <span class="token comment">; 闭合为 0</span>
JZ   NEXT1
JMP  NEXT2
</code></pre></div><h4 id="锁存器接口及-74ls273-74ls373-74ls374"><a href="#锁存器接口及-74ls273-74ls373-74ls374" class="header-anchor">#</a> 锁存器接口及 74LS273 74LS373 74LS374</h4> <p>锁存器接口：</p> <ul><li>通常由 D 触发器构成</li> <li>特点：
<ul><li>具有对数据的锁存能力</li> <li>不具备对数据的输出控制能力</li></ul></li></ul> <hr> <p>74LS273：8 个 D 触发器</p> <p><img src="/images/1e0bb6f1d803fa9cdc1495cd95c4fd81a4347588cd75ea5ed6cafc7de0fcb3b8.png" alt="74LS273"></p> <hr> <p>74LS373和74LS374：</p> <ul><li>三态输出的8 D触发器，并具有对数据的控制能力。</li> <li>既可以做输入接口，也可以做输出接口。</li></ul> <p><img src="/images/8444334785e7b869da453bb51e8d877169200ae08afaf04cf8160fd3b1e42349.png" alt="74LS374"></p> <p>不懂</p> <hr> <p>例题：输出接口地址是多少？</p> <p><img src="/images/7a87ce50ade289782694bbbaecba5648c219d15bbe81e3cfcc9617c5139f1b33.png" alt="例题图"></p> <p>不懂+1</p> <h4 id="i-o接口综合应用例题-重要"><a href="#i-o接口综合应用例题-重要" class="header-anchor">#</a> I/O接口综合应用例题（重要！）</h4> <ul><li>根据 4 个开关的状态控制 7 段数码管的显示（<strong>输入：4位开关 输出：显示符号与输出数据对应表中的 7 位</strong>）</li> <li>当4个开关的状态分别为<code>0000</code>~<code>1111</code>时，在7段数码管上对应显示'0'～'F'</li> <li>设显示接口的地址为 <code>F0H</code>，开关接口地址为 <code>F1H</code></li></ul> <p><img src="/images/ccf5a8484feab575f81507e2a0403d2058634868ced55bc9ea9b5bbdd04b8788.png" alt="数码管结构图"></p> <p><img src="/images/8c5a5589a6292e003fe60f5e5ef0cffd10a2e7e253224f9db9ec90a02091a5ed.png" alt="显示符号与输出数据对应表"></p> <p>解：下面是总线连接图。</p> <ol><li>四个开关 K0~K3 连接 74LS244，输入到 CPU</li> <li>汇编程序将 D0~D3 转为上表中的 8 位值</li> <li>8 位值通过 D0~D7 连接 74LS273，输出到数码管</li></ol> <p>译码器部分有一个 74LS138，它把 3 位信号 (A B C) 转为 Y0~Y7（此问只用到了 Y0 和 Y1）。A3~A7 接入到 74LS138 的使能端。</p> <p><img src="/images/e7121bad55aca7bfec3b3ea37c3618bd0d5809211e51fb0190f0976d54f868e0.png" alt="总线连接图"></p> <p>程序段：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>......
Seg7  DB  <span class="token number">3FH</span>,<span class="token number">06H</span>,
      <span class="token number">5BH</span>,<span class="token number">4FH</span>,<span class="token number">66H</span>,<span class="token number">6DH</span>,
      <span class="token number">7DH</span>,<span class="token number">07H</span>,<span class="token number">7FH</span>,<span class="token number">67H</span>,<span class="token number">77H</span>,
      <span class="token number">7CH</span>,<span class="token number">39H</span>,<span class="token number">5EH</span>,<span class="token number">79H</span>,<span class="token number">71H</span>
......
    LEA  <span class="token register variable">BX</span>, Seg7
    MOV  <span class="token register variable">AH</span>, <span class="token number">0</span>
<span class="token label function">GO:</span> IN   <span class="token register variable">AL</span>, <span class="token number">0F1H</span>
    AND  <span class="token register variable">AL</span>, <span class="token number">0FH</span>
    MOV  <span class="token register variable">SI</span>, <span class="token register variable">AX</span>
    MOV  <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">+</span><span class="token register variable">SI</span><span class="token operator">]</span>
    OUT  <span class="token number">0F0H</span>, <span class="token register variable">AL</span>
    JMP  GO
</code></pre></div><h3 id="基本输入-输出方法"><a href="#基本输入-输出方法" class="header-anchor">#</a> 基本输入/输出方法</h3> <p>基本输入/输出方法有：</p> <ul><li>无条件传送</li> <li>查询式传送</li> <li>中断方式传送</li> <li>直接存储器存取(DMA)</li></ul> <p>其中前三种是程序控制方式。</p> <h4 id="无条件传送"><a href="#无条件传送" class="header-anchor">#</a> 无条件传送</h4> <p>要求外设总是处于准备好状态。</p> <p>优点：</p> <ul><li>软件及接口硬件简单</li></ul> <p>缺点：</p> <ul><li>只适用于简单外设，适应范围较窄</li></ul> <p>例：读取开关的状态；当开关闭合时，输出编码使发光二极管亮。</p> <h4 id="查询工作方式"><a href="#查询工作方式" class="header-anchor">#</a> 查询工作方式</h4> <ul><li>仅当条件满足时才能进行数据传送；</li> <li>每满足一次条件一般只进行一次数据传送。</li> <li>适用场合：
<ul><li>外设并不总是处于“准备好”状态</li> <li>对传送速率和效率要求不高</li></ul></li> <li>工作条件：
<ul><li>外设应提供设备状态信息</li> <li>接口应具备状态端口</li></ul></li></ul> <p><img src="/images/d6e75309923a7b7d78f94fcc2a193200c4719224ff34da82547c4be4a020f962.png" alt="单个外设的查询工作方式流程图"></p> <p>上述流程图可能出现一直等待外设，导致死机的情况。</p> <p><img src="/images/f576ff745c7d1beca9c00fb917a8d67c4a60cb703f6743cfe02d9b1111b2cc6a.png" alt="单个外设的查询工作方式流程图（改进）"></p> <p>例：数据输出</p> <ul><li>外设状态端口地址为<code>03FBH</code>，<code>bit5</code> 为状态标志（=1忙，=0准备好）</li> <li>外设数据端口地址为<code>03F8H</code>，CPU 写入数据会使状态标志置1；外设把数据读走后又把它置 0。</li> <li>试画出其电路图，并将 BUF 中的 100 个字节数据输出。</li></ul> <p><img src="/images/fca64462c982107b626fd346cdb2f144183f0ec904add363dc7908285ed2b6d3.png" alt="电路图"></p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>      MOV  <span class="token register variable">CL</span>, <span class="token number">100</span>
      LEA  <span class="token register variable">SI</span>, BUF
<span class="token label function">AGAI:</span> MOV  <span class="token register variable">DX</span>, <span class="token number">03FBH</span> 
<span class="token label function">NEXT:</span> IN   <span class="token register variable">AL</span>, <span class="token register variable">DX</span>
      TEST <span class="token register variable">AL</span>, <span class="token number">20H</span>
      JNZ  NEXT
      MOV  <span class="token register variable">DX</span>, <span class="token number">03F8H</span>
      MOV  <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
      OUT  <span class="token register variable">DX</span>, <span class="token register variable">AL</span>
      INC  <span class="token register variable">SI</span>
      LOOP AGAI
</code></pre></div><hr> <h4 id="多个外设时查询工作方式"><a href="#多个外设时查询工作方式" class="header-anchor">#</a> 多个外设时查询工作方式</h4> <ul><li>优点：软硬件比较简单</li> <li>缺点：CPU 效率低，数据传送的实时性差，速度较慢</li></ul> <p><img src="/images/387c5b8cbf55732c085cf3cd2abfa7bfad8c72e1e19caf58b31d04745e408175.png" alt="多个外设时查询工作方式"></p> <h4 id="中断控制方式"><a href="#中断控制方式" class="header-anchor">#</a> 中断控制方式</h4> <ul><li>特点：外设在需要时向CPU提出请求，CPU再去为它服务。服务结束后或在外设不需要时，CPU可执行自己的程序。</li> <li>优点：CPU 效率高，实时性好，速度快。</li> <li>缺点：程序编制相对较复杂。</li></ul> <h4 id="以上三种i-o方式的共性"><a href="#以上三种i-o方式的共性" class="header-anchor">#</a> 以上三种I/O方式的共性</h4> <ul><li><strong>信息的传送均需通过CPU</strong></li> <li>软件： 外设与内存之间的数据传送是通过CPU执行程序来完成的（PIO方式）；</li> <li>硬件：I/O接口和存储器的读写控制信号、地址信号都是由CPU发出的。</li> <li>缺点：程序的执行速度限定了传送的最大速度</li></ul> <h4 id="dma控制方式"><a href="#dma控制方式" class="header-anchor">#</a> DMA控制方式</h4> <ul><li>外设直接与存储器进行数据交换 ，CPU不再担当数据传输的中介者；</li> <li>总线由DMA控制器（DMAC）进行控制（CPU要放弃总线控制权），内存/外设的地址和读写控制信号均由DMAC提供。</li></ul> <p><img src="/images/5545755c2b85b8696eec8d1f703113611f53ad2b18790c453deb964a53be51d0.png" alt="DMA控制方式"></p> <hr> <p>DMA控制方式的工作过程：</p> <ol><li>外设向DMA控制器发出“DMA传送请求”信号 DREQ；</li> <li>DMA控制器收到请求后，向CPU发出“总线请求”信号HOLD；</li> <li>CPU在完成当前总线周期后会立即发出HLDA信号，对HOLD信号进行响应；</li> <li>DMA控制器收到HLDA信号后，就开始控制总线，并向外设发出DMA响应信号DACK。</li></ol> <hr> <p>DMA控制方式工作过程例：从外设向内存传送若干字节数据</p> <ol><li>DMAC向I/O接口发出读信号；</li> <li>向地址总线上发出存储器的地址；</li> <li>发出存储器写信号和AEN信号；</li> <li>传送数据并自动修改地址和字节计数器</li> <li>判断是否需要重复传送操作;</li> <li>若数据传送完，DMA控制器撤销发往CPU的HOLD信号；</li> <li>CPU检测到HOLD失效后，则撤销HLDA信号，并在下一时钟周期重新开始控制总线。</li></ol> <hr> <p>DMA工作方式：</p> <ul><li>周期窃取：每个DMA周期只传送一个字节或一个字就立即释放总线。</li> <li>数据块传送：DMAC在申请到总线后，将一块数据传送完后才释放总线，而不管中间DREQ是否有效。</li></ul> <p><img src="/images/076342bd2e70ca365190fd100745fcf5b92ddfe11c845f8285c023b5728301a7.png" alt="周期窃取的DMA"></p> <hr> <p>DMA控制方式的优缺点：</p> <ul><li>优点：数据传输由DMA硬件来控制，数据直接在内存和外设之间交换，可以达到很高的传输速率。</li> <li>缺点：控制复杂，硬件成本相对较高。</li></ul> <h3 id="中断技术"><a href="#中断技术" class="header-anchor">#</a> 中断技术</h3> <h4 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h4> <p>CPU执行程序时，发生了某种随机的事件(外部或内部)，引起CPU暂时中断正在运行的程序，转去执行一段特殊的服务程序(称为中断服务程序或中断处理程序)，以处理该事件，该事件处理完后又返回被中断的程序继续执行，这一过程称为中断。</p> <hr> <p>中断源：引起CPU中断的事件，发出中断请求的来源。</p> <p>分类</p> <ul><li>内部中断
<ul><li>异常中断：异常事件引起</li> <li>软件中断：中断指令引起</li></ul></li> <li>外部中断
<ul><li>可屏蔽中断：<code>INTR</code> 中断</li> <li>非屏蔽中断：<code>NMI</code> 中断</li></ul></li></ul> <hr> <p>引入中断的原因：</p> <ul><li>提高数据传输率；</li> <li>避免了CPU不断检测外设状态的过程，提高了CPU的利用率。</li> <li>实现对特殊事件的实时响应。</li></ul> <h4 id="中断处理的一般过程"><a href="#中断处理的一般过程" class="header-anchor">#</a> 中断处理的一般过程</h4> <ol><li>中断请求</li> <li>中断源识别及中断判优</li> <li>中断响应</li> <li>中断处理（服务）</li> <li>中断返回</li></ol> <h5 id="中断请求"><a href="#中断请求" class="header-anchor">#</a> 中断请求</h5> <ul><li>包括 NMI、INTR</li> <li>中断请求信号应保持到中断被处理为止；</li> <li>CPU响应中断后，中断请求信号应及时撤销。</li></ul> <h5 id="中断源识别"><a href="#中断源识别" class="header-anchor">#</a> 中断源识别</h5> <ul><li>软件查询法：在中断处理程序中查找中断源</li> <li>中断矢量法—硬件识别
<ul><li>由中断源提供中断类型号，CPU根据类型号确定中断源。</li> <li>中断源识别及中断判优（确定先响应哪个中断请求）由硬件系统完成</li></ul></li></ul> <h5 id="中断判优"><a href="#中断判优" class="header-anchor">#</a> 中断判优</h5> <p>当有多个中断源同时提出请求时，需要确定首先响应哪一个中断源。</p> <p>优先级法则：</p> <ul><li>同时出现或等待的多个中断源，优先级最高的被响应。</li> <li>低优先级的中断程序允许被高优先级的中断源所中断（可能出现中断嵌套）</li> <li>也可以设置成禁止中断嵌套</li></ul> <p>软件判优：顺序查询中断请求，先查询的先服务，即先被查询的中断源优先级别高<br>
硬件判优：链式判优、并行判优（中断向量法）</p> <p><img src="/images/fd25e75bef9a49c0de88ce5e21117fa5d15662e5a8d50e16af8c31a89d15eb10.png" alt="菊花链逻辑电路"></p> <p>看不懂图。</p> <h5 id="中断响应"><a href="#中断响应" class="header-anchor">#</a> 中断响应</h5> <p>中断响应包含以下几个操作：</p> <ol><li>向中断源发出中断响应信号 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></li> <li>关中断</li> <li>保护硬件现场：将FLAGS压入堆栈</li> <li>保护断点：将CS、IP压入堆栈</li> <li>获得中断服务程序入口地址</li></ol> <p>这些步骤都是由硬件系统完成。</p> <h5 id="中断处理"><a href="#中断处理" class="header-anchor">#</a> 中断处理</h5> <p>执行中断服务程序</p> <p>中断服务程序的特点：</p> <ul><li>中断服务程序要定义为“远过程”</li> <li>结束时要用 <code>IRET</code> 指令返回</li></ul> <p>中断服务程序完成的工作：</p> <ol><li>保护软件现场（参数）</li> <li>开中断 <code>STI</code>--允许中断嵌套</li> <li>中断处理—具体的处理</li> <li>关中断 <code>CLI</code></li> <li>恢复软件现场</li> <li>中断返回 <code>IRET</code></li></ol> <h5 id="中断返回"><a href="#中断返回" class="header-anchor">#</a> 中断返回</h5> <p>执行 <code>IRET</code> 指令，包括下面的操作：</p> <ul><li>使 IP、CS 和 FLAGS 从堆栈弹出</li> <li>开中断</li></ul> <p><img src="/images/e3b7d3f62dce4349ed51b3216974bd8e234978eab3c564ff14ce818b83691e6b.png" alt="外部可屏蔽中断处理过程"></p> <h4 id="_8088-8086中断系统"><a href="#_8088-8086中断系统" class="header-anchor">#</a> 8088/8086中断系统</h4> <p>在8086/8088所有的中断源都统一分配了不同的类型号</p> <p><img src="/images/35b32e639011712b98f10c22e8d52fab5877d99637fe6de0b4f4e05ffce76e98.png" alt="8088/8086中断系统"></p> <h5 id="内部中断"><a href="#内部中断" class="header-anchor">#</a> 内部中断</h5> <table><thead><tr><th>中断类型</th> <th style="text-align:center;">功能</th></tr></thead> <tbody><tr><td>类型0</td> <td style="text-align:center;">除数为0中断例行程序</td></tr> <tr><td>类型1</td> <td style="text-align:center;">单步</td></tr> <tr><td>类型2</td> <td style="text-align:center;">非屏蔽中断，<code>NMI</code></td></tr> <tr><td>类型3</td> <td style="text-align:center;">设置断点</td></tr> <tr><td>类型4</td> <td style="text-align:center;">溢出处理中断，<code>INTO</code>指令</td></tr> <tr><td>类型10H</td> <td style="text-align:center;">显示设备中断</td></tr> <tr><td>类型20H</td> <td style="text-align:center;">程序结束中断</td></tr> <tr><td>类型21H</td> <td style="text-align:center;">DOS系统功能调用功能程序</td></tr></tbody></table> <h5 id="外部中断"><a href="#外部中断" class="header-anchor">#</a> 外部中断</h5> <ol><li>非屏蔽中断</li></ol> <ul><li>NMI 引脚上出现上升沿触发</li> <li>不受标志位IF的限制，即不可以屏蔽。</li> <li>类型号：2</li></ul> <ol start="2"><li>可屏蔽中断</li></ol> <ul><li>INTR引脚输入，高电平有效</li> <li>受标志位IF的限制</li> <li>类型号：08H~0FH   70H~77H</li></ul> <h5 id="中断向量表"><a href="#中断向量表" class="header-anchor">#</a> 中断向量表</h5> <ul><li>存放各类中断的中断服务程序的入口地址；</li> <li>每个入口占用4 Bytes，低字为段内偏移，高字为段基址；</li> <li>表的地址位于内存的00000H～003FFH，大小为1KB，共256个入口。</li></ul> <h5 id="中断向量表-ivt"><a href="#中断向量表-ivt" class="header-anchor">#</a> 中断向量表 IVT</h5> <p>8086/8088中断向量表位于内存最低1KB</p> <p><img src="/images/a6bb3979da9cee3916e3ec4dc03dd03ded27a9ed555acfe73e4d9531606164b3.png" alt="中断向量表 IVT"></p> <h5 id="中断向量表的初始化"><a href="#中断向量表的初始化" class="header-anchor">#</a> 中断向量表的初始化</h5> <ul><li>系统启动时已经把默认的中断向量写入IVT</li> <li>用户需将自定义的中断服务程序入口地址放入向量表</li> <li>注意点：
<ul><li>向量表所在的段基址=<code>0</code></li> <li>存放中断服务程序入口的单元的偏移地址=<code>n*4</code></li></ul></li></ul> <p>例：将中断类型码为48H的服务程序入口地址放入向量表</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>TIMER  PROC  FAR
       <span class="token comment">; ...</span>
       <span class="token comment">; ...</span>
       IRET
TIMER  ENDP

<span class="token comment">; 下面的程序用MOV指令将类型码为48H的中断服务程序TIMER的中断向量放入向量表</span>
MOV <span class="token register variable">AX</span>，<span class="token number">0000H</span>
MOV <span class="token register variable">DS</span>，<span class="token register variable">AX</span>
MOV <span class="token register variable">SI</span>，<span class="token number">0120H</span>          <span class="token comment">; 48H*4</span>
MOV <span class="token register variable">BX</span>，OFFSET TIMER
MOV <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>，<span class="token register variable">BX</span>
MOV <span class="token register variable">BX</span>，SEG TIMER 
MOV <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">]</span>，<span class="token register variable">BX</span>
</code></pre></div><h5 id="可屏蔽中断的类型号的获取时序"><a href="#可屏蔽中断的类型号的获取时序" class="header-anchor">#</a> 可屏蔽中断的类型号的获取时序</h5> <p>对可屏蔽中断的响应需要两个总线周期：</p> <p><img src="/images/6b8def93e04b078fa8d94ae4d44d94c51e06c1adc9deb9cc421aa0e6d193c7d4.png" alt="可屏蔽中断的类型号的获取时序"></p> <h5 id="_8088内部中断与nmi中断"><a href="#_8088内部中断与nmi中断" class="header-anchor">#</a> 8088内部中断与NMI中断</h5> <p>特点：</p> <ul><li>无 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span> 总线周期</li> <li>中断类型码固定或由指令给出</li></ul> <h5 id="_8086的中断响应和处理流程"><a href="#_8086的中断响应和处理流程" class="header-anchor">#</a> 8086的中断响应和处理流程</h5> <p><img src="/images/4a99e7ff1b719a2a8ea78cf127650143b77b24f43f76f4ce0388c2906341acdb.png" alt="8086的中断响应和处理流程"></p> <h5 id="ia-32的中断模式"><a href="#ia-32的中断模式" class="header-anchor">#</a> IA-32的中断模式</h5> <p><img src="/images/40650dbd19b0ca79c9d155a60aef2f6df90457c926dc02f1543fca582f751ea9.png" alt="picture 29"></p> <p><img src="/images/53a43442aecd2dd21a93b0d53954e413ea04863a13a6f1ae51526516693ef956.png" alt="picture 30"></p> <p><img src="/images/3e73fc0c66da19a9cec93700da6858635f7fd3dd6a99d95b2bd1967c9f8d7b7d.png" alt="picture 31"></p> <p><img src="/images/e91012dfbc943302f33aafffdf47140a11ad4e9b7df10148dc49d8627957ac79.png" alt="picture 32"></p> <p><img src="/images/aab485d5b11361337ade9f5c29cfa820f1d40b5038d0bb564e695fc3b583dec9.png" alt="picture 33"></p> <h3 id="中断控制器-8259a-介绍"><a href="#中断控制器-8259a-介绍" class="header-anchor">#</a> 中断控制器 8259A 介绍</h3> <h4 id="一-8259a-的功能与结构"><a href="#一-8259a-的功能与结构" class="header-anchor">#</a> 一. 8259A 的功能与结构</h4> <h5 id="_8259a-的主要功能"><a href="#_8259a-的主要功能" class="header-anchor">#</a> 8259A 的主要功能</h5> <ul><li>记录 8 个中断源的中断请求。</li> <li>确定是否响应中断请求，并确定优先的中断请求并响应。</li> <li>CPU 响应中断时向 CPU 发送中断类型号。</li></ul> <h5 id="_8259a-的内部结构"><a href="#_8259a-的内部结构" class="header-anchor">#</a> 8259A 的内部结构</h5> <p><img src="/images/63ee119036fb3f3048eb5d751f374dd5dafda4d1160cda5fb71b9ec8f141de6f.png" alt="8259A的内部结构"></p> <p><img src="/images/7d331f96dc0e9a4839c9ba104955b81f7dd4b8b875bb5fea553895193f8166fa.png" alt="6-5-p4"></p> <p><img src="/images/4e2c1c95febf913d73775f9775b1ebeaef55a2762c2af81407c8a26ea81c08b0.png" alt="6-5-p5"></p> <p><img src="/images/864e6fc3c09262472d512565b4c3dabe52cd43a44651fc716d987efd2a7c3bab.png" alt="6-5-p6"></p> <p>三个寄存器的英文分别是 <code>Interrupt Request Register</code> (IRR), <code>In-Service Register</code> (ISR), <code>Interrupt Mask Register</code> (IMR)。这三个的功能一定要记住，当然要是记住了英文就很好记了。</p> <h5 id="_8259a-的工作原理"><a href="#_8259a-的工作原理" class="header-anchor">#</a> 8259A 的工作原理</h5> <ol><li>当IR0～IR7中的一条或多条请求线变高时，将相应的IRR位置1。</li> <li>根据中断服务寄存器（ISR）和中断屏蔽寄存器（IMR）的内容，找出未被屏蔽的最高优先权的中断请求，向CPU发中断请求信号INT。</li> <li>CPU响应中断时，送回应答信号 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span> 脉冲。</li> <li>8259A接到CPU发的第一个 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span> 脉冲时，把ISR中与最高优先级请求信号对应的位置1，并把IRR中的相应位复位。</li> <li>在8259A接到第二个 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span> 脉冲时向CPU发送中断类型码。如果是在AEOI（自动结束中断）方式，在这个脉冲结束时复位ISR的相应位。在其他方式下，要在中断服务程序结束时通过发EOI命令来复位ISR相应位。</li></ol> <h5 id="_8259a-的外部特性"><a href="#_8259a-的外部特性" class="header-anchor">#</a> 8259A 的外部特性</h5> <p><img src="/images/8fce5745daa744f1e55ad49138d1430c3ab0100f56d38535e8519df36a9f9858.png" alt="8259A与CPU的接口引脚图"></p> <p><img src="/images/fd2db466f4c68183565f70a32d3e1d9c8dcef5cab87ba9beb52e1994ad51e8d6.png" alt="8259A与CPU的接口引脚(1)"></p> <p><img src="/images/f873b23eab4d87695b79ec6b237757dcd1e2aacf801bb84306d876d72a57c8e8.png" alt="8259A与CPU的接口引脚(2)"></p> <h4 id="二-8259a-的工作方式"><a href="#二-8259a-的工作方式" class="header-anchor">#</a> 二. 8259A 的工作方式</h4> <p>下面的部分应该只用对名字留一个印象，具体是什么功能、怎么工作，应该不重要。</p> <h5 id="_1-优先级管理方式"><a href="#_1-优先级管理方式" class="header-anchor">#</a> 1. 优先级管理方式</h5> <h6 id="_1-中断嵌套方式"><a href="#_1-中断嵌套方式" class="header-anchor">#</a> 1) 中断嵌套方式</h6> <ol><li>普通全嵌套方式</li></ol> <ul><li>这是最常用最基本的工作方式，8259A初始化后为该方式。</li> <li>当一个中断正被处理时，只有比它优先级更高的中断请求才会被响应。</li></ul> <ol start="2"><li>特殊全嵌套方式</li></ol> <ul><li>它与普通全嵌套方式的区别是：允许同级中断进行嵌套</li> <li>只允许主片8259A使用特殊全嵌套方式，以实现从片中的高低优先级之间的嵌套。</li></ul> <p>以上两种嵌套方式中各中断源的优先级顺序是固定的，加电时优先级从高到低顺序为：IR0、IR1、IR2、IR3、IR4、IR5、IR6、IR7。也可以重设和循环优先级。</p> <h6 id="_2-优先级变化方式"><a href="#_2-优先级变化方式" class="header-anchor">#</a> 2) 优先级变化方式</h6> <ol><li>优先级固定方式</li></ol> <ul><li>各中断请求的优先级固定不变，8259A加电后IR0最高，IR7最低。</li></ul> <ol start="2"><li>优先级循环方式</li></ol> <ul><li>优先队列是变化的，一个中断源得到中断服务后，它的优先级自动降为最低。</li> <li>按照加电时的优先级顺序进行优先级循环称为<strong>优先级自动循环方式</strong>。改变初始优先级顺序后的循环，称为<strong>优先级特殊循环方式</strong>。</li> <li>优先级循环方式适合于系统中各个中断源级别相当，能够得到均衡的服务。</li></ul> <h5 id="_2-中断源的屏蔽方式"><a href="#_2-中断源的屏蔽方式" class="header-anchor">#</a> 2．中断源的屏蔽方式</h5> <ol><li>常规屏蔽方式</li></ol> <ul><li>8259A的每个中断请求输入端都可通过对应的IMR位的设置被屏蔽。IMR某位为“1”表示屏蔽对应的中断请求。</li></ul> <ol start="2"><li>特殊屏蔽方式</li></ol> <ul><li>使正在处理的中断所对应的IMR位置1，并使对应的ISR位清零，这样任何优先级的中断都可得到响应。</li> <li>主要用在中断服务程序中需要动态地改变系统的优先级结构的情况。</li> <li>例如，在执行中断服务程序的某一部分时，需要禁止比本中断优先级低的其他中断请求，而在执行另一部分时，又希望开放这些中断请求。</li></ul> <p>看不懂</p> <h5 id="_3-中断结束的处理方式"><a href="#_3-中断结束的处理方式" class="header-anchor">#</a> 3．中断结束的处理方式</h5> <p>中断结束 (End of Interrupt, EOI)</p> <ol><li>自动中断结束方式</li></ol> <ul><li>它是最简单的中断结束方式。</li> <li>系统进入中断过程，在第二个INTA脉冲的后沿，8259A将当前处理的中断所对应的ISR位清零。</li> <li>当系统正在为某外设进行中断服务，但在8259A的ISR中却没有对应位指示，故该方式只能用于非嵌套方式处理。</li> <li>在初始化时由初始化命令字ICW4的AEOI位置1来设置这种方式。</li></ul> <ol start="2"><li>正常中断结束方式</li></ol> <ul><li>它用在两种全嵌套方式下，当CPU向8259A发出中断结束命令时，8259A将ISR中优先级最高的位复位（即当前正在进行的中断服务结束）。</li> <li>这种结束方式的操作很简单，通过向8259A的偶地址端口输出一个操作命令字OCW2来发EOI命令。</li></ul> <ol start="3"><li>特殊中断结束方式</li></ol> <ul><li>用这种方式结束中断时，在程序中要发一条特殊中断结束命令，指出当前中断服务寄存器ISR中的哪一位将被清除。</li> <li>它通过向8259A的偶地址端口输出一个操作命令字OCW2，其中的L2、L1、L0这三位指出了对ISR中的哪一位进行清除。</li> <li>该方式用于中断优先级顺序会改变的特殊全嵌套方式（两种优先级循环方式），无法判断ISR的哪位是当前处理的中断。</li></ul> <p>对于多片8259A级联情况，如果不是自动中断结束方式，在中断服务程序的最后需要发两次EOI命令，分别清除从片中的ISR位和主片中的ISR位。</p> <p>对于采用特殊嵌套方式的多片级联，从片中可能嵌套有多个中断源，应先向从片发EOI命令，然后读ISR，检查还有无为1的位，如无则才能向主片发EOI命令。</p> <p>这说的是人话吗（逃</p> <h5 id="_4-连接系统总线的方式"><a href="#_4-连接系统总线的方式" class="header-anchor">#</a> 4．连接系统总线的方式</h5> <ol><li>缓冲方式</li></ol> <ul><li>在很多片8259A级联的大系统中，8259A需要通过总线驱动器和数据总线相连，这就是缓冲方式。</li> <li>在缓冲方式下，8259A的SP/EN端和总线驱动器的允许端相连， SP/EN端输出的低电平可作为总线驱动器的控制信号。</li></ul> <ol start="2"><li>非缓冲方式</li></ol> <ul><li>当系统中只有单片8259A或有少量几片8259A级联时，一般将8259A直接与数据总线相连，这种方式就称为非缓冲方式。</li> <li>8259A的SP/EN端作为输入端，在单片8259A系统中， SP/EN端接高电平；在多片系统，主片的SP/EN 端接高电平，从片的SP/EN端接低电平。</li></ul> <p><img src="/images/4a2707a4c1bdc98e67c76ad4c37195dab86d0ec9fda950e5bb91a78b4bfa90d3.png" alt="8259的级联结构"></p> <h5 id="_5-中断触发方式"><a href="#_5-中断触发方式" class="header-anchor">#</a> 5．中断触发方式</h5> <ol><li>电平触发方式</li></ol> <ul><li>把中断请求输入端的高电平作为中断请求信号。这时高电平信号不能持续太久，否则一次中断请求可能会被多次响应。</li></ul> <ol start="2"><li>边沿触发方式</li></ol> <ul><li>8259A将中断请求输入端IRi出现的上升沿作为中断请求信号。该中断请求得到触发后可以一直保持高电平。</li></ul> <p>真心看不懂。</p> <h4 id="三-8259a-的初始化命令字和初始化流程"><a href="#三-8259a-的初始化命令字和初始化流程" class="header-anchor">#</a> 三. 8259A 的初始化命令字和初始化流程</h4> <p><img src="/images/0832bb47c7347d4ccfb2cea481db217f6bf577b3d65f7fa61416eff8b7b8b414.png" alt="ICW OCW"></p> <p>下面的图考试应该会给吧。应该就是依葫芦画瓢的事情了。</p> <p><img src="/images/ffdb52e18272453dd8280ee78165da7ce5ba33361c06ac77bcdf6bbd5c2b4061.png" alt="8259A 读写功能的实现"></p> <p><img src="/images/fcd0dbac702ef95c154e88914f3316095f07cbb24a18381c31739c346730843b.png" alt="ICW1"></p> <p><img src="/images/9bc9c55d0e2ceb3039d6bdbe374bbf5e8fced03bb304a7b30477d34632614d4e.png" alt="ICW2"></p> <ul><li>ICW2是用来设置中断类型码，编程时用ICW2设置中断类型码高5位T7～T3（即D7～D3），而D2～D0的值恒为零。</li> <li>中断类型码的高5位就是ICW2的高5位，而低3位是由引起中断请求的引脚IR0～IR7决定。</li> <li>例如：ICW2为20Ｈ，则8259A的IR0～IR7对应的8个中断类型码为20H、21H、22H、23H、24H、25H、26H、27H。</li></ul> <p><img src="/images/10594a4c5e787998537801052f5b60d16e5252739e7c21b73bc6bd7356585073.png" alt="ICW3"></p> <p><img src="/images/57c5d2568a2ad098c43e9e2f4f9f84a0c5568423281b7afdb12d06af3fe2c335.png" alt="ICW4"></p> <p><img src="/images/24b596157c58b430d21d66fae472123b9129985d0994485474dea076941d1b7b.png" alt="ICW4 说明"></p> <p><img src="/images/9fa97479fa1b37091ecf2b13c095a92c682367ad37b19c1049d6f7de6481e905.png" alt="ICW4 说明（续）"></p> <hr> <p>8259A 的初始化流程：</p> <p><img src="/images/59e78e045b5629fb301ed1a2dcd77b3e0d3ab062aed7cc0929a403f53423bc79.png" alt="8259A 的初始化流程"></p> <hr> <p>例题：以微型计算机中使用的单片8259A为例，试对其进行初始化设置。在微型计算机中，8259A的ICW1和ICW4的端口地址分别为20H、21H。初始化设置的程序段如下：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>MOV	 <span class="token register variable">AL</span>, <span class="token number">13H</span>  <span class="token comment">;设置ICW1（中断请求信号采用边沿触发方式；单片；后面要写ICW4）</span>
OUT	 <span class="token number">20H</span>, <span class="token register variable">AL</span>  
MOV	 <span class="token register variable">AL</span>, <span class="token number">18H</span>  <span class="token comment">;设置ICW2（将中断类型码高5位指定为00011）</span>
OUT	 <span class="token number">21H</span>, <span class="token register variable">AL</span>
MOV	 <span class="token register variable">AL</span>, <span class="token number">0DH</span>  <span class="token comment">;设置ICW4（用常规全嵌套方式；不用中断自动结束方式；采用缓冲方式；工作于8088/8086系统）</span>
OUT  <span class="token number">21H</span>, <span class="token register variable">AL</span>  
</code></pre></div><p>应该对照着表就能做叭。</p> <h4 id="四-8259a-的操作命令字"><a href="#四-8259a-的操作命令字" class="header-anchor">#</a> 四. 8259A 的操作命令字</h4> <ul><li>对8259A用初始化命令字初始化后，就进入工作状态了，准备接受IRi输入的中断请求信号。</li> <li>在8259A工作期间，可通过操作命令字（OCW）来使它按不同的方式操作。</li> <li>8259A有3个操作命令字OCW1-OCW3，没有写入顺序和时间要求，可独立使用。</li> <li>OCW1写入奇地址，OCW2和OCW3写入偶地址。</li></ul> <p><img src="/images/fdda93c01b5fae978a5c8a4a182db5ae4c7728f7f2f0fd534851b6a8ecdfed32.png" alt="OCW1"></p> <p>8259A初始化后缺省的状态是全部屏蔽位=0(允许中断)</p> <hr> <p>例：若要屏蔽IR5、IR4和IR1引脚上的中断，而让其余的中断得到允许。试确定其中断屏蔽操作命令字。</p> <p>OCW1为：<code>00110010</code> 或 <code>32H</code>。</p> <hr> <p><img src="/images/9b7b0d77ff495432cc26be3c58e9151572f932cb84ed7eddbbd9ea157bcd3032.png" alt="OCW2"></p> <p>OCW2具有发EOI命令和设置优先级循环方式的两种功能，其中101和111两种情况是结束中断后的系统方式设置。</p> <ul><li>R：优先级方式控制位。
<ul><li>1：循环优先级</li> <li>0：为固定优先级。</li></ul></li> <li>SL：指示OCW2中L2～L0位是否有效。
<ul><li>1：有效；</li> <li>0：无效。</li></ul></li> <li>EOI：在非自动中断结束方式下的中断结束命令位。
<ul><li>1：发中断结束命令，它使现行中断的ISR位复位；</li> <li>0：不发出中断结束命令。</li></ul></li> <li>L2～L0：它有两个作用。
<ul><li>(1)设定优先级特殊循环方式时初始的最低优先级序号；</li> <li>(2)在特殊中断结束命令中指明ISR的哪位被复位。</li></ul></li></ul> <hr> <p>例：若某8259A的OCW2设置为11000011B，试分析此操作命令字所确定的操作方式。</p> <p>该命令字确定8259A为优先级特殊循环（参见<a href="#2-%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%98%E5%8C%96%E6%96%B9%E5%BC%8F">优先级变化方式</a>），将IR3定为最低优先级。因此，系统中优先级从高到低为IR4、IR5、IR6、IR7、IR0、IR1、IR2、IR3。</p> <hr> <p><img src="/images/1555fc3daad6be088c8ccb56e1647df68600f84c422c0e6e8b3a7d41105b2189.png" alt="OCW3"></p> <p>有三个功能：</p> <ol><li>设置特殊中断屏蔽方式：D6D5=11为设置，10为清除.</li> <li>查询中断请求：使P=1先写到8259A，再对该地址读入，得到中断状态字节（见下图）。</li></ol> <ul><li>I=1,表示IR0~IR7中有中断请求，R2R1R0表示其中最高优先级的编号（IRi）；</li> <li>I=0，表示无中断请求产生。</li></ul> <ol start="3"><li>读8259A的状态</li></ol> <ul><li>写RR和RIS=10的OCW3到8259A，再读该地址，得到IRR的内容；</li> <li>写RR和RIS=11的OCW3到8259A，再读该地址，得到ISR的内容；</li></ul> <p><img src="/images/e9f1fb53233f9548323147f3d9ee90a8a3b490c9fd54c7073c85c50f020850fe.png" alt="中断状态字"></p> <p>如果要读IMR，只需要从奇地址端口(A0=1)读8259A即可，与OCW3无关。</p> <h4 id="五-8259a-的应用举例"><a href="#五-8259a-的应用举例" class="header-anchor">#</a> 五. 8259A 的应用举例</h4> <p>两片级联，应该不会考（）</p> <p>设两片8259A级联，提供15级向量中断，CAS2～CAS0作为互连线，从片8259A的INT直接连到主片8259A的IR2上。</p> <ul><li>端口地址，主片在020H～03FH范围内，实际使用020H和021H两个端口；从片在0A0H～0BFH范围，实际使用0A0H和0A1H两个端口。</li> <li>主、从片的中断请求信号均采用边沿触发方式。</li> <li>主片与从片采用一般全嵌套方式，优先级的排列次序为0级最高（主片的IR0），依次为1级（主片的IR1）、2级（主片的IR2，即从片的IR0 ～IR7），然后是3级～7级（主片的IR3～IR7）。</li> <li>采用非缓冲方式，主片的SP/EN端接+5V，从片的SP/EN端接地。</li> <li>设定主片的中断号为08H～0FH，从片的中断号为70H～77H。</li></ul> <p><img src="/images/1cf8570b67f28852073e2a3f8d518b8084c8bdac4e0847c9f3d3056ffdfb21ea.png" alt="两个8259A的级联图"></p> <p>对主片8259A的初始化：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>INTM00	EQU  	<span class="token number">020H</span>       		<span class="token comment">;主8259A端口0</span>
INTM01	EQU   <span class="token number">021H</span>       		<span class="token comment">;主8259A端口l</span>
……      
MOV  <span class="token register variable">AL</span>, <span class="token number">00010001B</span><span class="token comment">;ICWl;  边沿触发，要ICW4，级联方式</span>
                        ；要ICW3
OUT  INTM00, <span class="token register variable">AL</span>
JMP  SHORT <span class="token operator">$</span><span class="token operator">+</span><span class="token number">2</span> <span class="token comment">;延迟=该指令的执行时间，$+2是下条指令</span>
MOV <span class="token register variable">AL</span>, <span class="token number">00001000B</span>	 <span class="token comment">;ICW2：设置主片的中断向量，起始</span>
                      <span class="token comment">;的中断向量为08H</span>
OUT INTM01, <span class="token register variable">AL</span>
JMP  SHORT <span class="token operator">$</span><span class="token operator">+</span><span class="token number">2</span>
MOV  <span class="token register variable">AL</span>, <span class="token number">00000100B</span>  <span class="token comment">;ICW3：主片的IR2接从片8259A的INT  			</span>

OUT  	INTM01, <span class="token register variable">AL</span>
JMP 	SHORT<span class="token operator">$</span><span class="token operator">+</span><span class="token number">2</span>
MOV 	<span class="token register variable">AL</span>, <span class="token number">00000001B</span>   <span class="token comment">;ICW4：非总线缓冲，常规全嵌套，</span>
                  <span class="token comment">;正常结束中断方式</span>
OUT  	INTM01, <span class="token register variable">AL</span>
JMP  	SHORT<span class="token operator">$</span><span class="token operator">+</span><span class="token number">2</span>
</code></pre></div><p>对从片8259A的初始化：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>INTS00  EQU  	<span class="token number">0A0H</span>       <span class="token comment">;从片8259A端口0</span>
INTS01  EQU  	<span class="token number">0A1H</span>       <span class="token comment">;从片8259A端口1</span>
MOV 	<span class="token register variable">AL</span>, 0001000lB	    <span class="token comment">;ICWl：边沿触发，要ICW4；</span>
                        <span class="token comment">;级联方式，要ICW3</span>
OUT 	INTS00, <span class="token register variable">Al</span>

JMP 	SHORT  <span class="token operator">$</span><span class="token operator">+</span><span class="token number">2</span>
MOV 	<span class="token register variable">AL</span>, <span class="token number">01110000B</span> 	<span class="token comment">;ICW2：设置从片的中断向量，</span>
                        ；起始的中断向量为<span class="token number">70H</span>
OUT 	INTS01, <span class="token register variable">AL</span>
JMP 	SHORT  <span class="token operator">$</span><span class="token operator">+</span><span class="token number">2</span>
MOV	<span class="token register variable">AL</span>, <span class="token number">00000010B</span> 	<span class="token comment">;ICW3，设置从片的识别标志，</span>
                        ；即指定连接主片的IR2
OUT 	INTS01, <span class="token register variable">AL</span>
JMP 	SHORT  <span class="token operator">$</span><span class="token operator">+</span><span class="token number">2</span>
MOV 	<span class="token register variable">AL</span>, <span class="token number">00000001B</span>  <span class="token comment">;ICW4：非总线缓冲，常规全嵌套，</span>
                      ；正常结束中断方式
OUT 	INTS01, <span class="token register variable">AL</span>
JMP 	SHORT  <span class="token operator">$</span><span class="token operator">+</span><span class="token number">2</span>
</code></pre></div><div class="language-nasm extra-class"><pre class="language-nasm"><code>MY_INT PROC FAR
PUSH  <span class="token register variable">AX</span>
PUSH  <span class="token register variable">BX</span>
….
STI
<span class="token operator">&lt;</span>中断服务程序主体<span class="token operator">&gt;</span>
CLI
….
POP  <span class="token register variable">BX</span>
POP  <span class="token register variable">AX</span>
MOV <span class="token register variable">AL</span>, <span class="token number">20H</span>	<span class="token comment">; 用OCW2写EOI 命令  ， 00100000B</span>
OUT  A0H, <span class="token register variable">AL</span>  <span class="token comment">;向从片发EOI命令</span>
MOV <span class="token register variable">AL</span>, <span class="token number">20H</span>
OUT <span class="token number">20H</span>, <span class="token register variable">AL</span>   <span class="token comment">; 向主片发EOI命令</span>
IRET	
MY_INT ENDP
CLI 
PUSH <span class="token register variable">DS</span>
XOR <span class="token register variable">AX</span>, <span class="token register variable">AX</span>
MOV <span class="token register variable">DS</span>, <span class="token register variable">AX</span>
MOV <span class="token register variable">BX</span>,  n   <span class="token comment">;  中断类型号</span>
MOV <span class="token register variable">CL</span>,<span class="token number">2</span>
SHL <span class="token register variable">BX</span>, <span class="token register variable">CL</span>   <span class="token comment">;向量表偏移地址=nX4</span>
MOV <span class="token register variable">AX</span>,  OFFSET MY_INT
MOV <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">]</span>,  <span class="token register variable">AX</span>
MOV <span class="token register variable">AX</span>,  SEG MY_INT
MOV <span class="token operator">[</span><span class="token register variable">BX</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">]</span>, <span class="token register variable">AX</span>
POP <span class="token register variable">DS</span>
<span class="token comment">;按上述方法设置用户的各个中断向量</span>
STI
</code></pre></div><h2 id="第七章-常用数字接口电路"><a href="#第七章-常用数字接口电路" class="header-anchor">#</a> 第七章 常用数字接口电路</h2> <h3 id="_7-1-并行通信与串行通信"><a href="#_7-1-并行通信与串行通信" class="header-anchor">#</a> 7.1 并行通信与串行通信</h3> <h4 id="_1-并行通信"><a href="#_1-并行通信" class="header-anchor">#</a> 1. 并行通信</h4> <ul><li>定义：能同时传送一个数据的所有位。</li> <li>一个数据的位数可以是字节或字长。
两个设备之间有必须有多条数据传输线，才能实现多位数据同时传输。</li></ul> <p><img src="/images/b6b7c0640acaf5f2865d6e395e159cff931f799747ccf83bd1e4e8013825259b.png" alt="并行通信"></p> <ul><li>并行方式主要用于近距离通信，如计算机内的总线结构</li> <li>并行通信有简单接口和可编程接口</li> <li>特点：
<ul><li>传输速度快，处理简单；</li> <li>适合近距离传送；</li> <li>所传送信息无固定格式要求。</li></ul></li></ul> <h4 id="_2-串行通信"><a href="#_2-串行通信" class="header-anchor">#</a> 2. 串行通信</h4> <ul><li>定义：数据逐位顺序传送。</li> <li>数据一位一位通过同一通信线进行传输。
<ul><li>发送设备将几位并行数据转换成串行方式，再逐位传输到接收设备。在接收端将数据从串行方式转换成并行方式。</li></ul></li></ul> <p><img src="/images/2a4458a1b84c4f8fcdfbde7486d0fa1276f9e7c90364d2db35ddf1355d1fdd35.png" alt="串行通信"></p> <ul><li>数据传送方式：
<ol><li>双工：两根数据传输线，能够同时发送和接收</li> <li>半双工：单根数据传输线，不能同时发送和接收</li> <li>单工：单根数据传输线只用作发送或只用作接收</li></ol></li> <li>通信方式：
<ol><li>同步通信：通信时，发送方和接收方的时钟频率和相位保持一致，收发双方采用同一个时钟信号来定时。每两个字符间的时间间隔固定。</li> <li>异步通信：收发双方没有统一的时钟来定时和同步，每两个字符间的时间间隔不固定。</li></ol></li> <li>传输速率：
<ul><li>在通讯中，用波特率来描述数据的传输速率。即每秒钟传送的二进制位数，简写为bps。</li></ul></li></ul> <h3 id="_7-2-可编程计数-定时器芯片-8253"><a href="#_7-2-可编程计数-定时器芯片-8253" class="header-anchor">#</a> 7.2 可编程计数/定时器芯片 8253</h3> <ul><li>定时/计数器的应用
<ul><li>生产线上统计产品的数目----计数器</li> <li>系统的动态存储器刷新----定时器</li> <li>系统时钟计时----定时器</li> <li>扬声器的频率源----定时器</li></ul></li> <li>常用的定时方法
<ol><li>软件定时：优点是节省硬件；缺点是执行程序期间CPU一直被占用，降低了CPU效率</li> <li>硬件定时：要用额外的硬件—计数/定时器，但可提高CPU的利用率</li></ol></li></ul> <h4 id="_8253-基本功能"><a href="#_8253-基本功能" class="header-anchor">#</a> 8253 基本功能</h4> <ol><li>具有三个相互独立的16位计数器，也叫通道。</li> <li>每个通道都可设定以6种工作方式之一进行计数/定时</li> <li>每个计数器都可设为按二进制或BCD码计数</li> <li>具有计数和定时功能，都是基于减1计数方式工作。</li> <li>计数器减为0后，产生输出信号，有的方式可自动装入初值重新计数。</li> <li>在减1过程中，随时都可由CPU读取计数器的当前值。</li></ol> <h4 id="_8253-结构"><a href="#_8253-结构" class="header-anchor">#</a> 8253 结构</h4> <p><img src="/images/8cc719731655e54e5ea589c8149e11bada97c985afb9fdeeb83fbfce8bd216fb.png" alt="8253 引脚"></p> <p><img src="/images/968f9655843f8cefa1c2eb3abc9b95f7295f4c5c1c99b4ab3b5896c4f1dcae63.png" alt="8253 接口"></p> <p><img src="/images/5896bdcb2843f84b54205eeccf61bb203fb713637a21f39e0ee67f9f9a64c1ea.png" alt="8253 寄存器选择表"></p> <p><img src="/images/19f479c2400bf7fdf5d1c581a81739c64d8ae91ed722757b12c534d898c2fb9d.png" alt="8253 内部结构"></p> <p><img src="/images/7ee8fc8e7c5fbc138e851ec1766e974f433bfa94d9a39ce81e28553a98f3f6a7.png" alt="各计数器的内部结构"></p> <h4 id="_8253的控制字"><a href="#_8253的控制字" class="header-anchor">#</a> 8253的控制字</h4> <p>8253工作前需要通过控制字进行设置，每个计数器（通道）都要单独写控制字，端口地址都为同一个地址。</p> <p><img src="/images/b04c0eb276ab85b67e30235cb00322db18e3b4368d6d4310e98b1cec294a0535.png" alt="8253的控制字"></p> <p>似乎挺好理解的，比 8259 的控制字好理解多了。</p> <p><s>虽然我还是不会背</s></p> <h4 id="_8253的工作方式"><a href="#_8253的工作方式" class="header-anchor">#</a> 8253的工作方式</h4> <p>8253共有6种工作方式：方式0~方式5。</p> <p>8253各工作方式的共同点：</p> <ol><li><strong>控制字写入</strong>计数器时，所有控制逻辑立即复位，输出端OUT进入初始态；</li> <li><strong>写入计数初值</strong>后，要经过一个时钟周期后计数器才开始计数；</li> <li>在时钟脉冲<strong>CLK的上升沿</strong>门控信号GATE被采样；</li> <li>计数器的计数时间点是<strong>CLK的下降沿</strong>。</li></ol> <h5 id="方式0-计数结束中断"><a href="#方式0-计数结束中断" class="header-anchor">#</a> 方式0—计数结束中断</h5> <p>下面六个方式，主要是看图说话，图比字形象的多。</p> <p><img src="/images/474e1c2a0a6d2a9e2c4d2b01a19ed3b0ff7c822840683a17de8c996d6eea8923.png" alt="方式0—计数结束中断"></p> <ul><li>写入控制字后OUT变低；</li> <li>写入计数初值后的一个CLK的下降沿，计数初值被装入计数器，然后在每个CLK的下降沿做减1计数；</li> <li>当计数到0时OUT输出变为高电平；</li> <li>GATE为高电平时，计数器工作，为低电平时停止计数；
在计数过程中若重新写了新的计数初值，则按新值重新工作；
每写一次计数初值只计数一个周期。</li></ul> <h5 id="方式1-可重复触发的单稳态触发器-硬件触发"><a href="#方式1-可重复触发的单稳态触发器-硬件触发" class="header-anchor">#</a> 方式1—可重复触发的单稳态触发器(硬件触发)</h5> <p><img src="/images/ce7a3bb46843012d3c284b292afd39619353c25a84fbac23ec16088a268cb34e.png" alt="方式1—可重复触发的单稳态触发器(硬件触发)"></p> <ul><li>写入控制字后，OUT变为高电平；</li> <li>写入计数初值后，当GATE从低变高后的一个CLK下降沿装入初值，OUT变为低。然后对每个CLK下降沿做减1计数，计到0时OUT变高。</li> <li>若计数结束后GATE又出现上跳，则重新装入计数初值，重新开始计数。</li> <li>若计数过程中GATE又出现上跳，则重新装入计数初值，重新开始计数，本次OUT周期宽度加长。</li> <li>负脉冲宽度=计数初值 X CLK周期。</li></ul> <h5 id="方式2-频率发生器-软件或硬件触发"><a href="#方式2-频率发生器-软件或硬件触发" class="header-anchor">#</a> 方式2—频率发生器(软件或硬件触发)</h5> <p><img src="/images/f21c06a9019be19a3fcb586d252826ab6bcc1f90d6667c19d0faac866da6a86b.png" alt="方式2—频率发生器(软件或硬件触发)"></p> <p>软件触发：保持GATE为高</p> <ul><li>写控制字后，OUT变为高电平；</li> <li>写计数初值后的一个CLK的下降沿，初值被装入计数器，然后对每个CLK的下降沿减1计数；</li> <li>计数期间OUT保持为高，当计数到1时OUT输出宽度为1个CLK周期的负脉冲，然后重新装入计数初值开始计数。</li> <li>若计数中重写计数初值，则下次计数周期才会以新值开始计数。</li></ul> <p>硬件触发：写控制字和计数初值时GATE为低，当其变高后的下一个CLK下降沿计数器装入初值，后面每个CLK下降沿计数。</p> <ul><li>方式2为自动装入计数初值的重复计数器。</li></ul> <h5 id="方式3-方波发生器-软件或硬件触发"><a href="#方式3-方波发生器-软件或硬件触发" class="header-anchor">#</a> 方式3—方波发生器(软件或硬件触发)</h5> <p><img src="/images/37fb5eb71893b0d4363d92ea8d1740e0ded7d0696570548e3f94339a65f150dc.png" alt="方式3—方波发生器(软件或硬件触发)"></p> <ul><li>方式3与方式2相似，只是OUT输出是一个占空比为1:1的方波；</li> <li>若计数初值为偶数，则OUT输出是高低电平对称的方波；</li> <li>若计数初值为奇数，则OUT输出不对称，前面的高比后面的低多1个CLK周期，即近似方波。</li> <li>方式3与方式2一样也可由硬件触发，即GATE从低变高后启动。</li></ul> <h5 id="方式4-软件触发选通"><a href="#方式4-软件触发选通" class="header-anchor">#</a> 方式4—软件触发选通</h5> <p><img src="/images/fe1483f12d2e5c621a9b92a056a13b813fabcf6b9084f09c8a93d39129bdd851.png" alt="方式4—软件触发选通"></p> <ul><li>写入控制字输出变高，写入计数值后的一个CLK下降沿装入初值，然后对每个CLK下降沿计数；</li> <li>计数到0时输出1个CLK周期宽度的负脉冲；</li> <li>若计数中重写计数初值，则下一个CLK下降沿被装入，然后按此初值计数；</li> <li>若计数中GATE变低将停止计数，当其变高时继续计数；</li> <li>计数初值一次写入只计数一个周期，类似软件触发的方式2的一个周期，但负脉冲的出现会延后一个周期。</li></ul> <h5 id="方式5-硬件触发选通"><a href="#方式5-硬件触发选通" class="header-anchor">#</a> 方式5—硬件触发选通</h5> <p><img src="/images/accbf435d0c3cf13e70d2eab971616880334fdf3447da3d464f3dcdf5678d76f.png" alt="方式5—硬件触发选通"></p> <ul><li>写入控制字后，OUT变高；</li> <li>写入计数值后，当GATE出现上升沿后的一个CLK下降沿装入初值，然后对每个CLK下降沿计数，计数到0时OUT输出一个CLK周期的负脉冲。</li> <li>在计数中若GATE变低后再变高，将重新启动一次计数周期。</li> <li>在计数中若写入新计数值，本次计数周期不受影响。</li> <li>一次GATE触发只计数一个周期，即类似硬件触发的方式2的一个周期，但负脉冲的出现会延后一个周期。</li></ul> <h5 id="方式比较"><a href="#方式比较" class="header-anchor">#</a> 方式比较</h5> <p><img src="/images/1cf44d8287c38ddeaff473dafc7fb1dc483b8b09ca79ce83e15696e8a3f78242.png" alt="方式 0 与方式 4 的比较（软件控制）"></p> <p><img src="/images/6781e42d4900e765e930ef5cb0e8727759f6c3c6d65ce2af52a3b08bcbceae58.png" alt="方式 1 与方式 5 的比较（硬件触发）"></p> <p><img src="/images/96dc459b6ac1791f5e1273b6fb0773a6cde62452ee582e6b47b153efd6053b16.png" alt="方式 2 与方式 3 的比较（连续波形输出）"></p> <p><img src="/images/707e732ca94dba7bee0f31570c33b44a2011815699d5d01d62d567a7197dd8a3.png" alt="方式 4 与方式 5 的比较（非连续的单脉冲输出）"></p> <h5 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h5> <ul><li>8253的六种工作方式中有软件启动和硬件启动：
<ul><li>软件启动：写入控制字及初值后的第一个CLK下降沿装入初值，下一个CLK下降沿开始减1计数。有方式0，2，3，4。</li> <li>硬件启动：写入控制字及初值后的一个GATE信号上升沿后的第一个CLK下降沿装入初值，下一个CLK下降沿开始计数。有方式1，2，3和5。</li> <li>其中方式2和方式3既可软件启动，也可硬件启动。</li></ul></li> <li>8253工作方式分为连续波形和非连续波形输出：
<ul><li>连续波形输出：一次启动后，计数到0时则自动装入初值循环工作。有方式2，3</li> <li>非连续波形输出：一次启动后，计数到0后则结束。有方式0，1，4，5</li></ul></li></ul> <table><thead><tr><th style="text-align:center;">方式0—计数结束中断</th> <th style="text-align:center;">方式1—可重复触发的单稳态触发器(硬件触发)</th> <th style="text-align:center;">方式2—频率发生器(软件或硬件触发)</th></tr></thead> <tbody><tr><td style="text-align:center;"><img src="/images/474e1c2a0a6d2a9e2c4d2b01a19ed3b0ff7c822840683a17de8c996d6eea8923.png"></td> <td style="text-align:center;"><img src="/images/ce7a3bb46843012d3c284b292afd39619353c25a84fbac23ec16088a268cb34e.png"></td> <td style="text-align:center;"><img src="/images/f21c06a9019be19a3fcb586d252826ab6bcc1f90d6667c19d0faac866da6a86b.png"></td></tr> <tr><td style="text-align:center;">方式3—方波发生器(软件或硬件触发)</td> <td style="text-align:center;">方式4—软件触发选通</td> <td style="text-align:center;">方式5—硬件触发选通</td></tr> <tr><td style="text-align:center;"><img src="/images/37fb5eb71893b0d4363d92ea8d1740e0ded7d0696570548e3f94339a65f150dc.png"></td> <td style="text-align:center;"><img src="/images/fe1483f12d2e5c621a9b92a056a13b813fabcf6b9084f09c8a93d39129bdd851.png"></td> <td style="text-align:center;"><img src="/images/accbf435d0c3cf13e70d2eab971616880334fdf3447da3d464f3dcdf5678d76f.png"></td></tr></tbody></table> <h4 id="_8253-的初始化编程"><a href="#_8253-的初始化编程" class="header-anchor">#</a> 8253 的初始化编程</h4> <p>下面这段话很重要！</p> <p>初始化编程的顺序为：</p> <ol><li><strong>对某一指定计数器，先写入控制字，再写入计数初始值。</strong></li> <li><strong>计数初值写入的格式和顺序必须按控制字D5和D4规定的格式写入。</strong></li></ol> <p><strong>注意：所有通道的控制字都写入同一个控制端口，而计数初值则要写入指定计数器对应的端口。</strong></p> <p>可以结合下面的例子食用：</p> <p><img src="/images/3bd7528842be30ed97afebe4f0d631275bd9e5ddb288beecb2894f5cf32b2c72.png" alt="例 1"></p> <p><img src="/images/8e4827fcc36dd73213b652b6fa74b971e71c1fd365482a7a1c7ee2d37b92c7eb.png" alt="例 2"></p> <p><img src="/images/ded3aed010c78f1c96bd23c11b8dedaccb363c1233bafef183ef29ca305e2796.png" alt="例 3"></p> <p><img src="/images/748d56cc43db130ff89a326a7576d6c442c13446c68bac92c1d04aaa9622f5b9.png" alt="例 4-1"></p> <p><img src="/images/2dac4649fc71476249a1ef7b45a0f9ea5f0db1acb7d41c81fc7faebb33038666.png" alt="例 4-2"></p> <p><img src="/images/446b4449f4ea40dd4116b692de48605816c5b5e9485c7c5f94293f902147d734.png" alt="例 4-3"></p> <p><img src="/images/18cee96eecea92ecf8e52e9b2376530266cb4dfacc2369eb44a5728592ae1fd9.png" alt="例 4-4"></p> <p>更复杂的例子就不一贴出了。</p> <h2 id="考试重点"><a href="#考试重点" class="header-anchor">#</a> 考试重点</h2> <p>编一个小的接口应用程序</p> <p>8253 8255 8259（内容有点多，但考试不会考太难）考工作方式、工作模式，不会设计</p> <p>8253 定时计数器
8255 应用题</p> <p>给一组数，找非零数的个数，15 分，框架 12 分</p> <hr> <p>不考的内容（已经老师确认）
1.第五章存储器系统
2.第六章8237
3.第七章8251</p> <h2 id="错题"><a href="#错题" class="header-anchor">#</a> 错题</h2> <h3 id="三四章"><a href="#三四章" class="header-anchor">#</a> 三四章</h3> <ol><li>对段寄存器CS的装入方式有(    234         ).
(1)使用MOV指令
(2) 使用段间转移指令
(3)使用段间子程序调用指令
(4)使用END伪指令</li></ol> <h3 id="rcr-填空题"><a href="#rcr-填空题" class="header-anchor">#</a> RCR 填空题</h3> <p>1．	设 (BX)=0C49CH, (CX)=0F002H</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>ROL  <span class="token register variable">BX</span>, <span class="token register variable">CL</span>
XOR  <span class="token register variable">BH</span>, <span class="token register variable">CH</span>
RCR  <span class="token register variable">BX</span>, <span class="token register variable">CL</span>
</code></pre></div><p>上述指令序列执行后，(BX)=() ,CF=()</p> <hr> <p>一定看清 <code>0F</code> 开头的，第一位是 <code>0</code> 还是 <code>F</code>！上面两个都应该是字母开头。</p> <p>答案是 (BX)=<code>0B89C</code> ,CF=<code>1</code></p> <h3 id="编程题"><a href="#编程题" class="header-anchor">#</a> 编程题</h3> <p>试编制一完整源程序，将一个字符串（只包含有字母和数字符）中的小写字母转换为大写，数字符转换成其对应的二进制值。各字符转换后的内容仍然存放在原来的单元中。已知A的ASCII码为41H，a的ASCII码为61H。字符串的定义如下：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA  SEGMENT
      STRING  DB  <span class="token string">'BTe3F5…….'</span>
DATA  ENDS
</code></pre></div><div class="language-nasm extra-class"><pre class="language-nasm"><code>DATA    SEGMENT
        STRING  DB  <span class="token string">'BTe3F5…….'</span>
        LEN     EQU <span class="token operator">$</span><span class="token operator">-</span>STRING
DATA    ENDS

STACK1  SEGMENG STACK
        DW  <span class="token number">20H</span> DUP(?)
STACK1  ENDS

CODE    SEGMENT
        ASSUME <span class="token register variable">CS</span>:CODE, <span class="token register variable">SS</span>:STACK1, <span class="token register variable">DS</span>:DATA
<span class="token label function">START:</span>  MOV <span class="token register variable">AX</span>, DATA
        MOV <span class="token register variable">DS</span>, <span class="token register variable">AX</span>
        MOV <span class="token register variable">CX</span>, LEN
        LEA <span class="token register variable">SI</span>, STRING
<span class="token label function">LOP:</span>    MOV <span class="token register variable">AL</span>, <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>
        CMP <span class="token register variable">AL</span>, <span class="token string">'a'</span>
        JGE LITTLE1
        CMP <span class="token register variable">AL</span>, <span class="token string">'9'</span>
        JLE NUMBER1
        JMP NEXT2
<span class="token label function">LITTLE1:</span>SUB <span class="token register variable">AL</span>, <span class="token string">'a'</span><span class="token operator">-</span><span class="token string">'A'</span>
        JMP NEXT1
<span class="token label function">NUMBER1:</span>SUB <span class="token register variable">AL</span>, <span class="token string">'0'</span>
<span class="token label function">NEXT1:</span>  MOV <span class="token operator">[</span><span class="token register variable">SI</span><span class="token operator">]</span>, <span class="token register variable">AL</span>
<span class="token label function">NEXT:</span><span class="token number">2</span>  INC <span class="token register variable">SI</span>
        LOOP LOP
        HLT
CODE    ENDS
        END START
</code></pre></div><h3 id="六七八章-接口部分"><a href="#六七八章-接口部分" class="header-anchor">#</a> 六七八章 接口部分</h3> <ol><li>8086/8088复位后，初始化执行的物理地址是 <code>0FFFF0H</code></li> <li>当中断处理程序准备执行第一条指令时，<code>IF=0, TF=0</code></li> <li>8259A中，特殊全嵌套优先级方式一般用于 <code>多片8259A中的主片中</code></li> <li>DAC0803工作在 <code>两级缓存</code> 方式下时，可在转换输出模拟信号的同时可接收下一个数字信号</li> <li>IRET指令会向8259A发送EOI信息，以结束当前的中断 <code>×</code></li> <li>8086/8088中地址引脚与其它信号复用，所以地址信息需要锁存 <code>√</code></li> <li>8255A中的端口C置1/0方式使得端口C适合配合端口A、B做控制位使用。<code>√</code></li> <li>是否响应软件指令INT引发的中断受IF位的影响。<code>×</code></li> <li>CPU和外设之间的数据传送方式有 <code>无条件传送</code>、<code>查询方式</code>、<code>中断方式</code>、<code>DMA方式</code></li> <li>硬件中断分为 <code>可屏蔽中断</code>、<code>非屏蔽中断</code></li> <li>8259A工作的优先级方式有<code>全嵌套</code>、<code>特殊嵌套</code>、优<code>先级自动循环</code>、<code>优先级特殊循环</code></li></ol> <h2 id="后记"><a href="#后记" class="header-anchor">#</a> 后记</h2> <p>最后考试考了很多的原题。选填题全是前四章的内容，简单题是前四章和后三章各一半，最后解答题一个是前四章的，三个是接口部分，其中两个是老师发的练习题的原题/简化。</p> <p>隔壁网安就乱划重点 + 没有原题。表扬一下汇编。</p></div> <hr role="separator" aria-orientation="horizontal" class="ma-4 v-divider theme--light"> <div data-v-5794ffe6><script src="https://giscus.app/client.js" async="async" service="giscus" data-repo="lyh543/blog-comments" data-repo-id="R_kgDOHIb2Zg" data-category="Announcements" data-category-id="DIC_kwDOHIb2Zs4COh2z" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" data-v-5794ffe6></script></div></div></div></article></div> <!----></div></div> <div class="v-dialog__container"><button type="button" role="button" aria-haspopup="true" aria-expanded="false" class="v-btn v-btn--bottom v-btn--is-elevated v-btn--fab v-btn--fixed v-btn--has-bg v-btn--right v-btn--round theme--dark v-size--default primary"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-information-variant theme--dark"></i></span></button><!----></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2024</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0113cb43.js" defer></script><script src="/assets/js/31.26e285be.js" defer></script>
  </body>
</html>
