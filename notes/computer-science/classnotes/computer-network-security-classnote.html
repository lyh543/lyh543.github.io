<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络安全 课程笔记 | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/theme/favicon.png">
    <link rel="alternate" type="application/rss+xml" href="https://blog.lyh543.cn/rss.xml" title="小灰灰灰灰的博客 RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://blog.lyh543.cn/feed.atom" title="小灰灰灰灰的博客 Atom Feed">
    <link rel="alternate" type="application/json" href="https://blog.lyh543.cn/feed.json" title="小灰灰灰灰的博客 JSON Feed">
    <meta name="description" content="
什么是信息
什么是信息安全

信息是对事物不确定性的度量，并进而采用信息量来描述信息。

信息安全是保证信息的基本属性所需的全面的管理
规程和控制。

信息安全的基本属性

完整性
可用性
机密性
可靠性
不可抵赖性

信息安全服务

认证
访问控制
数据保密
数据完整性
非否认

安全机制

加密
数字签名 ...">
    
    <link rel="preload" href="/assets/css/0.styles.94ecd5c7.css" as="style"><link rel="preload" href="/assets/js/app.ba06a0b0.js" as="script"><link rel="preload" href="/assets/js/35.48ba4f1f.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.94ecd5c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><div class="container"><div class="row justify-center"><div class="col-sm-9 col-12"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><div class="v-card v-sheet theme--light"><div class="container"><div itemprop="articleBody" class="markdown-body content__default"><h2 id="第一章-信息安全概述"><a href="#第一章-信息安全概述" class="header-anchor">#</a> 第一章 信息安全概述</h2> <h3 id="什么是信息"><a href="#什么是信息" class="header-anchor">#</a> 什么是信息</h3> <ul><li>什么是信息安全</li></ul> <p>信息是对事物不确定性的度量，并进而采用信息量来描述信息。</p> <p>信息安全是保证信息的基本属性所需的全面的管理</p> <ul><li>规程和控制。</li></ul> <h3 id="信息安全的基本属性"><a href="#信息安全的基本属性" class="header-anchor">#</a> 信息安全的基本属性</h3> <ul><li>完整性</li> <li>可用性</li> <li>机密性</li> <li>可靠性</li> <li>不可抵赖性</li></ul> <h3 id="信息安全服务"><a href="#信息安全服务" class="header-anchor">#</a> 信息安全服务</h3> <ul><li>认证</li> <li>访问控制</li> <li>数据保密</li> <li>数据完整性</li> <li>非否认</li></ul> <h3 id="安全机制"><a href="#安全机制" class="header-anchor">#</a> 安全机制</h3> <p>加密</p> <ul><li>数字签名</li> <li>访问控制</li> <li>数据完整性</li> <li>认证交换机制</li> <li>业务填充机制（发送额外数据掩盖正常通信）</li> <li>路由控制</li> <li>公正（可信第三方）</li></ul> <h3 id="安全服务与安全机制的关系"><a href="#安全服务与安全机制的关系" class="header-anchor">#</a> 安全服务与安全机制的关系</h3> <p>安全服务是由安全机制来实现的；一种安全机制可以实现一种或者多种安全服务；一种安全服务可以由一种或者多种安全机制来实现。</p> <p><img src="/images/8edaa57c3948c8b3728994ab744a550f45359320c0bf30c93ee28376ab99171b.png" alt="安全服务与安全机制的关系"></p> <h3 id="安全威胁与攻击"><a href="#安全威胁与攻击" class="header-anchor">#</a> 安全威胁与攻击</h3> <ul><li>被动攻击（未经许可泄露信息但不修改，不容易被检测）</li> <li>主动攻击（数据篡改、虚假流的产生，如重放攻击、DoS）</li> <li>物理访问攻击</li> <li>内部人员攻击</li> <li>软硬件配装攻击</li></ul> <h2 id="第二章-网络接口层协议的安全威胁"><a href="#第二章-网络接口层协议的安全威胁" class="header-anchor">#</a> 第二章 网络接口层协议的安全威胁</h2> <h3 id="osi-参考模型"><a href="#osi-参考模型" class="header-anchor">#</a> OSI 参考模型</h3> <p>OSI 参考模型的七层，即是将 TCP/IP 中的应用层细分为（自底向上）会话层、表示层、应用层。</p> <p><img src="/images/978f649de87b3e8f06001047f227bffd0c239c0192745900f573eba9f965670c.png" alt="OSI 参考模型"></p> <h3 id="网络接口层的安全威胁"><a href="#网络接口层的安全威胁" class="header-anchor">#</a> 网络接口层的安全威胁</h3> <p>攻击原理：窃听。</p> <p>原因：集线器、交换机物理功能（集线器重新生成该信号，并广播给所有接口；如果帧的目的 MAC 地址是 <code>FF-FF-FF-FF-FF-FF</code> 或在交换机表中查不到对应的表项，则广播该帧）</p> <h3 id="arp-协议的安全威胁"><a href="#arp-协议的安全威胁" class="header-anchor">#</a> ARP 协议的安全威胁</h3> <p>攻击原理：如果我们冒充网关主机 C，不停的向以太网发送自己的 ARP 广播包，告知自己的 IP-MAC ，此时其它主机就会被欺骗，更新我们 C 的 IP-MAC 为网关主机的 IP-MAC ，那么其它主机的数据包就会发送到 C 主机上，因为没有发给真正的网关，就会造成其它主机的网络中断</p> <p>原因：ARP 协议信任以太网所有的节点，效率高但是不安全。<br>
这份协议没有其它字协议来保证以太网内部信息传输的安全，它不会检查自己是否接受或发送过请求包，只要它就收到的 ARP 广播包，他就会把对应的 IP-MAC 更新到自己的缓存表。</p> <h3 id="ip-协议的安全威胁"><a href="#ip-协议的安全威胁" class="header-anchor">#</a> IP 协议的安全威胁</h3> <h4 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="header-anchor">#</a> 拒绝服务攻击</h4> <p>避免被追踪而受到惩罚，构造针对同一目的 IP 地址的 IP 分组，而源 IP 地址为随机的 IP地址</p> <p>原因：IP 协议并不能对 IP 数据报中的源 IP 的真实性进行验证，导致任意节点可以构造 IP 数据报，其源 IP 并非该节点的真实 IP。该假冒 IP 分组仍能顺利达到目的结点，即 IP 假冒攻击。</p> <h4 id="对链路层和-ip-层攻击的本质是什么"><a href="#对链路层和-ip-层攻击的本质是什么" class="header-anchor">#</a> 对链路层和 IP 层攻击的本质是什么</h4> <p>没有验证发送者的身份。</p> <h3 id="tcp-协议的安全威胁"><a href="#tcp-协议的安全威胁" class="header-anchor">#</a> TCP 协议的安全威胁</h3> <p>TCP 原理略。</p> <h4 id="syn-flooding"><a href="#syn-flooding" class="header-anchor">#</a> SYN Flooding</h4> <p>原因：当客户端请求服务器时，客户端发起一个TCP SYN包，服务器端接收到该请求后，如果能够响应该请求，即回复一个TCP ACK SYN包，同时分配相应的资源记录客户请求信息，然后等待客户端的ACK包，以便完成“三次握手”过程。</p> <p>攻击方式：客户端可以不理会服务器端的 TCP ACK SYN 包，而是继续发送假冒的 TCP SYN 包，在没有超时之前服务器端都会分配资源保持客户端请求的状态信息。</p> <h4 id="ack-flooding"><a href="#ack-flooding" class="header-anchor">#</a> ACK Flooding</h4> <p>原因：在TCP连接建立之后，所有的数据传输TCP报文都是带有ACK标志位的，主机在接收到一个带有ACK标志位的数据包时，需要检查该数据包所标识的连接四元组是否存在，如果存在则检查该数据包所标识的状态是否合法，然后再向应用层传递该数据包。</p> <p>攻击方式：攻击者一定要用大流量ACK小包冲击才会对服务器造成影响。随机源IP的ACK小包应该会被服务器很快丢弃，因为在服务器的TCP堆栈中没有这些ACK包的状态信息。</p> <h4 id="序列号预测攻击"><a href="#序列号预测攻击" class="header-anchor">#</a> 序列号预测攻击</h4> <p>原因：TCP 端口号和序列号是接收方判断数据包是否为所需数据包的主要依据。</p> <p>攻击方式：如果这两个因素都能被攻击者确定，那么攻击者可以构造一个TCP包发送出去并被接收方接受。<br>
如果所构造的TCP包里包含的内容或者所设置的标志位并非发送方的后续行为，则形成攻击。</p> <h4 id="land-攻击"><a href="#land-攻击" class="header-anchor">#</a> LAND 攻击</h4> <p>攻击方式：构造特殊 TCP SYN 包，该包的目的地址和源地址均为目的主机，结果被攻击主机又发回ACK消息并创建一个空连接，每一个这样的连接都将保持到超时为止，从而导致目的主机连续地自我响应。</p> <p>原因：操作系统的设计缺陷，现已基本消除。</p> <h3 id="udp-协议的安全威胁"><a href="#udp-协议的安全威胁" class="header-anchor">#</a> UDP 协议的安全威胁</h3> <h4 id="udp-假冒"><a href="#udp-假冒" class="header-anchor">#</a> UDP 假冒</h4> <p>攻击者假冒客户端向客户端发出请求。</p> <h4 id="udp-劫持"><a href="#udp-劫持" class="header-anchor">#</a> UDP 劫持</h4> <p>攻击者假冒服务器向客户端发出 UDP 应答。</p> <h3 id="dns-协议安全威胁"><a href="#dns-协议安全威胁" class="header-anchor">#</a> DNS 协议安全威胁</h3> <p>根源为：DNS 是建立在 UDP 上的服务，且没有进一步的验证端主机身份的步骤，也是无连接、不可靠的。</p> <h4 id="ddos"><a href="#ddos" class="header-anchor">#</a> DDoS</h4> <p>分布式拒绝服务攻击 (DDoS) 是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施拒绝服务攻击。</p> <h4 id="缓存投毒"><a href="#缓存投毒" class="header-anchor">#</a> 缓存投毒</h4> <p>攻击者仿冒权威名字服务器向缓存 DNS 服务器发送伪造应答包，力争抢先完成应答以污染 DNS 缓存。</p> <h4 id="域名劫持"><a href="#域名劫持" class="header-anchor">#</a> 域名劫持</h4> <p>在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。</p> <h3 id="http-协议安全威胁"><a href="#http-协议安全威胁" class="header-anchor">#</a> HTTP 协议安全威胁</h3> <h4 id="钓鱼攻击"><a href="#钓鱼攻击" class="header-anchor">#</a> 钓鱼攻击</h4> <p>就是钓鱼网站等。</p> <p>原因： HTTP 协议并没有考虑用户认证（用户并不能确定远端服务器的真实身份）。</p> <h4 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="header-anchor">#</a> 跨站脚本攻击</h4> <p>跨站脚本 (Cross-site scripting, XSS)：攻击者将恶意的客户端脚本注入正常的网页中，利用此漏洞进行 Cookie 窃取、会话劫持、钓鱼等攻击。</p> <p>原因：网页开发时留下的漏洞。</p> <h3 id="电子邮件安全威胁"><a href="#电子邮件安全威胁" class="header-anchor">#</a> 电子邮件安全威胁</h3> <ul><li>传输安全（原因：明文传输）</li> <li>存储安全</li> <li>发送者身份确认</li> <li>接受者已收到确认</li> <li>邮箱炸弹攻击（发送无意义邮件耗尽空间）</li></ul> <h2 id="第三章"><a href="#第三章" class="header-anchor">#</a> 第三章</h2> <h3 id="网络隔离"><a href="#网络隔离" class="header-anchor">#</a> 网络隔离</h3> <ul><li>同轴电缆（物理层，无隔离）</li> <li>集线器（物理层，无隔离）</li> <li>交换机（链路层）
<ul><li>虚拟子网（基于交换机实现 VLAN 划分，可基于端口、MAC、网络层、IP 组划分）</li></ul></li> <li>路由器（网络层）
<ul><li>作为唯一安全组件时：路由器相对交换机，集线器，能提供更高层次的安全功能</li> <li>作为安全组件的一部分时：路由器常用作屏蔽设备，执行包过滤功能，而防火墙对能够通过路由器的数据包进行检查（路由器是第一道关口，防火墙是第二道）</li></ul></li></ul> <h3 id="防火墙技术"><a href="#防火墙技术" class="header-anchor">#</a> 防火墙技术</h3> <p>用一个或一组网络设备（计算机系统或路由器等），在两个或多个网络间加强访问控制，以保护一个网络不受来自另一个网络攻击的安全技术。</p> <p>需掌握基本原理。</p> <h4 id="分组过滤防火墙"><a href="#分组过滤防火墙" class="header-anchor">#</a> 分组过滤防火墙</h4> <ul><li>分组：IP 包分组</li> <li>网络层</li> <li>分组过滤防火墙根据包头信息进行处理</li></ul> <h4 id="应用代理防火墙"><a href="#应用代理防火墙" class="header-anchor">#</a> 应用代理防火墙</h4> <ul><li>应用层</li> <li>又称代理网关、代理服务器</li> <li>用户需将代理设置为应用代理防火墙</li> <li>用户感觉是<code>自己 - HTTP 服务器</code> 的连接，实际是 <code>自己 - 代理服务器</code> 和 <code>代理服务器 - HTTP 服务器</code></li></ul> <h4 id="状态监测防火墙"><a href="#状态监测防火墙" class="header-anchor">#</a> 状态监测防火墙</h4> <ul><li>传输层</li> <li>上二者技术的折中</li> <li>建立状态表（记录已连接的数据报信息）、规则集</li></ul> <p><img src="/images/79e24527cc125b13997f250448a59e2815a859918b1924ac8e602367c51308c2.png" alt="状态监测防火墙 流程图"></p> <h3 id="防火墙的典型体系结构"><a href="#防火墙的典型体系结构" class="header-anchor">#</a> 防火墙的典型体系结构</h3> <h4 id="包过滤路由器模型"><a href="#包过滤路由器模型" class="header-anchor">#</a> 包过滤路由器模型</h4> <p>是有一个带有路由功能的防火墙或者起防火墙作用的路由器，也被称为筛选路由器。通常作为边界路由器部署在用户网络的边界。通常采用分组过滤技术。</p> <ul><li>优点：价格。</li> <li>缺点：内部网络的IP地址并没有被隐藏起来，并且不具备监测、跟踪和记录的功能。</li></ul> <p><img src="/images/f56265c490414de77d42a440a594fcbee5fa11800c41155e800e4995dde93644.png" alt="picture 3"></p> <h4 id="单宿主堡垒主机模型"><a href="#单宿主堡垒主机模型" class="header-anchor">#</a> 单宿主堡垒主机模型</h4> <p>堡垒主机，是指应用代理防火墙，它连接着一个不安全的网络和一个安全的网络。</p> <p>单宿主堡垒机模型是指只有一个网络接口的堡垒主机。由包过滤路由器和堡垒主机组成。安全等级比包过滤防火墙系统高，实现了网络层安全（包过滤）和应用层安全（代理服务）。</p> <p>说人话，堡垒主机用一根网线连接了外网和内网（外网和内网其实是物理连通的）。</p> <p><img src="/images/2f19b885a109501c64c2506ae95d31c5136ed562e3a68adf1373355ce313c636.png" alt="picture 4"></p> <h4 id="双宿主堡垒主机模型"><a href="#双宿主堡垒主机模型" class="header-anchor">#</a> 双宿主堡垒主机模型</h4> <p>双宿主堡垒主机有两块网卡：一块连接内部网络，一块连接包过滤路由器。在应用层提供代理服务，可以构造更加安全的防火墙系统。主机在两个端口之间直接转发信息的功能被关掉了，在物理结构上强行使所有传送内部网络的信息经过堡垒主机。</p> <p>说人话，堡垒主机一根网线连外网，一根网线连内网（外网和内网没有直接物理连通）。内网上外网必须经过堡垒主机。</p> <h4 id="子网屏蔽防火墙模型"><a href="#子网屏蔽防火墙模型" class="header-anchor">#</a> 子网屏蔽防火墙模型</h4> <p>用两个内网和一个堡垒主机。</p> <p><img src="/images/3f8b2ce5659c81af59003df973559b57866418e3b24c3a8a87a337ac4386b031.png" alt="picture 5"></p> <ul><li>内部路由器的主要功能是保护内部网络免受来自外部网络与参数网络的侵扰。</li> <li>堡垒主机的主要功能是为内外部服务请求进行代理。</li></ul> <p>两个路由器之间的区域叫 DMZ 网络。</p> <h3 id="防火墙在网络边界安全中的作用"><a href="#防火墙在网络边界安全中的作用" class="header-anchor">#</a> 防火墙在网络边界安全中的作用</h3> <ul><li>通过过滤不安全的服务而降低风险，提高内部网络安全性</li> <li>保护网络免受基于路由的攻击</li> <li>强化网络安全策略</li> <li>对网络存取和访问进行监控审计</li> <li>利用防火墙对内部网络的划分，实现内部网重点或敏感网段的隔离</li></ul> <h3 id="网络地址转换的基本概念、分类"><a href="#网络地址转换的基本概念、分类" class="header-anchor">#</a> 网络地址转换的基本概念、分类</h3> <p>将每个局域网节点的地址转换成一个 IP 地址，反之亦然。</p> <ul><li>静态 NAT</li> <li>动态 NAT（动态分配 IP）</li> <li>网络地址端口转换 (NAPT)，最常用</li></ul> <p>网络地址转换与网络安全：</p> <ul><li>如果改变源地址的话，数字签名不再有效</li> <li>给网络取证带来了巨大的困难</li> <li>依赖于IP和端口的防火墙过滤规则需要改变</li></ul> <h3 id="物理隔离的基本概念、网闸"><a href="#物理隔离的基本概念、网闸" class="header-anchor">#</a> 物理隔离的基本概念、网闸</h3> <p>物理隔离：指处于不同安全域的网络之间不能以直接或间接的方式相连接。</p> <p>分为单向隔离、协议隔离、网闸。</p> <p>网闸 (gap)：位于两个不同安全域之间，通过协议转换的手段，以信息摆渡的方式实现数据交换，且只有被系统明确要求传输的信息可以通过。（最常用）</p> <h2 id="第四章"><a href="#第四章" class="header-anchor">#</a> 第四章</h2> <p>前三章也就图一乐，后面才是重点.jpg</p> <h3 id="网络安全模型"><a href="#网络安全模型" class="header-anchor">#</a> 网络安全模型</h3> <h4 id="pdr-模型"><a href="#pdr-模型" class="header-anchor">#</a> PDR 模型</h4> <ul><li><strong>保护 (Protection)</strong>：在入侵前预防</li> <li><strong>检测 (Detection)</strong>：在入侵时检测</li> <li><strong>响应 (Response)</strong>：检测到入侵时响应</li></ul> <p>保护分为物理实体保护技术、信息处理保护技术；<br>
检测分为入侵检测技术、漏洞检测技术、网络扫描技术；<br>
响应需要把系统调整到安全状态，以及杜绝危害的进一步扩大</p> <h4 id="ppdr-模型"><a href="#ppdr-模型" class="header-anchor">#</a> PPDR 模型</h4> <p>在 PDR 的基础上增加了<strong>安全策略 (Policy)</strong>。</p> <p>安全策略是 PPDR 模型的核心，所有的保护、检测、响应都依据安全策略而实施。</p> <h4 id="pdrr-模型"><a href="#pdrr-模型" class="header-anchor">#</a> PDRR 模型</h4> <p>在 PDR 的基础上增加了<strong>恢复 (Recover)</strong>：检测入侵失败或响应失败后，会进行恢复。</p> <p>另外 PDRR 中的“响应”由 Responce 换成了 <strong>Reaction</strong>。</p> <p>PDRR 模型还引入了时间的概念：</p> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Pt</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">t</span></span></span></span></span>: 保护时间，即入侵开始到成功入侵的时间;</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Dt</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">t</span></span></span></span></span>: 检测时间;</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Rt</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">t</span></span></span></span></span>: 响应时间;</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Et</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">t</span></span></span></span></span>: 系统暴露时间.</li></ul> <p>PDRR 模型用两个公式表示安全的要求：</p> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>t</mi><mo>&gt;</mo><mi>D</mi><mi>t</mi><mo>+</mo><mi>R</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Pt &gt; Dt + Rt</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">t</span></span></span></span></span>，即系统的保护时间应大于系统的检测时间和响应时间之和</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>t</mi><mo>=</mo><mi>D</mi><mi>t</mi><mo>+</mo><mi>R</mi><mi>t</mi><mo separator="true">,</mo><mi>i</mi><mi>f</mi><mi>P</mi><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">Et = Dt + Rt, if  Pt = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span>，即如果保护时间为 0，那么检测时间与响应时间的和就是安全目标系统的暴露时间</li></ul> <p>PDRR 应当：</p> <ul><li>提高系统的防护时间 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Pt</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">t</span></span></span></span></span></li> <li>降低检测时间 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Dt</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">t</span></span></span></span></span> 和响应时间 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Rt</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">t</span></span></span></span></span></li> <li>在系统遭到破坏后，应尽快恢复，以减少系统暴露时间 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Et</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">t</span></span></span></span></span></li></ul> <h4 id="appdrr-模型"><a href="#appdrr-模型" class="header-anchor">#</a> APPDRR 模型</h4> <p>APPDRR 在综合了 PPDR 和 PDRR 的基础上，又添加了风险评估 (Assessment)，所以留个单词分别是：</p> <ul><li><strong>由风险评估 (Assessment)</strong></li> <li><strong>安全策略 (Policy)</strong></li> <li><strong>保护 (Protection)</strong></li> <li><strong>检测 (Detection)</strong></li> <li><strong>响应 (Reaction)</strong></li> <li><strong>恢复 (Restoration)</strong></li></ul> <p><s>响应和恢复的英文都变了，但是中文还是那个意思</s></p> <h4 id="padimee-模型"><a href="#padimee-模型" class="header-anchor">#</a> PADIMEE 模型</h4> <p>这个变动就大了：</p> <ul><li>Policy (安全策略）</li> <li>Assessment (安全评估)</li> <li>Design (设计/方案)</li> <li>Implementation (实现)</li> <li>Management/Monitor (管理/监控)</li> <li>Emergency Response (紧急响应)</li> <li>Education (安全教育)</li></ul> <p>PPT 戛然而止，所以应该不是重点。</p> <h3 id="网络安全预警"><a href="#网络安全预警" class="header-anchor">#</a> 网络安全预警</h3> <p>主要功能：</p> <ul><li>实时网络数据流跟踪</li> <li>网络攻击模式识别</li> <li>网络安全违规活动捕获</li> <li>对将要发生的或已发生的网络攻击进行预警</li> <li>对攻击的下一步动作进行合理的推测</li></ul> <p><img src="/images/fc758a99a1ffc0fd729ac7c531eef737e093a81a30635d768504375d093f40ec.png" alt="网络安全预警系统结构"></p> <p>通用网络安全预警系统功能模块结构：</p> <p><img src="/images/1cc2b51fe9d673186b4c30f97bb34e080fcd1419c2ce611c7d2022b511524944.png" alt="通用网络安全预警系统功能模块结构"></p> <hr> <p>常见网络安全预警模型：</p> <ul><li>基于入侵事件的预警模型</li> <li>基于攻击过程的预警模型</li> <li>基于流量监控的预警模型</li></ul> <p>戛然而止。</p> <h3 id="常见加密算法"><a href="#常见加密算法" class="header-anchor">#</a> 常见加密算法</h3> <ul><li>对称加密算法：DES（数据加密标准）、AES（高级数据加密标准）等</li> <li>非对称加密算法：RSA（三个人的名字）、ECC（椭圆曲线加密）等</li> <li>流密码（上面四个算法都需要将数据段分块）：RC4（其实也属于对称加密算法）</li></ul> <h3 id="vpn"><a href="#vpn" class="header-anchor">#</a> VPN</h3> <h4 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h4> <p>依靠 ISP (Internet 服务提供商) 和其它 NSP(网络服务提供商) 在公用网络中建立专用的数据通信网络的技术。</p> <h4 id="原理-关键技术"><a href="#原理-关键技术" class="header-anchor">#</a> 原理/关键技术</h4> <ul><li><strong>隧道技术</strong>：实质上是一种封装，即将一种协议 (如协议 X) 封装在另一种协议 (如协议 Y) 中传输，从而实现协议 X 对公共网络的透明性。</li> <li><strong>加密技术</strong>：对信息进行重新编码。</li> <li><strong>密钥管理技术</strong>：确保在公用数据网上安全地传递密钥而不被窃取。密钥的分发有两种方法：一种是通过手工配置；另一种采用密钥交换协议动态分发。</li> <li><strong>用户认证技术</strong>：在正式的隧道连接开始之前确认用户身份，实施资源访问控制或用户授权。有两种基本模式：有第三方参与的仲裁模式和没有第三方参与的基于共享秘密的认证模式。</li></ul> <h4 id="分类"><a href="#分类" class="header-anchor">#</a> 分类</h4> <p><img src="/images/15b9457f542ac3e6419cadf3eb50d08cb7af33a45b9f631d31b4e5da751c6c62.png" alt="picture 2"></p> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <h4 id="用到的协议"><a href="#用到的协议" class="header-anchor">#</a> 用到的协议</h4> <ul><li>第二层转发协议 L2F</li> <li><strong>点到点隧道协议 PPTP</strong>：是对点到点协议 PPP 的扩展，使用一种增强的 GRE 封装机制使 PPP 数据包按隧道方式穿越 IP 网络，并对传送的 PPP 数据流进行流量控制和拥塞控制。</li> <li><strong>第二层隧道协议 L2TP</strong>：国际标准隧道协议，综合了 PPTP 协议以及 L2F 协议的优点，它将链路层协议封装起来进行传输。优点在于提供了差错和流量控制。</li> <li><strong>通用路由封装协议 GRE</strong>：规定了怎样用一种网络层协议去封装另一种网络层协议的方法，GRE 的隧道由其两端的源 IP 地址和目的地址来定义。</li> <li><strong>IP 安全协议 IPSec</strong>：是一组开放协议的总称，它给出了应用于 IP 层上网络数据安全的一整套体系结构。</li></ul> <h4 id="ipsec-协议组成"><a href="#ipsec-协议组成" class="header-anchor">#</a> IPSec 协议组成</h4> <p>？？？</p> <h3 id="内网监管技术基本概念"><a href="#内网监管技术基本概念" class="header-anchor">#</a> 内网监管技术基本概念</h3> <p>针对局域网内的用户终端和网络设备进行监视和控制，规范内部网络用户的行为、防止敏感信息的泄漏的技术。</p> <h3 id="入侵检测的分类、技术"><a href="#入侵检测的分类、技术" class="header-anchor">#</a> 入侵检测的分类、技术</h3> <ul><li>根据入侵检测的数据源：
<ul><li>基于主机的入侵检测</li> <li>基于网络的入侵检测</li> <li>混合型入侵检测</li></ul></li> <li>根据检测方法：
<ul><li>异常检测，即对已知攻击进行分析，建立入侵模式库，并比对捕获的流量</li> <li>误用检测，即对正常系统行为建立模型，并比对观察到的目标活动</li></ul></li> <li>按时间：
<ul><li>实时入侵检测</li> <li>定时入侵检测</li></ul></li> <li>按系统体系结构：
<ul><li>集中式 IDS</li> <li>分布式 IDS</li></ul></li></ul> <p><img src="/images/aad0d2777bbfa91df1de6117940c494093f45f2f22bd3374bcfdfa60dc52e0ba.png" alt="入侵检测框架"></p> <p>技术：</p> <ul><li>用于误用入侵检测的技术，见上</li> <li>用于异常入侵检测的技术，见上</li></ul> <h3 id="入侵防御系统分类、组成"><a href="#入侵防御系统分类、组成" class="header-anchor">#</a> 入侵防御系统分类、组成</h3> <p>入侵防御系统：一种主动积极的网络防护系统，当发现攻击企图后，会将攻击包丢掉或采取阻断措施，实现对系统的实时防护，是一种积极的、主动的入侵防范和阻止系统。</p> <p>分类：</p> <ul><li>基于主机的入侵防御系统</li> <li>基于网络的入侵防御系统</li> <li>应用入侵防御系统</li></ul> <p>组成：</p> <ul><li>嗅探器</li> <li>监测分析组件</li> <li>策略执行组件</li> <li>日志系统</li> <li>管理控制台</li></ul> <h3 id="漏洞的分类"><a href="#漏洞的分类" class="header-anchor">#</a> 漏洞的分类</h3> <p>按漏洞的成因：</p> <ul><li>设计漏洞</li> <li>实现漏洞</li> <li>配置漏洞</li></ul> <p>按攻击危险程度：</p> <ul><li>高级危险漏洞</li> <li>中级危险漏洞</li> <li>低级危险漏洞</li></ul> <p>按攻击结果：</p> <ul><li>攻击入侵型漏洞</li> <li>攻击死机型漏洞</li> <li>信息泄露型漏洞</li></ul> <h3 id="漏洞检测方法分类"><a href="#漏洞检测方法分类" class="header-anchor">#</a> 漏洞检测方法分类</h3> <p>按测试程序或测试者的角色：</p> <ul><li>主动检测法</li> <li>被动检测法</li></ul> <p>按测试程序或测试者测试的途径：</p> <ul><li>主动测试</li> <li>网络测试</li> <li>分布式测试</li></ul> <h3 id="漏洞检测方法"><a href="#漏洞检测方法" class="header-anchor">#</a> 漏洞检测方法</h3> <ul><li>安全扫描（模拟攻击）</li> <li>源代码扫描</li> <li>反汇编扫描</li> <li>环境错误注入</li></ul> <h3 id="网络扫描技术"><a href="#网络扫描技术" class="header-anchor">#</a> 网络扫描技术</h3> <ul><li>完全 TCP 连接</li> <li>TCP SYN 扫描</li> <li>秘密扫描技术</li> <li>间接扫描技术</li> <li>分片、诱导扫描</li> <li>UDP 扫描</li> <li>识别扫描</li> <li>代理扫描</li></ul> <h3 id="安全响应阶段、分类"><a href="#安全响应阶段、分类" class="header-anchor">#</a> 安全响应阶段、分类</h3> <ul><li>前期：确认时间、初步分析</li> <li>中期：护理时间</li> <li>后期：进一步提供安全性、分析总结、</li></ul> <p>分类：</p> <ul><li>被动响应：被入侵时仅向用户报告</li> <li>主动响应：被入侵时自动采取措施</li></ul> <h3 id="蜜罐、蜜网"><a href="#蜜罐、蜜网" class="header-anchor">#</a> 蜜罐、蜜网</h3> <p>蜜罐：一种安全资源，其价值在于被扫描、攻击和攻陷。</p> <p>蜜罐系统：一个包含漏洞且运行于互联网上的计算机系统，它通过模拟一个或多个易受攻击的系统，给攻击者提供一个包含漏洞并容易被攻破的攻击目标，吸引攻击者对其发起攻击，同时完整地且不被察觉地将他们的活动记录下来。</p> <p>蜜网：蜜网技术建立了一个攻击诱捕的网络体系架构，该体系结构可以包含一个或多个蜜罐，并提供多种工具以方便对攻击信息的采集和分析，同时保证蜜网网络的高度可控性。</p> <h4 id="蜜罐分类"><a href="#蜜罐分类" class="header-anchor">#</a> 蜜罐分类</h4> <p>按照其部署目的：</p> <ul><li>产品型蜜罐：的在于为一个组织的网络提供安全保护。</li> <li>研究型蜜罐：对黑客攻击进行追踪和分析，了解到黑客所使用的攻击工具及攻击方法</li></ul> <p>按照其交互度的等级：</p> <ul><li>低交互蜜罐：一般仅仅模拟操作系统和网络服务。</li> <li>中交互蜜罐：对真正的操作系统的各种行为的模拟。</li> <li>高交互蜜罐：完全向攻击者提供真实的操作系统和网络服务。</li></ul> <h4 id="蜜罐功能"><a href="#蜜罐功能" class="header-anchor">#</a> 蜜罐功能</h4> <ul><li>攻击诱骗：吸引黑客的注意并诱使其发起攻击，增大黑客发现并入侵蜜罐的几率。</li> <li>数据捕捉：基于主机的数据收集；基于网络的数据收集；</li> <li>数据控制：防止以当前攻陷系统作为跳板，进而攻击其它系统。</li></ul> <p><img src="/images/5f481b837de451acee0c9eafff633ea7e57e9464c4f3aadd851be16eb16128e4.png" alt="蜜网拓扑结构"></p> <h4 id="蜜网技术应用"><a href="#蜜网技术应用" class="header-anchor">#</a> 蜜网技术应用</h4> <ul><li>捕获僵尸网</li> <li>捕获网络钓鱼</li> <li>抗蠕虫病毒</li></ul> <h4 id="蜜网技术发展趋势"><a href="#蜜网技术发展趋势" class="header-anchor">#</a> 蜜网技术发展趋势</h4> <p><img src="/images/c14cf593451b2b717920d3c76e1fd11570d168a6c2f5388221028afb46935053.png" alt="picture 2"></p> <h2 id="第五章-协议安全技术"><a href="#第五章-协议安全技术" class="header-anchor">#</a> 第五章 协议安全技术</h2> <p>前四章也就图一乐，后面才是重点.jpg</p> <h3 id="什么是协议、什么是安全协议"><a href="#什么是协议、什么是安全协议" class="header-anchor">#</a> 什么是协议、什么是安全协议</h3> <p>协议：两个或两个以上的参与者所采取的一系列步骤以完成某项特点的任务。</p> <p>安全协议 (Cryptographic Protocol)：在消息处理过程中采用了若干密码算法的协议</p> <h3 id="安全协议按协议目的分类"><a href="#安全协议按协议目的分类" class="header-anchor">#</a> 安全协议按协议目的分类</h3> <ul><li>密钥交换协议</li> <li>认证协议</li> <li>认证和密钥交换协议</li> <li>电子商务协议</li></ul> <h4 id="双向认证并交换两个秘密值-nspk-协议"><a href="#双向认证并交换两个秘密值-nspk-协议" class="header-anchor">#</a> 双向认证并交换两个秘密值——NSPK 协议</h4> <p>NS 这个人有点 nb，发明了一个公钥协议 <code>Public Key Protocol</code> 和一个对称密钥协议 <code>Symmetric Key Protocol</code>。前者简称为 <strong>NSPK</strong> 协议，后者称为 <strong>NSSK</strong> 协议。</p> <p><img src="/images/66154caf4f4f3b880b9eb027e76254a9080c664d94eabaf41a9eb125e12791a9.png" alt="Needham-Schreoder 公钥认证协议 (NSPK 协议)"></p> <blockquote><p>协议主体就是协议的参与者（或用户）。其中圆括号中的数字表示消息的顺序；符号“→”表示消息的流向：“M”表示Alice向Bob发送消息M；{M}K表示用密钥k对消息M进行加密；如{Na, A}kb表示用Bob的公钥kb对消息Na和A（即消息Na和A进行简单串接后得到的消息）进行加密；A是Alice的身份，Na和Nb是新鲜的一次性随机数。所谓新鲜的一次性随机数（Nonce）或一次性随机数是指该随机数在产生时间上很新且用完后即被丢弃，不会重用。</p> <ul><li>第一步：Alice在本地生成共享秘密值之一的Na，将Na和自己的身份A串联之后，用Bob的公钥kb对整个消息进行加密，并将得到的密文发送给Bob</li> <li>第二步：Bob收到用自己的公钥加密的密文之后，用自己的私钥解读该消息，得到Na和A。Bob本地生成另外一个共享秘密值Nb，将解密得到的Na与Nb串联之后，用Alice的公钥ka对所得到的消息进行加密，并将对应的密文发送给Alice</li> <li>第三步：Alice收到密文之后，用自己的私钥进行解密得到Na与Nb。如果解密得到Na值与自己在第一步中所生成的Na值相同，则Alice知道通信的另外一方就是Bob（即Alice证明了Bob的身份），并得到了两个共享秘密值Na与Nb。同时Alice用Bob的公钥kb对解密得到的Nb进行加密，并将密文发送给Bob。Bob收到密文后，用自己的私钥解密得到Nb，如果该值与自己在第二步生成的值相同，则Bob就证明了通信的另外一方就是Alice(即Bob证明了Alice的身份），并得到了两个共享秘密值Na与Nb。
由于只有拥有Bob的私钥才能解密消息{Na, A}kb，从而得到Na,而除了Bob之外，其他任何人均不可能拥有该私钥，因此不能知道Alice和Bob之间所交换的内容，即消息的机密性得到保证。同样，由于只有Bob才能解密得到Na ，因此第二步中的Na也只有Bob才能知道，因此Alice可以通过解密{Na, Nb}ka ，并通过比较Na值是否相同来确认Bob的身份。Bob对Alice的身份认证过程与Alice相似。</li></ul></blockquote> <h4 id="密钥交换协议、密钥传输协议-rpc-协议"><a href="#密钥交换协议、密钥传输协议-rpc-协议" class="header-anchor">#</a> 密钥交换协议、密钥传输协议：RPC 协议</h4> <p>密钥交换协议可分为两种情况：密钥传输和密钥协商。密钥传输是单方把密钥算出来然后发给另一方用，密钥协商是双方共同协商得出，中间没有直接传输密钥。</p> <p>下面几个密钥交换协议只进行了密钥交换，没有验证对方的身份。如果加入了验证身份，那就是认证与密钥交换协议了。</p> <p><img src="/images/373aa719329251b21474eeae97ce55ad4928b8194f7e85b26e630f481ed6cae8.png" alt="基于对称密码的密钥传输协议"></p> <p>协议5-1-2由4条消息组成，需要交换的共享密钥由Bob生成，通过协议传递给Alice。协议过程中用到了对称密码算法和认证，使用一次性随机数的目的是为了防范重放攻击。</p> <p>作为密钥交换协议，其并没有对对方的身份进行认证，只知道对面是拥有 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">k_{ab}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 的人。如果攻击者拥有了 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">k_{ab}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，就可以伪装成任意一方和另一方进行通讯。可见只使用一个对称密钥，安全性是不高的。</p> <h4 id="密钥交换协议、密钥协商协议-dh-协议"><a href="#密钥交换协议、密钥协商协议-dh-协议" class="header-anchor">#</a> 密钥交换协议、密钥协商协议：DH 协议</h4> <p>DH 是密钥协商协议。</p> <p><img src="/images/85595e9b74edbbad8941af01d29048abe913765d9371eca37420522224a707bf.png" alt="DH 协议"></p> <p>协议5-1-3由3条消息组成，其中 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">x_a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 和 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">x_b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 分别为 Alice 和 Bob 选择的随机数。在消息交换之后，Alice 计算 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><msup><mi>g</mi><msub><mi>x</mi><mi>b</mi></msub></msup><msup><mo stretchy="false">)</mo><msub><mi>x</mi><mi>a</mi></msub></msup><mo>=</mo><msup><mi>g</mi><mrow><msub><mi>x</mi><mi>a</mi></msub><msub><mi>x</mi><mi>b</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">k_{ab}=(g^{x_b})^{x_a} = g^{x_ax_b}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>。同理，Bob计算 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><msup><mi>g</mi><msub><mi>x</mi><mi>a</mi></msub></msup><msup><mo stretchy="false">)</mo><msub><mi>x</mi><mi>b</mi></msub></msup><mo>=</mo><msup><mi>g</mi><mrow><msub><mi>x</mi><mi>a</mi></msub><msub><mi>x</mi><mi>b</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">k_{ab}=(g^{x_a})^{x_b} = g^{x_ax_b}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>。因此实现了共享密钥（或秘密）的交换。</p> <p>DH 协议不能防止重放攻击。经 DH 改进的 <a href="#%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE%EF%BC%9ASTS-%E5%8D%8F%E8%AE%AE">STS 协议</a> 能防止重放攻击。</p> <h4 id="单向认证协议-x-509-标准"><a href="#单向认证协议-x-509-标准" class="header-anchor">#</a> 单向认证协议：X. 509 标准</h4> <p>这里实现对自己的认证的思路是，<strong>使用自己的私钥加密消息</strong>。如果包经中间人修改过，那么中间人加密过的包是没法用原发送者的公钥解密的。</p> <p>除此之外，消息中还加入了 Nonce、时间戳以及接接收，防止了重放攻击。（加入接收者可以防止中间人把 A 发往 B 的包反手转发给 C 这种情况）</p> <p><img src="/images/e13131b33db851870cd97d7a7c8dad402b57e7a1c9f826896f9fbf0168498693.png" alt="X. 509 标准中的一次传输单向认证协议"></p> <p>需要注意的是，双向认证协议一般不能等同于两个单向认证协议的简单叠加。似乎是需要 Bob 完成对自己认证的同时，发起对 Alice 的认证请求。</p> <h4 id="双向认证协议-x-509-标准"><a href="#双向认证协议-x-509-标准" class="header-anchor">#</a> 双向认证协议：X. 509 标准</h4> <p><img src="/images/bdfc9ea4917f26e14988be46278e59c7f3ceadecbda84c069619a0888ea5dc5c.png" alt="X. 509 标准中的三次传输双向认证协议"></p> <p>协议5-1-5由3条消息组成，其中M1、 M2 、 M3和M4是可选内容。</p> <h4 id="认证与密钥交换协议-sts-协议"><a href="#认证与密钥交换协议-sts-协议" class="header-anchor">#</a> 认证与密钥交换协议：STS 协议</h4> <p>STS 协议是 DH 协议的一个改进版本，不仅实现了双向认证，而且实现了双向密钥确认，因而属于认证与密钥交换协议。协议5-1-6由3条消息组成，其中<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><mo>=</mo><msup><mi>g</mi><mrow><msub><mi>x</mi><mi>a</mi></msub><msub><mi>x</mi><mi>b</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">k_{ab}= g^{x_ax_b}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>。由于采用了签名机制来保证消息的真实性，因此可以抵御许多针对 DH 协议的攻击。</p> <p><img src="/images/58b260a187fddd26f47b6f21690a76fa1453276feb10e5b08abe3d7a9012ff70.png" alt="STS 协议"></p> <p>协议中不仅用到了 DH 的方法，还加入了私钥用以认证。可以说是 DH 方法和双向认证方法的结合。</p> <h4 id="电子商务安全协议"><a href="#电子商务安全协议" class="header-anchor">#</a> 电子商务安全协议</h4> <blockquote><p>与其它类型的安全协议相比，电子商务协议具有显著的特殊性。在电子商务安全协议中，协议主体往往是交易的双方和金融机构，因此远比一般安全协议复杂。
此外，除了一般协议中要求的机密性、完整性和不可抵赖性之外，电子商务安全协议还特别强调<strong>公平性（Fairness）<strong>和</strong>匿名性（Anonymity）</strong>。前者指协议应该保证交易双方都不能通过损害对方的利益而得到不应该得到的利益，后者指交易双方的身份应该尽量不为他人所知（有时甚至要求交易双方和金融机构也不能知道交易方的信息）。安全电子交易（SET协议）是一个典型的电子商务安全协议。</p></blockquote> <h3 id="安全协议按是否需要可信第三方分类"><a href="#安全协议按是否需要可信第三方分类" class="header-anchor">#</a> 安全协议按是否需要可信第三方分类</h3> <h4 id="仲裁协议"><a href="#仲裁协议" class="header-anchor">#</a> 仲裁协议</h4> <p>仲裁协议需要借助于一个称之为仲裁者的可信第三方（Trusted Third Party）来完成消息交换。可信意味着仲裁者在协议过程中并无既得利益，且于协议中的其它任何主体之间无厉害关系，因此协议主体也乐于信赖该仲裁者。在仲裁者的帮助下，协议主体之间完成协议过程。</p> <p><img src="/images/f9a789be3fa0858a3fd68f1a20f41fd6210f6b16862671bc030463ffb90da572.png" alt="仲裁协议原理示意图"></p> <h4 id="裁决协议"><a href="#裁决协议" class="header-anchor">#</a> 裁决协议</h4> <p><img src="/images/fd93b744c6e82647c9e519c82dd77b08bc4aed9a5871d3a2156468430b3a9e83.png" alt="裁决协议原理示意图"></p> <p>由图5-1-3可知，裁决者Trent并不参与Alice和Bob之间的交易，仅当Bob没有收到书款提交裁决请求时，Trent才参与协议。如果交易顺利完成，Trent在协议中无需承担任何工作，其负担大为减轻。</p> <h4 id="自动执行协议"><a href="#自动执行协议" class="header-anchor">#</a> 自动执行协议</h4> <blockquote><p>自动执行协议不需要任何第三方（如仲裁者和裁决者）的参与，在协议主体之间完成协议过程。由于自动执行协议本身就保证了协议的安全性（如机密性、公平性等），因此不需要仲裁者来协助完成协议，也不需要裁决者来解决争端，因此是比较好的一种安全协议。
但是，设计一个安全的自动执行协议具有很高的难度，目前属于安全协议研究的热点问题。以上述Alice向Bob购书为例，要设计一个无仲裁者和裁决者的自动执行协议无疑是极为困难的事情。</p></blockquote> <h3 id="安全协议缺陷分类"><a href="#安全协议缺陷分类" class="header-anchor">#</a> 安全协议缺陷分类</h3> <p>（1）基本协议缺陷：协议中没有或者很少考虑对攻击者的防范而引发的协议缺陷（如TCP/IP协议的安全缺陷问题等）。<br>
（2）口令/密码设置缺陷：在设置和使用口令或密码的过程中，未考虑攻击者对其的猜测攻击等情况（如口令和密码过短，直接采用用户名来作为口令和密码等）。<br>
（3）陈旧消息缺陷：在协议设计过程中，未考虑消息的时效性（即新鲜性），从而使得攻击者可以利用协议过程中产生的过时消息来对协议进行重放攻击。<br>
（4）并行会话缺陷：协议设计对仅考虑单个协议执行的情况，对多个协议（或同一个协议的多个运行实例）并行会话缺乏考虑，使得攻击者可以相互交换适当的协议消息来获得更为重要的消息。<br>
（5）内部协议缺陷：协议参与者中至少有一方不能够完成所有必须的动作而导致缺陷。<br>
（6）密码系统缺陷：协议中使用的密码算法的安全强度问题导致协议不能完全满足所要求的机密性、完整性、认证等需要而产生的缺陷。</p> <h3 id="对-dh-协议的中间人攻击"><a href="#对-dh-协议的中间人攻击" class="header-anchor">#</a> 对 DH 协议的中间人攻击</h3> <blockquote><p>在实际应用中，要设计一个安全的协议是极为困难的。以著名的<a href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE%E3%80%81%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86%E5%8D%8F%E8%AE%AE%EF%BC%9ADH-%E5%8D%8F%E8%AE%AE">DH 协议</a>为例，由于存在针对该协议的“中间人攻击”，因此DH协议就不是一个绝对安全的协议。所谓中间人攻击，就是攻击者作为第三者，插入到协议主体Alice和Bob的通信过程的中间，对消息进行处理，从而破坏协议的正常执行。DH协议的中间人攻击如攻击5-2-1所示。</p></blockquote> <p><img src="/images/0e2b241021c8bd1e14ce7902f241a11790b75f71be2a0f55efc945fac4439b62.png" alt="针对 DH 协议的中间人攻击"></p> <blockquote><p>而作为中间人的Malice，则同时获得了Alice和Bob所拥有的两个密钥（即kam和kbm）。在随后的通信中，当Alice用kam加密消息时，Malice可以用相同的kam解密，得到消息的明文，并对该明文消息用kbm加密后转发给Bob。后者可以用自己拥有的kbm解密，因此不能感知任何错误或异常。同样，对于Bob发送给Alice的加密消息，Malice 可以采用 kbm `密钥实施欺骗功能。</p></blockquote> <h3 id="重放攻击"><a href="#重放攻击" class="header-anchor">#</a> 重放攻击</h3> <h4 id="对-nssk-的重放攻击"><a href="#对-nssk-的重放攻击" class="header-anchor">#</a> 对 NSSK 的重放攻击</h4> <p>注意，前提是 Malice 获得了 Alice 和 Bob 之前使用过的某个会话密钥 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">k_{ab}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>。</p> <p><img src="/images/5e402c1d9911c769e5a2e2669591c73d02bc1fa8646b3fc8ca83956305c6a23a.png" alt="对 NSSK 的重放攻击"></p> <blockquote><p>攻击者Malice通过对Alice和Bob过去某次NSSK协议的通过过程进行窃听，获得了其中的第三条消息 {kab , A } kbt.通过对该加密消息的攻击（如典型的蛮力破解），破译了该消息，从而得到了Alice和Bob使用的会话密钥 kab .当然，该破译过程可能需要较长的时间（如一年甚至更长）。一旦获得旧的会话密钥kab之后，Malice可以在今后某个时刻重新发送过去截获的旧消息 {kab , A } kbt而Bob对此并无只觉，因此它按照协议执行。随后的过程中Malice可以成功欺骗Bob，使得Bob认为和Alice发起了一次认证和密钥交换协议，并使得Alice（实质上是Malice伪装成Alice）的身份得以认证通过。但是，Alice在整个协议过程中根本未出现，所有的行为均为攻击者Malice所为。
通过对攻击5-2-2的分析可知，重放攻击之所以成功，其根本原因在于<strong>消息的新鲜性无法得到保证</strong>。如当Bob收到NSSK协议中第三条消息{kab , A} kbt时，他并不能区分该消息是现在产生的，还是过去的旧消息。</p></blockquote> <h4 id="分类-2"><a href="#分类-2" class="header-anchor">#</a> 分类</h4> <p>从被重放消息的来源来看，重放攻击可分为<strong>协议轮内攻击</strong>和<strong>协议轮外攻击</strong>。协议轮是指一个协议的整个过程消息交换过程（如NSSK协议中的5条消息交换即为一个协议轮）。因此，协议轮内的重放攻击就是指重放在本协议轮被截获的消息，而协议论外攻击则是重放从其它协议轮中捕获的消息。</p> <p>根据消息的去向，重放攻击可分为<strong>偏转攻击</strong>和<strong>直接攻击</strong>。偏转攻击是通过改变消息的去向而实施的攻击。直接攻击是将消息发送给任意接收方而实施的攻击。其中偏转攻击分为反射攻击和第三方攻击。前者指将消息返回给发送者，而后者指将消息发给协议合法通信双方之外的任一方。攻击5-2-2中的重放攻击属于协议轮外攻击和直接攻击。</p> <h3 id="抵抗重放攻击的三种方法及其特点"><a href="#抵抗重放攻击的三种方法及其特点" class="header-anchor">#</a> 抵抗重放攻击的三种方法及其特点</h3> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">特点</th> <th style="text-align:center;">缺点</th> <th style="text-align:center;">应用</th></tr></thead> <tbody><tr><td style="text-align:center;">挑战－应答机制</td> <td style="text-align:center;">通过新鲜一次性随机数保证消息的新鲜性</td> <td style="text-align:center;">需要生成一次性随机数的算法</td> <td style="text-align:center;">用于挑战的<strong>发起者</strong>验证所收到消息的新鲜性</td></tr> <tr><td style="text-align:center;">时戳机制</td> <td style="text-align:center;">利用时戳保证消息的新鲜性</td> <td style="text-align:center;">需要全局时钟同步；时间窗口大小不易控制</td> <td style="text-align:center;">用于消息的<strong>接收者</strong>判断消息的新鲜性</td></tr> <tr><td style="text-align:center;">序列号机制</td> <td style="text-align:center;">利用消息序列号来保证消息的新鲜性</td> <td style="text-align:center;">需要协商初始序列号，序列号不易同步</td> <td style="text-align:center;">可用于<strong>发送者和接收者</strong>判断消息的新鲜性</td></tr></tbody></table> <h4 id="挑战-应答机制"><a href="#挑战-应答机制" class="header-anchor">#</a> 挑战－应答机制</h4> <p><img src="/images/60415378971c7300cc97ea3f88210768b61fbc34358aa681c4892686d388519b.png" alt="挑战－应答机制"></p> <p>在协议5-2-1中，Bob对Alice的挑战是利用对称密钥进行加密。Alice收到Bob发送的消息之后，用相同的密钥解密得到自己所期望的应答，并与自己在第一步中所发送的挑战进行比较。如果相同，则消息是新鲜的；否则消息即为陈旧消息，可能是重放攻击。</p> <p>需要说明的是，协议5-2-1仅仅证明了消息的新鲜性，而其它消息的新鲜性则未提供保证。</p> <h4 id="时戳机制"><a href="#时戳机制" class="header-anchor">#</a> 时戳机制</h4> <p>时戳机制是指发送者在消息中嵌入发送消息的本地时刻，而接收者在消息达到后，通过对比消息中所包含的时间信息和本地时间信息的差值，来决定该消息是否为新鲜消息。如果接收者对消息延迟达到所能容忍的时间差值为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span></span>，发送消息的时刻为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Ts</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">s</span></span></span></span></span>，收到消息的时刻为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Tr</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></span>，如果<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>T</mi><mi>r</mi><mo>−</mo><mi>T</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo>=</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">| Tr - Ts |&lt;= \delta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span></span>，则接收者认为该消息是新鲜的，否则该消息是陈旧消息（即可能时重放攻击）。</p> <p>与挑战－应答机制不同，对时戳的保护（或变化）只能由消息的发送者提供。</p> <p>前文的<a href="#%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE%EF%BC%9AX-509-%E6%A0%87%E5%87%86">单向认证协议</a>即加入了时戳机制，只需要一次传输就能完成单向认证。</p> <h4 id="序列号机制"><a href="#序列号机制" class="header-anchor">#</a> 序列号机制</h4> <p>在序列号机制中，协议主体之间首先协商一个一致的初始序列号。协议过程中每条协议消息均带上序列号。每发送一条消息，序列号对应加1。因此，协议实体可以通过对比消息中的序列号和自己当前所期望的序列号是否相同来判断消息的新鲜性。典型的采用序列号机制来对抗消息重返的过程如图5-2-4所示。</p> <p><img src="/images/850592265fe052e09cd86ab1b10516d3efce6b6ee163a5c46835369f675ac9d4.png" alt="序列号机制"></p> <p>注意在实现上，双方共用一套序列号。</p> <p>由于序列号需要协商并保持同步，因此在实际应用中较少采用。</p> <h3 id="kerberos-协议内容"><a href="#kerberos-协议内容" class="header-anchor">#</a> Kerberos 协议内容</h3> <p>常见的<strong>认证协议</strong>包括用户口令认证协议（PAP）、挑战－握手认证协议（CHAP）、Kerberos 认证协议和 X. 509 认证协议等。</p> <h4 id="kerberos-原理"><a href="#kerberos-原理" class="header-anchor">#</a> Kerberos 原理</h4> <p>在 Kerberos 认证协议中，存在四个角色：</p> <ul><li><strong>客户端</strong>（C：Client）：请求服务的用户</li> <li><strong>服务器</strong>（S：Server，即提供某种服务的服务器）：向用户提供服务的一方</li> <li><strong>认证服务器</strong>（AS：Authentication Server）：负责验证用户的身份，如果通过了认证，则向用户提供访问票据准许服务器的票据许可票据（Ticket-Granting Ticket）</li> <li><strong>票据准许服务器</strong>（TGS：Ticket-Granting Server）：负责验证用户的票据许可票据，如果验证通过，则为用户提供访问服务器的服务许可票据（Service-Granting Ticket）。</li></ul> <p>因此，从认证服务器所获得的票据许可票据不能作为用户访问服务器的凭证，只能作为访问票据许可服务器的凭证，而后者所授予的服务票据才是用户访问服务器的凭证。</p> <p><img src="/images/f4d79dd95149e72095a96a4b6bb5ec7f84f77faee1173c89e64bffb0fa52894d.png" alt="Kerberos中的四种角色及其相互间的密钥共享关系示意图"></p> <p>用户C和票据准许服务器TGS和服务器S之间并无密钥共享关系，因此它们之间的通信采用会话密钥来加密。</p> <p><img src="/images/d7de7da69494b21715d204af63bbdd3f68ea99ff91fd3b90946b496627f67262.png" alt="Kerberos 系统构架"></p> <p>其中，</p> <ul><li>(1)(2) 每次用户登录执行一次；</li> <li>(3)(4) 每种服务执行一次；</li> <li>(5)(6) 每次服务会话执行一次。</li></ul> <p>在 Kerberos 的认证过程中也存在票据有效期问题。因此，当用户向认证服务器 AS 请求一张与票据许服务器 TGS 通信的通行证时，该通行证除了会话密钥之外，还包括用户端、服务器端、时戳以及有效期等信息。</p> <p>同样，票据许可服务器颁发给用户的服务许可票据除了包含会话密钥之外，同样也包含用户、服务器、时戳和有效期等信息。一旦用户获得票据许可票据，则访问其它服务时只需要访问票据许可服务器，而无需通过认证服务器。</p> <p>有意思的是，Kerberos 协议可以看做两次 NSSK 协议。第一次是用户和 TGS 经过 AS 仲裁后完成一次 NSSK 协议；第二次是用户和 S 经过 TGS 仲裁后完成一次 NSSK 协议。</p> <h4 id="kerberos-v4-缺陷"><a href="#kerberos-v4-缺陷" class="header-anchor">#</a> Kerberos V4 缺陷</h4> <ul><li>依赖性：加密系统的依赖性（DES）、对 IP 协议的依赖性和对时间依赖性。</li> <li>字节顺序：没有遵循标准</li> <li>票据有效期：有效期最小为5分钟，最大约为21小时, 往往不能满足要求</li> <li>认证转发能力：不允许签发给一个用户的鉴别证书转发给其他工作站或其他客户使用</li> <li>领域间的鉴别</li> <li>加密操作缺陷：非标准形式的 DES 加密（传播密码分组链接 PCBC）方式，易受攻击</li> <li>会话密钥：存在着攻击者重放会话报文进行攻击的可能</li> <li>口令攻击：未对口令提供额外的保护，攻击者有机会进行口令攻击</li></ul> <h4 id="kerberos-v5-改进"><a href="#kerberos-v5-改进" class="header-anchor">#</a> Kerberos V5 改进</h4> <ul><li>加密系统：支持使用任何加密技术。</li> <li>通信协议：IP 协议外，还提供了对其他协议的支持</li> <li>报文字节顺序：采用抽象语法表示（ASN.1）和基本编码规则（BER）来进行规范</li> <li>票据的有效期：允许任意大小的有效期，有效期定义为一个开始时间和结束时间</li> <li>鉴别转发能力：更有效的方法来解决领域间的认证问题</li> <li>口令攻击：提供了一种预鉴别（preauthentication）机制，使口令攻击更加困难。</li></ul> <h4 id="kerberos-领域间的互通"><a href="#kerberos-领域间的互通" class="header-anchor">#</a> Kerberos 领域间的互通</h4> <p>跨领域的服务访问：</p> <ul><li>一个用户可能需要访问另一个 Kerberos 领域中应用服务器；</li> <li>一个应用服务器也可以向其他领域中的客户提供网络服务。</li></ul> <p>领域间互通的前提：</p> <ul><li>支持不同领域之间进行用户身份鉴别的机制；</li> <li>互通领域中的 Kerberos 服务器之间必须共享一个密钥；</li> <li>同时两个 Kerberos 服务器也必须进行相互注册。</li></ul> <p><img src="/images/111ea5e49e2f75da4762b95fea6fa4c487156771673682e144af908baf8f7bad.png" alt="远程服务访问的认证过程"></p> <p>远程服务访问的认证过程就是把 TGS 的一步拆为了本地 TGS 和远程 TGS 两个部分。</p> <h3 id="x-509"><a href="#x-509" class="header-anchor">#</a> X. 509</h3> <p>X.509 是密码学里公钥证书的格式标准。X.509 证书已应用在包括 TLS/SSL 在内的众多网络协议里。</p> <h4 id="x-509-证书"><a href="#x-509-证书" class="header-anchor">#</a> X. 509 证书</h4> <p>SSL/TLS 证书就是 X. 509 证书。</p> <h5 id="证书的颁发"><a href="#证书的颁发" class="header-anchor">#</a> 证书的颁发</h5> <p>证书由可信证书权威机构（CA - Certficate  Authority）创建。</p> <ul><li>用户或 CA 将证书存放在目录服务器中；</li> <li>表示法：证书机构 Y 颁发给用户 X 的证书表示为 <code>Y&lt;&lt;X&gt;&gt;</code></li> <li><code>CA&lt;&lt;A&gt;&gt;</code>  表示 CA 颁发给用户 A 的证书。</li></ul> <p>CA 用其私有密钥对证书进行了签名。</p> <ul><li>用户可用 CA 的公开密钥验证证书的有效性；</li> <li>任何拥有 CA 公开密钥的用户都可以从证书中提取被该证书认证的用户的公开密钥；</li> <li>除了CA外，任何用户都无法伪造证书或篡改证书的内容；</li> <li>由于证书是不可伪造的，可将证书存放数据库（即目录服务）中，而无需进行特殊的保护。</li></ul> <h5 id="证书的获取"><a href="#证书的获取" class="header-anchor">#</a> 证书的获取</h5> <p>通信双方 A 和 B 如何获得对方的证书：</p> <ul><li>小型网络中，共同信任同一个 CA。通过访问公共目录服务获取对方的证书，或直接传递。</li> <li>大型网络， 多个 CA，层次化管理。CA 之间交换公开密钥（即交换证书）。</li></ul> <p><img src="/images/75490e7da9388678588c7e808404e2421503fc85639e53f45ce2a7c386cba9f8.png" alt="X.509认证协议中的证书的获得"></p> <h5 id="证书的吊销"><a href="#证书的吊销" class="header-anchor">#</a> 证书的吊销</h5> <ol><li>证书过期；</li> <li>在证书过期之前申请将其作废。例如，用户密钥被泄露，CA的密钥被泄露，或者用户不再使用某一个CA颁发的证书等。</li></ol> <p><img src="/images/252b362bccd0ff5f2ccfa5aba8602d3fdf26121ad42369809fcec9f480120039.png" alt="X.509认证协议中的证书的吊销"></p> <h4 id="x-509-三种认证"><a href="#x-509-三种认证" class="header-anchor">#</a> X. 509 三种认证</h4> <h3 id="tls-协议、会话、连接、tls记录层协议、握手协议"><a href="#tls-协议、会话、连接、tls记录层协议、握手协议" class="header-anchor">#</a> TLS 协议、会话、连接、TLS记录层协议、握手协议</h3> <h2 id="第七章-计算机系统可靠性技术"><a href="#第七章-计算机系统可靠性技术" class="header-anchor">#</a> 第七章 计算机系统可靠性技术</h2> <h3 id="容错系统"><a href="#容错系统" class="header-anchor">#</a> 容错系统</h3> <ul><li>自动侦测</li> <li>自动切换</li> <li>自动恢复</li></ul> <h3 id="raid"><a href="#raid" class="header-anchor">#</a> RAID</h3> <ul><li>RAID 0：冗余无校验的磁盘阵列</li> <li>RAID 1：镜象磁盘阵列</li> <li>RAID 2：并行海明纠错阵列</li> <li>RAID 3：奇偶校验<strong>并行位</strong>交错阵列</li> <li>RAID 4：奇偶校验<strong>扇区</strong>交错阵列</li> <li>RAID 5：<strong>循环</strong>奇偶校验阵列，是目前采用最多、最流行的方式</li></ul> <h3 id="容灾分类"><a href="#容灾分类" class="header-anchor">#</a> 容灾分类</h3> <ul><li>本地容灾</li> <li>异地数据冷备份</li> <li>异地数据热备份</li> <li>异地应用级容灾</li></ul> <h3 id="容灾技术"><a href="#容灾技术" class="header-anchor">#</a> 容灾技术</h3> <ul><li>数据容灾：数据复制技术、数据备份技术和数据管理技术</li> <li>应用容灾：系统迁移技术、灾难检测技术和系统恢复技术</li></ul> <h2 id="例题"><a href="#例题" class="header-anchor">#</a> 例题</h2> <p>以下考题大多基于 2016 年、2017 年的考卷，和 2020 年的考题有很大出入，所以参考价值可能不是很大。请读者知悉。</p> <h3 id="单词卡"><a href="#单词卡" class="header-anchor">#</a> 单词卡</h3> <blockquote><p>这个单词卡背下来以后，做选择填空有用：https://quizlet.com/cn/248705201/网络安全-flash-cards/
下面有不少题都可以在这个单词卡中找到！宝藏网站</p></blockquote> <h3 id="第二章"><a href="#第二章" class="header-anchor">#</a> 第二章</h3> <h3 id="tcp-ip-协议栈除应用层外面临的主要安全协议"><a href="#tcp-ip-协议栈除应用层外面临的主要安全协议" class="header-anchor">#</a> TCP/IP 协议栈除应用层外面临的主要安全协议</h3> <ul><li>物理层：窃听</li> <li>链路层：窃听、假冒</li> <li>网络层：假冒</li> <li>传输层：
<ul><li>UDP：假冒</li> <li>TCP：SYN Flooding、ACK Flooding、序列号预测攻击、Land 攻击</li></ul></li></ul> <h4 id="tcp-协议在设计之初考虑到了安全问题"><a href="#tcp-协议在设计之初考虑到了安全问题" class="header-anchor">#</a> TCP 协议在设计之初考虑到了安全问题</h4> <p>错。在开发的时候只考虑了可靠性和兼容性，没有考虑到安全性。</p> <h4 id="tcp-特点"><a href="#tcp-特点" class="header-anchor">#</a> TCP 特点</h4> <ul><li><strong>全双工通信</strong>：服务连接的两端有两条彼此独立、方向相反的通道。可以使数据在两个方向上同时进行传送操作。在发送数据的同时也能够接收数据，两者同步进行。</li> <li><strong>面向连接</strong>：所谓面向连接，是指通信的双方在开始传输数据之前，必须通过“三次握手”的方式在通信双方建立一条逻辑上的链路</li> <li><strong>可靠通信</strong>：TCP协议通过自动分片，保证分片的顺序，确认-重传等机制来实现可靠通信</li> <li><strong>面向字节流</strong>：TCP所传输的数据包是面向字节流的，即将多个消息连接成一个字符串，再依照TCP所认定的分片大小来分割传送</li></ul> <h3 id="第四章-2"><a href="#第四章-2" class="header-anchor">#</a> 第四章</h3> <h4 id="安全机制是-的总称"><a href="#安全机制是-的总称" class="header-anchor">#</a> 安全机制是__的总称</h4> <ul><li>保护信息</li> <li>信息系统安全措施</li> <li></li></ul> <h4 id="包过滤技术基本原理及优缺点"><a href="#包过滤技术基本原理及优缺点" class="header-anchor">#</a> 包过滤技术基本原理及优缺点</h4> <p>防火墙在网络层中根据数据包的包头信息进行判断，允许该包通过或者阻断。其原理是根据数据包的源IP地址、目的IP地址、源端口号、目的端口号、包类型和数据包头中的各种标志位等因素来确定是否允许数据包通过。其核心是安全策略即过滤规则的设计。</p> <p>包过滤技术的优点在于其容易实现、费用少、对性能的影响不大，对流量的管理较出色。</p> <p>包过滤技术的缺点是：</p> <ol><li>过滤规则表随着应用的深化会很快变得很大而且复杂，这样不仅规则难以测试，而且规则结构出现漏洞的可能性也会增加。</li> <li>包过滤技术只对数据包头进行检查，没有身份验证机制，因此不能分辨正常用户和入侵者。</li> <li>包过滤技术不能进行应用层的深度检查，因此不能发现传输的恶意代码及其攻击数据包。</li> <li>包过滤技术容易遭受源地址欺骗，外部攻击者可通过将攻击数据包源地址改为内部地址而穿透防火墙。</li></ol> <h4 id="子网屏蔽防火墙模型-2"><a href="#子网屏蔽防火墙模型-2" class="header-anchor">#</a> 子网屏蔽防火墙模型</h4> <p>用两个内网和一个堡垒主机。</p> <p><img src="/images/3f8b2ce5659c81af59003df973559b57866418e3b24c3a8a87a337ac4386b031.png" alt="picture 5"></p> <p>主要功能：</p> <p>外部路由器：主要是对参数网络上的主机提供保护
内部路由器：保护内部网络免受来自外部网与参数网络的侵扰
参数网络： 防止从堡垒主机上偷看内部信息流
堡垒主机： 为内部服务请求进行代理</p> <h4 id="常见的物理隔离部件包括"><a href="#常见的物理隔离部件包括" class="header-anchor">#</a> 常见的物理隔离部件包括</h4> <ul><li>单向隔离部件</li> <li>协议隔离</li> <li>网闸</li></ul> <h4 id="vpn-按应用分类"><a href="#vpn-按应用分类" class="header-anchor">#</a> VPN 按应用分类</h4> <ul><li><strong>Access VPN（远程接入VPN）</strong>：客户端到网关，使用公网作为骨干网在设备之间传输VPN数据流量；</li> <li><strong>Intranet VPN（内联网VPN）</strong>：网关到网关，通过公司的网络架构连接来自同公司的资源；</li> <li><strong>Extranet VPN（外联网VPN）</strong>：与合作伙伴企业网构成Extranet，将一个公司与另一个公司的资源进行连接。</li></ul> <p>用户通过本地的Internet服务提供商登陆到Internet，并在现在办公室和公司内部网之间建立一条保密通道。这种访问方式是：远程访问 VPN。</p> <p>网上能找到对于三种 VPN 的解释实在是太少，例题似乎都是这一题。想要了解的童鞋可以看看下图。</p> <p><img src="/images/61eb40dac83adf4f760f18da443348be8f11a36d69624425aaf5cef633c82876.png" alt="三种 VPN"></p> <h4 id="ipsec-运行模式"><a href="#ipsec-运行模式" class="header-anchor">#</a> IPSec 运行模式</h4> <ul><li>传输模型</li> <li>隧道模式</li></ul> <h4 id="ppdr安全模型包括4个主要部分-分别是"><a href="#ppdr安全模型包括4个主要部分-分别是" class="header-anchor">#</a> PPDR安全模型包括4个主要部分，分别是</h4> <ul><li>安全策略</li> <li>保护</li> <li>检测</li> <li>响应</li></ul> <h4 id="常用网络安全预警模型有"><a href="#常用网络安全预警模型有" class="header-anchor">#</a> 常用网络安全预警模型有：</h4> <ul><li>基于入侵事件的预警模型</li> <li>基于攻击过程的预警模型</li> <li>基于流量监控的预警模型</li></ul> <h4 id="入侵检测系统的主要技术指标"><a href="#入侵检测系统的主要技术指标" class="header-anchor">#</a> 入侵检测系统的主要技术指标：</h4> <ul><li>主要：<strong>漏报率</strong>、<strong>误报率</strong></li> <li>其他的还包括处理性能、完备性、容错性、及时性</li></ul> <h4 id="入侵检测根据数据来源分为"><a href="#入侵检测根据数据来源分为" class="header-anchor">#</a> 入侵检测根据数据来源分为：</h4> <ul><li>基于主机的入侵检测</li> <li>基于网络的入侵检测</li> <li>混合型入侵检测</li></ul> <h4 id="入侵检测按照检测方法分为"><a href="#入侵检测按照检测方法分为" class="header-anchor">#</a> 入侵检测按照检测方法分为：</h4> <ul><li>异常检测</li> <li>无用检测</li></ul> <h4 id="通用入侵检测框架四个基本组件"><a href="#通用入侵检测框架四个基本组件" class="header-anchor">#</a> 通用入侵检测框架四个基本组件：</h4> <ul><li>事件产生器</li> <li>时间分析器</li> <li>响应单元</li> <li>时间数据库</li></ul> <h4 id="数据传输加密应用模式有"><a href="#数据传输加密应用模式有" class="header-anchor">#</a> 数据传输加密应用模式有：</h4> <ul><li>链路加密</li> <li>节点加密</li> <li>端到端加密</li></ul> <h4 id="以下关于链路加密的说法不正确的是"><a href="#以下关于链路加密的说法不正确的是" class="header-anchor">#</a> 以下关于链路加密的说法不正确的是：</h4> <p>A. 链路加密是在通信链路两端加上加密设备对数据进行加密
B. 链路加密可以采用硬件实现
C. 链路加密中每个用户可以选择自己的加密密钥
D. 链路加密中所用用户使用相同的加密密钥</p> <p>选 C。</p> <h4 id="端口扫描的基本原理是什么-端口扫描技术可以分成哪几类"><a href="#端口扫描的基本原理是什么-端口扫描技术可以分成哪几类" class="header-anchor">#</a> 端口扫描的基本原理是什么？端口扫描技术可以分成哪几类？</h4> <p>端口扫描的原理是向目标主机的TCP/IP端口发送探测数据包，并记录目标主机的响应。通过分析响应来判断端口是打开还是关闭等状态信息。</p> <p>根据所使用通信协议的不同，网络通信端口可以分为TCP端口和UDP端口两大类，因此端口扫描技术也可以相应的分为TCP端口扫描技术和UDP端口扫描技术。</p> <h3 id="第五章"><a href="#第五章" class="header-anchor">#</a> 第五章</h3> <h4 id="安全协议按是否需要可行第三方分类"><a href="#安全协议按是否需要可行第三方分类" class="header-anchor">#</a> 安全协议按是否需要可行第三方分类</h4> <ul><li>仲裁协议</li> <li>裁决协议</li> <li>自动执行协议</li></ul> <h4 id="kerberos的设计目标不包括-授权"><a href="#kerberos的设计目标不包括-授权" class="header-anchor">#</a> Kerberos的设计目标不包括：授权</h4> <p>包括：认证、记账、审计</p> <h4 id="数字签名机制至少包括两个过程"><a href="#数字签名机制至少包括两个过程" class="header-anchor">#</a> 数字签名机制至少包括两个过程</h4> <ul><li>（用私钥）签名</li> <li>（用公钥）验证</li></ul> <h4 id="x-509证书包含的主要内容有哪些-至少列举5条"><a href="#x-509证书包含的主要内容有哪些-至少列举5条" class="header-anchor">#</a> X.509证书包含的主要内容有哪些？（至少列举5条）</h4> <p>（1）证书的版本信息 (1')<br>
（2）证书的序列号 (1')<br>
（3）证书所用的签名算法 (1')<br>
（4）证书的发行机构 (1')<br>
（5）证书的有效期 (1')<br>
（6）证书所有人的名称 (1')<br>
（7）证书所有人的公开密钥 (1')<br>
（8）证书发行者对证书的签名 (1')</p> <h4 id="ssl产生会话密钥的方式"><a href="#ssl产生会话密钥的方式" class="header-anchor">#</a> SSL产生会话密钥的方式</h4> <p>随机由客户机产生并加密后通知服务器</p> <h4 id="简述ssl中会话状态和连接状态的区别和联系"><a href="#简述ssl中会话状态和连接状态的区别和联系" class="header-anchor">#</a> 简述SSL中会话状态和连接状态的区别和联系</h4> <p>答：会话状态包含了标识一个会话的特征的信息和握手协议的协商结果。客户端和服务器端都需要记住已建立的所有的会话的状态。会话状态供握手协议层使用；（2分）<br>
连接状态包含了客户端和服务器端在传输数据过程中使用的加密参数。客户端和服务器端只需在一个连接存在时记住这个连接的状态。连接状态供记录协议层使用；（2分）<br>
多个连接状态可以和同一个会话状态关联，避免为每一个连接进行协商以提供新的安全参数。</p> <h4 id="简述-tls-的概念及功能"><a href="#简述-tls-的概念及功能" class="header-anchor">#</a> 简述 TLS 的概念及功能</h4> <p>TLS全称是Transport Layer Security (传输层安全)。在客户端和服务器两实体之间建立一个安全的通道，防止敌手的侦听、篡改以及消息伪造。TLS协议基于可靠的传输协议（如TCP协议），其组成主要包括TLS记录层协议和TLS握手协议。(3分) TLS记录层协议利用密钥协商协议和对称加密机制，可以为通信双方提供一个安全通道，用于数据的安全传输。此外，TLS记录层协议还包括了消息的完整性校验功能，从而确保消息传输的完整性。TLS握手协议用于通信实体之间的相互认证和密钥协商。TLS协议位于OSI模型中的应用层和传输层之间，对于参与通信的客户端和服务器来说，TLS协议是透明的。(3分)</p> <h4 id="tls-握手协议分为-5-个阶段"><a href="#tls-握手协议分为-5-个阶段" class="header-anchor">#</a> TLS 握手协议分为 5 个阶段</h4> <p>（1）交换安全能力（客户端向）<br>
（2）服务器密钥交换与认证
（3）客户端密钥交换与认证<br>
（4）结束阶段<br>
（5）应用程序阶段</p> <h4 id="set-的安全性体现在"><a href="#set-的安全性体现在" class="header-anchor">#</a> SET 的安全性体现在</h4> <ul><li>认证</li> <li>数据完整性</li> <li>消息的私密性</li></ul> <h4 id="set-协议的实体由六部分组成"><a href="#set-协议的实体由六部分组成" class="header-anchor">#</a> SET 协议的实体由六部分组成：</h4> <ul><li>持卡人</li> <li>商家</li> <li>发卡行</li> <li>收单行</li> <li>支付网关</li> <li>认证中心</li></ul> <h4 id="set-协议使用了双重数字签名技术。请简述双重数字签名的目的和基本过程。"><a href="#set-协议使用了双重数字签名技术。请简述双重数字签名的目的和基本过程。" class="header-anchor">#</a> SET 协议使用了双重数字签名技术。请简述双重数字签名的目的和基本过程。</h4> <p>SET 协议中，持卡人进行支付时需要对订单信息和支付信息同时进行签名，因此称为双重数字签名。</p> <p>双重数字签名允许商家验证持卡人对订单信息和支付信息的签名，但只能看到订单信息，而不知道支付信息的具体内容。这样的目的是保护用户的个人信息的隐私性。</p> <p>持卡人将支付信息摘要，订单信息和双重数字签名用数字信封加密后发送给商家，将订单信息摘要、支付信息和双重数字签名用数字信封加密后经商家转发给支付网关。</p> <p>商家解开信封，生成订单的摘要后和账号的摘要连接起来，用持卡人证书的签名公钥即可验证签名。</p> <h3 id="六至九章"><a href="#六至九章" class="header-anchor">#</a> 六至九章</h3> <h4 id="容错技术分为"><a href="#容错技术分为" class="header-anchor">#</a> 容错技术分为</h4> <ul><li>硬件容错技术（多硬件重复运行）</li> <li>时间容错技术（重复执行指令）</li> <li>信息容错技术（冗余位）</li> <li>软件容错技术（多程序冲突运行）</li></ul> <h4 id="容灾技术分为"><a href="#容灾技术分为" class="header-anchor">#</a> 容灾技术分为</h4> <ol><li>本地容灾</li> <li>异地数据冷备份</li> <li>异地数据热备份</li> <li>异地应用级容灾</li></ol> <h4 id="访问控制模型分为"><a href="#访问控制模型分为" class="header-anchor">#</a> 访问控制模型分为</h4> <ul><li>自主访问控制模型</li> <li>强制访问控制模型</li> <li>基于角色的访问控制模型</li></ul></div> <hr role="separator" aria-orientation="horizontal" class="ma-4 v-divider theme--light"> <div data-v-5794ffe6><script src="https://giscus.app/client.js" async="async" service="giscus" data-repo="lyh543/blog-comments" data-repo-id="R_kgDOHIb2Zg" data-category="Announcements" data-category-id="DIC_kwDOHIb2Zs4COh2z" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" data-v-5794ffe6></script></div></div></div></article></div> <!----></div></div> <div class="v-dialog__container"><button type="button" role="button" aria-haspopup="true" aria-expanded="false" class="v-btn v-btn--bottom v-btn--is-elevated v-btn--fab v-btn--fixed v-btn--has-bg v-btn--right v-btn--round theme--dark v-size--default primary"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-information-variant theme--dark"></i></span></button><!----></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2022</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ba06a0b0.js" defer></script><script src="/assets/js/35.48ba4f1f.js" defer></script>
  </body>
</html>
