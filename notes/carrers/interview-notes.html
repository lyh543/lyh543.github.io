<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>后台开发面试相关知识 | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/theme/favicon.png">
    <link rel="alternate" type="application/rss+xml" href="https://blog.lyh543.cn/rss.xml" title="小灰灰灰灰的博客 RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://blog.lyh543.cn/feed.atom" title="小灰灰灰灰的博客 Atom Feed">
    <link rel="alternate" type="application/json" href="https://blog.lyh543.cn/feed.json" title="小灰灰灰灰的博客 JSON Feed">
    <meta name="description" content="以下知识均在后台开发面试中实际出现过、总结而来。

C++

多态的实现

即虚函数表。

STL 容器库

容器库 - cppreference.com

unordered_map 和 map 的区别

略。

multimap 和 map 的区别

略。
 ...">
    
    <link rel="preload" href="/assets/css/0.styles.94ecd5c7.css" as="style"><link rel="preload" href="/assets/js/app.1606e5e2.js" as="script"><link rel="preload" href="/assets/js/28.2e1b5e41.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.94ecd5c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><div class="container"><div class="row justify-center"><div class="col-sm-9 col-12"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><div class="v-card v-sheet theme--light"><div class="container"><div itemprop="articleBody" class="markdown-body content__default"><p>以下知识均在后台开发面试中实际出现过、总结而来。</p> <h2 id="c"><a href="#c" class="header-anchor">#</a> C++</h2> <h3 id="多态的实现"><a href="#多态的实现" class="header-anchor">#</a> 多态的实现</h3> <p>即虚函数表。</p> <h3 id="stl-容器库"><a href="#stl-容器库" class="header-anchor">#</a> STL 容器库</h3> <p><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener noreferrer">容器库 - cppreference.com<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="unordered-map-和-map-的区别"><a href="#unordered-map-和-map-的区别" class="header-anchor">#</a> unordered_map 和 map 的区别</h3> <p>略。</p> <h3 id="multimap-和-map-的区别"><a href="#multimap-和-map-的区别" class="header-anchor">#</a> multimap 和 map 的区别</h3> <p>略。</p> <h3 id="智能指针"><a href="#智能指针" class="header-anchor">#</a> 智能指针</h3> <p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-160" target="_blank" rel="noopener noreferrer">智能指针（现代C++） | Microsoft Docs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>智能指针是对普通指针的一个封装。普通指针 <code>new</code> 了以后一定要 <code>delete</code>，而智能指针是一个类，当这个类的对象超出作用域以后，会自动调用析构函数，因此不再需要 <code>delete</code>，也不会因为忘记 <code>delete</code> 而发生内存泄露。</p> <p>智能指针和普通指针的对比：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">UseRawPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Using a raw pointer -- not recommended.</span>
    Song<span class="token operator">*</span> pSong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Song</span><span class="token punctuation">(</span>L<span class="token string">&quot;Nothing on You&quot;</span><span class="token punctuation">,</span> L<span class="token string">&quot;Bruno Mars&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token comment">// Use pSong...</span>

    <span class="token comment">// Don't forget to delete!</span>
    <span class="token keyword">delete</span> pSong<span class="token punctuation">;</span>   
<span class="token punctuation">}</span>


<span class="token keyword">void</span> <span class="token function">UseSmartPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Declare a smart pointer on stack and pass it the raw pointer.</span>
    unique_ptr<span class="token operator">&lt;</span>Song<span class="token operator">&gt;</span> <span class="token function">song2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Song</span><span class="token punctuation">(</span>L<span class="token string">&quot;Nothing on You&quot;</span><span class="token punctuation">,</span> L<span class="token string">&quot;Bruno Mars&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Use song2...</span>
    wstring s <span class="token operator">=</span> song2<span class="token operator">-&gt;</span>duration_<span class="token punctuation">;</span>
    <span class="token comment">//...</span>

<span class="token punctuation">}</span> <span class="token comment">// song2 is deleted automatically here.</span>
</code></pre></div><p>智能指针体现什么机制：封装。</p> <ul><li><code>unique_ptr</code>：<code>unique_ptr</code> 的出现是为了替代 C++98 的 <code>auto_ptr</code> (而 <code>auto_ptr</code> 于 C++11 中被弃用)。如果不知道用什么，默认用 <code>unique_ptr</code> 就对了。<code>unique_ptr</code> 只占一个指针大小的空间</li> <li><code>shared_ptr</code>：<code>shared_ptr</code> 的管理类似于 Python 的垃圾回收机制：对变量进行计数（如下图）。拷贝构造 <code>auto sp3(sp2);</code> 和赋值 <code>auto sp4 = sp2;</code> 都会使得计数++。<code>shared_ptr</code> 占两个指针大小的空间</li> <li><code>weak_ptr</code>：<code>shared_ptr</code> 中如果有循环引用，导致二者的计数都不为 0，会导致内存泄露。可以在引用的地方使用 <code>weak_ptr</code> 并将 <code>shared_ptr</code> 赋给它，这不会使得 <code>shared_ptr</code> 计数++，之后能被正确地回收。<a href="https://blog.csdn.net/c_base_jin/article/details/79440999" target="_blank" rel="noopener noreferrer">例子<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/how-to-create-and-use-weak-ptr-instances?view=msvc-160" target="_blank" rel="noopener noreferrer">例子2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><img src="/images/bfe1ee01619b2c9ccc4caed3ac55690651d628abb8b9e9956c2da7d9420c8fe4.png" alt="shared_ptr"></p> <h2 id="java"><a href="#java" class="header-anchor">#</a> Java</h2> <blockquote><p>参考：<a href="https://github.com/angrySquirrel/bookCollection/blob/master/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86.pdf" target="_blank" rel="noopener noreferrer">《Spring 技术内幕：深入解析 Spring 架构与设计原理》（第 2 版）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="spring-ioc"><a href="#spring-ioc" class="header-anchor">#</a> Spring IoC</h3> <h4 id="ioc-和-di-的概念"><a href="#ioc-和-di-的概念" class="header-anchor">#</a> IoC 和 DI 的概念</h4> <p>先说两个概念：</p> <ul><li>IoC (Inversion of Control)：控制反转。</li> <li>DI (Dependency Injection)：依赖注入。</li></ul> <p>控制反转是目的、结果，依赖注入是实现控制反转的手段、方法。可以使用依赖注入或依赖查找实现 IoC，但还是依赖注入比较主流。</p> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ol><li>资源不再由我们进行管理，而是交给框架进行管理。比如我们写了 <code>UserController</code>、<code>UserService</code>，在实际运行时，我们不需要进行 <code>new UserController()</code> 等代码，而是交给框架进行创建和销毁。</li> <li>降低耦合度。说实话我不太赞同这个优点是 IoC 带来的，我认为这个是将接口和实现分离而带来的。</li> <li>解决循环依赖。如果两个 Service 有互相依赖，如果让我们让我们负责创建这两个 Service，我们在 ServiceA 的构造函数中会 <code>new ServiceB()</code>，而在 ServiceB 的构造函数中会 <code>new ServiceA()</code>，导致循环依赖。Spring 的 IoC 的确解决了循环依赖的问题，不过 Spring 2.6 中会默认禁止循环依赖，避免用户不小心创建循环依赖的 Beans。</li></ol> <h4 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h4> <blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/q6zs7xRjpcB4YxLw6w477w" target="_blank" rel="noopener noreferrer">Spring源码系列之容器启动流程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>基本概念：</p> <ul><li>Bean：需要由 Spring IoC 容器管理的对象，如 <code>UserController</code>、<code>UserService</code></li> <li>BeanFactory：Spring IoC 容器的接口，提供获取 Bean 对象、Bean 的基本信息（以 BeanDefinition 的形式保存）等接口</li> <li>ApplicationContext：BeanFactory 的子接口，除了提供 BeanFactory 的所有接口外，还提供了更多功能（如 Spring AOP、Message Source、事件广播器）。Spring 应用的数据都保存在 ApplicationContext 的实现类中。有意思的是，这个实现类的 BeanFactory 相关接口是通过代理模式实现的（类里存储了一个 BeanFactory 对象）。</li> <li>Processor：Spring IoC 中拥有处理能力的工具类。Spring 中有两种：<code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code>。前者用于干预 BeanFactory 的创建过程，后者用于干预 Bean 的创建过程（如实现 <code>@Autowired</code>、AOP 等）。二者的接口定义如下：</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>
	<span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>
	<span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Spring Boot 通过在 main 函数里调用 <code>SpringApplication.run()</code>，完成 Spring 容器的初始化，其过程可以参考下面的思维导图。</p> <blockquote><p>在线思维导图：<a href="https://tw00cr92rp.feishu.cn/mindnotes/bmncngNRYP7OEjCGanqNkafIQfg#mindmap" target="_blank" rel="noopener noreferrer">Spring Boot 的 IoC 初始化 - 飞书文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><img src="/images/aec963bf14b351c3a718e8efc210a79f11806fd62586baec0bf910e526338392.png" alt="Spring Boot 的 IoC 初始化"></p> <p>下面是可以用于面试的回答模板。</p> <ol><li>初始化一个 Spring Boot 应用，可以使用 <code>SpringApplication.run()</code> 函数。这个函数主要做了两件事：实例化 ApplicationContext，和调用 <code>refresh()</code> 函数：实例化所有<code>非懒加载</code>的<code>单例</code> Bean</li> <li>在实例化 ApplicationContext 时，Spring 会实例化 BeanFactory；然后将几个自带的 Processor 注册到容器中，之后会在 <code>refresh()</code> 函数中用到</li> <li><code>refresh()</code> 函数的核心有 5 个步骤：
<ol><li>执行所有 <code>BeanFactoryPostProcessor</code></li> <li>注册所有的 <code>BeanPostProcessor</code>，这个过程会扫描所有的 Bean，并保存到 BeanFactory 中</li> <li>初始化 MessageSource</li> <li>初始化事件广播器</li> <li>实例化剩余的<code>非懒加载</code>的<code>单例</code> Bean。这里会遍历 Bean 的列表，通过查询 Bean 的定义，排除掉不满足条件的 Bean，然后对剩下的 Bean 调用 <code>getBean()</code>。</li></ol></li> <li><code>getBean</code> 函数首先会检查 <code>BeanFactory</code> 中是否已经实例化这个 Bean，如果已经实例化则直接返回实例化的对象；如果没有，则会调用 <code>createBean</code> 创建 Bean。</li> <li><code>createBean</code> 函数分为三个步骤：
<ol><li>利用反射，拿到这个 Bean 的所有构造函数，然后根据传入的参数选择一个构造函数进行实例化</li> <li>实例化以后将其存入 BeanFactory</li> <li>调用 <code>populateBean</code> 装配当前 Bean 关联的其它 Bean。通过反射找到这个 Bean 里需要装配（如 <code>@Autowired</code>）的字段，然后调用 <code>getBean()</code> 递归地获取 Bean。</li></ol></li></ol> <h4 id="如何解决循环依赖"><a href="#如何解决循环依赖" class="header-anchor">#</a> 如何解决循环依赖</h4> <blockquote><p>参考: <a href="https://juejin.cn/post/6844903962412318734" target="_blank" rel="noopener noreferrer">Spring中是如何处理循环依赖的 - 掘金<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>Spring 通过调用 <code>getBean() -&gt; createBean() -&gt; populateBean() -&gt; getBean()</code> 递归地创建 Bean。但创建了一个 Bean 以后，Spring 会将其存到 BeanFactory 中，下次 <code>getBean()</code> 时会直接返回该实例。因此每个 Bean 只会被创建一次，不会无限递归。</p> <p>下面是从一个来自掘金的详细流程图，可供参考。</p> <p><img src="/images/8b04b6c23892395bc930fa8ab1a1bb5281170663f2219db8f7fe30c36e24a3b7.awebp" alt="picture 5"></p> <h3 id="java-动态代理-spring-aop"><a href="#java-动态代理-spring-aop" class="header-anchor">#</a> Java 动态代理 &amp; Spring AOP</h3> <blockquote><p>参考：《Spring技术内幕：深入解析Spring架构与设计原理》第三章 —— Spring AOP 的实现</p></blockquote> <p>AOP 是 Aspect-Oriented Programming（面向方面编程），和 OOP（面向对象编程）都是为了使代码和功能更模块化。OOP 利用继承，很容易实现纵向的模块化（为一个类的所有子类添加相同的功能和代码），而 AOP 的出现就是为了实现横向的模块化，它可以按照指定的规则，给满足条件的函数加相同的功能和代码。例如，AOP 常用于日志等场景，可以为指定的所有方法添加日志功能。</p> <h4 id="aop-使用场景"><a href="#aop-使用场景" class="header-anchor">#</a> AOP 使用场景</h4> <ul><li>Auth（认证）</li> <li>Cache（缓存）</li> <li>Context passing（上下文传递）</li> <li>Logging（日志）</li></ul> <h4 id="aop-相关概念"><a href="#aop-相关概念" class="header-anchor">#</a> AOP 相关概念</h4> <h5 id="advice"><a href="#advice" class="header-anchor">#</a> Advice</h5> <p>Advice（通知）定义了 AOP 中“相同的功能和代码”。直接理解这个概念会相当抽象，所以我们看看 Advice 的三个核心的子接口：<code>MethodBeforeAdvice</code>、<code>AfterReturningAdvice</code> 和 <code>ThrowsAdvice</code> 的代码。</p> <p><img src="/images/712c4b478f94bf09f156a1f8ada5d29aab9b19d26a25f8ca5e2b2fa02bfa0008.png" alt="picture 2"></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MethodBeforeAdvice</span> <span class="token keyword">extends</span> <span class="token class-name">BeforeAdvice</span> <span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AfterReturningAdvice</span> <span class="token keyword">extends</span> <span class="token class-name">AfterAdvice</span> <span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token function">afterReturning</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> returnValue<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * &lt;p&gt;There are not any methods on this interface, as methods are invoked by
 * reflection. Implementing classes must implement methods of the form:
 *
 * &lt;pre class=&quot;code&quot;&gt;void afterThrowing([Method, args, target], ThrowableSubclass);&lt;/pre&gt;
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ThrowsAdvice</span> <span class="token keyword">extends</span> <span class="token class-name">AfterAdvice</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><p>看到 Advice 接口下面定义的函数，其实就比较好理解了。接口里定义的是<strong>回调函数</strong>，比如 <code>MethodBeforeAdvice.before()</code> 就是在目标函数被调用前，会调用这个函数；<code>AfterReturningAdvice.afterReturning()</code> 就是在目标函数被调用后，会调用这个函数；而 <code>ThrowsAdvice.afterThrowing()</code> 就是在目标函数抛异常以后，会调用这个函数。当我们把“相同的功能和代码”写到这几个回调函数里，就可以在不同的函数执行前后，执行这些代码了。</p> <h5 id="pointcut"><a href="#pointcut" class="header-anchor">#</a> PointCut</h5> <p>Advice 定义了需要在不同函数的先后执行的“相同的功能和代码”，而 PointCut（切入点）定义了哪些函数需要执行。说白了，PointCut 就是一个<strong>筛选器</strong>。我们还是直接看 PointCut 接口的定义。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ClassFilter</span> <span class="token punctuation">{</span>
	<span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MethodMatcher</span> <span class="token punctuation">{</span>
	<span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Pointcut</span> <span class="token punctuation">{</span>
	<span class="token class-name">ClassFilter</span> <span class="token function">getClassFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">MethodMatcher</span> <span class="token function">getMethodMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>ClassFilter</code> 定义了筛选类的类，<code>ClassFilter.matches</code> 接收一个类，返回 <code>boolean</code> 表示是否匹配；<code>MethodMatcher</code> 定义了筛选方法的类，<code>MethodMatcher.matches</code> 接收一个方法（还有它的类、以及调用方法时的参数），返回 <code>boolean</code> 表示是否匹配。</p> <p>很显然，<code>PointCut</code> 就是负责筛选类和方法。</p> <h5 id="advisor"><a href="#advisor" class="header-anchor">#</a> Advisor</h5> <p>Advisor（通知器）做的事情，就是<strong>将 PointCut 和 Advice 结合起来</strong>，这样就可以表达“给满足条件的函数加相同的功能和代码”的意思。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Advisor</span> <span class="token punctuation">{</span>
	<span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PointcutAdvisor</span> <span class="token keyword">extends</span> <span class="token class-name">Advisor</span> <span class="token punctuation">{</span>
	<span class="token class-name">Pointcut</span> <span class="token function">getPointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="aop-的实现"><a href="#aop-的实现" class="header-anchor">#</a> AOP 的实现</h4> <p>AOP 的核心技术是动态代理（Dynamic Proxy）。代理是常见的设计模式，它基于实际的对象 <code>realSubject</code> 创建一个拥有相同方法的对象 <code>proxySubject</code>（代理对象也被称为增强过的对象），并在今后的操作中代替 <code>realSubject</code>。Python 的装饰器就是类似的设计模式。</p> <p>静态代理和动态代理的区别在于，静态代理需要我们手写 <code>proxySubject</code> 的类，而动态代理则不需要，可以动态生成类，并为我们实例化一个 <code>proxySubject</code>。</p> <p>Java 中有两种动态代理的方案，一是使用 JDK 自带的动态代理，另一种是使用 cglib 提供的动态代理。</p> <p>JDK 和 cglib 的动态代理在使用上最大的区别在于：JDK 动态代理只能通过实现接口的方式进行代理（所以目标类必须实现一个接口，而 JDK 代理类也会实现这个接口）；而 cglib 代理可以通过创建目标类的子类进行代理，不需要目标类实现接口。因此，JDK 只能代理实现了接口的类，cglib 可以代理没有接口的类，但 <code>cglib</code> 不能代理 <code>final</code> 类和类中的 <code>final</code> 方法。</p> <hr> <p>代理是 AOP 的第一步，在完成代理后，还需要启动代理对象的 Interceptor（拦截器）将 Advice 的代码进行织入。</p> <h4 id="spring-aop-的自调用问题"><a href="#spring-aop-的自调用问题" class="header-anchor">#</a> Spring AOP 的自调用问题</h4> <blockquote><p><a href="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch08s06.html" target="_blank" rel="noopener noreferrer">8.6 Proxying mechanisms | Spring Docs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>读 Spring 文档的时候突然发现一个网上没怎么提到过的问题：自调用（self-invocation），比如在 <code>this.foo()</code> 方法中调用了 <code>this.bar()</code>。</p> <p>考虑下面这个情形：我们编写了一个 <code>RealSubject</code>，其中 <code>foo()</code> 方法会调用 <code>bar()</code>。随后对这个类进行代理。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">Interface</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">ProxyFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      factory<span class="token punctuation">.</span><span class="token function">addInterface</span><span class="token punctuation">(</span><span class="token class-name">Interface</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      factory<span class="token punctuation">.</span><span class="token function">addAdvice</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RetryAdvice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      factory<span class="token punctuation">.</span><span class="token function">setExposeProxy</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">RealSubject</span> proxySubject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">RealSubject</span><span class="token punctuation">)</span> factory<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// this is a method call on the proxy!</span>
      proxySubject<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用链是这样的：</p> <div class="language- extra-class"><pre class="language-text"><code>proxySubject.foo() -&gt; realSubject.foo() -&gt; realSubject.bar()
</code></pre></div><p>这里的问题在于，<code>realSubject.foo()</code> 调用 <code>bar()</code> 时，调用的是 <code>this</code>（即 <code>realSubject</code>） 的 <code>bar()</code>，<strong>没有经过代理就调用了 <code>bar()</code> 方法</strong>，会导致对 <code>bar()</code> 方法添加的 Advice 不会生效。</p> <hr> <p>Spring 给出了三种解决方案：</p> <ol><li>重构 <code>RealSubject</code> 的代码，回避掉自调用和 Advice 需要同时发生的情况。</li> <li>将 Spring AOP 的逻辑加入 <code>RealSubject.foo()</code> 中（但这样的侵入性很强，不推荐）</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">Interface</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RealSubject</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>改用 AspectJ 的 AOP 方案，因为 AspectJ 的 AOP 不是基于代理的，就不存在这个问题。</li></ol> <h3 id="spring-事务"><a href="#spring-事务" class="header-anchor">#</a> Spring 事务</h3> <p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative-annotations" target="_blank" rel="noopener noreferrer">Data Access | Spring<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Spring 提供了事务管理。其本质是调用 JDBC 提供的 <code>TransactionManager</code>，最终落实到数据库的事务上。</p> <hr> <p>可以在方法前加 <code>@Transactional</code> 来使用 Spring 事务。标注了 <code>@Transactional</code> 的方法会被代理，用以在实际执行前开启事务，成功结束后提交，抛出异常时回滚。</p> <hr> <p>除了使用 <code>@Transactional</code> 这种声明式的事务管理（Declarative Transaction Management）以外，也可以使用 <code>TransactionManager</code> 或 <code>TransactionTemplate</code> 编程式的事务管理（Programmatic Transaction Management）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleService</span> <span class="token keyword">implements</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">TransactionManager</span> transactionManager<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">someServiceMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TransactionStatus</span> status <span class="token operator">=</span> transactionManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span>def<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// put your business logic here</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MyException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            transactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        transactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleService</span> <span class="token keyword">implements</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">TransactionTemplate</span> transactionTemplate<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">someServiceMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> transactionTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// the code in this method runs in a transactional context</span>
            <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doInTransaction</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">updateOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token function">resultOfUpdateOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h2> <h3 id="快排算法、快排的时间复杂度-平均、最坏"><a href="#快排算法、快排的时间复杂度-平均、最坏" class="header-anchor">#</a> 快排算法、快排的时间复杂度（平均、最坏）</h3> <h3 id="java-自带数据结构"><a href="#java-自带数据结构" class="header-anchor">#</a> Java 自带数据结构</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 排序</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arr<span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 队列、优先队列</span>
<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> priorityQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">assert</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 栈</span>
<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">assert</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// Map</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry<span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">assert</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Set</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">assert</span> set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="数据库"><a href="#数据库" class="header-anchor">#</a> 数据库</h2> <h3 id="mysql-数据库引擎"><a href="#mysql-数据库引擎" class="header-anchor">#</a> MySQL 数据库引擎</h3> <ul><li>MyISAM：读性能高，但不支持外键、行级锁和事务，MySQL 5.5 默认</li> <li>InnoDB：读性能稍弱，支持外键、行级锁和事务，MySQL 5.5.5 及以后默认</li></ul> <p>二者都使用 B+ 树作为存储的数据结构。</p> <h3 id="b-树和-b-树"><a href="#b-树和-b-树" class="header-anchor">#</a> B 树和 B+ 树</h3> <h4 id="b-树"><a href="#b-树" class="header-anchor">#</a> B 树</h4> <p><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B 树 | 维基百科<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://segmentfault.com/a/1190000020416577" target="_blank" rel="noopener noreferrer">面试官问你B树和B+树，就把这篇文章丢给他- SegmentFault 思否<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>先要纠正两个常见误区：</p> <ul><li>B 树 (B-Tree) 不是二叉树 (Binary Tree)。B 的全称，可能起源于其<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91#%E5%90%8D%E5%AD%97%E5%8F%96%E4%B9%89" target="_blank" rel="noopener noreferrer">发明者<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，不过理解成平衡 (balanced) 或宽的(broad) 或 茂密(bushy) 也不错。</li> <li>没有 B 减树！B 减树的出现可能是翻译人员错误地将 B 树 (B-Tree) 翻译成了 B 减树。</li></ul> <p><img src="/images/df871baea1f5b1cc17ad6a1c36c13eaae55a55f30987474ebe1ac5570b9d7567.png" alt="B 树"></p> <p>概述：B 树是是一种自平衡的树，能够保持数据有序（听起来就是在说平衡二叉树）。其与平衡二叉树的不同在于，B 树的一个节点可以拥有 2 个以上的子节点，且节点数在某范围内可变。这样的好处有：</p> <ol><li>子结点的增多能够降低深度，减少定位记录时所经历的中间过程，运用在磁盘、数据库中可以加快存取速度；</li> <li>由于节点数在范围内可变，因此 B 树不需要像其他平衡二叉查找树那样经常进行平衡</li></ol> <p>定义：一棵 m 阶 B 树的定义：</p> <ol><li>每个节点最多有 <code>m-1</code> 个 key；</li> <li>根节点最少可以只有 <code>1</code> 个 key，非根节点至少有 <code>m/2</code> 个 key（根节点的 key 数量范围：<code>[1, m-1]</code>，非根节点的 key 数量范围：<code>[m/2, m-1]</code>。）；</li> <li>每个节点中的 key 都按照从小到大的顺序排列，每个 key 的左子树中的所有 key 都小于它，而右子树中的所有 key 都大于它；</li> <li>所有叶子节点都位于同一层（即根节点到每个叶子节点的长度都相同）；</li> <li>每个节点都存有索引和数据，也就是对应的 key 和 value。</li></ol> <p>B 树插入的规则：<strong>插入的时候，判断当前结点key的个数是否小于等于 <code>m-1</code>，如果满足，直接插入即可，如果不满足，将节点的中间的 key 将这个节点分为左右两部分，中间的节点放到父节点中即可。</strong></p> <h4 id="b-树-2"><a href="#b-树-2" class="header-anchor">#</a> B+ 树</h4> <p>B+ 树具有上述 B 树的前四个特点。除此之外，B+ 树还有以下特点：</p> <ol><li>B 树的所有结点都存储数据，而 B+ 树只有叶子结点存储数据，内部节点（或非叶子结点、索引节点）只存放索引。在节点空间大小一定的前提下，B+ 树一个结点能存的索引数远大于 B 树一个结点能存的数据的量，这使得 B+ 树的高度远低于 B 树。</li> <li>B+ 树每个叶子结点存有下一个叶子结点的指针，而 B 树无，所以<strong>所有叶子结点形成了一条有序链表</strong>，遍历整棵树只需要遍历链表，而不需要从树根往下遍历。</li></ol> <p>B+ 树较 B 树的优点就是遍历快吧。</p> <h3 id="慢查询"><a href="#慢查询" class="header-anchor">#</a> 慢查询</h3> <p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener noreferrer">MySQL索引原理及慢查询优化- 美团技术团队<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>慢查询：超过指定时间的 SQL 语句查询。</p> <p>优化方法：</p> <ol><li>使用 <code>explain</code> 语句查看慢查询的查询过程（有无使用索引等）</li> <li>添加索引、修改索引（如先查区分度大的）</li> <li>分库、分表</li></ol> <h3 id="聚簇索引-非聚簇索引"><a href="#聚簇索引-非聚簇索引" class="header-anchor">#</a> 聚簇索引 &amp; 非聚簇索引</h3> <p><img src="/images/4489820786c2c39801d2488fac6c238e8963a52f2cb7efcd623cd0f8ee3eba66.png" alt="聚簇索引 &amp; 非聚簇索引"></p> <p>InnoDB 主键使用的是聚簇索引。</p> <ul><li><strong>非聚簇索引</strong>（二级索引、辅助索引）：表数据和索引分成两部分存储，叶子结点存<strong>主键</strong>和<strong>索引键</strong></li> <li><strong>聚簇索引</strong>：表数据和主键一起存储，主键索引的叶子结点存<strong>行数据 (包含主键值)</strong></li></ul> <p>聚簇索引的优点简单说就是三个字：查询快</p> <ol><li>查询非主键数据时，使用非聚簇索引查询到主键后，还需要使用聚簇索引查询数据</li> <li>非聚簇索引查询主键时不需要进行二次查询，查询其他键时需要二次查询</li> <li>查询范围的数据时，如果命中的是聚簇索引可以一并把范围内的数据取出来，但命中的是非聚簇索引的话需要再在聚簇索引中查询多次</li></ol> <p>聚簇索引的缺点简单的说也是三个字：插入、更新慢</p> <ol><li>插入速度依赖插入顺序，如果是随机插入在表中间，插入的过程会很慢；如果直接插入到表末尾的话就会比较快</li> <li>更新主键慢，因为需要移动被更新的行</li></ol> <h3 id="innodb-为什么推荐使用-auto-increment-作为主键"><a href="#innodb-为什么推荐使用-auto-increment-作为主键" class="header-anchor">#</a> InnoDB 为什么推荐使用 auto_increment 作为主键</h3> <ol><li>auto_increment 保证能新加入的数据的主键永远是最大的，加入的数据会被放在最后。在写入量大的时候，插入数据时是连续写入，而不是随机 I/O</li> <li>auto_increment 使得主键和业务分离，这样即便业务上出现调整，也不需要重构数据库</li></ol> <h3 id="回表、索引覆盖、索引下推"><a href="#回表、索引覆盖、索引下推" class="header-anchor">#</a> 回表、索引覆盖、索引下推</h3> <p>参考：</p> <blockquote><p><a href="https://zhuanlan.zhihu.com/p/401198674" target="_blank" rel="noopener noreferrer">在Mysql中，什么是回表，什么是覆盖索引，索引下推？ - 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://segmentfault.com/a/1190000039869289" target="_blank" rel="noopener noreferrer">第26期：索引设计（索引下推） - SegmentFault 思否<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="回表"><a href="#回表" class="header-anchor">#</a> 回表</h4> <p>回表的概念是和非聚簇索引相关的。<strong>非聚簇索引</strong>只存储了主键和索引键，查询时如果用到了某个索引，但需要查询的字段不全在索引上，就需要回到<strong>聚簇索引</strong>的这张表上再查一遍。</p> <p>举个栗子：一个表上有主键 <code>id</code>、字段 <code>name</code>（建立了关于 <code>name</code> 的索引）、另外还有普通字段 <code>gender</code> 和 <code>phone</code>。</p> <p>如果我们 <code>SELECT id FROM table WHERE name = 'query'</code>，在索引表上查到满足条件的 <code>name</code> 和 <code>id</code> 就够了，不需要回表；</p> <p>如果改为 <code>SELECT gender FROM table WHERE name = 'query'</code>，则需要回表。</p> <h4 id="索引覆盖"><a href="#索引覆盖" class="header-anchor">#</a> 索引覆盖</h4> <p>索引覆盖是解决回表的方法。如果我们把 <code>name</code> 的索引改为 <code>(name, gender)</code> 的联合索引，同样是 <code>SELECT gender FROM table WHERE name = 'query'</code> 的查询就能在索引表上直接查到满足条件的 <code>gender</code>，避免了回表的操作。</p> <h4 id="索引下推"><a href="#索引下推" class="header-anchor">#</a> 索引下推</h4> <p>索引下推是 MySQL 5.6 起引入的一个内部优化。</p> <p>假设现在的索引是 <code>(name, gender)</code>，需要查询的语句为</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span>
    <span class="token keyword">FROM</span> <span class="token keyword">table</span>
    <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'query'</span> 
        <span class="token operator">AND</span> gender <span class="token operator">=</span> <span class="token number">2</span> 
        <span class="token operator">AND</span> phone <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
</code></pre></div><p>索引查询时，如果没有索引下推，则根据最左匹配原则，索引会筛选出 <code>name = 'query'</code> 条件对应的 <code>id</code>，然后回表，在主表中使用 <code>gender = 2 AND phone IS NOT NULL</code> 过滤结果。</p> <p>这里的问题在于，索引既然包含 <code>gender</code> 字段，在索引表里其实可以使用 <code>name = 'query' AND gender = 2</code> 进行筛选，减少回表的数据量，在回表中再使用 <code>phone IS NOT NULL</code> 过滤结果。<strong>索引下推</strong>就是这样一个作用：尽量充分利用索引表进行筛选，最后再在主表中完成剩余的筛选。</p> <h3 id="事务的-acid"><a href="#事务的-acid" class="header-anchor">#</a> 事务的 ACID</h3> <p>ACID，是指数据库管理系统 (DBMS) 在写入或更新资料的过程中，为保证事务 (transaction) 是正确可靠的，所必须具备的四个特性：</p> <ul><li>原子性 (atomicity)：一个事务要么全做要么全不做；</li> <li><strong>一致性</strong> (consistency)：数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。最常见的例子是转帐：从帐户 A 转一笔钱到帐户 B 上，如果帐户 A 上的钱减少了，而帐户 B 上的钱却没有增加，那么我们认为此时数据处于不一致的状态；</li> <li>隔离性 (isolation)：一个事务不影响其他事务的运行效果；</li> <li>持久性 (durability)：事务一旦提交，则其结果就是永久性的，即使故障也能恢复。</li></ul> <p>从数据库层面，数据库通过原子性、隔离性、持久性来保证<strong>一致性</strong>。也就是说 ACID 四大特性之中，C 是目的，AID 是手段，是为了保证一致性，数据库提供的手段。</p> <h3 id="事务的原子性和持久性的保证"><a href="#事务的原子性和持久性的保证" class="header-anchor">#</a> 事务的原子性和持久性的保证</h3> <ol><li>将所有事务开始、提交、终止，以及数据的更新操作（记录数据更新前的值即前像，或更新后的值即后像）计入 log</li> <li>系统崩溃后重启，先读取日志对已提交的事务进行 REDO（保证持久性）</li> <li>然后对尚未提交的的事务进行 UNDO（保证原子性）</li></ol> <h3 id="innodb-事务隔离级别"><a href="#innodb-事务隔离级别" class="header-anchor">#</a> InnoDB 事务隔离级别</h3> <p><a href="https://developer.ibm.com/zh/technologies/databases/articles/os-mysql-transaction-isolation-levels-and-locks/" target="_blank" rel="noopener noreferrer">MySQL 事务隔离级别和锁– IBM Developer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>SQL 标准定义了四种隔离，隔离程度由低到高依次为：</p> <ul><li><strong>读未提交</strong>/<strong>脏读</strong>：未提交事务的数据也可以被读，这也被称为脏读；</li> <li><strong>读提交</strong>/<strong>不可重复读</strong>：提交了的东西就可以被读，但若一个事务两次读取过程中，有事务更新了数据，会导致不可重复读；</li> <li><strong>可重复读</strong>/<strong>幻读</strong>（默认）：同一个事务中，<code>select</code> 的结果是事务开始时的状态，因此可重复读。但由于 <code>insert</code> 语句等不受影响，所以可能出现幻读（本事务开始后，别的事务提交了数据 <code>pk=1</code>，本事务 <code>select</code> 不到 <code>pk=1</code>，但 <code>insert pk=1</code> 会报错主键冲突，像是读到了幽灵）</li> <li><strong>序列化</strong>：如果要完全解决上面的三种问题，就只能让事务串行化了，也就是把多个事务变成一个序列。</li></ul> <table><thead><tr><th>有/无问题</th> <th>脏读</th> <th>不可重复读</th> <th>幻读</th></tr></thead> <tbody><tr><td>读未提交</td> <td>有</td> <td>有</td> <td>有</td></tr> <tr><td>读提交</td> <td>无</td> <td>有</td> <td>有</td></tr> <tr><td>可重复读</td> <td>无</td> <td>无</td> <td>有</td></tr> <tr><td>序列化</td> <td>无</td> <td>无</td> <td>无</td></tr></tbody></table> <h4 id="数据库并发控制"><a href="#数据库并发控制" class="header-anchor">#</a> 数据库并发控制</h4> <p>见 <a href="/posts/2021-07-21-database-concurrency-control/1-transactions.html">数据库并发控制</a>。</p> <h2 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h2> <h3 id="osi-七层"><a href="#osi-七层" class="header-anchor">#</a> OSI 七层</h3> <p>就是把 TCP/IP 五层中的“应用层”拓展为（自底向上）“会话层”、“表示层（加密相关，如 TLS）”、“应用层”。</p> <div class="language- extra-class"><pre class="language-text"><code>应用层（例：HTTP 协议）
表示层（例：TLS 协议）
会话层
传输层（例：TCP 协议）
网络层（例：IP 协议）
链路层（例：OCSP 协议）
物理层
</code></pre></div><h3 id="tcp-三次握手与四次挥手"><a href="#tcp-三次握手与四次挥手" class="header-anchor">#</a> TCP 三次握手与四次挥手</h3> <p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B" target="_blank" rel="noopener noreferrer">TCP 三次握手与四次挥手<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>三次握手：</p> <ol><li>客户端：发送 <code>SYN</code>，进入 <code>SYN_SENT</code> 状态</li> <li>服务器：收到包后发送 <code>SYN ACK</code>，进入 <code>SYN_RCVD</code> 状态</li> <li>客户端：收到包后发送 <code>ACK</code>，进入 <code>ESTABLISHED</code> 状态（服务器接收后也进入 <code>ESTABLISHED</code> 状态）</li></ol> <p>三个包的 <code>seq</code> 和 <code>ACKnum</code> 数值有如下关系：</p> <ul><li><code>SYN ACK</code> 的 ACKnum = <code>SYN</code> 的 seq+1</li> <li><code>ACK</code> 的 ACKnum = <code>SYN ACK</code> 的 seq+1</li></ul> <p><img src="/images/11828738d7578e6fa82c6f0b1eb4ddbb974924935c80003fc0d892acbd66d8f0.png" alt="TCP 三次握手"></p> <hr> <p>四次挥手并不一定是客户端发起，也可以由服务端发起。故下面用 <code>主动关闭</code> 和 <code>被动关闭</code> 称呼：</p> <ol><li>主动关闭方：发送最后一个数据包后，发送 <code>FIN</code>，进入 <code>FIN_WAIT_1</code>；</li> <li>被动关闭方：收到包后发送 <code>ACK</code>，进入 <code>CLOSE_WAIT</code>；客户端收到后进入 <code>FIN_WAIT_2</code>，此时客户端到服务端的单方连接被关闭；</li> <li>被动关闭方：发送最后一个数据包后，发送 <code>FIN</code>，进入 <code>LAST_ACK</code>；</li> <li>主动关闭方：收到包后发送 <code>ACK</code>，进入 <code>TIME_WAIT</code>，一段时间后关闭通信；服务端收到后立即关闭通信。</li></ol> <p>可以理解为两对 <code>FIN - ACK</code>，且每个 <code>ACK</code> 的 ACKnum = 对方的 <code>FIN</code> 的 seq+1。</p> <ul><li><code>CLOSE_WAIT</code> 可以理解成对方主动关闭了连接，但本方还没有关闭，在等待关闭连接 (wait close)；</li> <li><code>TIME_WAIT</code> 首先发出 FIN 的一侧，如果给对侧的 FIN 响应了 ACK，那么就会超时等待 2*MSL 时间，然后关闭连接(time wait)。在这段超时等待时间内，本地的端口不能被新连接使用；避免延时的包的到达与随后的新连接相混淆。RFC793 定义了 MSL 为2分钟（即 <code>TIME_WAIT</code> 等待 4 分钟）。</li></ul> <p><img src="/images/TCP_CLOSE.svg" alt="TCP 四次挥手"></p> <p>被动关闭的一方也可以把 <code>ACK</code> 和 <code>FIN</code> 合并为 <code>FIN ACK</code>，实现三次挥手。</p> <h3 id="tcp-流量控制"><a href="#tcp-流量控制" class="header-anchor">#</a> TCP 流量控制</h3> <p><a href="https://zhuanlan.zhihu.com/p/37379780" target="_blank" rel="noopener noreferrer">TCP流量控制、拥塞控制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>流量控制：考虑到可能接收方处理的比较慢，需要限制发送方的发送速度。方法是，接收方发回的 ACK 中会包含自己接收窗口的大小。</li> <li>流量控制死锁：当发送者收到了一个窗口为 0 的应答，便停止发送，等待接收者的下一个应答。但如果之后接受者发送的窗口不为 0 的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</li> <li>流量控制死锁避免：TCP 使用持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器，时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为 0，则表示应答报文丢失了，此时重置发送窗口后开始发送。</li></ul> <h3 id="tcp-快速重传"><a href="#tcp-快速重传" class="header-anchor">#</a> TCP 快速重传</h3> <ul><li>在没有快速重传机制下，如果发送方的某报文丢失，即使接受方发送了多个重复确认，发送方仍需等待重传计时器到期才会重传；</li> <li>快速重传机制下，发送方一旦收到三个重复确认，就重传报文，无需等待计时器到期。</li></ul> <h3 id="tcp-拥塞控制"><a href="#tcp-拥塞控制" class="header-anchor">#</a> TCP 拥塞控制</h3> <p><a href="https://zhuanlan.zhihu.com/p/37379780" target="_blank" rel="noopener noreferrer">TCP流量控制、拥塞控制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>发送方维持一个变量：拥塞窗口 (congestion window, cwnd)，取决于网络拥塞情况，且动态变化。</p> <p>发送方使自己的发送窗口为 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>w</mi><mi>n</mi><msub><mi>d</mi><mtext>接收方</mtext></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min(cwnd, wnd_\text{接收方})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">接收方</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。</p> <ul><li>慢启动阶段，<code>cwnd=1</code>，每成功传输一次则 <code>cwnd*=2</code>，直至 cwnd 到达慢启动阈值 (slow-start threshold, ssthresh)，进入拥塞避免状态。</li> <li>拥塞避免状态，每成功传输一次则 <code>cwnd++</code></li> <li>任何时刻，出现发送方对某报文的计时器超时，令 <code>ssthresh=cwnd/2，cwnd=1</code>，重新进入慢启动</li> <li><strong>快速恢复</strong>：任何时刻，出现发送方接收到三个重复确认，并不按照上一条执行，而是令 <code>ssthresh=cwnd/2, cwnd=cwnd/2+3</code>，进入拥塞避免状态（能收到重复报文，说明网络没那么拥堵，超时才是真的拥堵）</li></ul> <h3 id="用户从输入域名到获取到信息过程中发生了什么"><a href="#用户从输入域名到获取到信息过程中发生了什么" class="header-anchor">#</a> 用户从输入域名到获取到信息过程中发生了什么</h3> <ol><li><p>DNS 解析的过程：计算机先检查 DNS 缓存，如果没有缓存则向 DNS 服务器查询域名对应的 IP，查询的过程分为迭代和递归两种方式（主机向本地域名服务器查询是递归查询，本地域名服务器查询是迭代查询）；面试官接着问了 DNS 基于什么协议，答案是 UDP，服务器一般使用 53 端口；</p></li> <li><p>获取到 IP 以后就可以发包了，需要对包进行一层层的封装，自顶向下的封装顺序为：HTTP、TLS、TCP、IP；</p></li> <li><p>HTTP 协议的内容大致为 <code>HTTP/1.1 GET /</code>；</p></li> <li><p>TLS 协议会进行 TLS 握手，主要是客户端、服务端交换密钥；</p></li> <li><p>再往下是 TCP 和 UDP 协议。经典一问：TCP 和 UDP 的区别（TCP 面向连接、拥塞控制、流量控制），顺便还简单问了一下拥塞控制；</p></li> <li><p>再往下就是 IP 层，主机会向向路由器发 IP 包、路由器根据路由表（用到了最长前缀匹配原则）和选路算法进行转发的过程；面试官又问了有那些选路算法（分为域内和域间协议，域内有 OSPF 和 RIP，域间使用 BGP）；</p></li> <li><p>再往下就是物理层了。</p></li> <li><p>服务器返回 HTML 内容，前端接收到后开始渲染：</p> <ul><li>构建 DOM 树</li> <li>构建 CSS 规则树</li> <li>构建 render 树</li> <li>布局（计算 element 在屏幕的位置）</li> <li>绘制：使用 UI 绘制每个 element</li></ul></li></ol> <p><img src="/images/fdfb246461cb6e8d89e1936746795f5614bbe013dc2aacac2801b1c9e6919686.png" alt="浏览器渲染过程"></p> <ol start="9"><li>执行 JS 代码</li> <li>如果有引用到其它地方的图片、JS、CSS 会再次进行 HTTP 请求，进行获取。</li></ol> <h2 id="操作系统"><a href="#操作系统" class="header-anchor">#</a> 操作系统</h2> <h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="header-anchor">#</a> 进程和线程的区别</h3> <ul><li><strong>调度并分派的单位</strong>称为<strong>线程</strong>（或轻量级进程 <code>LWP</code>）</li> <li><strong>资源所有权的单位</strong>称为<strong>进程</strong></li></ul> <p>进程会创建进程控制块 (PCB)，而线程是线程控制块 (TCB)。由于线程没有父子进程、资源控制等结构，所以 TCB 比 PCB 简单得多，这也导致线程的创建比进程的创建快得多，大概有一个数量级的区别。</p> <p>这也是平时开发中，为了利用 CPU 多线程，我们常使用多线程开发，而不是多进程开发的原因。</p> <h3 id="用户态和内核态的区别-这样有什么好处"><a href="#用户态和内核态的区别-这样有什么好处" class="header-anchor">#</a> 用户态和内核态的区别，这样有什么好处</h3> <ul><li>用户模式：优先权较少，用于运行用户程序</li> <li>内核模式：优先权更高，用于运行内核，且某些指令、内存只能在特权模式下运行/访问，如：
<ul><li>读取/修改 PSW 等控制<strong>寄存器</strong></li> <li>原始 <strong>I/O</strong> 指令</li> <li><strong>内存</strong>管理相关</li></ul></li></ul> <p>区分用户模式和内核模式的原因：<strong>保护 OS 和重要操作系统表不受程序干扰</strong></p> <h3 id="用户级线程和内核级线程"><a href="#用户级线程和内核级线程" class="header-anchor">#</a> 用户级线程和内核级线程</h3> <p><img src="/images/1ff352e0972f8ffc505e4894c7b735ea5cd53cebaa644755185f2a07ab9a2479.png" alt="用户级线程和内核级线程"></p> <ul><li>用户级线程：线程、线程的创建、销毁全部由库函数实现。<strong>内核不知道用户级线程的存在，依旧按照进程为单位进行调度</strong>。
<ul><li>优点：线程切换不需要内核模式，快；调度策略因应用程序不同而不同；可以运行在任何操作系统上</li> <li>缺点：系统调用将阻塞同一进程中的其他线程；不能利用多处理器技术</li></ul></li> <li>内核级线程：管理线程的所有工作均由内核完成。 Windows是这种方法的一个例子。
<ul><li>优点：ULT 两个缺点反过来说；内核本身也可以是多线程的</li> <li>缺点：ULT 三个优点反过来说；</li></ul></li></ul> <h3 id="进程七状态"><a href="#进程七状态" class="header-anchor">#</a> 进程七状态</h3> <ul><li>运行</li> <li>就绪</li> <li>阻塞</li> <li>就绪/挂起</li> <li>阻塞/挂起</li> <li>New</li> <li>Exit</li></ul> <h3 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="header-anchor">#</a> 僵尸进程和孤儿进程</h3> <p>二者都是进程派生后，父子进程其中一个退出的情况。僵尸进程是子进程退出，孤儿进程是父进程退出。</p> <p>孤儿进程：父进程派生出子进程。父进程退出，但子进程还在运行，子进程就被称为孤儿进程。Unix 系统下，孤儿进程会被 <code>init</code> 进程收养，并在孤儿进程退出后由 <code>init</code> 进程对它们完成状态收集工作。孤儿进程没有什么危害。</p> <p>僵尸进程：父进程 <code>fork</code> 出子进程。子进程退出，父进程并没有获取子进程的状态信息，子进程的进程描述符仍然留在系统中，子进程被称为僵尸进程，在 htop 的状态一栏会被标记为 <code>Z</code>。大量僵尸进程会占用内存空间，需要把父进程 kill 掉，僵尸进程转为孤儿进程，进而被 <code>init</code> 回收。</p> <h3 id="进程调度算法"><a href="#进程调度算法" class="header-anchor">#</a> 进程调度算法</h3> <ul><li>先来先服务 <code>First Come First Served, FCFS</code></li> <li>时间片轮转 <code>Round Robin, RR</code></li> <li>短进程优先 <code>Shortest Process Next, SPN</code></li> <li>剩余时间最短优先 <code>Shortest Remaining Time, SRT</code></li> <li>响应比高者优先 <code>Highest Response Ratio Next, HRRN</code></li> <li>反馈 <code>Feedback</code></li></ul> <h3 id="进程切换算法"><a href="#进程切换算法" class="header-anchor">#</a> 进程切换算法</h3> <ul><li>保存处理器上下文（寄存器）</li> <li>更新当前进程的 PCB（状态、数据结构等变化）</li> <li>将 PCB 的指针移至相应队列（就绪、阻塞、挂起等）</li> <li>选择另一进程执行</li></ul> <h3 id="中断是什么-软硬中断的区别是什么"><a href="#中断是什么-软硬中断的区别是什么" class="header-anchor">#</a> 中断是什么，软硬中断的区别是什么</h3> <ul><li>中断：CPU 接受到<strong>外围硬件的异步信号</strong> or <strong>软件的同步信号</strong>，进行响应的软硬件处理</li> <li>硬中断：CPU 接受到外围硬件的异步信号</li> <li>软终端：CPU 接受到软件的同步信号（多为硬终端处理程序或进程调度程序发出）</li> <li>区别：
<ul><li>硬中断会有<strong>中断控制器</strong>参与，外设-&gt;中断控制器-&gt;通过CPU针脚告诉CPU</li> <li>软中断使用 <strong>CPU 指令</strong>触发</li> <li>硬中断速度快</li> <li>硬中断可以通过设置 <strong>CPU 屏蔽位</strong>来屏蔽</li></ul></li></ul> <h3 id="线程间通信方式"><a href="#线程间通信方式" class="header-anchor">#</a> 线程间通信方式</h3> <p>同一进程的线程共享内存地址空间，没有必要依赖 OS 进行通信，但要做好同步/互斥，保护共享的全局变量。</p> <ol><li>锁机制：三种常见的锁的实现包括互斥锁、读写锁、条件变量</li></ol> <ul><li>互斥锁：提供了以排他方式防止数据结构被并发修改的方法</li> <li>读写锁：允许多个线程同时读共享数据，而对写操作是互斥的</li> <li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止（对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用）</li></ul> <ol start="2"><li>信号量 (Semaphore)</li> <li>信号机制 (Signal)：类似进程间的信号处理</li></ol> <h3 id="进程间通信方式"><a href="#进程间通信方式" class="header-anchor">#</a> 进程间通信方式</h3> <p><a href="https://www.cnblogs.com/luo77/p/5816326.html" target="_blank" rel="noopener noreferrer">进程间通信的方式——信号、管道、消息队列、共享内存 - 0giant - 博客园<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol><li>管道(Pipe)，分为无名管道和有名管道，无名管道只能在父子进程或兄弟进程间通信，而有名管道就没有这个限制</li> <li>信号(Signal)</li> <li>消息队列(Message Queue)</li> <li>共享内存(Shared Memory)</li> <li>信号量(Semaphore)</li> <li>套接字(Socket)</li></ol> <p>记住上面的六个词就可以对付 90% 的面试了，7% 的可能会问一下有名管道和无名管道的区别，剩下 3% 的面试可能每个都会问一下。</p> <h3 id="如何保证缓存一致性"><a href="#如何保证缓存一致性" class="header-anchor">#</a> 如何保证缓存一致性</h3> <p>缓存一致性就是保证内存和 CPU 缓存中的内容相同。</p> <p>实现上有两种方案：<code>Write-Through</code> 和 <code>Write-back</code>。</p> <p><code>Write-Through</code> 在每次 CPU 更新缓存时会同时更新对应的内存，即把对缓存的更新穿透（through）到内存。</p> <p><code>Write-Back</code> 在每一行的缓存用一个 <code>modified</code> 标记了是否被修改。当这行缓存被修改时，不立即写入内存，而是标记该行缓存为 <code>modified</code>。当这行缓存将被替换时，就image.png会将这行内容写回（back）内存。</p> <p>值得一提的是，这两种更新策略在使用 Redis 对数据库进行缓存时也会用于保证缓存一致性。编写一个 <code>Cache Provider</code> 提供对缓存和数据库的查询，程序不直接查询 Redis 或数据库，而是调用 <code>Cache Provider</code> 提供的接口进行读写，<code>Cache Provider</code> 可选择 <code>Write-Through</code> 或 <code>Write-back</code> 方案实现缓存一致性。</p> <h2 id="开发"><a href="#开发" class="header-anchor">#</a> 开发</h2> <h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="header-anchor">#</a> 深拷贝和浅拷贝</h3> <ul><li>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li> <li>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</li></ul> <p><img src="/images/605a9d2f21aeff216aacc4e08072cdddba4ba0ca9d0b60e3759c75a88e1a31dd.png" alt="浅拷贝"></p> <p><img src="/images/e3af0f7454816313bae5f86994a8eddbf0e052b007b1d7acf54ba27781e86f99.png" alt="深拷贝"></p> <h3 id="如何进行调试"><a href="#如何进行调试" class="header-anchor">#</a> 如何进行调试</h3> <ul><li>利用标准输出 / log 调试；</li> <li>利用 IDE 单步调试；</li> <li>利用 <code>assert</code> 语句调试。</li></ul> <h3 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h3> <p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528" target="_blank" rel="noopener noreferrer">设计模式- 廖雪峰的官方网站<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <table><thead><tr><th>范围/目的</th> <th>创建型模式</th> <th>结构型模式</th> <th>行为型模式</th></tr></thead> <tbody><tr><td>类模式</td> <td>工厂方法</td> <td>(类）适配器</td> <td>模板方法、解释器</td></tr> <tr><td>对象模式</td> <td>单例<br>原型<br>抽象工厂<br>建造者</td> <td>代理<br>(对象）适配器<br>桥接<br>装饰<br>外观<br>享元<br>组合</td> <td>策略<br>命令<br>职责链<br>状态<br>观察者<br>中介者<br>迭代器<br>访问者<br>备忘录</td></tr></tbody></table> <h4 id="设计模式的原则"><a href="#设计模式的原则" class="header-anchor">#</a> 设计模式的原则</h4> <ul><li>开闭原则：对扩展开放、对修改关闭</li> <li><a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" target="_blank" rel="noopener noreferrer">里氏替换原则<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：如果对父类的调用可以成功，对子类的调用也应该成功，这也是面向对象编程的基础</li></ul> <h4 id="创建型模式"><a href="#创建型模式" class="header-anchor">#</a> 创建型模式</h4> <blockquote><p>工厂方法：工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>┌─────────────┐      ┌─────────────┐
│   Product   │      │   Factory   │
└─────────────┘      └─────────────┘
       ▲                    ▲
       │                    │
┌─────────────┐      ┌─────────────┐
│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │
└─────────────┘      └─────────────┘
</code></pre></div><blockquote><p>抽象工厂：抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>                                ┌────────┐
                             ─ &gt;│ProductA│
┌────────┐    ┌─────────┐   │   └────────┘
│ Client │─ ─&gt;│ Factory │─ ─
└────────┘    └─────────┘   │   ┌────────┐
                   ▲         ─ &gt;│ProductB│
           ┌───────┴───────┐    └────────┘
           │               │
      ┌─────────┐     ┌─────────┐
      │Factory1 │     │Factory2 │
      └─────────┘     └─────────┘
           │   ┌─────────┐ │   ┌─────────┐
            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│
           │   └─────────┘ │   └─────────┘
               ┌─────────┐     ┌─────────┐
           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│
               └─────────┘     └─────────┘
</code></pre></div><blockquote><p>生成器模式（Builder）：使用多个“小型”工厂来最终创建出一个完整对象。</p></blockquote> <blockquote><p>原型模式（Prototype）：创建新对象的时候，根据现有的一个原型来创建。</p></blockquote> <blockquote><p>单例模式（Singleton）：保证在一个进程中，某个类有且仅有一个实例。</p></blockquote> <h4 id="结构型模式"><a href="#结构型模式" class="header-anchor">#</a> 结构型模式</h4> <blockquote><p>适配器（Adapter）：转换器，即负责将 A 类转换为 B 类的类</p></blockquote> <p><code>InputStreamReader</code> 就是 Java 标准库提供的 Adapter，它负责把一个 <code>InputStream</code> 适配为 <code>Reader</code>。类似的还有 <code>OutputStreamWriter</code>。</p> <blockquote><p>桥接模式（Bridge）：不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>桥接前：

                   ┌───────┐
                   │  Car  │
                   └───────┘
                       ▲
    ┌──────────────────┼───────────────────┐
    │                  │                   │
┌───────┐          ┌───────┐          ┌───────┐
│BigCar │          │TinyCar│          │BossCar│
└───────┘          └───────┘          └───────┘
    ▲                  ▲                  ▲
    │                  │                  │
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │
      └───────────────┘  └───────────────┘  └───────────────┘

桥接后：

       ┌───────────┐
       │    Car    │
       └───────────┘
             ▲
             │
       ┌───────────┐       ┌─────────┐
       │RefinedCar │ ─ ─ ─&gt;│ Engine  │
       └───────────┘       └─────────┘
             ▲                  ▲
    ┌────────┼────────┐         │ ┌──────────────┐
    │        │        │         ├─│  FuelEngine  │
┌───────┐┌───────┐┌───────┐     │ └──────────────┘
│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐
└───────┘└───────┘└───────┘     ├─│ElectricEngine│
                                │ └──────────────┘
                                │ ┌──────────────┐
                                └─│ HybridEngine │
                                  └──────────────┘
</code></pre></div><blockquote><p>组合（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    <span class="token comment">// 添加一个节点为子节点:</span>
    <span class="token class-name">Node</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取子节点:</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> <span class="token function">children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输出为XML:</span>
    <span class="token class-name">String</span> <span class="token function">toXml</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。类似于这样的方法 <code>A decorator(A a);</code>。<br>
顺带一提，Python 的装饰器就玩得很好。</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 创建原始的数据源:</span>
<span class="token class-name">InputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;test.gz&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 增加缓冲功能:</span>
<span class="token class-name">InputStream</span> bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 增加解压缩功能:</span>
<span class="token class-name">InputStream</span> gis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GZIPInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 或者一次性写成这样：</span>
<span class="token class-name">InputStream</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GZIPInputStream</span><span class="token punctuation">(</span> <span class="token comment">// 第二层装饰</span>
                        <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span> <span class="token comment">// 第一层装饰</span>
                            <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;test.gz&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 核心功能</span>
                        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>外观模式（Facade）：将复杂的流程包装成一个函数并暴露给调用方。</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 将 register, openAccount, applyTaxCode 三个步骤包装成一个函数</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Facade</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Company</span> <span class="token function">openCompany</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Company</span> c <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>admin<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> bankAccount <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>bank<span class="token punctuation">.</span><span class="token function">openAccount</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token punctuation">.</span><span class="token function">setBankAccount</span><span class="token punctuation">(</span>bankAccount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> taxCode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taxation<span class="token punctuation">.</span><span class="token function">applyTaxCode</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token punctuation">.</span><span class="token function">setTaxCode</span><span class="token punctuation">(</span>taxCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>享元模式（Flyweight）：通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。如 <code>Integer.valueOf()</code>。</p></blockquote> <blockquote><p>代理模式（Proxy）：将 A 接口转换成 A 接口，可在调用 A 的方法前后加一些额外的代码，实现对 A 的控制。</p></blockquote> <h5 id="装饰器和代理的区别"><a href="#装饰器和代理的区别" class="header-anchor">#</a> 装饰器和代理的区别</h5> <p><a href="https://zhuanlan.zhihu.com/p/97499017" target="_blank" rel="noopener noreferrer">代理模式和装饰器模式的区别 - 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>装饰器和代理很相似，都是接收 A 接口，返回 A 接口。其区别主要是思想上的区别：</p> <p><strong>装饰模式</strong>是为装饰的对象<strong>增强功能</strong>；</p> <p>而<strong>代理模式</strong>对代理的对象施加<strong>控制</strong>，但不对对象本身的功能进行增强；</p> <h4 id="行为型模式"><a href="#行为型模式" class="header-anchor">#</a> 行为型模式</h4> <blockquote><p>责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>     ┌─────────┐
     │ Request │
     └─────────┘
          │
┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐
          ▼
│  ┌─────────────┐  │
   │ ProcessorA  │
│  └─────────────┘  │
          │
│         ▼         │
   ┌─────────────┐
│  │ ProcessorB  │  │
   └─────────────┘
│         │         │
          ▼
│  ┌─────────────┐  │
   │ ProcessorC  │
│  └─────────────┘  │
          │
└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘
          │
          ▼
</code></pre></div><blockquote><p>命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。好处是可以对请求排队、记录请求日志，以及支持可撤销的操作。</p></blockquote> <blockquote><p>解释器模式（Interpreter）：如 Python 解释器、正则表达式匹配等。</p></blockquote> <blockquote><p>迭代器模式（Iterator）</p></blockquote> <blockquote><p>中介模式（Mediator）：在多个组件的相互交互中，添加一个中介，所有组件和中介交互，实现组件间的松耦合。</p></blockquote> <blockquote><p>备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。简单的实现是，编写这个类的 <code>getState()</code> 和 <code>setState()</code> 方法，负责导出、导入信息即可。</p></blockquote> <blockquote><p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe, Pub/Sub）：发布方搞一个 <code>Observer</code> 数组；订阅操作就是将订阅者加入数组中；当发布方需要告知订阅者时，对数组中每个对象调用通知方法 <code>void onEvent(Event event);</code> 即可。</p></blockquote> <blockquote><p>状态（State）</p></blockquote> <blockquote><p>策略（Stategy）：即排序算法时使用的 Comparator</p></blockquote> <blockquote><p>模板方法（Template Method）：使用抽象类定义流程，流程中的部分细节让子类实现</p></blockquote> <blockquote><p>访问者（Visitor）：包含对不同种类东西的访问方法（也可以理解成回调函数），如对文件和文件夹的访问方法</p></blockquote> <h2 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h2> <h3 id="缓存穿透、击穿、雪崩"><a href="#缓存穿透、击穿、雪崩" class="header-anchor">#</a> 缓存穿透、击穿、雪崩</h3> <ul><li>缓存雪崩：大批数据的缓存同时过期，大量请求打到数据库，造成整个数据库服务崩溃（依赖该数据库的其他服务也接连崩溃）
<ul><li>预防方法：设置过期时间时加一个随机量</li> <li>抢救方法：<strong>熔断机制</strong>，当流量达到阈值时拒绝请求，至少让一部分请求能正常工作，其他用户刷新几次也能得到结果</li></ul></li> <li>缓存击穿：某一条热点数据过期的瞬间， 大量请求打到数据库，造成整个数据库服务崩溃
<ul><li>预防方案：设置热点数据不过期，或使用互斥锁，降低请求同一条数据的并发量</li></ul></li> <li>缓存穿透：大量请求中 key 不存在，缓存自然不存在，导致大量请求打到数据库
<ul><li>预防方案：将无效的 key 存到 Redis 中；使用<a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" target="_blank" rel="noopener noreferrer">布隆过滤器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（即多重哈希表）。</li></ul></li></ul> <h3 id="redis-除了缓存还能做什么"><a href="#redis-除了缓存还能做什么" class="header-anchor">#</a> Redis 除了缓存还能做什么</h3> <p><a href="https://www.dounaite.com/article/625a3924ae87fd3f79645efd.html" target="_blank" rel="noopener noreferrer">Redis除了做缓存，还能做什么 - 豆奶特<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="消息队列"><a href="#消息队列" class="header-anchor">#</a> 消息队列</h2> <h3 id="消息队列的好处"><a href="#消息队列的好处" class="header-anchor">#</a> 消息队列的好处</h3> <p><a href="https://javaguide.cn/high-performance/message-queue/message-queue.html#%E4%BA%8C-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" target="_blank" rel="noopener noreferrer">消息队列基础常见面试题总结 | JavaGuide<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol><li>减少系统响应时间（不再等待请求数据成功，而是直接返回）</li> <li>削峰/限流</li> <li>降低系统耦合性（模块之间不再直接调用，而是从 MQ 里存取数据）</li></ol> <h3 id="消息队列模型"><a href="#消息队列模型" class="header-anchor">#</a> 消息队列模型</h3> <p>比较常见的就是：点对点模式（一个生产者对一个消费者）、发布/订阅（一个生产者对多个消费者）。</p> <h2 id="分布式"><a href="#分布式" class="header-anchor">#</a> 分布式</h2> <p><a href="https://javaguide.cn/distributed-system/theorem&amp;algorithm&amp;protocol/cap&amp;base-theorem.html#cap%E7%90%86%E8%AE%BA" target="_blank" rel="noopener noreferrer">分布式知识点 | JavaGuide<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="cap-理论"><a href="#cap-理论" class="header-anchor">#</a> CAP 理论</h3> <ul><li>C: Consistency (一致性), 所有节点返回相同的数据</li> <li>A: Availability (可用性), 非故障节点能够在合理的时间内返回正确的数据</li> <li>P: Partial Tolerance（分区容错性), 即使由于网络故障, 某些节点之间不能通信, 也能对外提供服务</li></ul> <p>CAP 理论简单的说就是：当发生网络分区时，一致性和可用性只能 2 选 1。也就是说，只能选 CP 或 AP。</p> <p><img src="/images/18f9c5b74e3f536860bf536ce0a8e51e51158b14b5b0fb988f7f3bad8476a645.png" alt="picture 5"></p> <p>以常见的可以作为注册中心的组件为例：</p> <ul><li>Zookeeper 保证 CP：任何时候读 Zookeeper 都能得到一致的结果，但不保证每次请求的可用性（如选举 leader 时，服务不可用）；</li> <li>Eureka 保证 AP：每个节点都都是平等的，都可以返回数据，但返回的数据不保证是最新的；</li> <li>Nacos 支持 CP 和 AP 两种模式。</li></ul> <h3 id="一致性理论-base-理论"><a href="#一致性理论-base-理论" class="header-anchor">#</a> 一致性理论 / BASE 理论</h3> <p>上面说到大多数分布式框架都是保证 CP 或者 AP 的。其实还有一种情况，在保证 P 的前提下，在 A 和 C 之间进行平衡。一致性理论抛弃了 C 的强一致性（任何时刻都一致），转为追求最终一致性（最后一致即可），并在这个平衡中获得了一部分的 A，这种 A 称为“主要可用”。</p> <p>一致性理论的三要素：</p> <ul><li>BA: Basically Available (基本可用), 响应时间可以变慢, 非核心功能可以不工作</li> <li>S: Soft state (软状态), 即数据从不一致到一致的过程的中间状态</li> <li>E: Eventually Consistent (最终一致性), 即系统保证一定时间内数据到达一致性</li></ul> <p>一致性分为三种级别，由强到弱依次为：强一致性、最终一致性、弱一致性：</p> <ol><li>强一致性：系统在任何时间的数据都是一致的</li> <li>最终一致性：系统保证一定时间内达到数据一致</li> <li>弱一致性：系统尽快达到数据一致（也就是没有做任何保证）</li></ol> <p>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</p> <p>最终一致性有三种实现：读时修复、写时修复、异步修复：</p> <ol><li>读时修复：系统读取数据时，如果检测到不一致，则进行修复</li> <li>写时修复：系统写入数据时，如果失败，则定时重传</li> <li>异步修复：系统定时对账，检测数据一致性</li></ol> <h3 id="raft-算法"><a href="#raft-算法" class="header-anchor">#</a> Raft 算法</h3> <p>Paxos 算法和 Raft 算法都是分布式系统共识算法。 Paxos 算法比较复杂，而 Raft 算法是基于 Paxos 算法改进而来，直接学习 Raft 算法即可。</p> <h4 id="共识算法的基本原理"><a href="#共识算法的基本原理" class="header-anchor">#</a> 共识算法的基本原理</h4> <p>共识算法的目标是：即使面对故障，多个服务器也能在共享状态上达成一致。</p> <p>为了达到这个目的，一般通过复制日志来实现。只要所有服务器的日志的内容和顺序都相同，就能保证它们执行了相同的命令，这对于确定性图灵机来说就是执行结果相同。</p> <h4 id="共识算法的特点"><a href="#共识算法的特点" class="header-anchor">#</a> 共识算法的特点</h4> <ul><li>安全</li> <li>高可用</li> <li>一致性不依赖时序（错误的时钟和消息延迟不会影响一致性，只可能影响可用性）</li> <li>不会被少数运行缓慢的服务器影响性能</li></ul> <h4 id="raft-算法-选举-leader"><a href="#raft-算法-选举-leader" class="header-anchor">#</a> Raft 算法 -- 选举 Leader</h4> <p>Raft 算法的核心为两个部分：<strong><code>选举 Leader</code> 和 <code>日志复制</code></strong>。</p> <p>集群里的每个服务器就称为一个节点。分为三种类型：</p> <ul><li><code>Leader</code>，即主服务器。被选举为 Leader 的服务器将在其任期内负责和客户端交互、将日志分发给 Follower。</li> <li><code>Candicate</code>，为 Leader 选举中的候选人。在<code>选举 Leader</code>期间，所有服务器都可以成为 Candidate 竞选 Leader。</li> <li><code>Follower</code> 即从服务器</li></ul> <hr> <p><strong>任期</strong>：Raft 算法将时间划分为多个任期（term），每个任期会用一个自增的数字 id 表示。每个任期开始时都需要竞选 Leader，成功当选的服务器会在该任期内担任 Leader。</p> <p>服务器间的交互都会带上任期号，确保交互的<strong>双方是在同一个任期内</strong>。如果某方的 <code>term</code> 较小，说明该服务器的信息过期了。</p> <ul><li>如果 Follower 发现本地的 <code>term</code> 过期了，则会更新到新的 <code>term</code>。</li> <li>如果 Leader 或 Candidate 发现本地的 <code>term</code> 过期了，则会退回为 Follower。</li> <li>如果服务器发现对方的 <code>term</code> 过期了，则会拒绝此次请求。</li></ul> <hr> <p>一个选举过程中可能出现以下几种情形：</p> <p><strong>给别人投票</strong>：如果一台 Follower 收到 Leader 或 Candidate 的心跳包，则会一直保持为 Follower。</p> <p><strong>参加选举</strong>：如果 Follower 一直没有收到（超时），则会开始一次选举：自增本地的 <code>term</code> 并变为 Candidate，并向其它服务器周期性发送心跳包。</p> <p><strong>选举成功</strong>：如果 Candidate 在一个任期内收到了集群内的过半选票，则成为 Leader。</p> <p><strong>Candidate 收到 Candidate 或 Leader 的心跳包</strong>：此时需要根据双方 <code>term</code> 大小分情况讨论：如果接收到的 <code>term</code> 大于或等于自身的 <code>term</code>，则本 Candidate 转化为 Follower 并对发送心跳包的服务器投票；如果接受到的 <code>term</code> 小于自身的 <code>term</code>，则拒绝该请求。</p> <p>如果同一时间出现多名 Candidate，导致没有 Candidate 获得大多数选票，导致多个服务器同时开始新一轮选票，就陷入了活锁。Raft 的解决方案是，每个服务器的每次超时都是随机的 <code>150ms~300ms</code>，于是最先超时的服务器会率先更新 <code>term</code>，并向其它服务器发送新 <code>term</code> 的心跳包。</p> <h4 id="raft-算法-日志复制"><a href="#raft-算法-日志复制" class="header-anchor">#</a> Raft 算法 -- 日志复制</h4> <p><strong>选举过程中服务器集群处于不可用的状态</strong>，因为没有 Leader。在完成选举后，选举出的 Leader 就会负责和客户端进行交互。</p> <p>日志复制的流程如下：</p> <p>Leader 收到客户端请求后，会生成一个<strong>条目</strong>（<code>entry</code>）。一个 <code>entry</code> 包含当前 <code>term</code>、一个自增的索引 <code>index</code> 和客户端的指令 <code>cmd</code>。</p> <p>生成 <code>entry</code> 后，Leader 将其追加到自己的日志末尾，并向所有节点广播该 <code>entry</code>，要求 Follower 也将其追加到自己的日志末尾。如果过半 Follower 接受该 <code>entry</code>，则 Leader 提交该 <code>entry</code>，将 <code>entry</code> 应用到自己的状态机中，并向客户端返回执行结果。</p> <hr> <p>Raft 算法保证日志的以下两个特性：</p> <ul><li><strong>如果两个日志中的两个 <code>entry</code> 具有相同的 <code>term</code> 和 <code>index</code>，则它们的 <code>cmd</code> 也相同。</strong></li> <li><strong>如果两个日志中的两个 <code>entry</code> 具有相同的 <code>term</code> 和 <code>index</code>，则它们前面的所有 <code>entries</code> 都相同。</strong></li></ul> <p>第一个特性是因为只有 leader 可以生成日志，且一个 term 只有一个 leader。</p> <p>第二个特性需要 Leader 每次要求 Follower 追加日志时，同时进行<strong>一致性检查</strong>来保证。Leader 发送追加日志请求时，除了发送本次完整的 <code>entry</code> 以外，还会发送前面一条 <code>entry</code> 的 <code>term</code> 和 <code>index</code>。Follower 收到后对本地最新一条 <code>entry</code> 的 <code>term</code> 和 <code>index</code> 进行检查，如果相同才会接受。（既然每次添加日志时保证前一条都相同，由数学归纳法可知前面所有的日志都相同）</p> <p>正常情况下一致性检查不会失败，但在节点崩溃时会出现日志不一致。Follower 的日志相较现任 Leader 的日志可能多、可能少、甚至可能既多一部分又少一部分。</p> <p><img src="/images/cc42088c4b1df5607ffaca3e4d6231c55358429cf2348d3161bfde3858265935.png" alt="picture 4"></p> <ul><li>a 和 b 是 Follower 的日志更少的情况，很好理解（Follower 曾掉线）</li> <li>c 和 d 是 Follower 的日志更多的情况。这种情况可能是现任 Leader 向部分服务器发送了请求，但由于未过半，因此没有提交该请求；也可能现任 Leader 在 <code>term 6</code> 掉线了，新的服务器 d 已经在 <code>term 7</code> 推选出新的 Leader；</li> <li>e 和 f 是 Follower 的日志多一部分又少一部分的情况。比如服务器 f 在任期 2 当选 Leader，并追加了一些日志，但在提交前崩溃了；重启后又在任期 3 当选 Leader，并追加了一些日志，然后又又在提交前崩溃了。</li></ul> <p>Raft 算法处理日志不一致的方法直接粗暴：强制使用 Leader 的日志覆盖 Follower 的（即现任 Leader 永远是对的）。换句话说，Leader 和 Follower 找到两份日志最后一致的地方，Follower 删掉之后不一致的部分，然后将 Leader 之后不一致的部分追加到末尾。因此，接下来需要讨论 Leader 和 Follower 如何寻找最后一致的地方。</p> <p>Leader 会为每个 Follower 维护 <code>nextIndex</code> 表示下一个需要向其发送的 <code>entry</code> 的 <code>index</code>。当 Leader 刚上任时，它会初始化所有的 <code>nextIndex</code> 为自己本地最后一条 <code>entry</code> 的 <code>index</code> + 1。如果某个 Follower 的日志和 Leader 有不一致，下次 Leader 追加日志时的一致性检查会失败。失败后，Leader 会将 <code>nextIndex</code> 减小后重试。若干次重试后，Leader 将 <code>nextIndex</code> 退回到一致的日志条目 <code>index</code> + 1，此时一致性检查成功，Follower 将这之后的日志条目都删掉，并将 Leader 刚发送的日志条目追加到自己的日志中。之后的一致性检查会一直成功，Leader 会根据 <code>nextIndex</code> 将每条日志条目发送给 Follower。</p> <p>优化 1：在确定日志一致性之前，Leader 可以只发送不包含新的日志条目，只包含前一条的 <code>term</code> 和 <code>index</code> 的请求，可以节省带宽。
优化 2：Follower 拒绝请求时，可以一并发送该冲突日志的 <code>term</code>，和自己本地的该 term 的最早的 <code>index</code>，Leader 即可直接将 <code>nextIndex</code> 减少到该 <code>index</code>。</p> <h4 id="raft-算法-为了保证-leader-拥有所有已提交日志而产生的选举限制"><a href="#raft-算法-为了保证-leader-拥有所有已提交日志而产生的选举限制" class="header-anchor">#</a> Raft 算法 -- 为了保证 Leader 拥有所有已提交日志而产生的选举限制</h4> <p>上述部分的<code>选举 Leader</code> 和<code>日志复制</code>即是 Raft 的整体思路，但还有一个小的细节没有处理，本段即是叙述 Raft 如何处理这个细节。</p> <p>在任何基于 Leader 的一致性算法中，Leader 都需要存储所有已提交的日志条目。最直观的思路是，Follower 将已提交的日志条目回传给 Leader，但这种思路在实现时非常麻烦。</p> <p>Raft 采用的方法很有意思：在竞选阶段，<strong>Follower 不会支持已提交日志比自己少的 Candidate</strong>。在“日志需要被发送给过半数的服务器才会被提交”的前提下，超过半数的 Follower 不会支持没有完整已提交日志的 Candidate，该 Candidate 自然也不会赢得竞选、成为 Leader。</p> <h3 id="todo"><a href="#todo" class="header-anchor">#</a> todo</h3> <p>https://javaguide.cn/distributed-system/api-gateway.html#%E4%BD%95%E4%B8%BA%E7%BD%91%E5%85%B3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BD%91%E5%85%B3</p> <h2 id="linux-命令"><a href="#linux-命令" class="header-anchor">#</a> Linux 命令</h2> <table><thead><tr><th>命令</th> <th>用途</th></tr></thead> <tbody><tr><td><code>top</code></td> <td>任务管理器</td></tr> <tr><td><code>free</code></td> <td>查看剩余内存等（不过为什么不用 <code>top</code> 呢）</td></tr> <tr><td><code>ps</code></td> <td>查看进程，可使用 <code>ps aux | grep '&lt;process_name&gt;'</code> 查 pid</td></tr> <tr><td><code>kill -9 &lt;pid&gt;</code></td> <td>杀进程</td></tr> <tr><td><code>lsof -i:8000</code></td> <td>查看 8000 端口的占用进程</td></tr> <tr><td><code>nload</code></td> <td>查看流量大小</td></tr> <tr><td><code>wc</code></td> <td>(word count) 统计文件的字数、行数、字符数</td></tr> <tr><td><code>tail --follow</code></td> <td>实时输出（日志）文件内容</td></tr> <tr><td><code>journalctl -f -u &lt;unit.service&gt;</code></td> <td>实时输出日志内容</td></tr> <tr><td><code>grep word file.txt</code></td> <td>在 <code>find.txt</code> 查找 <code>word</code> 字符串，<code>-i</code> 大小写不敏感</td></tr> <tr><td><code>find &lt;directory&gt; -name 'file.txt'</code></td> <td>在目录下查找 <code>file.txt</code></td></tr> <tr><td><code>df -h</code></td> <td>查看文件剩余空间</td></tr></tbody></table> <h2 id="低频考点"><a href="#低频考点" class="header-anchor">#</a> 低频考点</h2> <p>以下是低频考点，但是在真实面试中问过一次，读者可以按需掌握。</p> <h3 id="c-2"><a href="#c-2" class="header-anchor">#</a> C++</h3> <h4 id="c-语言获取当前文件夹、函数名、行数"><a href="#c-语言获取当前文件夹、函数名、行数" class="header-anchor">#</a> C 语言获取当前文件夹、函数名、行数</h4> <p>中望龙腾 C++ 岗笔试考过。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;direct.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">_getcwd</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl                   <span class="token comment">// 获取当前文件夹</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;__FUNCSIG__:&quot;</span> <span class="token operator">&lt;&lt;</span> __FUNCSIG__ <span class="token operator">&lt;&lt;</span> endl    <span class="token comment">// 获取函数完整签名</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;__FUNCTION__:&quot;</span> <span class="token operator">&lt;&lt;</span> __FUNCTION__ <span class="token operator">&lt;&lt;</span> endl  <span class="token comment">// 获取函数名</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;__LINE__:&quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">__LINE__</span><span class="token punctuation">;</span>                 <span class="token comment">// 获取行数</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>C:\Users\liu\Desktop\test\cpp
__FUNCSIG__:int __cdecl main(void)
__FUNCTION__:main
__LINE__:11
</code></pre></div><h4 id="c-语言字节对齐"><a href="#c-语言字节对齐" class="header-anchor">#</a> <a href="/notes/cpp/cpp-grammar/c-byte-alignment.html">C 语言字节对齐</a></h4> <h4 id="cv-限定符"><a href="#cv-限定符" class="header-anchor">#</a> cv 限定符</h4> <p><a href="https://zh.cppreference.com/w/cpp/language/cv" target="_blank" rel="noopener noreferrer">cv（const 与 volatile）类型限定符 | cppreference.com<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>cv 限定符是 <code>const</code> 和 <code>volatile</code> 的合称。</p> <p><strong>当对象最初被创建</strong>时，所用的 cv 限定符决定对象的常量性或易变性。</p> <p><code>const</code> 大家都懂，就是不能修改的常量 (constant)，直接修改会编译报错，间接修改（如利用 <code>const_cast&lt;int&amp;&gt;</code> 等手段）为未定义行为。还有一点，就是写为 <code>const</code> 之后，编译器会进行优化。</p> <p>而 <code>volatile</code> 翻译过来是“易变”的，表明该变量可能通过软件甚至硬件方式变化。这会阻止编译器对这个变量进行任何优化，包括但不限于：不会将变量放到寄存器中；不会对 <code>const volatile</code> 变量当做 <code>const</code> 进行优化。（不过，CPU 仍可以将变量放入缓存中，因为缓存对程序员是透明的）</p> <p>代码例子见 <a href="#const-cast">const_cast</a> 部分。</p> <h4 id="static-用处"><a href="#static-用处" class="header-anchor">#</a> static 用处</h4> <p>C 语言的 static 有三个用处：</p> <ol><li>对<code>函数内变量</code>使用，扩展其生存期；</li> <li>对<code>函数外变量</code>和<code>函数</code>使用，使其他文件不能通过 <code>extern</code> 访问到该变量/函数（默认是可以的）；</li> <li>对<code>类的成员/方法</code>使用，使得该变量/函数属于类（其他的都是属于每个对象），可以直接由类名 <code>Classname::</code> 调用；</li></ol> <h4 id="禁止继承"><a href="#禁止继承" class="header-anchor">#</a> 禁止继承</h4> <p>C++ 11 引入了 <code>final</code> 关键字。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">final</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// error: 不能选择 final 类作为基类</span>
</code></pre></div><h4 id="禁止拷贝构造函数和赋值构造函数"><a href="#禁止拷贝构造函数和赋值构造函数" class="header-anchor">#</a> 禁止拷贝构造函数和赋值构造函数</h4> <p>C++11 加入了 <code>= delete</code> 控制类默认函数。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Thing</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Thing</span><span class="token punctuation">(</span><span class="token keyword">const</span> Thing<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    Thing<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Thing<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Thing t1<span class="token punctuation">;</span>       <span class="token comment">// 错误 E0291：类 &quot;Thing&quot; 不存在默认构造函数</span>
    Thing <span class="token function">t2</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 错误 E1776：无法引用 函数 &quot;Thing::Thing(const Thing &amp;)&quot; (已声明 所在行数:4) -- 它是已删除的函数</span>
    Thing t2 <span class="token operator">=</span> t1<span class="token punctuation">;</span>  <span class="token comment">// 错误 E1776：无法引用 函数 &quot;Thing::Thing(const Thing &amp;)&quot; (已声明 所在行数:4) -- 它是已删除的函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>C++98 前可以定义为 <code>private</code>。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Thing</span> 
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Thing</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Thing <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thing <span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Thing <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Thing t1<span class="token punctuation">;</span>
    Thing <span class="token function">t2</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//error C2248: “Thing::Thing”: 无法访问 private 成员</span>
    Thing t2 <span class="token operator">=</span> t1<span class="token punctuation">;</span> <span class="token comment">//error C2248: “Thing::Thing”: 无法访问 private 成员</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="std-vector-和-std-array"><a href="#std-vector-和-std-array" class="header-anchor">#</a> std::vector 和 std::array</h4> <ul><li>vector 和 array 都是可以通过 <code>[]</code> 访问下标对应元素的数组；</li> <li>vector 是变长数组，可以通过 <code>push_back</code> <code>insert</code> 和 <code>erase</code> 修数组大小。（注意 <code>insert</code> 和 <code>erase</code> 都是 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 的）；</li> <li><a href="https://blog.csdn.net/qq_30835655/article/details/60762196" target="_blank" rel="noopener noreferrer">C++ vector 内存分配与回收机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>；</li> <li>array 则是 C++11 引入的、对标准数组的封装，是定长数组。</li></ul> <h4 id="lambda-捕获值列表"><a href="#lambda-捕获值列表" class="header-anchor">#</a> Lambda 捕获值列表</h4> <p><a href="https://changkun.de/modern-cpp/zh-cn/03-runtime/index.html#3-1-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener noreferrer">Modern C++ zh-cn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>分为三种：</p> <ol><li>值捕获 <code>[value]</code> 或 <code>[=value]</code>：与参数传值类似，值捕获的前提是变量可以拷贝。不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝。</li> <li>引用捕获 <code>[&amp;value]</code>：与引用传参类似，引用捕获保存的是引用，值会发生变化。</li> <li>隐式捕获 <code>[=]</code> 或 <code>[&amp;]</code>：手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获。（很多地方说的是捕获 <code>this</code>，我觉得还是这个好理解一些，毕竟如果在 main 函数中，也没有 <code>this</code> 一说）</li></ol> <p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的<strong>最常用</strong>的四种形式可以是：</p> <ol><li><code>[]</code> 空捕获列表</li> <li><code>[name1, name2, ...]</code> 捕获一系列变量</li> <li><code>[&amp;]</code> 引用捕获, 让编译器自行推导引用列表</li> <li><code>[=]</code> 值捕获, 让编译器自行推导值捕获列表</li></ol> <h3 id="数据结构-2"><a href="#数据结构-2" class="header-anchor">#</a> 数据结构</h3> <h4 id="堆的复杂度"><a href="#堆的复杂度" class="header-anchor">#</a> 堆的复杂度</h4> <p>面腾讯的时候被问到，建堆的复杂度是多少，还好之前写过<a href="/notes/computer-science/classnotes/data-structure-and-algorithm.html#堆-Heap">博客</a>，还有一点点印象不是 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，而是 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。回顾了一下博客，果然是，顺便重温了一下证明。</p> <h3 id="计算机网络-2"><a href="#计算机网络-2" class="header-anchor">#</a> 计算机网络</h3> <h4 id="time-wait-快速回收与复用"><a href="#time-wait-快速回收与复用" class="header-anchor">#</a> TIME_WAIT 快速回收与复用</h4> <p><a href="http://langos.top/2019/04/07/time-wait%E5%BF%AB%E9%80%9F%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8/" target="_blank" rel="noopener noreferrer">time-wait快速回收与复用 - rosewind的博客 | BY Blog<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://ivanzz1001.github.io/records/post/tcpip/2018/04/24/tcpip_timewait#" target="_blank" rel="noopener noreferrer">time_wait的快速回收和重用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://blog.csdn.net/cui918/article/details/52850846" target="_blank" rel="noopener noreferrer">NAT环境下tcp_timestamps问题_〓☆〓 清风徐来918 （QQ:89617663）-CSDN博客_tcp_timestamps<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>这是腾讯主管问的问题，一般第二次考到的概率很小，但作为一个知识了解也不错。</p> <p>TIME_WAIT 状态产生的原因在上面部分提到了，这里不再赘述。如果 TIME_WAIT 太多，导致无法对外建立新 TCP 连接。</p> <p>在 Linux 下，可以从系统层面，或从应用程序层面解决这个问题。</p> <hr> <p>系统层面上，也有三种方法。</p> <p>一是提高 <code>tcp_max_tw_buckets</code>，就能接受更多的 TIME_WAIT，但是治标不治本。</p> <p>二是开启 TIME_WAIT 快速回收 <code>tcp_tw_recycle</code>（需同时开启 <code>tcp_timestamps</code>，系统默认开启）。原理是在 TCP 报文中加入时间戳（时间戳在 TCP 报文中的可选字段），然后系统缓存每个连接最新的时间戳。如果收到的 TCP 报文的时间戳早于缓存值，就丢弃数据包 (RFC1323)。</p> <p>快速回收的问题在于，搭配 NAT 可能会出现问题。现在很多公司都用 LVS 做负载均衡，通常是前面一台 LVS，后面多台后端服务器，这其实就是 NAT，当请求到达 LVS 后，它修改地址数据后便转发给后端服务器，但不会修改时间戳数据，对于后端服务器来说，请求的源地址就是 LVS 的地址，加上端口会复用，所以从后端服务器的角度看，原本不同客户端的请求经过 LVS 的转发，就可能会被认为是同一个连接，加之不同客户端的时间可能不一致，所以就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的 SYN，但服务端就是不响应 ACK。如果服务器身处 NAT 环境，安全起见，通常要禁止 <code>tcp_tw_recycle</code>，至于TIME_WAIT连接过多的问题，可以通过 TIME_WAIT 复用解决。</p> <p>三是开启 TIME_WAIT 复用 <code>tcp_tw_reuse</code>（也需要同时开启 <code>tcp_timestamps</code>）另外复用也是也是有条件的：协议认为复用是安全的。与 <code>tcp_tw_recycle</code> 选项相比，本选项一般不会带来副作用。</p> <hr> <p>应用层面上，有两种解决办法：一是将 TCP 短连接改造为长连接，二是快速关闭 socket。</p> <h4 id="http-1-0-vs-1-1-vs-2-0-vs-3-0"><a href="#http-1-0-vs-1-1-vs-2-0-vs-3-0" class="header-anchor">#</a> HTTP 1.0 vs 1.1 vs 2.0 vs 3.0</h4> <blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/330300133?utm_id=0" target="_blank" rel="noopener noreferrer">关于队头阻塞（Head-of-Line blocking），看这一篇就足够了 - 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <ul><li>HTTP/1.1：通过使用 TCP 长链接，可以在一个 TCP 链接上以<strong>流水线</strong>的形式发送多个文件</li> <li>HTTP/2：通过<strong>分帧</strong>，解决了 HTTP/1.1 在 HTTP 协议层的队头阻塞（两个文件可以交叉传输，而不是先发送的大文件必须全部收到后，才能发送后面的小文件）</li> <li>HTTP/3：通过<strong>改用基于 UDP 的 QUIC</strong>，解决了 HTTP/2 在 TCP 协议层的队头阻塞（如果 TCP 层面发生了丢包，HTTP 层不能先拿到后面的包）。不过 HTTP/3 只有在丢包率很高的网络下才会有显著的优势</li></ul> <h4 id="http-状态码"><a href="#http-状态码" class="header-anchor">#</a> HTTP 状态码</h4> <p><a href="/posts/2021-01-30-http-status-code.html">HTTP 状态码</a></p> <ul><li>1xx：
<ul><li><code>102 Processing (WebDAV)</code> 用于表明 WebDAV 服务器收到了请求，但请求的操作比较费时，服务器正在处理（如遍历当前文件夹）。为了防止客户端 TCP 超时、假设请求丢失，于是服务器可以发送一个没有信息的 102 应答。</li></ul></li> <li>2xx：
<ul><li><code>200 OK</code></li> <li><code>201 Created</code></li> <li><code>202 Accepted</code> 表示正在进行一个异步操作。用于 1. 重置密码时，服务器返回 <code>202</code>，然后将重置邮件发送给邮箱；2. <a href="https://docs.microsoft.com/zh-cn/onedrive/developer/rest-api/api/driveitem_createuploadsession?view=odsp-graph-online" target="_blank" rel="noopener noreferrer">Onedrive 分段上传时<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，如果完成了一部分的上传，会返回 <code>202</code>。</li> <li><code>204 No Content</code></li> <li><code>206 Partial Content</code></li></ul></li> <li>3xx：
<ul><li>301 302 307 308 见后</li> <li><code>304 Not Modified</code></li></ul></li> <li>4xx：
<ul><li><code>400 Bad Request</code></li> <li><code>401 Unauthorized</code></li> <li><code>403 Forbidden</code></li> <li><code>404 Not Found</code></li> <li><code>405 Method Not Allowed</code></li> <li><code>409 Conflict</code></li> <li><code>415 Unsupported Media Type</code></li></ul></li> <li>5xx：
<ul><li><code>500 Internal Server Error</code></li> <li><code>502 Bad Gateway</code> 常见于 Nginx 反代的服务出锅了</li> <li><code>504 Gateway Timeout</code></li></ul></li></ul> <table><thead><tr><th></th> <th>永久重定向 <code>Permanently</code></th> <th>暂时重定向 <code>Temporarily</code></th></tr></thead> <tbody><tr><td>允许将 <code>POST</code> 方法改为 <code>GET</code></td> <td><code>301 Moved Permanently</code></td> <td><code>302 Moved Temporarily</code></td></tr> <tr><td>不允许将 <code>POST</code> 方法改为 <code>GET</code></td> <td><code>308 Permanent Redirect</code></td> <td><code>307 Temporary Redirect</code></td></tr></tbody></table> <h4 id="https-原理及握手过程"><a href="#https-原理及握手过程" class="header-anchor">#</a> HTTPS 原理及握手过程</h4> <p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener noreferrer">SSL/TLS协议运行机制的概述 - 阮一峰的网络日志<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol><li>客户端发送：ClientHello + 随机数 client random</li> <li>服务端发送：ServerHello + 随机数 server random + 证书</li> <li>（客户端验证证书有效性）</li> <li>客户端发送：随机数 premaster secret (经公钥加密)</li> <li>（服务器和客户端使用三个随机数生成一个会话密钥）</li> <li>客户端发送：finished (经会话密钥加密)</li> <li>服务端发送：finished (经会话密钥加密)</li></ol> <h3 id="nginx"><a href="#nginx" class="header-anchor">#</a> Nginx</h3> <p><a href="https://zhuanlan.zhihu.com/p/108031600" target="_blank" rel="noopener noreferrer">Nginx为什么快到根本停不下来？ - 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="/images/654b6c7ba89678ec0e0725ddffe75a93cac5d4146c22cc8da161bb2a4da9c683.png" alt="Nginx 的进程模型"></p> <h4 id="nginx-多进程"><a href="#nginx-多进程" class="header-anchor">#</a> Nginx 多进程</h4> <p>一个 Master 进程配合多个 Worker 进程</p> <ol><li>Master 进程：管理 Worker 进程</li></ol> <ul><li>对外接口：接收外部的操作（信号）</li> <li>对内转发：根据外部的操作的不同，通过信号管理 Worker</li> <li>监控：监控 worker 进程的运行状态，worker 进程异常终止后，自动重启 worker 进程</li></ul> <ol start="2"><li>Worker 进程：所有 Worker 进程都是平等的</li></ol> <ul><li>实际处理：网络请求，由 Worker 进程处理；</li> <li>Worker 进程数量：可在 nginx.conf 中配置，一般设置为核心数；</li></ul> <h4 id="nginx-io-多路复用"><a href="#nginx-io-多路复用" class="header-anchor">#</a> Nginx IO 多路复用</h4> <p>Nginx 使用epoll 多路复用</p> <h4 id="nginx-均衡负载算法"><a href="#nginx-均衡负载算法" class="header-anchor">#</a> Nginx 均衡负载算法</h4> <p>共五种：</p> <ol><li>轮询 (Round Robin)</li> <li>加权轮训，权越大表示服务器的能力越强，能承受更大负载</li> <li>最小连接数 (Least Connections)</li> <li>IP Hash，保证同 IP 映射到同一服务器，在集群不同享 Session 时很好用</li> <li>URL Hash，保证同 URL 映射到同一服务器，在有 URL 缓存时效率高</li></ol> <h3 id="docker"><a href="#docker" class="header-anchor">#</a> Docker</h3> <h4 id="docker-底层"><a href="#docker-底层" class="header-anchor">#</a> Docker 底层</h4> <p><a href="https://xiaoxiami.gitbook.io/docker/docker-de-di-ceng-ji-zhu" target="_blank" rel="noopener noreferrer">Docker 的底层技术<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>概要：Docker 使用 <strong>Linux 命名空间</strong>实现<strong>容器的隔离</strong>，使用<strong>控制组</strong>实现对容器的<strong>资源限制</strong>，使用<strong>联合文件系统</strong>提高<strong>存储效率</strong>。</p></blockquote> <p>和虚拟机不同，Docker 进程和宿主机进程共用一个内核和某些系统库等。而彼此各个进程的方法是 Linux 上的<strong>命名空间 (Namespaces)</strong>。</p> <p>Docker 使用名称空间来为容器提供隔离的工作空间。当一个容器运行时，Docker 就会为该容器创建一系列的名称空间，并为名称空间提供一层隔离。</p> <p>Docker 引擎也依赖另一项叫 Control groups (cgroups，控制组) 的技术。控制组可以对程序进行资源限定，并允许 Docker 引擎在容器间进行硬件资源共享以及随时进行限制和约束，如内存等。</p> <p>联合文件系统 (UnionFS) 是一种分层、轻量级并且高性能的文件系统，它支持将文件系统的修改作为一次提交来一层层地叠加。不同 Docker 容器可以共享基础的文件系统层，与自己独有的改动层一起使用，可以大大提高存储效率。</p> <h3 id="i-o-多路复用"><a href="#i-o-多路复用" class="header-anchor">#</a> I/O 多路复用</h3> <p>I/O 多路复用是一种同步 I/O 模型，实现一个线程监听多个文件句柄；一旦某个文件句柄就绪，就能通知应用程序进行读写操作。没有文件句柄就绪时就会阻塞应用程序。</p> <p>I/O 多路复用提供了三种实现：select、poll 和 epoll。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>select 函数将需要监听的 file descriptors(fd) 传给 select 函数，当其中一个就绪后函数就返回。</p> <p>select 优点：跨平台
select 缺点：</p> <ol><li>底层是通过轮询数组来实现的，时间复杂度为 <code>O(n)</code>，且监听的 fd 有数量限制</li> <li>每次调用 select 时都需要把 fd 从用户态复制到内核态</li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">poll</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>poll 在使用上和 select 没什么区别。</p> <p>poll 优点：改用轮询链表实现，监听的 fd 就没有数量限制了
poll 缺点：</p> <ol><li>依旧是轮询链表，时间复杂度依旧是 <code>O(n)</code>。</li> <li>在每次调用时依旧需要把 fd 从用户态复制到内核态</li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>；<span class="token comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span>
<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span>；
<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>epoll 的使用稍微复杂一些，使用事件来驱动。</p> <p>epoll 优点：</p> <ol><li>使用哈希表来实现，优点是时间复杂度降低到 <code>O(1)</code>，且依旧没有大小限制</li> <li>在最开始调用 <code>epoll_ctl</code> 时会将 fd 态从用户态复制到内核态，之后每次调用 <code>epoll_wait</code> 进行等待时都不需要复制。</li></ol> <p>epoll 缺点：最开始需要调用 <code>epoll_create</code> 在 OS 中创建一个 fd。</p> <h3 id="零拷贝"><a href="#零拷贝" class="header-anchor">#</a> 零拷贝</h3> <p><a href="https://zhuanlan.zhihu.com/p/83398714" target="_blank" rel="noopener noreferrer">深入剖析Linux IO原理和几种零拷贝机制的实现 - 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>零拷贝指的是在数据从网络等设备到用户程序空间传递的作用中，实现 CPU 的零参与，消除 CPU 在这方面的负载，也减少了拷贝次数。用到的主要技术是 DMA + 内存区域映射。</p> <h4 id="dma"><a href="#dma" class="header-anchor">#</a> DMA</h4> <p>直接内存存取（Direct Memory Access，DMA）允许网络、磁盘、显卡等设备直接绕过 CPU 访问内存。</p> <p>除了开始和结束需要 CPU 参与（向 DMA 控制器发出、接收信号）以外，其余操作都是由 DMA 控制器完成的。</p> <p><img src="/images/9d4bdb70b571d40ba60e5e8e34505669cac289b2d9d2b07e23c6d6405fa73213.png" alt="picture 1"></p> <p>图中可以看出，CPU 仍需要在内存的内核缓冲区和用户缓冲区间进行拷贝（如下图）。为了解决这个问题，有好几种方案，用于解决不同的场景。</p> <p><img src="/images/6a029200dd084c0928973b9fcd48b724c83b1ee9361048538ad89056215c6595.png" alt="picture 2"></p> <h4 id="mmap-write"><a href="#mmap-write" class="header-anchor">#</a> mmap + write</h4> <p>mmap 是 Linux 提供的一种内存映射文件方法，能将“内核读缓冲区”映射到“用户空间的缓冲区”，减少一次复制，但写的时候仍然需要复制，如下图：</p> <p><img src="/images/b2508e82324279a50eca3276d7f5d60cadc6f5828d7ab6a64aa8ce1a2dabeeb1.png" alt="picture 3"></p> <h4 id="sendfile-dma-gather-copy"><a href="#sendfile-dma-gather-copy" class="header-anchor">#</a> sendfile + DMA gather copy</h4> <p>sendfile + DMA gather copy 用于进程不需要读写数据，仅将数据原封不动地从一个外设拷贝到另一个外设中。sendfile 可以让数据直接在内核空间中进行传输（从“内核读缓冲区”到“内核写缓冲区”）。而 DMA gather copy 技术可以内核读缓冲区“映射”到内存写缓冲区，从而实现内存之间的零次拷贝。当然缺点是进程无法读写这部分数据。</p> <p><img src="/images/6eef23c997b4634a07932251e14ea19dc3af2f0d277ad676cdfabddc5a522d09.png" alt="picture 4"></p></div> <hr role="separator" aria-orientation="horizontal" class="ma-4 v-divider theme--light"> <div data-v-5794ffe6><script src="https://giscus.app/client.js" async="async" service="giscus" data-repo="lyh543/blog-comments" data-repo-id="R_kgDOHIb2Zg" data-category="Announcements" data-category-id="DIC_kwDOHIb2Zs4COh2z" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" data-v-5794ffe6></script></div></div></div></article></div> <!----></div></div> <div class="v-dialog__container"><button type="button" role="button" aria-haspopup="true" aria-expanded="false" class="v-btn v-btn--bottom v-btn--is-elevated v-btn--fab v-btn--fixed v-btn--has-bg v-btn--right v-btn--round theme--dark v-size--default primary"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-information-variant theme--dark"></i></span></button><!----></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2024</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1606e5e2.js" defer></script><script src="/assets/js/28.2e1b5e41.js" defer></script>
  </body>
</html>
