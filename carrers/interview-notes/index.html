<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>面试相关知识 | 小灰灰灰灰的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="打工人,C++,操作系统,面经集合,计算机网络">
    <meta name="description" content="以下知识均在后台开发面试中实际出现过、总结而来。 C++多态的实现即虚函数表。 STL 容器库容器库 - cppreference.com unordered_map 和 map 的区别略。 multimap 和 map 的区别略。 智能指针智能指针（现代C++） | Microsoft Docs 智能指针是对普通指针的一个封装。普通指针 new 了以后一定要 delete，而智能指针是一个类，当">
<meta property="og:type" content="article">
<meta property="og:title" content="面试相关知识">
<meta property="og:url" content="https://blog.lyh543.cn/carrers/interview-notes/index.html">
<meta property="og:site_name" content="小灰灰灰灰的博客">
<meta property="og:description" content="以下知识均在后台开发面试中实际出现过、总结而来。 C++多态的实现即虚函数表。 STL 容器库容器库 - cppreference.com unordered_map 和 map 的区别略。 multimap 和 map 的区别略。 智能指针智能指针（现代C++） | Microsoft Docs 智能指针是对普通指针的一个封装。普通指针 new 了以后一定要 delete，而智能指针是一个类，当">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.lyh543.cn/images/bfe1ee01619b2c9ccc4caed3ac55690651d628abb8b9e9956c2da7d9420c8fe4.png">
<meta property="og:image" content="https://blog.lyh543.cn/images/df871baea1f5b1cc17ad6a1c36c13eaae55a55f30987474ebe1ac5570b9d7567.png">
<meta property="og:image" content="https://blog.lyh543.cn/images/4489820786c2c39801d2488fac6c238e8963a52f2cb7efcd623cd0f8ee3eba66.png">
<meta property="og:image" content="https://blog.lyh543.cn/images/11828738d7578e6fa82c6f0b1eb4ddbb974924935c80003fc0d892acbd66d8f0.png">
<meta property="og:image" content="https://blog.lyh543.cn/images/TCP_CLOSE.svg">
<meta property="og:image" content="https://blog.lyh543.cn/images/1ff352e0972f8ffc505e4894c7b735ea5cd53cebaa644755185f2a07ab9a2479.png">
<meta property="og:image" content="https://blog.lyh543.cn/images/605a9d2f21aeff216aacc4e08072cdddba4ba0ca9d0b60e3759c75a88e1a31dd.png">
<meta property="og:image" content="https://blog.lyh543.cn/images/e3af0f7454816313bae5f86994a8eddbf0e052b007b1d7acf54ba27781e86f99.png">
<meta property="og:image" content="https://blog.lyh543.cn/images/654b6c7ba89678ec0e0725ddffe75a93cac5d4146c22cc8da161bb2a4da9c683.png">
<meta property="article:published_time" content="2021-03-26T16:00:00.000Z">
<meta property="article:modified_time" content="2021-09-11T12:19:35.015Z">
<meta property="article:author" content="lyh543">
<meta property="article:tag" content="打工人">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="面经集合">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.lyh543.cn/images/bfe1ee01619b2c9ccc4caed3ac55690651d628abb8b9e9956c2da7d9420c8fe4.png">
    
        <link rel="alternate" type="application/atom+xml" title="小灰灰灰灰的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="mdi mdi-close icon-lg"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">lyh543</h5>
          <a href="mailto:lyh543@outlook.com" title="lyh543@outlook.com" class="mail">lyh543@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg mdi mdi-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg mdi mdi-archive"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg mdi mdi-tag-multiple"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg mdi mdi-format-list-bulleted-square"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lyh543" target="_blank" >
                <i class="icon icon-lg mdi mdi-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg mdi mdi-menu"></i>
        </a>
        <div class="flex-col header-title ellipsis">面试相关知识</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg mdi mdi-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg mdi mdi-magnify"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg mdi mdi-share-variant"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">面试相关知识</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-03-26T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2021-03-27
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%89%93%E5%B7%A5%E4%BA%BA/">打工人</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C"><span class="post-toc-text">C++</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多态的实现"><span class="post-toc-text">多态的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#STL-容器库"><span class="post-toc-text">STL 容器库</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#unordered-map-和-map-的区别"><span class="post-toc-text">unordered_map 和 map 的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#multimap-和-map-的区别"><span class="post-toc-text">multimap 和 map 的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#智能指针"><span class="post-toc-text">智能指针</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据结构"><span class="post-toc-text">数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#快排算法、快排的时间复杂度（平均、最坏）"><span class="post-toc-text">快排算法、快排的时间复杂度（平均、最坏）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据库"><span class="post-toc-text">数据库</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MySQL-数据库引擎"><span class="post-toc-text">MySQL 数据库引擎</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-树和-B-树"><span class="post-toc-text">B 树和 B+ 树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#B-树"><span class="post-toc-text">B 树</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#B-树-1"><span class="post-toc-text">B+ 树</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#慢查询"><span class="post-toc-text">慢查询</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#聚簇索引-amp-非聚簇索引"><span class="post-toc-text">聚簇索引 &amp; 非聚簇索引</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InnoDB-为什么推荐使用-auto-increment-作为主键"><span class="post-toc-text">InnoDB 为什么推荐使用 auto_increment 作为主键</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#事务的-ACID"><span class="post-toc-text">事务的 ACID</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#事务的原子性和持久性的保证"><span class="post-toc-text">事务的原子性和持久性的保证</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InnoDB-事务隔离级别"><span class="post-toc-text">InnoDB 事务隔离级别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InnoDB-锁"><span class="post-toc-text">InnoDB 锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#行锁"><span class="post-toc-text">行锁</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#表锁"><span class="post-toc-text">表锁</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#行锁的算法"><span class="post-toc-text">行锁的算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#乐观锁和悲观锁，以及多版本并发控制"><span class="post-toc-text">乐观锁和悲观锁，以及多版本并发控制</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#计算机网络"><span class="post-toc-text">计算机网络</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OSI-七层"><span class="post-toc-text">OSI 七层</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TCP-三次握手与四次挥手"><span class="post-toc-text">TCP 三次握手与四次挥手</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TCP-流量控制"><span class="post-toc-text">TCP 流量控制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TCP-快速重传"><span class="post-toc-text">TCP 快速重传</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TCP-拥塞控制"><span class="post-toc-text">TCP 拥塞控制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用户从输入域名到获取到信息过程中发生了什么"><span class="post-toc-text">用户从输入域名到获取到信息过程中发生了什么</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#操作系统"><span class="post-toc-text">操作系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程和线程的区别"><span class="post-toc-text">进程和线程的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用户态和内核态的区别，这样有什么好处"><span class="post-toc-text">用户态和内核态的区别，这样有什么好处</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用户级线程和内核级线程"><span class="post-toc-text">用户级线程和内核级线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程七状态"><span class="post-toc-text">进程七状态</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#僵尸进程和孤儿进程"><span class="post-toc-text">僵尸进程和孤儿进程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程调度算法"><span class="post-toc-text">进程调度算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程切换算法"><span class="post-toc-text">进程切换算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程间通信方式"><span class="post-toc-text">线程间通信方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#进程间通信方式"><span class="post-toc-text">进程间通信方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何保证缓存一致性"><span class="post-toc-text">如何保证缓存一致性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#开发"><span class="post-toc-text">开发</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#深拷贝和浅拷贝"><span class="post-toc-text">深拷贝和浅拷贝</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何进行调试"><span class="post-toc-text">如何进行调试</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#设计模式"><span class="post-toc-text">设计模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#设计模式的原则"><span class="post-toc-text">设计模式的原则</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#创建型模式"><span class="post-toc-text">创建型模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#结构型模式"><span class="post-toc-text">结构型模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#装饰器和代理的区别"><span class="post-toc-text">装饰器和代理的区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#行为型模式"><span class="post-toc-text">行为型模式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Linux-命令"><span class="post-toc-text">Linux 命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#低频考点"><span class="post-toc-text">低频考点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C-1"><span class="post-toc-text">C++</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#C-语言获取当前文件夹、函数名、行数"><span class="post-toc-text">C 语言获取当前文件夹、函数名、行数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#C-语言字节对齐"><span class="post-toc-text">C 语言字节对齐</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#cv-限定符"><span class="post-toc-text">cv 限定符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#static-用处"><span class="post-toc-text">static 用处</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#禁止继承"><span class="post-toc-text">禁止继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#禁止拷贝构造函数和赋值构造函数"><span class="post-toc-text">禁止拷贝构造函数和赋值构造函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#std-vector-和-std-array"><span class="post-toc-text">std::vector 和 std::array</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Lambda-捕获值列表"><span class="post-toc-text">Lambda 捕获值列表</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据结构-1"><span class="post-toc-text">数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#堆的复杂度"><span class="post-toc-text">堆的复杂度</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#计算机网络-1"><span class="post-toc-text">计算机网络</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#TIME-WAIT-快速回收与复用"><span class="post-toc-text">TIME_WAIT 快速回收与复用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HTTP-状态码"><span class="post-toc-text">HTTP 状态码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HTTPS-原理及握手过程"><span class="post-toc-text">HTTPS 原理及握手过程</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Nginx"><span class="post-toc-text">Nginx</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Nginx-多进程"><span class="post-toc-text">Nginx 多进程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Nginx-IO-多路复用"><span class="post-toc-text">Nginx IO 多路复用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Nginx-均衡负载算法"><span class="post-toc-text">Nginx 均衡负载算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Docker"><span class="post-toc-text">Docker</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Docker-底层"><span class="post-toc-text">Docker 底层</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#I-O-多路复用"><span class="post-toc-text">I&#x2F;O 多路复用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内存零拷贝"><span class="post-toc-text">内存零拷贝</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-carrers/interview-notes"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">面试相关知识</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-03-27 00:00:00" datetime="2021-03-26T16:00:00.000Z"  itemprop="datePublished">2021-03-27</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%89%93%E5%B7%A5%E4%BA%BA/">打工人</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>以下知识均在后台开发面试中实际出现过、总结而来。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h3><p>即虚函数表。</p>
<h3 id="STL-容器库"><a href="#STL-容器库" class="headerlink" title="STL 容器库"></a>STL 容器库</h3><p><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库 - cppreference.com</a></p>
<h3 id="unordered-map-和-map-的区别"><a href="#unordered-map-和-map-的区别" class="headerlink" title="unordered_map 和 map 的区别"></a>unordered_map 和 map 的区别</h3><p>略。</p>
<h3 id="multimap-和-map-的区别"><a href="#multimap-和-map-的区别" class="headerlink" title="multimap 和 map 的区别"></a>multimap 和 map 的区别</h3><p>略。</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-160" target="_blank" rel="noopener">智能指针（现代C++） | Microsoft Docs</a></p>
<p>智能指针是对普通指针的一个封装。普通指针 <code>new</code> 了以后一定要 <code>delete</code>，而智能指针是一个类，当这个类的对象超出作用域以后，会自动调用析构函数，因此不再需要 <code>delete</code>，也不会因为忘记 <code>delete</code> 而发生内存泄露。</p>
<p>智能指针和普通指针的对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseRawPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Using a raw pointer -- not recommended.</span></span><br><span class="line">    Song* pSong = <span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use pSong...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't forget to delete!</span></span><br><span class="line">    <span class="keyword">delete</span> pSong;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseSmartPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Declare a smart pointer on stack and pass it the raw pointer.</span></span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Song&gt; <span class="title">song2</span><span class="params">(<span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use song2...</span></span><br><span class="line">    <span class="built_in">wstring</span> s = song2-&gt;duration_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// song2 is deleted automatically here.</span></span><br></pre></td></tr></table></figure>

<p>智能指针体现什么机制：封装。</p>
<ul>
<li><code>unique_ptr</code>：<code>unique_ptr</code> 的出现是为了替代 C++98 的 <code>auto_ptr</code> (而 <code>auto_ptr</code> 于 C++11 中被弃用)。如果不知道用什么，默认用 <code>unique_ptr</code> 就对了。<code>unique_ptr</code> 只占一个指针大小的空间</li>
<li><code>shared_ptr</code>：<code>shared_ptr</code> 的管理类似于 Python 的垃圾回收机制：对变量进行计数（如下图）。拷贝构造 <code>auto sp3(sp2);</code> 和赋值 <code>auto sp4 = sp2;</code> 都会使得计数++。<code>shared_ptr</code> 占两个指针大小的空间</li>
<li><code>weak_ptr</code>：<code>shared_ptr</code> 中如果有循环引用，导致二者的计数都不为 0，会导致内存泄露。可以在引用的地方使用 <code>weak_ptr</code> 并将 <code>shared_ptr</code> 赋给它，这不会使得 <code>shared_ptr</code> 计数++，之后能被正确地回收。<a href="https://blog.csdn.net/c_base_jin/article/details/79440999" target="_blank" rel="noopener">例子</a> <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/how-to-create-and-use-weak-ptr-instances?view=msvc-160" target="_blank" rel="noopener">例子2</a></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../../images/bfe1ee01619b2c9ccc4caed3ac55690651d628abb8b9e9956c2da7d9420c8fe4.png" alt="shared_ptr" title="">
                </div>
                <div class="image-caption">shared_ptr</div>
            </figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="快排算法、快排的时间复杂度（平均、最坏）"><a href="#快排算法、快排的时间复杂度（平均、最坏）" class="headerlink" title="快排算法、快排的时间复杂度（平均、最坏）"></a>快排算法、快排的时间复杂度（平均、最坏）</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL-数据库引擎"><a href="#MySQL-数据库引擎" class="headerlink" title="MySQL 数据库引擎"></a>MySQL 数据库引擎</h3><ul>
<li>MyISAM：读性能高，但不支持外键、行级锁和事务，MySQL 5.5 默认</li>
<li>InnoDB：读性能稍弱，支持外键、行级锁和事务，MySQL 5.5.5 及以后默认</li>
</ul>
<p>二者都使用 B+ 树作为存储的数据结构。</p>
<h3 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h3><h4 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h4><p><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">B 树 | 维基百科</a><br><a href="https://segmentfault.com/a/1190000020416577" target="_blank" rel="noopener">面试官问你B树和B+树，就把这篇文章丢给他- SegmentFault 思否</a></p>
<p>先要纠正两个常见误区：</p>
<ul>
<li>B 树 (B-Tree) 不是二叉树 (Binary Tree)。B 的全称，可能起源于其<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91#%E5%90%8D%E5%AD%97%E5%8F%96%E4%B9%89" target="_blank" rel="noopener">发明者</a>，不过理解成平衡 (balanced) 或宽的(broad) 或 茂密(bushy) 也不错。</li>
<li>没有 B 减树！B 减树的出现可能是翻译人员错误地将 B 树 (B-Tree) 翻译成了 B 减树。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../../images/df871baea1f5b1cc17ad6a1c36c13eaae55a55f30987474ebe1ac5570b9d7567.png" alt="B 树" title="">
                </div>
                <div class="image-caption">B 树</div>
            </figure>

<p>概述：B 树是是一种自平衡的树，能够保持数据有序（听起来就是在说平衡二叉树）。其与平衡二叉树的不同在于，B 树的一个节点可以拥有 2 个以上的子节点，且节点数在某范围内可变。这样的好处有：</p>
<ol>
<li>子结点的增多能够降低深度，减少定位记录时所经历的中间过程，运用在磁盘、数据库中可以加快存取速度；</li>
<li>由于节点数在范围内可变，因此 B 树不需要像其他平衡二叉查找树那样经常进行平衡</li>
</ol>
<p>定义：一棵 m 阶 B 树的定义：</p>
<ol>
<li>每个节点最多有 <code>m-1</code> 个 key；</li>
<li>根节点最少可以只有 <code>1</code> 个 key，非根节点至少有 <code>m/2</code> 个 key（根节点的 key 数量范围：<code>[1, m-1]</code>，非根节点的 key 数量范围：<code>[m/2, m-1]</code>。）；</li>
<li>每个节点中的 key 都按照从小到大的顺序排列，每个 key 的左子树中的所有 key 都小于它，而右子树中的所有 key 都大于它；</li>
<li>所有叶子节点都位于同一层（即根节点到每个叶子节点的长度都相同）；</li>
<li>每个节点都存有索引和数据，也就是对应的 key 和 value。</li>
</ol>
<p>B 树插入的规则：<strong>插入的时候，判断当前结点key的个数是否小于等于 <code>m-1</code>，如果满足，直接插入即可，如果不满足，将节点的中间的 key 将这个节点分为左右两部分，中间的节点放到父节点中即可。</strong></p>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>B+ 树具有上述 B 树的前四个特点。除此之外，B+ 树还有以下特点：</p>
<ol>
<li>B 树的所有结点都存储数据，而 B+ 树只有叶子结点存储数据，内部节点（或非叶子结点、索引节点）只存放索引；</li>
<li>B+ 树每个叶子结点存有下一个叶子结点的指针，而 B 树无，所以<strong>所有叶子结点形成了一条有序链表</strong>，遍历整棵树只需要遍历链表，而不需要从树根往下遍历。</li>
</ol>
<p>B+ 树较 B 树的优点就是遍历快吧。</p>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化- 美团技术团队</a></p>
<p>慢查询：超过指定时间的 SQL 语句查询。</p>
<p>优化方法：</p>
<ol>
<li>查看日志查看慢查询</li>
<li>添加索引、修改索引（如先查区分度大的）</li>
<li>分库、分表</li>
</ol>
<h3 id="聚簇索引-amp-非聚簇索引"><a href="#聚簇索引-amp-非聚簇索引" class="headerlink" title="聚簇索引 &amp; 非聚簇索引"></a>聚簇索引 &amp; 非聚簇索引</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../../images/4489820786c2c39801d2488fac6c238e8963a52f2cb7efcd623cd0f8ee3eba66.png" alt="聚簇索引 & 非聚簇索引" title="">
                </div>
                <div class="image-caption">聚簇索引 & 非聚簇索引</div>
            </figure>

<ul>
<li><strong>非聚簇索引</strong>（二级索引、辅助索引）：表数据和索引分成两部分存储，叶子结点存<strong>主键</strong>和<strong>索引键</strong></li>
<li><strong>聚簇索引</strong>：表数据和主键一起存储，主键索引的叶子结点存<strong>行数据 (包含主键值)</strong></li>
</ul>
<h3 id="InnoDB-为什么推荐使用-auto-increment-作为主键"><a href="#InnoDB-为什么推荐使用-auto-increment-作为主键" class="headerlink" title="InnoDB 为什么推荐使用 auto_increment 作为主键"></a>InnoDB 为什么推荐使用 auto_increment 作为主键</h3><ol>
<li>auto_increment 保证能新加入的数据的主键永远是最大的，加入的数据会被放在最后。在写入量大的时候，插入数据时是连续写入，而不是随机 I/O</li>
<li>auto_increment 使得主键和业务分离，这样即便业务上出现调整，也不需要重构数据库</li>
</ol>
<h3 id="事务的-ACID"><a href="#事务的-ACID" class="headerlink" title="事务的 ACID"></a>事务的 ACID</h3><p>ACID，是指数据库管理系统 (DBMS) 在写入或更新资料的过程中，为保证事务 (transaction) 是正确可靠的，所必须具备的四个特性：</p>
<ul>
<li>原子性 (atomicity)：一个事务要么全做要么全不做；</li>
<li><strong>一致性</strong> (consistency)：数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。最常见的例子是转帐：从帐户 A 转一笔钱到帐户 B 上，如果帐户 A 上的钱减少了，而帐户 B 上的钱却没有增加，那么我们认为此时数据处于不一致的状态；</li>
<li>隔离性 (isolation)：一个事务不影响其他事务的运行效果；</li>
<li>持久性 (durability)：事务一旦提交，则其结果就是永久性的，即使故障也能恢复。</li>
</ul>
<p>从数据库层面，数据库通过原子性、隔离性、持久性来保证<strong>一致性</strong>。也就是说 ACID 四大特性之中，C 是目的，AID 是手段，是为了保证一致性，数据库提供的手段。</p>
<h3 id="事务的原子性和持久性的保证"><a href="#事务的原子性和持久性的保证" class="headerlink" title="事务的原子性和持久性的保证"></a>事务的原子性和持久性的保证</h3><ol>
<li>将所有事务开始、提交、终止，以及数据的更新操作（记录数据更新前的值即前像，或更新后的值即后像）计入 log</li>
<li>系统崩溃后重启，先读取日志对已提交的事务进行 REDO（保证持久性）</li>
<li>然后对尚未提交的的事务进行 UNDO（保证原子性）</li>
</ol>
<h3 id="InnoDB-事务隔离级别"><a href="#InnoDB-事务隔离级别" class="headerlink" title="InnoDB 事务隔离级别"></a>InnoDB 事务隔离级别</h3><p><a href="https://developer.ibm.com/zh/technologies/databases/articles/os-mysql-transaction-isolation-levels-and-locks/" target="_blank" rel="noopener">MySQL 事务隔离级别和锁– IBM Developer</a></p>
<p>SQL 标准定义了四种隔离，隔离程度由高到低依次为：</p>
<ul>
<li><strong>读未提交</strong>/<strong>脏读</strong>：未提交事务的数据也可以被读，这也被称为脏读；</li>
<li><strong>读提交</strong>/<strong>不可重复读</strong>：提交了的东西就可以被读，但若一个事务两次读取过程中，有事务更新了数据，会导致不可重复读；</li>
<li><strong>可重复读</strong>/<strong>幻读</strong>（默认）：同一个事务中，<code>select</code> 的结果是事务开始时的状态，因此可重复读。但由于 <code>insert</code> 语句等不受影响，所以可能出现幻读（本事务开始后，别的事务提交了数据 <code>pk=1</code>，本事务 <code>select</code> 不到 <code>pk=1</code>，但 <code>insert pk=1</code> 会报错主键冲突，像是读到了幽灵）</li>
<li><strong>序列化</strong>：如果要完全解决上面的三种问题，就只能让事务串行化了，也就是把多个事务变成一个序列。</li>
</ul>
<table>
<thead>
<tr>
<th>有/无问题</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>读提交</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>可重复读</td>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>序列化</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="InnoDB-锁"><a href="#InnoDB-锁" class="headerlink" title="InnoDB 锁"></a>InnoDB 锁</h3><p><a href="https://developer.ibm.com/zh/technologies/databases/articles/os-mysql-transaction-isolation-levels-and-locks/" target="_blank" rel="noopener">MySQL 事务隔离级别和锁 - IBM Developer</a></p>
<p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系 - 美团技术团队</a>（很有意思，推荐认真阅读）</p>
<p>数据库遵循的是<strong>两段锁协议</strong>，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）</p>
<ul>
<li>加锁阶段：在该阶段可以进行加锁操作。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li>
<li>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li>
</ul>
<p>这种方式虽然<strong>无法避免死锁</strong>，但是两段锁协议<strong>可以保证事务的并发调度是串行化</strong>（串行化很重要，尤其是在数据恢复和备份的时候）的。</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB 实现了两种类型的行级锁：</p>
<ul>
<li>共享锁 (S)：在对任何数据进行读操作之前要申请并获得 S 锁。其它事务可以继续加共享锁，但不能加排它锁；</li>
<li>独占锁 (X)：在进行写操作之前要申请并获得 X 锁。其它事务不能再获得任何锁；</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>InnoDB 支持多粒度锁，因此 S 和 X 锁还可以锁表（如使用 <code>ALTER TABLE</code> 等语句会给表上 X 锁）。</p>
<p>另外还设计了两个意向锁，注意<strong>意向锁都是表级的</strong>：</p>
<ul>
<li>意向共享锁 (IS)：表明事务即将给表中的行设置 S 锁。事务给行加 S 锁前必须获得该表的 IS 锁。</li>
<li>意向排它锁 (IX)：表明事务即将给表中的行设置 X 锁。事务给行加 X 锁前必须获得该表的 IX 锁。</li>
</ul>
<p>综上，MySQL 支持两种行锁和四种表锁。</p>
<p>四种表锁的兼容表如下：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>总结一下就是：</p>
<ul>
<li><code>意向锁</code>之间相互不冲突</li>
<li><code>互斥锁</code>和所有锁都冲突</li>
<li><code>共享锁</code>和<code>互斥意向锁</code>冲突</li>
</ul>
<h4 id="行锁的算法"><a href="#行锁的算法" class="headerlink" title="行锁的算法"></a>行锁的算法</h4><ul>
<li>Record Locks：锁（单条）记录</li>
<li>Rocord Gaps：锁范围</li>
<li>Next-Key Locks：锁范围+锁记录</li>
</ul>
<h3 id="乐观锁和悲观锁，以及多版本并发控制"><a href="#乐观锁和悲观锁，以及多版本并发控制" class="headerlink" title="乐观锁和悲观锁，以及多版本并发控制"></a>乐观锁和悲观锁，以及多版本并发控制</h3><p><a href="https://learnku.com/articles/47517" target="_blank" rel="noopener">一文读懂数据库中的乐观锁和悲观锁和MVCC | MySQL 技术论坛</a><br><a href="https://www.zhihu.com/question/27876575/answer/71836010" target="_blank" rel="noopener">乐观锁和 MVCC 的区别？ - 用心阁的回答 - 知乎</a></p>
<p><strong>乐观锁和悲观锁都不是数据库锁</strong>，而是两种用于解决<strong>写-写冲突</strong>的思想。</p>
<hr>
<p>乐观锁（又称乐观并发控制）是乐观地假设，事务间的竞争没有那么多。</p>
<p>乐观并发控制的一种实现是基于版本号。首先进行修改，在提交事务前，检查一下事务开始后是否有别的提交，如果没有就提交，如果有就放弃并回滚重做。</p>
<p>乐观并发控制多用于<strong>读多写少</strong>的场景，由于没有上锁解锁（此处指数据库锁）的过程，读的性能会很高；但在读少写多的场景，需要反复回滚重做，所以效率会变低。</p>
<hr>
<p>悲观锁（又称悲观并发控制）是悲观地假设，事务间的竞争很多。</p>
<p>悲观并发控制的一种实现就是利用数据库锁，在数据库层对数据进行上锁。</p>
<p>悲观并发控制多用于<strong>读少写多</strong>的场景，这种场景下，不需要回滚重做而是等待，会比乐观锁好；但是上锁解锁需要消耗一定性能。</p>
<hr>
<p>多版本并发控制（MVCC）和上面的区别是，MVCC 解决的是<strong>读-写冲突</strong>。</p>
<p>MVCC 在各数据库中有不同的实现，在 InnoDB 中是一种<strong>无锁并发控制</strong>。InnoDB MVCC 为事务分配递增的时间戳（或者 version），更新时 version++，读操作只读该事务开始前的数据库的快照。</p>
<p>这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI-七层"><a href="#OSI-七层" class="headerlink" title="OSI 七层"></a>OSI 七层</h3><p>就是把应用层拓展为（自底向上）会话层、表示层（加密相关）、应用层。</p>
<h3 id="TCP-三次握手与四次挥手"><a href="#TCP-三次握手与四次挥手" class="headerlink" title="TCP 三次握手与四次挥手"></a>TCP 三次握手与四次挥手</h3><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B" target="_blank" rel="noopener">TCP 三次握手与四次挥手</a></p>
<p>三次握手：</p>
<ol>
<li>客户端：发送 <code>SYN</code>，进入 <code>SYN_SENT</code> 状态</li>
<li>服务器：收到包后发送 <code>SYN ACK</code>，进入 <code>SYN_RCVD</code> 状态</li>
<li>客户端：收到包后发送 <code>ACK</code>，进入 <code>ESTABLISHED</code> 状态（服务器接收后也进入 <code>ESTABLISHED</code> 状态）</li>
</ol>
<p>三个包的 <code>seq</code> 和 <code>ACKnum</code> 数值有如下关系：</p>
<ul>
<li><code>SYN ACK</code> 的 ACKnum = <code>SYN</code> 的 seq+1</li>
<li><code>ACK</code> 的 ACKnum = <code>SYN ACK</code> 的 seq+1</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../../images/11828738d7578e6fa82c6f0b1eb4ddbb974924935c80003fc0d892acbd66d8f0.png" alt="TCP 三次握手" title="">
                </div>
                <div class="image-caption">TCP 三次握手</div>
            </figure>

<hr>
<p>四次挥手并不一定是客户端发起，也可以由服务端发起。故下面用 <code>主动关闭</code> 和 <code>被动关闭</code> 称呼：</p>
<ol>
<li>主动关闭方：发送最后一个数据包后，发送 <code>FIN</code>，进入 <code>FIN_WAIT_1</code>；</li>
<li>被动关闭方：收到包后发送 <code>ACK</code>，进入 <code>CLOSE_WAIT</code>；客户端收到后进入 <code>FIN_WAIT_2</code>，此时客户端到服务端的单方连接被关闭；</li>
<li>被动关闭方：发送最后一个数据包后，发送 <code>FIN</code>，进入 <code>LAST_ACK</code>；</li>
<li>主动关闭方：收到包后发送 <code>ACK</code>，进入 <code>TIME_WAIT</code>，一段时间后关闭通信；服务端收到后立即关闭通信。</li>
</ol>
<p>可以理解为两对 <code>FIN - ACK</code>，且每个 <code>ACK</code> 的 ACKnum = 对方的 <code>FIN</code> 的 seq+1。</p>
<ul>
<li><code>CLOSE_WAIT</code> 可以理解成对方主动关闭了连接，但本方还没有关闭，在等待关闭连接 (wait close)；</li>
<li><code>TIME_WAIT</code> 首先发出 FIN 的一侧，如果给对侧的 FIN 响应了 ACK，那么就会超时等待 2*MSL 时间，然后关闭连接(time wait)。在这段超时等待时间内，本地的端口不能被新连接使用；避免延时的包的到达与随后的新连接相混淆。RFC793 定义了 MSL 为2分钟（即 <code>TIME_WAIT</code> 等待 4 分钟）。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../../images/TCP_CLOSE.svg" alt="TCP 四次挥手" title="">
                </div>
                <div class="image-caption">TCP 四次挥手</div>
            </figure>  

<p>被动关闭的一方也可以把 <code>ACK</code> 和 <code>FIN</code> 合并为 <code>FIN ACK</code>，实现三次挥手。</p>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p><a href="https://zhuanlan.zhihu.com/p/37379780" target="_blank" rel="noopener">TCP流量控制、拥塞控制</a></p>
<ul>
<li>流量控制：考虑到可能接收方处理的比较慢，需要限制发送方的发送速度。方法是，接收方发回的 ACK 中会包含自己接收窗口的大小。</li>
<li>流量控制死锁：当发送者收到了一个窗口为 0 的应答，便停止发送，等待接收者的下一个应答。但如果之后接受者发送的窗口不为 0 的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</li>
<li>流量控制死锁避免：TCP 使用持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器，时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送。</li>
</ul>
<h3 id="TCP-快速重传"><a href="#TCP-快速重传" class="headerlink" title="TCP 快速重传"></a>TCP 快速重传</h3><ul>
<li>在没有快速重传机制下，如果发送方的某报文丢失，即使接受方发送了多个重复确认，发送方仍需等待重传计时器到期才会重传；</li>
<li>快速重传机制下，发送方一旦收到三个重复确认，就重传报文，无需等待计时器到期。</li>
</ul>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p><a href="https://zhuanlan.zhihu.com/p/37379780" target="_blank" rel="noopener">TCP流量控制、拥塞控制</a></p>
<p>发送方维持一个变量：拥塞窗口 (congestion window, cwnd)，取决于网络拥塞情况，且动态变化。</p>
<p>发送方使自己的发送窗口为 $\min(cwnd, wnd_{接收方})$。</p>
<ul>
<li>慢启动阶段，<code>cwnd=1</code>，每成功传输一次则 <code>cwnd*=2</code>，直至 cwnd 到达慢启动阈值 (slow-start threshold, ssthresh)，进入拥塞避免状态。</li>
<li>拥塞避免状态，每成功传输一次则 <code>cwnd++</code></li>
<li>任何时刻，出现发送方对某报文的计时器超时，令 <code>ssthresh=cwnd/2，cwnd=1</code>，重新进入慢启动</li>
<li><strong>快速恢复</strong>：任何时刻，出现发送方接收到三个重复确认，并不按照上一条执行，而是令 <code>ssthresh=cwnd/2, cwnd=cwnd/2+3</code>，进入拥塞避免状态（能收到重复报文，说明网络没那么拥堵，超时才是真的拥堵）</li>
</ul>
<h3 id="用户从输入域名到获取到信息过程中发生了什么"><a href="#用户从输入域名到获取到信息过程中发生了什么" class="headerlink" title="用户从输入域名到获取到信息过程中发生了什么"></a>用户从输入域名到获取到信息过程中发生了什么</h3><p>a. DNS 解析的过程：计算机先检查 DNS 缓存，如果没有缓存则向 DNS 服务器查询域名对应的 IP，查询的过程分为迭代和递归两种方式；面试官接着问了 DNS 基于什么协议，答案是 UDP，服务器一般使用 53 端口；<br>b. 获取到 IP 以后就可以发包了，需要对包进行一层层的封装，自顶向下的封装顺序为：HTTP、TLS、TCP、IP。<br>c. HTTP 协议的内容大致为 <code>HTTP/1.1 GET /</code>；<br>d. TLS 协议会进行 TLS 握手，主要是客户端、服务端交换密钥；<br>e. 再往下是 TCP 和 UDP 协议。经典一问：TCP 和 UDP 的区别（TCP 面向连接、拥塞控制、流量控制），顺便还简单问了一下拥塞控制；<br>f. 再往下就是 IP 层，主机会向向路由器发 IP 包、路由器根据路由表和选路算法进行转发的过程；面试官又问了有那些选路算法（分为域内和域间协议，域内有 OSPF 和 RIP，域间使用 BGP）；以及路由表的最长前缀匹配原则；<br>e. 再往下就是物理层了。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li><strong>调度并分派的单位</strong>称为<strong>线程</strong>（或轻量级进程 <code>LWP</code>）</li>
<li><strong>资源所有权的单位</strong>称为<strong>进程</strong></li>
</ul>
<p>进程会创建进程控制块 (PCB)，而线程是线程控制块 (TCB)。由于线程没有父子进程、资源控制等结构，所以 TCB 比 PCB 简单得多，这也导致线程的创建比进程的创建快得多，大概有一个数量级的区别。</p>
<p>这也是平时开发中，为了利用 CPU 多线程，我们常使用多线程开发，而不是多进程开发的原因。</p>
<h3 id="用户态和内核态的区别，这样有什么好处"><a href="#用户态和内核态的区别，这样有什么好处" class="headerlink" title="用户态和内核态的区别，这样有什么好处"></a>用户态和内核态的区别，这样有什么好处</h3><ul>
<li>用户模式：优先权较少，用于运行用户程序</li>
<li>内核模式：优先权更高，用于运行内核，且某些指令、内存只能在特权模式下运行/访问，如：<ul>
<li>读取/修改 PSW 等控制<strong>寄存器</strong></li>
<li>原始 <strong>I/O</strong> 指令</li>
<li><strong>内存</strong>管理相关</li>
</ul>
</li>
</ul>
<p>区分用户模式和内核模式的原因：<strong>保护 OS 和重要操作系统表不受程序干扰</strong></p>
<h3 id="用户级线程和内核级线程"><a href="#用户级线程和内核级线程" class="headerlink" title="用户级线程和内核级线程"></a>用户级线程和内核级线程</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/1ff352e0972f8ffc505e4894c7b735ea5cd53cebaa644755185f2a07ab9a2479.png" alt="用户级线程和内核级线程" title="">
                </div>
                <div class="image-caption">用户级线程和内核级线程</div>
            </figure>

<ul>
<li>用户级线程：线程、线程的创建、销毁全部由库函数实现。<strong>内核不知道用户级线程的存在，依旧按照进程为单位进行调度</strong>。<ul>
<li>优点：线程切换不需要内核模式，快；调度策略因应用程序不同而不同；可以运行在任何操作系统上</li>
<li>缺点：系统调用将阻塞同一进程中的其他线程；不能利用多处理器技术</li>
</ul>
</li>
<li>内核级线程：管理线程的所有工作均由内核完成。 Windows是这种方法的一个例子。<ul>
<li>优点：ULT 两个缺点反过来说；内核本身也可以是多线程的</li>
<li>缺点：ULT 三个优点反过来说；</li>
</ul>
</li>
</ul>
<h3 id="进程七状态"><a href="#进程七状态" class="headerlink" title="进程七状态"></a>进程七状态</h3><ul>
<li>运行</li>
<li>就绪</li>
<li>阻塞</li>
<li>就绪/挂起</li>
<li>阻塞/挂起</li>
<li>New</li>
<li>Exit</li>
</ul>
<h3 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h3><p>二者都是进程派生后，父子进程其中一个退出的情况。僵尸进程是子进程退出，孤儿进程是父进程退出。</p>
<p>孤儿进程：父进程派生出子进程。父进程退出，但子进程还在运行，子进程就被称为孤儿进程。Unix 系统下，孤儿进程会被 <code>init</code> 进程收养，并在孤儿进程退出后由 <code>init</code> 进程对它们完成状态收集工作。孤儿进程没有什么危害。</p>
<p>僵尸进程：父进程 <code>fork</code> 出子进程。子进程退出，父进程并没有获取子进程的状态信息，子进程的进程描述符仍然留在系统中，子进程被称为僵尸进程，在 htop 的状态一栏会被标记为 <code>Z</code>。大量僵尸进程会占用内存空间，需要把父进程 kill 掉，僵尸进程转为孤儿进程，进而被 <code>init</code> 回收。</p>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul>
<li>先来先服务 <code>First Come First Served, FCFS</code></li>
<li>时间片轮转 <code>Round Robin, RR</code></li>
<li>短进程优先 <code>Shortest Process Next, SPN</code></li>
<li>剩余时间最短优先 <code>Shortest Remaining Time, SRT</code></li>
<li>响应比高者优先 <code>Highest Response Ratio Next, HRRN</code></li>
<li>反馈 <code>Feedback</code></li>
</ul>
<h3 id="进程切换算法"><a href="#进程切换算法" class="headerlink" title="进程切换算法"></a>进程切换算法</h3><ul>
<li>保存处理器上下文（寄存器）</li>
<li>更新当前进程的 PCB（状态、数据结构等变化）</li>
<li>将 PCB 的指针移至相应队列（就绪、阻塞、挂起等）</li>
<li>选择另一进程执行</li>
</ul>
<h3 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h3><p>同一进程的线程共享内存地址空间，没有必要依赖 OS 进行通信，但要做好同步/互斥，保护共享的全局变量。</p>
<ol>
<li>锁机制：三种常见的锁的实现包括互斥锁、读写锁、条件变量</li>
</ol>
<ul>
<li>互斥锁：提供了以排他方式防止数据结构被并发修改的方法</li>
<li>读写锁：允许多个线程同时读共享数据，而对写操作是互斥的</li>
<li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止（对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用）</li>
</ul>
<ol start="2">
<li>信号量 (Semaphore)</li>
<li>信号机制 (Signal)：类似进程间的信号处理</li>
</ol>
<h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ol>
<li>管道(pipe)，分为无名管道和有名管道</li>
<li>信号(signal)</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>套接字(socket)</li>
</ol>
<p>记住上面的六个词就可以对付 60% 的面试了，30% 的可能会问一下有名管道和无名管道的区别，剩下 10% 的面试可能每个都会问一下。</p>
<h3 id="如何保证缓存一致性"><a href="#如何保证缓存一致性" class="headerlink" title="如何保证缓存一致性"></a>如何保证缓存一致性</h3><p>缓存一致性就是保证内存和缓存中的内容相同。</p>
<p>实现上，每一行的缓存用一个 <code>modified</code> 标记了是否被修改。当这行缓存将被替换时，就会将这行内容写回内存。</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul>
<li>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>
<li>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../../images/605a9d2f21aeff216aacc4e08072cdddba4ba0ca9d0b60e3759c75a88e1a31dd.png" alt="浅拷贝" title="">
                </div>
                <div class="image-caption">浅拷贝</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../../images/e3af0f7454816313bae5f86994a8eddbf0e052b007b1d7acf54ba27781e86f99.png" alt="深拷贝" title="">
                </div>
                <div class="image-caption">深拷贝</div>
            </figure>

<h3 id="如何进行调试"><a href="#如何进行调试" class="headerlink" title="如何进行调试"></a>如何进行调试</h3><ul>
<li>利用标准输出 / log 调试；</li>
<li>利用 IDE 单步调试；</li>
<li>利用 <code>assert</code> 语句调试。</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528" target="_blank" rel="noopener">设计模式- 廖雪峰的官方网站</a></p>
<table>
<thead>
<tr>
<th>范围/目的</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>(类）适配器</td>
<td>模板方法、解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例<br>原型<br>抽象工厂<br>建造者</td>
<td>代理<br>(对象）适配器<br>桥接<br>装饰<br>外观<br>享元<br>组合</td>
<td>策略<br>命令<br>职责链<br>状态<br>观察者<br>中介者<br>迭代器<br>访问者<br>备忘录</td>
</tr>
</tbody></table>
<h4 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h4><ul>
<li>开闭原则：对扩展开放、对修改关闭</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">里氏替换原则</a>：如果对父类的调用可以成功，对子类的调用也应该成功，这也是面向对象编程的基础</li>
</ul>
<h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><blockquote>
<p>工厂方法：工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品</p>
</blockquote>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│   <span class="built_in">Product</span>   │      │   Factory   │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br><span class="line">       ▲                    ▲</span><br><span class="line">       │                    │</span><br><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<p>抽象工厂：抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                                ┌────────┐</span><br><span class="line">                             ─ &gt;│ProductA│</span><br><span class="line">┌────────┐    ┌─────────┐   │   └────────┘</span><br><span class="line">│<span class="built_in"> Client </span>│─ ─&gt;│ Factory │─ ─</span><br><span class="line">└────────┘    └─────────┘   │   ┌────────┐</span><br><span class="line">                   ▲         ─ &gt;│ProductB│</span><br><span class="line">           ┌───────┴───────┐    └────────┘</span><br><span class="line">           │               │</span><br><span class="line">      ┌─────────┐     ┌─────────┐</span><br><span class="line">      │Factory1 │     │Factory2 │</span><br><span class="line">      └─────────┘     └─────────┘</span><br><span class="line">           │   ┌─────────┐ │   ┌─────────┐</span><br><span class="line">            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│</span><br><span class="line">           │   └─────────┘ │   └─────────┘</span><br><span class="line">               ┌─────────┐     ┌─────────┐</span><br><span class="line">           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│</span><br><span class="line">               └─────────┘     └─────────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成器模式（Builder）：使用多个“小型”工厂来最终创建出一个完整对象。</p>
</blockquote>
<blockquote>
<p>原型模式（Prototype）：创建新对象的时候，根据现有的一个原型来创建。</p>
</blockquote>
<blockquote>
<p>单例模式（Singleton）：保证在一个进程中，某个类有且仅有一个实例。</p>
</blockquote>
<h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><blockquote>
<p>适配器（Adapter）：转换器，即负责将 A 类转换为 B 类的类</p>
</blockquote>
<p><code>InputStreamReader</code> 就是 Java 标准库提供的 Adapter，它负责把一个 <code>InputStream</code> 适配为 <code>Reader</code>。类似的还有 <code>OutputStreamWriter</code>。</p>
<blockquote>
<p>桥接模式（Bridge）：不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">桥接前：</span><br><span class="line"></span><br><span class="line">                   ┌───────┐</span><br><span class="line">                   │  Car  │</span><br><span class="line">                   └───────┘</span><br><span class="line">                       ▲</span><br><span class="line">    ┌──────────────────┼───────────────────┐</span><br><span class="line">    │                  │                   │</span><br><span class="line">┌───────┐          ┌───────┐          ┌───────┐</span><br><span class="line">│<span class="keyword">BigCar </span>│          │TinyCar│          │<span class="keyword">BossCar│</span></span><br><span class="line"><span class="keyword">└───────┘ </span>         └───────┘          └───────┘</span><br><span class="line">    ▲                  ▲                  ▲</span><br><span class="line">    │                  │                  │</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    ├─│  <span class="keyword">BigFuelCar </span>  │├─│  TinyFuelCar  │├─│  <span class="keyword">BossFuelCar </span> │</span><br><span class="line">    │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    ├─│<span class="keyword">BigElectricCar </span>│├─│TinyElectricCar│├─│<span class="keyword">BossElectricCar│</span></span><br><span class="line"><span class="keyword"> </span>   │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    └─│ <span class="keyword">BigHybridCar </span> │└─│ TinyHybridCar │└─│ <span class="keyword">BossHybridCar </span>│</span><br><span class="line">      └───────────────┘  └───────────────┘  └───────────────┘</span><br><span class="line"></span><br><span class="line">桥接后：</span><br><span class="line"></span><br><span class="line">       ┌───────────┐</span><br><span class="line">       │    Car    │</span><br><span class="line">       └───────────┘</span><br><span class="line">             ▲</span><br><span class="line">             │</span><br><span class="line">       ┌───────────┐       ┌─────────┐</span><br><span class="line">       │RefinedCar │ ─ ─ ─&gt;│ Engine  │</span><br><span class="line">       └───────────┘       └─────────┘</span><br><span class="line">             ▲                  ▲</span><br><span class="line">    ┌────────┼────────┐         │ ┌──────────────┐</span><br><span class="line">    │        │        │         ├─│  FuelEngine  │</span><br><span class="line">┌───────┐┌───────┐┌───────┐     │ └──────────────┘</span><br><span class="line">│<span class="keyword">BigCar </span>││TinyCar││<span class="keyword">BossCar│ </span>    │ ┌──────────────┐</span><br><span class="line">└───────┘└───────┘└───────┘     ├─│ElectricEngine│</span><br><span class="line">                                │ └──────────────┘</span><br><span class="line">                                │ ┌──────────────┐</span><br><span class="line">                                └─│ HybridEngine │</span><br><span class="line">                                  └──────────────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<p>组合（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个节点为子节点:</span></span><br><span class="line">    <span class="function">Node <span class="title">add</span><span class="params">(Node node)</span></span>;</span><br><span class="line">    <span class="comment">// 获取子节点:</span></span><br><span class="line">    <span class="function">List&lt;Node&gt; <span class="title">children</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 输出为XML:</span></span><br><span class="line">    <span class="function">String <span class="title">toXml</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。类似于这样的方法 <code>A decorator(A a);</code>。<br>顺带一提，Python 的装饰器就玩得很好。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建原始的数据源:</span></span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"test.gz"</span>);</span><br><span class="line"><span class="comment">// 增加缓冲功能:</span></span><br><span class="line">InputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"><span class="comment">// 增加解压缩功能:</span></span><br><span class="line">InputStream gis = <span class="keyword">new</span> GZIPInputStream(bis);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者一次性写成这样：</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> GZIPInputStream( <span class="comment">// 第二层装饰</span></span><br><span class="line">                        <span class="keyword">new</span> BufferedInputStream( <span class="comment">// 第一层装饰</span></span><br><span class="line">                            <span class="keyword">new</span> FileInputStream(<span class="string">"test.gz"</span>) <span class="comment">// 核心功能</span></span><br><span class="line">                        ));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>外观模式（Facade）：将复杂的流程包装成一个函数并暴露给调用方。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 register, openAccount, applyTaxCode 三个步骤包装成一个函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Company <span class="title">openCompany</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Company c = <span class="keyword">this</span>.admin.register(name);</span><br><span class="line">        String bankAccount = <span class="keyword">this</span>.bank.openAccount(c.getId());</span><br><span class="line">        c.setBankAccount(bankAccount);</span><br><span class="line">        String taxCode = <span class="keyword">this</span>.taxation.applyTaxCode(c.getId());</span><br><span class="line">        c.setTaxCode(taxCode);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>享元模式（Flyweight）：通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。如 <code>Integer.valueOf()</code>。</p>
</blockquote>
<blockquote>
<p>代理模式（Proxy）：将 A 接口转换成 A 接口，可在调用 A 的方法前后加一些额外的代码，实现对 A 的控制。</p>
</blockquote>
<h5 id="装饰器和代理的区别"><a href="#装饰器和代理的区别" class="headerlink" title="装饰器和代理的区别"></a>装饰器和代理的区别</h5><p><a href="https://zhuanlan.zhihu.com/p/97499017" target="_blank" rel="noopener">代理模式和装饰器模式的区别 - 知乎</a></p>
<p>装饰器和代理很相似，都是接收 A 接口，返回 A 接口。其区别主要是思想上的区别：</p>
<p><strong>装饰模式</strong>是为装饰的对象<strong>增强功能</strong>；</p>
<p>而<strong>代理模式</strong>对代理的对象施加<strong>控制</strong>，但不对对象本身的功能进行增强；</p>
<h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><blockquote>
<p>责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：</p>
</blockquote>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">     ┌─────────┐</span><br><span class="line">     │ <span class="built_in">Request</span> │</span><br><span class="line">     └─────────┘</span><br><span class="line">          │</span><br><span class="line">┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorA  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">          │</span><br><span class="line">│         ▼         │</span><br><span class="line">   ┌─────────────┐</span><br><span class="line">│  │ ProcessorB  │  │</span><br><span class="line">   └─────────────┘</span><br><span class="line">│         │         │</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorC  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">          │</span><br><span class="line">└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘</span><br><span class="line">          │</span><br><span class="line">          ▼</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。好处是可以对请求排队、记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<blockquote>
<p>解释器模式（Interpreter）：如 Python 解释器、正则表达式匹配等。</p>
</blockquote>
<blockquote>
<p>迭代器模式（Iterator）</p>
</blockquote>
<blockquote>
<p>中介模式（Mediator）：在多个组件的相互交互中，添加一个中介，所有组件和中介交互，实现组件间的松耦合。</p>
</blockquote>
<blockquote>
<p>备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。简单的实现是，编写这个类的 <code>getState()</code> 和 <code>setState()</code> 方法，负责导出、导入信息即可。</p>
</blockquote>
<blockquote>
<p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe, Pub/Sub）：发布方搞一个 <code>Observer</code> 数组；订阅操作就是将订阅者加入数组中；当发布方需要告知订阅者时，对数组中每个对象调用通知方法 <code>void onEvent(Event event);</code> 即可。</p>
</blockquote>
<blockquote>
<p>状态（State）</p>
</blockquote>
<blockquote>
<p>策略（Stategy）：即排序算法时使用的 Comparator</p>
</blockquote>
<blockquote>
<p>模板方法（Template Method）：使用抽象类定义流程，流程中的部分细节让子类实现</p>
</blockquote>
<blockquote>
<p>访问者（Visitor）：</p>
</blockquote>
<h2 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td>任务管理器</td>
</tr>
<tr>
<td><code>free</code></td>
<td>查看剩余内存等（不过为什么不用 <code>top</code> 呢）</td>
</tr>
<tr>
<td><code>ps</code></td>
<td>查看进程，可使用 `ps aux</td>
</tr>
<tr>
<td><code>kill -9 &lt;pid&gt;</code></td>
<td>杀进程</td>
</tr>
<tr>
<td><code>lsof -i:8000</code></td>
<td>查看 8000 端口的占用进程</td>
</tr>
<tr>
<td><code>nload</code></td>
<td>查看流量大小</td>
</tr>
<tr>
<td><code>wc</code></td>
<td>(word count) 统计文件的字数、行数、字符数</td>
</tr>
<tr>
<td><code>tail --follow</code></td>
<td>实时输出（日志）文件内容</td>
</tr>
<tr>
<td><code>journalctl -f -u &lt;unit.service&gt;</code></td>
<td>实时输出日志内容</td>
</tr>
<tr>
<td><code>grep word file.txt</code></td>
<td>在 <code>find.txt</code> 查找 <code>word</code> 字符串，<code>-i</code> 大小写不敏感</td>
</tr>
<tr>
<td><code>find &lt;directory&gt; -name &#39;file.txt&#39;</code></td>
<td>在目录下查找 <code>file.txt</code></td>
</tr>
<tr>
<td><code>df -h</code></td>
<td>查看文件剩余空间</td>
</tr>
</tbody></table>
<h2 id="低频考点"><a href="#低频考点" class="headerlink" title="低频考点"></a>低频考点</h2><p>以下是低频考点，但是在真实面试中问过一次，读者可以按需掌握。</p>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><h4 id="C-语言获取当前文件夹、函数名、行数"><a href="#C-语言获取当前文件夹、函数名、行数" class="headerlink" title="C 语言获取当前文件夹、函数名、行数"></a>C 语言获取当前文件夹、函数名、行数</h4><p>中望龙腾 C++ 岗笔试考过。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;direct.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; _getcwd(<span class="number">0</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>                   <span class="comment">// 获取当前文件夹</span></span><br><span class="line">        &lt;&lt; <span class="string">"__FUNCSIG__:"</span> &lt;&lt; __FUNCSIG__ &lt;&lt; <span class="built_in">endl</span>    <span class="comment">// 获取函数完整签名</span></span><br><span class="line">        &lt;&lt; <span class="string">"__FUNCTION__:"</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">endl</span>  <span class="comment">// 获取函数名</span></span><br><span class="line">        &lt;&lt; <span class="string">"__LINE__:"</span> &lt;&lt; __LINE__;                 <span class="comment">// 获取行数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">C:</span>\Users\liu\Desktop\test\cpp</span><br><span class="line"><span class="string">__FUNCSIG__:</span><span class="keyword">int</span> __cdecl main(<span class="keyword">void</span>)</span><br><span class="line"><span class="string">__FUNCTION__:</span>main</span><br><span class="line"><span class="string">__LINE__:</span><span class="number">11</span></span><br></pre></td></tr></table></figure>

<h4 id="C-语言字节对齐"><a href="#C-语言字节对齐" class="headerlink" title="C 语言字节对齐"></a><a href="/cpp/cpp-grammar/c-byte-alignment">C 语言字节对齐</a></h4><h4 id="cv-限定符"><a href="#cv-限定符" class="headerlink" title="cv 限定符"></a>cv 限定符</h4><p><a href="https://zh.cppreference.com/w/cpp/language/cv" target="_blank" rel="noopener">cv（const 与 volatile）类型限定符 | cppreference.com</a></p>
<p>cv 限定符是 <code>const</code> 和 <code>volatile</code> 的合称。</p>
<p><strong>当对象最初被创建</strong>时，所用的 cv 限定符决定对象的常量性或易变性。</p>
<p><code>const</code> 大家都懂，就是不能修改的常量 (constant)，直接修改会编译报错，间接修改（如利用 <code>const_cast&lt;int&amp;&gt;</code> 等手段）为未定义行为。还有一点，就是写为 <code>const</code> 之后，编译器会进行优化。</p>
<p>而 <code>volatile</code> 翻译过来是“易变”的，表明该变量可能通过软件甚至硬件方式变化。这会阻止编译器对这个变量进行任何优化，包括但不限于：不会将变量放到寄存器中；不会对 <code>const volatile</code> 变量当做 <code>const</code> 进行优化。（不过，CPU 仍可以将变量放入缓存中，因为缓存对程序员是透明的）</p>
<p>代码例子见 <a href="#const-cast">const_cast</a> 部分。</p>
<h4 id="static-用处"><a href="#static-用处" class="headerlink" title="static 用处"></a>static 用处</h4><p>C 语言的 static 有三个用处：</p>
<ol>
<li>对<code>函数内变量</code>使用，扩展其生存期；</li>
<li>对<code>函数外变量</code>和<code>函数</code>使用，使其他文件不能通过 <code>extern</code> 访问到该变量/函数（默认是可以的）；</li>
<li>对<code>类的成员/方法</code>使用，使得该变量/函数属于类（其他的都是属于每个对象），可以直接由类名 <code>Classname::</code> 调用；</li>
</ol>
<h4 id="禁止继承"><a href="#禁止继承" class="headerlink" title="禁止继承"></a>禁止继承</h4><p>C++ 11 引入了 <code>final</code> 关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">final</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">// error: 不能选择 final 类作为基类</span></span><br></pre></td></tr></table></figure>

<h4 id="禁止拷贝构造函数和赋值构造函数"><a href="#禁止拷贝构造函数和赋值构造函数" class="headerlink" title="禁止拷贝构造函数和赋值构造函数"></a>禁止拷贝构造函数和赋值构造函数</h4><p>C++11 加入了 <code>= delete</code> 控制类默认函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Thing(<span class="keyword">const</span> Thing&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Thing&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Thing&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thing t1;       <span class="comment">// 错误 E0291：类 "Thing" 不存在默认构造函数</span></span><br><span class="line">    <span class="function">Thing <span class="title">t2</span><span class="params">(t1)</span></span>;   <span class="comment">// 错误 E1776：无法引用 函数 "Thing::Thing(const Thing &amp;)" (已声明 所在行数:4) -- 它是已删除的函数</span></span><br><span class="line">    Thing t2 = t1;  <span class="comment">// 错误 E1776：无法引用 函数 "Thing::Thing(const Thing &amp;)" (已声明 所在行数:4) -- 它是已删除的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++98 前可以定义为 <code>private</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thing (<span class="keyword">const</span> Thing &amp;);</span><br><span class="line">    Thing &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Thing &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thing t1;</span><br><span class="line">    <span class="function">Thing <span class="title">t2</span><span class="params">(t1)</span></span>;  <span class="comment">//error C2248: “Thing::Thing”: 无法访问 private 成员</span></span><br><span class="line">    Thing t2 = t1; <span class="comment">//error C2248: “Thing::Thing”: 无法访问 private 成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="std-vector-和-std-array"><a href="#std-vector-和-std-array" class="headerlink" title="std::vector 和 std::array"></a>std::vector 和 std::array</h4><ul>
<li>vector 和 array 都是可以通过 <code>[]</code> 访问下标对应元素的数组；</li>
<li>vector 是变长数组，可以通过 <code>push_back</code> <code>insert</code> 和 <code>erase</code> 修数组大小。（注意 <code>insert</code> 和 <code>erase</code> 都是 $O(n)$ 的）；</li>
<li><a href="https://blog.csdn.net/qq_30835655/article/details/60762196" target="_blank" rel="noopener">C++ vector 内存分配与回收机制</a>；</li>
<li>array 则是 C++11 引入的、对标准数组的封装，是定长数组。</li>
</ul>
<h4 id="Lambda-捕获值列表"><a href="#Lambda-捕获值列表" class="headerlink" title="Lambda 捕获值列表"></a>Lambda 捕获值列表</h4><p><a href="https://changkun.de/modern-cpp/zh-cn/03-runtime/index.html#3-1-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">Modern C++ zh-cn</a></p>
<p>分为三种：</p>
<ol>
<li>值捕获 <code>[value]</code> 或 <code>[=value]</code>：与参数传值类似，值捕获的前提是变量可以拷贝。不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝。</li>
<li>引用捕获 <code>[&amp;value]</code>：与引用传参类似，引用捕获保存的是引用，值会发生变化。</li>
<li>隐式捕获 <code>[=]</code> 或 <code>[&amp;]</code>：手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获。（很多地方说的是捕获 <code>this</code>，我觉得还是这个好理解一些，毕竟如果在 main 函数中，也没有 <code>this</code> 一说）</li>
</ol>
<p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的<strong>最常用</strong>的四种形式可以是：</p>
<ol>
<li><code>[]</code> 空捕获列表</li>
<li><code>[name1, name2, ...]</code> 捕获一系列变量</li>
<li><code>[&amp;]</code> 引用捕获, 让编译器自行推导引用列表</li>
<li><code>[=]</code> 值捕获, 让编译器自行推导值捕获列表</li>
</ol>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="堆的复杂度"><a href="#堆的复杂度" class="headerlink" title="堆的复杂度"></a>堆的复杂度</h4><p>面腾讯的时候被问到，建堆的复杂度是多少，还好之前写过<a href="/computer-science/data-structure-and-algorithm/#%E5%A0%86-Heap">博客</a>，还有一点点印象不是 $O(n\log n)$，而是 $O(n)$。回顾了一下博客，果然是，顺便重温了一下证明。</p>
<h3 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="TIME-WAIT-快速回收与复用"><a href="#TIME-WAIT-快速回收与复用" class="headerlink" title="TIME_WAIT 快速回收与复用"></a>TIME_WAIT 快速回收与复用</h4><p><a href="http://langos.top/2019/04/07/time-wait%E5%BF%AB%E9%80%9F%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8/" target="_blank" rel="noopener">time-wait快速回收与复用 - rosewind的博客 | BY Blog</a><br><a href="https://ivanzz1001.github.io/records/post/tcpip/2018/04/24/tcpip_timewait#" target="_blank" rel="noopener">time_wait的快速回收和重用</a><br><a href="https://blog.csdn.net/cui918/article/details/52850846" target="_blank" rel="noopener">NAT环境下tcp_timestamps问题_〓☆〓 清风徐来918 （QQ:89617663）-CSDN博客_tcp_timestamps</a></p>
<p>这是腾讯主管问的问题，一般第二次考到的概率很小，但作为一个知识了解也不错。</p>
<p>TIME_WAIT 状态产生的原因在上面部分提到了，这里不再赘述。如果 TIME_WAIT 太多，导致无法对外建立新 TCP 连接。</p>
<p>在 Linux 下，可以从系统层面，或从应用程序层面解决这个问题。</p>
<hr>
<p>系统层面上，也有三种方法。</p>
<p>一是提高 <code>tcp_max_tw_buckets</code>，就能接受更多的 TIME_WAIT，但是治标不治本。</p>
<p>二是开启 TIME_WAIT 快速回收 <code>tcp_tw_recycle</code>（需同时开启 <code>tcp_timestamps</code>，系统默认开启）。原理是在 TCP 报文中加入时间戳（时间戳在 TCP 报文中的可选字段），然后系统缓存每个连接最新的时间戳。如果收到的 TCP 报文的时间戳早于缓存值，就丢弃数据包 (RFC1323)。</p>
<p>快速回收的问题在于，搭配 NAT 可能会出现问题。现在很多公司都用 LVS 做负载均衡，通常是前面一台 LVS，后面多台后端服务器，这其实就是 NAT，当请求到达 LVS 后，它修改地址数据后便转发给后端服务器，但不会修改时间戳数据，对于后端服务器来说，请求的源地址就是 LVS 的地址，加上端口会复用，所以从后端服务器的角度看，原本不同客户端的请求经过 LVS 的转发，就可能会被认为是同一个连接，加之不同客户端的时间可能不一致，所以就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的 SYN，但服务端就是不响应 ACK。如果服务器身处 NAT 环境，安全起见，通常要禁止 <code>tcp_tw_recycle</code>，至于TIME_WAIT连接过多的问题，可以通过 TIME_WAIT 复用解决。</p>
<p>三是开启 TIME_WAIT 复用 <code>tcp_tw_reuse</code>（也需要同时开启 <code>tcp_timestamps</code>）另外复用也是也是有条件的：协议认为复用是安全的。与 <code>tcp_tw_recycle</code> 选项相比，本选项一般不会带来副作用。</p>
<hr>
<p>应用层面上，有两种解决办法：一是将 TCP 短连接改造为长连接，二是快速关闭 socket。</p>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><p><a href="/back-end/http-status-code">HTTP 状态码</a></p>
<ul>
<li>1xx：<ul>
<li><code>102 Processing (WebDAV)</code> 用于表明 WebDAV 服务器收到了请求，但请求的操作比较费时，服务器正在处理（如遍历当前文件夹）。为了防止客户端 TCP 超时、假设请求丢失，于是服务器可以发送一个没有信息的 102 应答。</li>
</ul>
</li>
<li>2xx：<ul>
<li><code>200 OK</code></li>
<li><code>201 Created</code></li>
<li><code>202 Accepted</code> 表示正在进行一个异步操作。用于 1. 重置密码时，服务器返回 <code>202</code>，然后将重置邮件发送给邮箱；2. <a href="https://docs.microsoft.com/zh-cn/onedrive/developer/rest-api/api/driveitem_createuploadsession?view=odsp-graph-online" target="_blank" rel="noopener">Onedrive 分段上传时</a>，如果完成了一部分的上传，会返回 <code>202</code>。</li>
<li><code>204 No Content</code></li>
<li><code>206 Partial Content</code></li>
</ul>
</li>
<li>3xx：<ul>
<li>301 302 307 308 见后</li>
<li><code>304 Not Modified</code></li>
</ul>
</li>
<li>4xx：<ul>
<li><code>400 Bad Request</code></li>
<li><code>401 Unauthorized</code></li>
<li><code>403 Forbidden</code></li>
<li><code>404 Not Found</code></li>
<li><code>405 Method Not Allowed</code></li>
<li><code>409 Conflict</code></li>
<li><code>415 Unsupported Media Type</code></li>
</ul>
</li>
<li>5xx：<ul>
<li><code>500 Internal Server Error</code></li>
<li><code>502 Bad Gateway</code> 常见于 Nginx 反代的服务出锅了</li>
<li><code>504 Gateway Timeout</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>永久重定向 <code>Permanently</code></th>
<th>暂时重定向 <code>Temporarily</code></th>
</tr>
</thead>
<tbody><tr>
<td>允许将 <code>POST</code> 方法改为 <code>GET</code></td>
<td><code>301 Moved Permanently</code></td>
<td><code>302 Moved Temporarily</code></td>
</tr>
<tr>
<td>不允许将 <code>POST</code> 方法改为 <code>GET</code></td>
<td><code>308 Permanent Redirect</code></td>
<td><code>307 Temporary Redirect</code></td>
</tr>
</tbody></table>
<h4 id="HTTPS-原理及握手过程"><a href="#HTTPS-原理及握手过程" class="headerlink" title="HTTPS 原理及握手过程"></a>HTTPS 原理及握手过程</h4><p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述 - 阮一峰的网络日志</a></p>
<ol>
<li>客户端发送：ClientHello + 随机数 client random</li>
<li>服务端发送：ServerHello + 随机数 server random + 证书</li>
<li>（客户端验证证书有效性）</li>
<li>客户端发送：随机数 premaster secret (经公钥加密) </li>
<li>（服务器和客户端使用三个随机数生成一个会话密钥）</li>
<li>客户端发送：finished (经会话密钥加密)</li>
<li>服务端发送：finished (经会话密钥加密)</li>
</ol>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p><a href="https://zhuanlan.zhihu.com/p/108031600" target="_blank" rel="noopener">Nginx为什么快到根本停不下来？ - 知乎</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../../images/654b6c7ba89678ec0e0725ddffe75a93cac5d4146c22cc8da161bb2a4da9c683.png" alt="Nginx 的进程模型" title="">
                </div>
                <div class="image-caption">Nginx 的进程模型</div>
            </figure>

<h4 id="Nginx-多进程"><a href="#Nginx-多进程" class="headerlink" title="Nginx 多进程"></a>Nginx 多进程</h4><p>一个 Master 进程配合多个 Worker 进程</p>
<ol>
<li>Master 进程：管理 Worker 进程</li>
</ol>
<ul>
<li>对外接口：接收外部的操作（信号）</li>
<li>对内转发：根据外部的操作的不同，通过信号管理 Worker</li>
<li>监控：监控 worker 进程的运行状态，worker 进程异常终止后，自动重启 worker 进程</li>
</ul>
<ol start="2">
<li>Worker 进程：所有 Worker 进程都是平等的</li>
</ol>
<ul>
<li>实际处理：网络请求，由 Worker 进程处理；</li>
<li>Worker 进程数量：可在 nginx.conf 中配置，一般设置为核心数；</li>
</ul>
<h4 id="Nginx-IO-多路复用"><a href="#Nginx-IO-多路复用" class="headerlink" title="Nginx IO 多路复用"></a>Nginx IO 多路复用</h4><p>Nginx 使用epoll 多路复用</p>
<h4 id="Nginx-均衡负载算法"><a href="#Nginx-均衡负载算法" class="headerlink" title="Nginx 均衡负载算法"></a>Nginx 均衡负载算法</h4><p>共五种：</p>
<ol>
<li>轮询 (Round Robin)</li>
<li>加权轮训，权越大表示服务器的能力越强，能承受更大负载</li>
<li>最小连接数 (Least Connections)</li>
<li>IP Hash，保证同 IP 映射到同一服务器，在集群不同享 Session 时很好用</li>
<li>URL Hash，保证同 URL 映射到同一服务器，在有 URL 缓存时效率高</li>
</ol>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="Docker-底层"><a href="#Docker-底层" class="headerlink" title="Docker 底层"></a>Docker 底层</h4><p><a href="https://xiaoxiami.gitbook.io/docker/docker-de-di-ceng-ji-zhu" target="_blank" rel="noopener">Docker 的底层技术</a></p>
<blockquote>
<p>概要：Docker 使用 <strong>Linux 命名空间</strong>实现<strong>容器的隔离</strong>，使用<strong>控制组</strong>实现对容器的<strong>资源限制</strong>，使用<strong>联合文件系统</strong>提高<strong>存储效率</strong>。</p>
</blockquote>
<p>和虚拟机不同，Docker 进程和宿主机进程共用一个内核和某些系统库等。而彼此各个进程的方法是 Linux 上的**命名空间 (Namespaces)**。</p>
<p>Docker 使用名称空间来为容器提供隔离的工作空间。当一个容器运行时，Docker 就会为该容器创建一系列的名称空间，并为名称空间提供一层隔离。</p>
<p>Docker 引擎也依赖另一项叫 Control groups (cgroups，控制组) 的技术。控制组可以对程序进行资源限定，并允许 Docker 引擎在容器间进行硬件资源共享以及随时进行限制和约束，如内存等。</p>
<p>联合文件系统 (UnionFS) 是一种分层、轻量级并且高性能的文件系统，它支持将文件系统的修改作为一次提交来一层层地叠加。不同 Docker 容器可以共享基础的文件系统层，与自己独有的改动层一起使用，可以大大提高存储效率。</p>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3><h3 id="内存零拷贝"><a href="#内存零拷贝" class="headerlink" title="内存零拷贝"></a>内存零拷贝</h3>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-09-11T12:19:35.015Z" itemprop="dateUpdated">2021-09-11 20:19:35</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://blog.lyh543.cn">
            <img src="/img/avatar.png" alt="lyh543">
            lyh543
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%89%93%E5%B7%A5%E4%BA%BA/" rel="tag">打工人</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F%E9%9B%86%E5%90%88/" rel="tag">面经集合</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/carrers/interview-notes/&title=《面试相关知识》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon mdi mdi-sina-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/carrers/interview-notes/&title=《面试相关知识》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon mdi mdi-qqchat"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/carrers/interview-notes/" data-title=" Facebook">
          <i class="icon mdi mdi-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试相关知识》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/carrers/interview-notes/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon mdi mdi-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/carrers/interview-notes/" data-title=" Google+">
          <i class="icon mdi mdi-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-lg mdi mdi-share-variant"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/front-end/vue-debug/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon mdi mdi-chevron-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Vue 的调试方法</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/others/android-flashing-notes/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-lg icon-pl mdi mdi-chevron-right"></i></div>
        <h4 class="title">安卓刷机记录</h4>
      </a>
    </div>
  
</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: 'ec7daa4e047c3c30570d',
          clientSecret: '025a9e40a1d101f28fd1a945d286a819e9fa1c3d',
          repo: 'lyh543.github.io',
          owner: 'lyh543',
          admin: ['lyh543'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg mdi mdi-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>lyh543 &copy; 2019 - 2021</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">蜀ICP备19034464号</a><br>
                
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg mdi mdi-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.lyh543.cn/carrers/interview-notes/&title=《面试相关知识》 — 小灰灰灰灰的博客&pic=https://blog.lyh543.cn/img/avatar.png" data-title="微博">
          <i class="icon mdi mdi-sina-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.lyh543.cn/carrers/interview-notes/&title=《面试相关知识》 — 小灰灰灰灰的博客&source=" data-title=" QQ">
          <i class="icon mdi mdi-qqchat"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.lyh543.cn/carrers/interview-notes/" data-title=" Facebook">
          <i class="icon mdi mdi-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试相关知识》 — 小灰灰灰灰的博客&url=https://blog.lyh543.cn/carrers/interview-notes/&via=https://blog.lyh543.cn" data-title=" Twitter">
          <i class="icon mdi mdi-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.lyh543.cn/carrers/interview-notes/" data-title=" Google+">
          <i class="icon mdi mdi-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aQY6DMBBE0dz/0kTKKlKE+dU2o6H9vUITGPxYlNxtv154HJ/xff09fu8kv/Knlg0ZMmQ8lnEMxy9jjKxhxtfjucmQIWMfBgnZlDGeyvhOPjcZMmTI4BHJAzT9BDJkyJCRBu44OskycfysDBkyZMwUsaQdxkvWMfvGWlyGDBkPZNQ2Bv7m+vb9DRkyZPx7xjExeIOMB2hxJjJkyGjNGBefq1IuXYammwQyZMjozbixTQ/+zqkXC1YZMmS0ZvAGGW/fp0+lG5yozpYhQ0YjBrkpDU3exCflMQLLkCGjNYMvAWulZsqbL31lyJDRj8H/NQnBWguPHMK4AMuQIWMbxtpyNz1CkZbHMmTI2IfBy8V0ojxG06dOP4oMGTKaMmaK1VpLjm8nBNEsQ4aMDRhpoy0NzXSJyUMcTVGGDBkPZ/CXpQfI4tAEcR+scGXIkNGIwcNxVaM/PUCGIluGDBkbMGovSI9QpNEcLwplyJDRlMFb8LUyNTiVFob76RamDBkyWjPSiJzZgKzF8UVMy5AhYwMGb83XjpGRo7G1jVIZMmTswOCDxy4faVmbtv9kyJDxdEbtlUFhiUOThO9pZMuQIaM1oxa1M3HJG3zkWoYMGfsw5pdutQNhfAmI3itDhowNGOlxB360Ip0c/wQyZMiQUVuirT1OEZSvMmTIkBFO947m2sUyVIYMGRswSBHLtw34Pct2WWXIkNGaUTtmkbbhauXu4mJYhgwZz2O8Af9kA/HXZzvjAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>










</body>
</html>
