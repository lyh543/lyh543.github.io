(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{384:function(t,a,s){"use strict";s.r(a);var e=s(3),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("以下知识均在后台开发面试中实际出现过、总结而来。")]),t._v(" "),s("h2",{attrs:{id:"c"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c"}},[t._v("#")]),t._v(" C++")]),t._v(" "),s("h3",{attrs:{id:"多态的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多态的实现"}},[t._v("#")]),t._v(" 多态的实现")]),t._v(" "),s("p",[t._v("即虚函数表。")]),t._v(" "),s("h3",{attrs:{id:"stl-容器库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stl-容器库"}},[t._v("#")]),t._v(" STL 容器库")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zh.cppreference.com/w/cpp/container",target:"_blank",rel:"noopener noreferrer"}},[t._v("容器库 - cppreference.com"),s("OutboundLink")],1)]),t._v(" "),s("h3",{attrs:{id:"unordered-map-和-map-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unordered-map-和-map-的区别"}},[t._v("#")]),t._v(" unordered_map 和 map 的区别")]),t._v(" "),s("p",[t._v("略。")]),t._v(" "),s("h3",{attrs:{id:"multimap-和-map-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#multimap-和-map-的区别"}},[t._v("#")]),t._v(" multimap 和 map 的区别")]),t._v(" "),s("p",[t._v("略。")]),t._v(" "),s("h3",{attrs:{id:"智能指针"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#智能指针"}},[t._v("#")]),t._v(" 智能指针")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://docs.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-160",target:"_blank",rel:"noopener noreferrer"}},[t._v("智能指针（现代C++） | Microsoft Docs"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("智能指针是对普通指针的一个封装。普通指针 "),s("code",[t._v("new")]),t._v(" 了以后一定要 "),s("code",[t._v("delete")]),t._v("，而智能指针是一个类，当这个类的对象超出作用域以后，会自动调用析构函数，因此不再需要 "),s("code",[t._v("delete")]),t._v("，也不会因为忘记 "),s("code",[t._v("delete")]),t._v(" 而发生内存泄露。")]),t._v(" "),s("p",[t._v("智能指针和普通指针的对比：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("UseRawPointer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Using a raw pointer -- not recommended.")]),t._v("\n    Song"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" pSong "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Song")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("L"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Nothing on You"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" L"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Bruno Mars"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Use pSong...")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Don't forget to delete!")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" pSong"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("UseSmartPointer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Declare a smart pointer on stack and pass it the raw pointer.")]),t._v("\n    unique_ptr"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Song"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("song2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Song")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("L"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Nothing on You"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" L"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Bruno Mars"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Use song2...")]),t._v("\n    wstring s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" song2"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("duration_"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// song2 is deleted automatically here.")]),t._v("\n")])])]),s("p",[t._v("智能指针体现什么机制：封装。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("unique_ptr")]),t._v("："),s("code",[t._v("unique_ptr")]),t._v(" 的出现是为了替代 C++98 的 "),s("code",[t._v("auto_ptr")]),t._v(" (而 "),s("code",[t._v("auto_ptr")]),t._v(" 于 C++11 中被弃用)。如果不知道用什么，默认用 "),s("code",[t._v("unique_ptr")]),t._v(" 就对了。"),s("code",[t._v("unique_ptr")]),t._v(" 只占一个指针大小的空间")]),t._v(" "),s("li",[s("code",[t._v("shared_ptr")]),t._v("："),s("code",[t._v("shared_ptr")]),t._v(" 的管理类似于 Python 的垃圾回收机制：对变量进行计数（如下图）。拷贝构造 "),s("code",[t._v("auto sp3(sp2);")]),t._v(" 和赋值 "),s("code",[t._v("auto sp4 = sp2;")]),t._v(" 都会使得计数++。"),s("code",[t._v("shared_ptr")]),t._v(" 占两个指针大小的空间")]),t._v(" "),s("li",[s("code",[t._v("weak_ptr")]),t._v("："),s("code",[t._v("shared_ptr")]),t._v(" 中如果有循环引用，导致二者的计数都不为 0，会导致内存泄露。可以在引用的地方使用 "),s("code",[t._v("weak_ptr")]),t._v(" 并将 "),s("code",[t._v("shared_ptr")]),t._v(" 赋给它，这不会使得 "),s("code",[t._v("shared_ptr")]),t._v(" 计数++，之后能被正确地回收。"),s("a",{attrs:{href:"https://blog.csdn.net/c_base_jin/article/details/79440999",target:"_blank",rel:"noopener noreferrer"}},[t._v("例子"),s("OutboundLink")],1),t._v(" "),s("a",{attrs:{href:"https://docs.microsoft.com/zh-cn/cpp/cpp/how-to-create-and-use-weak-ptr-instances?view=msvc-160",target:"_blank",rel:"noopener noreferrer"}},[t._v("例子2"),s("OutboundLink")],1)])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/bfe1ee01619b2c9ccc4caed3ac55690651d628abb8b9e9956c2da7d9420c8fe4.png",alt:"shared_ptr"}})]),t._v(" "),s("h2",{attrs:{id:"数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),s("h3",{attrs:{id:"快排算法、快排的时间复杂度-平均、最坏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快排算法、快排的时间复杂度-平均、最坏"}},[t._v("#")]),t._v(" 快排算法、快排的时间复杂度（平均、最坏）")]),t._v(" "),s("h2",{attrs:{id:"数据库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[t._v("#")]),t._v(" 数据库")]),t._v(" "),s("h3",{attrs:{id:"mysql-数据库引擎"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql-数据库引擎"}},[t._v("#")]),t._v(" MySQL 数据库引擎")]),t._v(" "),s("ul",[s("li",[t._v("MyISAM：读性能高，但不支持外键、行级锁和事务，MySQL 5.5 默认")]),t._v(" "),s("li",[t._v("InnoDB：读性能稍弱，支持外键、行级锁和事务，MySQL 5.5.5 及以后默认")])]),t._v(" "),s("p",[t._v("二者都使用 B+ 树作为存储的数据结构。")]),t._v(" "),s("h3",{attrs:{id:"b-树和-b-树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b-树和-b-树"}},[t._v("#")]),t._v(" B 树和 B+ 树")]),t._v(" "),s("h4",{attrs:{id:"b-树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b-树"}},[t._v("#")]),t._v(" B 树")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/B%E6%A0%91",target:"_blank",rel:"noopener noreferrer"}},[t._v("B 树 | 维基百科"),s("OutboundLink")],1),s("br"),t._v(" "),s("a",{attrs:{href:"https://segmentfault.com/a/1190000020416577",target:"_blank",rel:"noopener noreferrer"}},[t._v("面试官问你B树和B+树，就把这篇文章丢给他- SegmentFault 思否"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("先要纠正两个常见误区：")]),t._v(" "),s("ul",[s("li",[t._v("B 树 (B-Tree) 不是二叉树 (Binary Tree)。B 的全称，可能起源于其"),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/B%E6%A0%91#%E5%90%8D%E5%AD%97%E5%8F%96%E4%B9%89",target:"_blank",rel:"noopener noreferrer"}},[t._v("发明者"),s("OutboundLink")],1),t._v("，不过理解成平衡 (balanced) 或宽的(broad) 或 茂密(bushy) 也不错。")]),t._v(" "),s("li",[t._v("没有 B 减树！B 减树的出现可能是翻译人员错误地将 B 树 (B-Tree) 翻译成了 B 减树。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/df871baea1f5b1cc17ad6a1c36c13eaae55a55f30987474ebe1ac5570b9d7567.png",alt:"B 树"}})]),t._v(" "),s("p",[t._v("概述：B 树是是一种自平衡的树，能够保持数据有序（听起来就是在说平衡二叉树）。其与平衡二叉树的不同在于，B 树的一个节点可以拥有 2 个以上的子节点，且节点数在某范围内可变。这样的好处有：")]),t._v(" "),s("ol",[s("li",[t._v("子结点的增多能够降低深度，减少定位记录时所经历的中间过程，运用在磁盘、数据库中可以加快存取速度；")]),t._v(" "),s("li",[t._v("由于节点数在范围内可变，因此 B 树不需要像其他平衡二叉查找树那样经常进行平衡")])]),t._v(" "),s("p",[t._v("定义：一棵 m 阶 B 树的定义：")]),t._v(" "),s("ol",[s("li",[t._v("每个节点最多有 "),s("code",[t._v("m-1")]),t._v(" 个 key；")]),t._v(" "),s("li",[t._v("根节点最少可以只有 "),s("code",[t._v("1")]),t._v(" 个 key，非根节点至少有 "),s("code",[t._v("m/2")]),t._v(" 个 key（根节点的 key 数量范围："),s("code",[t._v("[1, m-1]")]),t._v("，非根节点的 key 数量范围："),s("code",[t._v("[m/2, m-1]")]),t._v("。）；")]),t._v(" "),s("li",[t._v("每个节点中的 key 都按照从小到大的顺序排列，每个 key 的左子树中的所有 key 都小于它，而右子树中的所有 key 都大于它；")]),t._v(" "),s("li",[t._v("所有叶子节点都位于同一层（即根节点到每个叶子节点的长度都相同）；")]),t._v(" "),s("li",[t._v("每个节点都存有索引和数据，也就是对应的 key 和 value。")])]),t._v(" "),s("p",[t._v("B 树插入的规则："),s("strong",[t._v("插入的时候，判断当前结点key的个数是否小于等于 "),s("code",[t._v("m-1")]),t._v("，如果满足，直接插入即可，如果不满足，将节点的中间的 key 将这个节点分为左右两部分，中间的节点放到父节点中即可。")])]),t._v(" "),s("h4",{attrs:{id:"b-树-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b-树-2"}},[t._v("#")]),t._v(" B+ 树")]),t._v(" "),s("p",[t._v("B+ 树具有上述 B 树的前四个特点。除此之外，B+ 树还有以下特点：")]),t._v(" "),s("ol",[s("li",[t._v("B 树的所有结点都存储数据，而 B+ 树只有叶子结点存储数据，内部节点（或非叶子结点、索引节点）只存放索引；")]),t._v(" "),s("li",[t._v("B+ 树每个叶子结点存有下一个叶子结点的指针，而 B 树无，所以"),s("strong",[t._v("所有叶子结点形成了一条有序链表")]),t._v("，遍历整棵树只需要遍历链表，而不需要从树根往下遍历。")])]),t._v(" "),s("p",[t._v("B+ 树较 B 树的优点就是遍历快吧。")]),t._v(" "),s("h3",{attrs:{id:"慢查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#慢查询"}},[t._v("#")]),t._v(" 慢查询")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://tech.meituan.com/2014/06/30/mysql-index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL索引原理及慢查询优化- 美团技术团队"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("慢查询：超过指定时间的 SQL 语句查询。")]),t._v(" "),s("p",[t._v("优化方法：")]),t._v(" "),s("ol",[s("li",[t._v("查看日志查看慢查询")]),t._v(" "),s("li",[t._v("添加索引、修改索引（如先查区分度大的）")]),t._v(" "),s("li",[t._v("分库、分表")])]),t._v(" "),s("h3",{attrs:{id:"聚簇索引-非聚簇索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引-非聚簇索引"}},[t._v("#")]),t._v(" 聚簇索引 & 非聚簇索引")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/4489820786c2c39801d2488fac6c238e8963a52f2cb7efcd623cd0f8ee3eba66.png",alt:"聚簇索引 & 非聚簇索引"}})]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("非聚簇索引")]),t._v("（二级索引、辅助索引）：表数据和索引分成两部分存储，叶子结点存"),s("strong",[t._v("主键")]),t._v("和"),s("strong",[t._v("索引键")])]),t._v(" "),s("li",[s("strong",[t._v("聚簇索引")]),t._v("：表数据和主键一起存储，主键索引的叶子结点存"),s("strong",[t._v("行数据 (包含主键值)")])])]),t._v(" "),s("h3",{attrs:{id:"innodb-为什么推荐使用-auto-increment-作为主键"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#innodb-为什么推荐使用-auto-increment-作为主键"}},[t._v("#")]),t._v(" InnoDB 为什么推荐使用 auto_increment 作为主键")]),t._v(" "),s("ol",[s("li",[t._v("auto_increment 保证能新加入的数据的主键永远是最大的，加入的数据会被放在最后。在写入量大的时候，插入数据时是连续写入，而不是随机 I/O")]),t._v(" "),s("li",[t._v("auto_increment 使得主键和业务分离，这样即便业务上出现调整，也不需要重构数据库")])]),t._v(" "),s("h3",{attrs:{id:"事务的-acid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务的-acid"}},[t._v("#")]),t._v(" 事务的 ACID")]),t._v(" "),s("p",[t._v("ACID，是指数据库管理系统 (DBMS) 在写入或更新资料的过程中，为保证事务 (transaction) 是正确可靠的，所必须具备的四个特性：")]),t._v(" "),s("ul",[s("li",[t._v("原子性 (atomicity)：一个事务要么全做要么全不做；")]),t._v(" "),s("li",[s("strong",[t._v("一致性")]),t._v(" (consistency)：数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。最常见的例子是转帐：从帐户 A 转一笔钱到帐户 B 上，如果帐户 A 上的钱减少了，而帐户 B 上的钱却没有增加，那么我们认为此时数据处于不一致的状态；")]),t._v(" "),s("li",[t._v("隔离性 (isolation)：一个事务不影响其他事务的运行效果；")]),t._v(" "),s("li",[t._v("持久性 (durability)：事务一旦提交，则其结果就是永久性的，即使故障也能恢复。")])]),t._v(" "),s("p",[t._v("从数据库层面，数据库通过原子性、隔离性、持久性来保证"),s("strong",[t._v("一致性")]),t._v("。也就是说 ACID 四大特性之中，C 是目的，AID 是手段，是为了保证一致性，数据库提供的手段。")]),t._v(" "),s("h3",{attrs:{id:"事务的原子性和持久性的保证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务的原子性和持久性的保证"}},[t._v("#")]),t._v(" 事务的原子性和持久性的保证")]),t._v(" "),s("ol",[s("li",[t._v("将所有事务开始、提交、终止，以及数据的更新操作（记录数据更新前的值即前像，或更新后的值即后像）计入 log")]),t._v(" "),s("li",[t._v("系统崩溃后重启，先读取日志对已提交的事务进行 REDO（保证持久性）")]),t._v(" "),s("li",[t._v("然后对尚未提交的的事务进行 UNDO（保证原子性）")])]),t._v(" "),s("h3",{attrs:{id:"innodb-事务隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#innodb-事务隔离级别"}},[t._v("#")]),t._v(" InnoDB 事务隔离级别")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://developer.ibm.com/zh/technologies/databases/articles/os-mysql-transaction-isolation-levels-and-locks/",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL 事务隔离级别和锁– IBM Developer"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("SQL 标准定义了四种隔离，隔离程度由高到低依次为：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("读未提交")]),t._v("/"),s("strong",[t._v("脏读")]),t._v("：未提交事务的数据也可以被读，这也被称为脏读；")]),t._v(" "),s("li",[s("strong",[t._v("读提交")]),t._v("/"),s("strong",[t._v("不可重复读")]),t._v("：提交了的东西就可以被读，但若一个事务两次读取过程中，有事务更新了数据，会导致不可重复读；")]),t._v(" "),s("li",[s("strong",[t._v("可重复读")]),t._v("/"),s("strong",[t._v("幻读")]),t._v("（默认）：同一个事务中，"),s("code",[t._v("select")]),t._v(" 的结果是事务开始时的状态，因此可重复读。但由于 "),s("code",[t._v("insert")]),t._v(" 语句等不受影响，所以可能出现幻读（本事务开始后，别的事务提交了数据 "),s("code",[t._v("pk=1")]),t._v("，本事务 "),s("code",[t._v("select")]),t._v(" 不到 "),s("code",[t._v("pk=1")]),t._v("，但 "),s("code",[t._v("insert pk=1")]),t._v(" 会报错主键冲突，像是读到了幽灵）")]),t._v(" "),s("li",[s("strong",[t._v("序列化")]),t._v("：如果要完全解决上面的三种问题，就只能让事务串行化了，也就是把多个事务变成一个序列。")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("有/无问题")]),t._v(" "),s("th",[t._v("脏读")]),t._v(" "),s("th",[t._v("不可重复读")]),t._v(" "),s("th",[t._v("幻读")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("读未提交")]),t._v(" "),s("td",[t._v("有")]),t._v(" "),s("td",[t._v("有")]),t._v(" "),s("td",[t._v("有")])]),t._v(" "),s("tr",[s("td",[t._v("读提交")]),t._v(" "),s("td",[t._v("无")]),t._v(" "),s("td",[t._v("有")]),t._v(" "),s("td",[t._v("有")])]),t._v(" "),s("tr",[s("td",[t._v("可重复读")]),t._v(" "),s("td",[t._v("无")]),t._v(" "),s("td",[t._v("无")]),t._v(" "),s("td",[t._v("有")])]),t._v(" "),s("tr",[s("td",[t._v("序列化")]),t._v(" "),s("td",[t._v("无")]),t._v(" "),s("td",[t._v("无")]),t._v(" "),s("td",[t._v("无")])])])]),t._v(" "),s("h4",{attrs:{id:"数据库并发控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库并发控制"}},[t._v("#")]),t._v(" 数据库并发控制")]),t._v(" "),s("p",[t._v("见 "),s("RouterLink",{attrs:{to:"/computer-science/databse-concurrency-control/"}},[t._v("数据库并发控制")]),t._v("。")],1),t._v(" "),s("h4",{attrs:{id:"innodb-为每一行添加的字段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#innodb-为每一行添加的字段"}},[t._v("#")]),t._v(" InnoDB 为每一行添加的字段")]),t._v(" "),s("blockquote",[s("p",[t._v("参考："),s("a",{attrs:{href:"https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL 8.0 Reference Manual :: 15.3 InnoDB Multi-Versioning"),s("OutboundLink")],1)])]),t._v(" "),s("p",[t._v("InnoDB 为每一行多记录了三个字段：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("字段名")]),t._v(" "),s("th",[t._v("长度")]),t._v(" "),s("th",[t._v("意义")]),t._v(" "),s("th",[t._v("备注")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("code",[t._v("DB_TRX_ID")])]),t._v(" "),s("td",[t._v("6 字节")]),t._v(" "),s("td",[t._v("表示最后插入/更新该行的事务 id")]),t._v(" "),s("td",[t._v("删除操作视为更新，同时会将其中的一位置为 "),s("code",[t._v("1")]),t._v(" 表示 deleted")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("DB_ROLL_PTR")])]),t._v(" "),s("td",[t._v("7 字节")]),t._v(" "),s("td",[t._v("指向该次插入/更新对应的 undo logs")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[s("code",[t._v("DB_ROW_ID")])]),t._v(" "),s("td",[t._v("6 字节")]),t._v(" "),s("td",[t._v("自增。如果有聚集索引，字段会出现在索引中")]),t._v(" "),s("td",[t._v("和 MVCC 无关")])])])]),t._v(" "),s("h4",{attrs:{id:"undo-logs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#undo-logs"}},[t._v("#")]),t._v(" undo logs")]),t._v(" "),s("p",[t._v("在 InnoDB 中，undo logs 分为 insert undo logs 和 update undo logs。")]),t._v(" "),s("p",[t._v("insert undo logs 对其他事务没啥用：其他事务只需要判断一下查到的行的 "),s("code",[t._v("DB_TRX_ID")]),t._v(" 和自己的 id 就能知道该不该看到这条记录，不需要读 insert undo log 的具体内容。")]),t._v(" "),s("p",[t._v("所以 insert undo logs 只有在回滚的时候才会起作用，在该事务提交以后就可以删除 insert undo logs 了。")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("而 update undo logs 就麻烦很多了：其他事务发现查到的行的 "),s("code",[t._v("DB_TRX_ID")]),t._v(" 比自己的 id 大，说明这条记录在自己之后发生了更新，就要根据 "),s("code",[t._v("DB_ROLL_PTR")]),t._v(" 找到此更新对应的 undo logs，找到更新前的信息（包括更新前的值和 "),s("code",[t._v("DB_TRX_ID")]),t._v(" "),s("code",[t._v("DB_ROLL_PTR")]),t._v("）。如果这行的 "),s("code",[t._v("DB_TRX_ID")]),t._v(" 仍然大于自己的 id，就还要通过这行 "),s("code",[t._v("DB_ROLL_PTR")]),t._v(" 继续往前找。（该过程待求证）")]),t._v(" "),s("p",[t._v("所以，这就是多版本的含义")]),t._v(" "),s("h2",{attrs:{id:"计算机网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络"}},[t._v("#")]),t._v(" 计算机网络")]),t._v(" "),s("h3",{attrs:{id:"osi-七层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#osi-七层"}},[t._v("#")]),t._v(" OSI 七层")]),t._v(" "),s("p",[t._v("就是把应用层拓展为（自底向上）会话层、表示层（加密相关）、应用层。")]),t._v(" "),s("h3",{attrs:{id:"tcp-三次握手与四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手与四次挥手"}},[t._v("#")]),t._v(" TCP 三次握手与四次挥手")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://hit-alibaba.github.io/interview/basic/network/TCP.html#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP 三次握手与四次挥手"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("三次握手：")]),t._v(" "),s("ol",[s("li",[t._v("客户端：发送 "),s("code",[t._v("SYN")]),t._v("，进入 "),s("code",[t._v("SYN_SENT")]),t._v(" 状态")]),t._v(" "),s("li",[t._v("服务器：收到包后发送 "),s("code",[t._v("SYN ACK")]),t._v("，进入 "),s("code",[t._v("SYN_RCVD")]),t._v(" 状态")]),t._v(" "),s("li",[t._v("客户端：收到包后发送 "),s("code",[t._v("ACK")]),t._v("，进入 "),s("code",[t._v("ESTABLISHED")]),t._v(" 状态（服务器接收后也进入 "),s("code",[t._v("ESTABLISHED")]),t._v(" 状态）")])]),t._v(" "),s("p",[t._v("三个包的 "),s("code",[t._v("seq")]),t._v(" 和 "),s("code",[t._v("ACKnum")]),t._v(" 数值有如下关系：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("SYN ACK")]),t._v(" 的 ACKnum = "),s("code",[t._v("SYN")]),t._v(" 的 seq+1")]),t._v(" "),s("li",[s("code",[t._v("ACK")]),t._v(" 的 ACKnum = "),s("code",[t._v("SYN ACK")]),t._v(" 的 seq+1")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/11828738d7578e6fa82c6f0b1eb4ddbb974924935c80003fc0d892acbd66d8f0.png",alt:"TCP 三次握手"}})]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("四次挥手并不一定是客户端发起，也可以由服务端发起。故下面用 "),s("code",[t._v("主动关闭")]),t._v(" 和 "),s("code",[t._v("被动关闭")]),t._v(" 称呼：")]),t._v(" "),s("ol",[s("li",[t._v("主动关闭方：发送最后一个数据包后，发送 "),s("code",[t._v("FIN")]),t._v("，进入 "),s("code",[t._v("FIN_WAIT_1")]),t._v("；")]),t._v(" "),s("li",[t._v("被动关闭方：收到包后发送 "),s("code",[t._v("ACK")]),t._v("，进入 "),s("code",[t._v("CLOSE_WAIT")]),t._v("；客户端收到后进入 "),s("code",[t._v("FIN_WAIT_2")]),t._v("，此时客户端到服务端的单方连接被关闭；")]),t._v(" "),s("li",[t._v("被动关闭方：发送最后一个数据包后，发送 "),s("code",[t._v("FIN")]),t._v("，进入 "),s("code",[t._v("LAST_ACK")]),t._v("；")]),t._v(" "),s("li",[t._v("主动关闭方：收到包后发送 "),s("code",[t._v("ACK")]),t._v("，进入 "),s("code",[t._v("TIME_WAIT")]),t._v("，一段时间后关闭通信；服务端收到后立即关闭通信。")])]),t._v(" "),s("p",[t._v("可以理解为两对 "),s("code",[t._v("FIN - ACK")]),t._v("，且每个 "),s("code",[t._v("ACK")]),t._v(" 的 ACKnum = 对方的 "),s("code",[t._v("FIN")]),t._v(" 的 seq+1。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("CLOSE_WAIT")]),t._v(" 可以理解成对方主动关闭了连接，但本方还没有关闭，在等待关闭连接 (wait close)；")]),t._v(" "),s("li",[s("code",[t._v("TIME_WAIT")]),t._v(" 首先发出 FIN 的一侧，如果给对侧的 FIN 响应了 ACK，那么就会超时等待 2*MSL 时间，然后关闭连接(time wait)。在这段超时等待时间内，本地的端口不能被新连接使用；避免延时的包的到达与随后的新连接相混淆。RFC793 定义了 MSL 为2分钟（即 "),s("code",[t._v("TIME_WAIT")]),t._v(" 等待 4 分钟）。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/TCP_CLOSE.svg",alt:"TCP 四次挥手"}})]),t._v(" "),s("p",[t._v("被动关闭的一方也可以把 "),s("code",[t._v("ACK")]),t._v(" 和 "),s("code",[t._v("FIN")]),t._v(" 合并为 "),s("code",[t._v("FIN ACK")]),t._v("，实现三次挥手。")]),t._v(" "),s("h3",{attrs:{id:"tcp-流量控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-流量控制"}},[t._v("#")]),t._v(" TCP 流量控制")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/37379780",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP流量控制、拥塞控制"),s("OutboundLink")],1)]),t._v(" "),s("ul",[s("li",[t._v("流量控制：考虑到可能接收方处理的比较慢，需要限制发送方的发送速度。方法是，接收方发回的 ACK 中会包含自己接收窗口的大小。")]),t._v(" "),s("li",[t._v("流量控制死锁：当发送者收到了一个窗口为 0 的应答，便停止发送，等待接收者的下一个应答。但如果之后接受者发送的窗口不为 0 的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。")]),t._v(" "),s("li",[t._v("流量控制死锁避免：TCP 使用持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器，时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送。")])]),t._v(" "),s("h3",{attrs:{id:"tcp-快速重传"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-快速重传"}},[t._v("#")]),t._v(" TCP 快速重传")]),t._v(" "),s("ul",[s("li",[t._v("在没有快速重传机制下，如果发送方的某报文丢失，即使接受方发送了多个重复确认，发送方仍需等待重传计时器到期才会重传；")]),t._v(" "),s("li",[t._v("快速重传机制下，发送方一旦收到三个重复确认，就重传报文，无需等待计时器到期。")])]),t._v(" "),s("h3",{attrs:{id:"tcp-拥塞控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-拥塞控制"}},[t._v("#")]),t._v(" TCP 拥塞控制")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/37379780",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP流量控制、拥塞控制"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("发送方维持一个变量：拥塞窗口 (congestion window, cwnd)，取决于网络拥塞情况，且动态变化。")]),t._v(" "),s("p",[t._v("发送方使自己的发送窗口为 "),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("min")]),s("mo",[t._v("⁡")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("c")]),s("mi",[t._v("w")]),s("mi",[t._v("n")]),s("mi",[t._v("d")]),s("mo",{attrs:{separator:"true"}},[t._v(",")]),s("mi",[t._v("w")]),s("mi",[t._v("n")]),s("msub",[s("mi",[t._v("d")]),s("mtext",[t._v("接收方")])],1),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("\\min(cwnd, wnd_\\text{接收方})")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mop"},[t._v("min")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathdefault"},[t._v("c")]),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02691em"}},[t._v("w")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mord mathdefault"},[t._v("d")]),s("span",{staticClass:"mpunct"},[t._v(",")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02691em"}},[t._v("w")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord mathdefault"},[t._v("d")]),s("span",{staticClass:"msupsub"},[s("span",{staticClass:"vlist-t vlist-t2"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.32833099999999993em"}},[s("span",{staticStyle:{top:"-2.5500000000000003em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),s("span",{staticClass:"sizing reset-size6 size3 mtight"},[s("span",{staticClass:"mord text mtight"},[s("span",{staticClass:"mord cjk_fallback mtight"},[t._v("接收方")])])])])]),s("span",{staticClass:"vlist-s"},[t._v("​")])]),s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.15em"}},[s("span")])])])])]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。")],1),t._v(" "),s("ul",[s("li",[t._v("慢启动阶段，"),s("code",[t._v("cwnd=1")]),t._v("，每成功传输一次则 "),s("code",[t._v("cwnd*=2")]),t._v("，直至 cwnd 到达慢启动阈值 (slow-start threshold, ssthresh)，进入拥塞避免状态。")]),t._v(" "),s("li",[t._v("拥塞避免状态，每成功传输一次则 "),s("code",[t._v("cwnd++")])]),t._v(" "),s("li",[t._v("任何时刻，出现发送方对某报文的计时器超时，令 "),s("code",[t._v("ssthresh=cwnd/2，cwnd=1")]),t._v("，重新进入慢启动")]),t._v(" "),s("li",[s("strong",[t._v("快速恢复")]),t._v("：任何时刻，出现发送方接收到三个重复确认，并不按照上一条执行，而是令 "),s("code",[t._v("ssthresh=cwnd/2, cwnd=cwnd/2+3")]),t._v("，进入拥塞避免状态（能收到重复报文，说明网络没那么拥堵，超时才是真的拥堵）")])]),t._v(" "),s("h3",{attrs:{id:"用户从输入域名到获取到信息过程中发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用户从输入域名到获取到信息过程中发生了什么"}},[t._v("#")]),t._v(" 用户从输入域名到获取到信息过程中发生了什么")]),t._v(" "),s("p",[t._v("a. DNS 解析的过程：计算机先检查 DNS 缓存，如果没有缓存则向 DNS 服务器查询域名对应的 IP，查询的过程分为迭代和递归两种方式；面试官接着问了 DNS 基于什么协议，答案是 UDP，服务器一般使用 53 端口；\nb. 获取到 IP 以后就可以发包了，需要对包进行一层层的封装，自顶向下的封装顺序为：HTTP、TLS、TCP、IP。\nc. HTTP 协议的内容大致为 "),s("code",[t._v("HTTP/1.1 GET /")]),t._v("；\nd. TLS 协议会进行 TLS 握手，主要是客户端、服务端交换密钥；\ne. 再往下是 TCP 和 UDP 协议。经典一问：TCP 和 UDP 的区别（TCP 面向连接、拥塞控制、流量控制），顺便还简单问了一下拥塞控制；\nf. 再往下就是 IP 层，主机会向向路由器发 IP 包、路由器根据路由表和选路算法进行转发的过程；面试官又问了有那些选路算法（分为域内和域间协议，域内有 OSPF 和 RIP，域间使用 BGP）；以及路由表的最长前缀匹配原则；\ne. 再往下就是物理层了。")]),t._v(" "),s("h2",{attrs:{id:"操作系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#操作系统"}},[t._v("#")]),t._v(" 操作系统")]),t._v(" "),s("h3",{attrs:{id:"进程和线程的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的区别"}},[t._v("#")]),t._v(" 进程和线程的区别")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("调度并分派的单位")]),t._v("称为"),s("strong",[t._v("线程")]),t._v("（或轻量级进程 "),s("code",[t._v("LWP")]),t._v("）")]),t._v(" "),s("li",[s("strong",[t._v("资源所有权的单位")]),t._v("称为"),s("strong",[t._v("进程")])])]),t._v(" "),s("p",[t._v("进程会创建进程控制块 (PCB)，而线程是线程控制块 (TCB)。由于线程没有父子进程、资源控制等结构，所以 TCB 比 PCB 简单得多，这也导致线程的创建比进程的创建快得多，大概有一个数量级的区别。")]),t._v(" "),s("p",[t._v("这也是平时开发中，为了利用 CPU 多线程，我们常使用多线程开发，而不是多进程开发的原因。")]),t._v(" "),s("h3",{attrs:{id:"用户态和内核态的区别-这样有什么好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用户态和内核态的区别-这样有什么好处"}},[t._v("#")]),t._v(" 用户态和内核态的区别，这样有什么好处")]),t._v(" "),s("ul",[s("li",[t._v("用户模式：优先权较少，用于运行用户程序")]),t._v(" "),s("li",[t._v("内核模式：优先权更高，用于运行内核，且某些指令、内存只能在特权模式下运行/访问，如：\n"),s("ul",[s("li",[t._v("读取/修改 PSW 等控制"),s("strong",[t._v("寄存器")])]),t._v(" "),s("li",[t._v("原始 "),s("strong",[t._v("I/O")]),t._v(" 指令")]),t._v(" "),s("li",[s("strong",[t._v("内存")]),t._v("管理相关")])])])]),t._v(" "),s("p",[t._v("区分用户模式和内核模式的原因："),s("strong",[t._v("保护 OS 和重要操作系统表不受程序干扰")])]),t._v(" "),s("h3",{attrs:{id:"用户级线程和内核级线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用户级线程和内核级线程"}},[t._v("#")]),t._v(" 用户级线程和内核级线程")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/1ff352e0972f8ffc505e4894c7b735ea5cd53cebaa644755185f2a07ab9a2479.png",alt:"用户级线程和内核级线程"}})]),t._v(" "),s("ul",[s("li",[t._v("用户级线程：线程、线程的创建、销毁全部由库函数实现。"),s("strong",[t._v("内核不知道用户级线程的存在，依旧按照进程为单位进行调度")]),t._v("。\n"),s("ul",[s("li",[t._v("优点：线程切换不需要内核模式，快；调度策略因应用程序不同而不同；可以运行在任何操作系统上")]),t._v(" "),s("li",[t._v("缺点：系统调用将阻塞同一进程中的其他线程；不能利用多处理器技术")])])]),t._v(" "),s("li",[t._v("内核级线程：管理线程的所有工作均由内核完成。 Windows是这种方法的一个例子。\n"),s("ul",[s("li",[t._v("优点：ULT 两个缺点反过来说；内核本身也可以是多线程的")]),t._v(" "),s("li",[t._v("缺点：ULT 三个优点反过来说；")])])])]),t._v(" "),s("h3",{attrs:{id:"进程七状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程七状态"}},[t._v("#")]),t._v(" 进程七状态")]),t._v(" "),s("ul",[s("li",[t._v("运行")]),t._v(" "),s("li",[t._v("就绪")]),t._v(" "),s("li",[t._v("阻塞")]),t._v(" "),s("li",[t._v("就绪/挂起")]),t._v(" "),s("li",[t._v("阻塞/挂起")]),t._v(" "),s("li",[t._v("New")]),t._v(" "),s("li",[t._v("Exit")])]),t._v(" "),s("h3",{attrs:{id:"僵尸进程和孤儿进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#僵尸进程和孤儿进程"}},[t._v("#")]),t._v(" 僵尸进程和孤儿进程")]),t._v(" "),s("p",[t._v("二者都是进程派生后，父子进程其中一个退出的情况。僵尸进程是子进程退出，孤儿进程是父进程退出。")]),t._v(" "),s("p",[t._v("孤儿进程：父进程派生出子进程。父进程退出，但子进程还在运行，子进程就被称为孤儿进程。Unix 系统下，孤儿进程会被 "),s("code",[t._v("init")]),t._v(" 进程收养，并在孤儿进程退出后由 "),s("code",[t._v("init")]),t._v(" 进程对它们完成状态收集工作。孤儿进程没有什么危害。")]),t._v(" "),s("p",[t._v("僵尸进程：父进程 "),s("code",[t._v("fork")]),t._v(" 出子进程。子进程退出，父进程并没有获取子进程的状态信息，子进程的进程描述符仍然留在系统中，子进程被称为僵尸进程，在 htop 的状态一栏会被标记为 "),s("code",[t._v("Z")]),t._v("。大量僵尸进程会占用内存空间，需要把父进程 kill 掉，僵尸进程转为孤儿进程，进而被 "),s("code",[t._v("init")]),t._v(" 回收。")]),t._v(" "),s("h3",{attrs:{id:"进程调度算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程调度算法"}},[t._v("#")]),t._v(" 进程调度算法")]),t._v(" "),s("ul",[s("li",[t._v("先来先服务 "),s("code",[t._v("First Come First Served, FCFS")])]),t._v(" "),s("li",[t._v("时间片轮转 "),s("code",[t._v("Round Robin, RR")])]),t._v(" "),s("li",[t._v("短进程优先 "),s("code",[t._v("Shortest Process Next, SPN")])]),t._v(" "),s("li",[t._v("剩余时间最短优先 "),s("code",[t._v("Shortest Remaining Time, SRT")])]),t._v(" "),s("li",[t._v("响应比高者优先 "),s("code",[t._v("Highest Response Ratio Next, HRRN")])]),t._v(" "),s("li",[t._v("反馈 "),s("code",[t._v("Feedback")])])]),t._v(" "),s("h3",{attrs:{id:"进程切换算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程切换算法"}},[t._v("#")]),t._v(" 进程切换算法")]),t._v(" "),s("ul",[s("li",[t._v("保存处理器上下文（寄存器）")]),t._v(" "),s("li",[t._v("更新当前进程的 PCB（状态、数据结构等变化）")]),t._v(" "),s("li",[t._v("将 PCB 的指针移至相应队列（就绪、阻塞、挂起等）")]),t._v(" "),s("li",[t._v("选择另一进程执行")])]),t._v(" "),s("h3",{attrs:{id:"线程间通信方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程间通信方式"}},[t._v("#")]),t._v(" 线程间通信方式")]),t._v(" "),s("p",[t._v("同一进程的线程共享内存地址空间，没有必要依赖 OS 进行通信，但要做好同步/互斥，保护共享的全局变量。")]),t._v(" "),s("ol",[s("li",[t._v("锁机制：三种常见的锁的实现包括互斥锁、读写锁、条件变量")])]),t._v(" "),s("ul",[s("li",[t._v("互斥锁：提供了以排他方式防止数据结构被并发修改的方法")]),t._v(" "),s("li",[t._v("读写锁：允许多个线程同时读共享数据，而对写操作是互斥的")]),t._v(" "),s("li",[t._v("条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止（对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用）")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("信号量 (Semaphore)")]),t._v(" "),s("li",[t._v("信号机制 (Signal)：类似进程间的信号处理")])]),t._v(" "),s("h3",{attrs:{id:"进程间通信方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信方式"}},[t._v("#")]),t._v(" 进程间通信方式")]),t._v(" "),s("ol",[s("li",[t._v("管道(pipe)，分为无名管道和有名管道")]),t._v(" "),s("li",[t._v("信号(signal)")]),t._v(" "),s("li",[t._v("消息队列")]),t._v(" "),s("li",[t._v("共享内存")]),t._v(" "),s("li",[t._v("信号量")]),t._v(" "),s("li",[t._v("套接字(socket)")])]),t._v(" "),s("p",[t._v("记住上面的六个词就可以对付 60% 的面试了，30% 的可能会问一下有名管道和无名管道的区别，剩下 10% 的面试可能每个都会问一下。")]),t._v(" "),s("h3",{attrs:{id:"如何保证缓存一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何保证缓存一致性"}},[t._v("#")]),t._v(" 如何保证缓存一致性")]),t._v(" "),s("p",[t._v("缓存一致性就是保证内存和缓存中的内容相同。")]),t._v(" "),s("p",[t._v("实现上，每一行的缓存用一个 "),s("code",[t._v("modified")]),t._v(" 标记了是否被修改。当这行缓存将被替换时，就会将这行内容写回内存。")]),t._v(" "),s("h2",{attrs:{id:"开发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发"}},[t._v("#")]),t._v(" 开发")]),t._v(" "),s("h3",{attrs:{id:"深拷贝和浅拷贝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝"}},[t._v("#")]),t._v(" 深拷贝和浅拷贝")]),t._v(" "),s("ul",[s("li",[t._v("浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。")]),t._v(" "),s("li",[t._v("深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/605a9d2f21aeff216aacc4e08072cdddba4ba0ca9d0b60e3759c75a88e1a31dd.png",alt:"浅拷贝"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/e3af0f7454816313bae5f86994a8eddbf0e052b007b1d7acf54ba27781e86f99.png",alt:"深拷贝"}})]),t._v(" "),s("h3",{attrs:{id:"如何进行调试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何进行调试"}},[t._v("#")]),t._v(" 如何进行调试")]),t._v(" "),s("ul",[s("li",[t._v("利用标准输出 / log 调试；")]),t._v(" "),s("li",[t._v("利用 IDE 单步调试；")]),t._v(" "),s("li",[t._v("利用 "),s("code",[t._v("assert")]),t._v(" 语句调试。")])]),t._v(" "),s("h3",{attrs:{id:"设计模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528",target:"_blank",rel:"noopener noreferrer"}},[t._v("设计模式- 廖雪峰的官方网站"),s("OutboundLink")],1)]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("范围/目的")]),t._v(" "),s("th",[t._v("创建型模式")]),t._v(" "),s("th",[t._v("结构型模式")]),t._v(" "),s("th",[t._v("行为型模式")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("类模式")]),t._v(" "),s("td",[t._v("工厂方法")]),t._v(" "),s("td",[t._v("(类）适配器")]),t._v(" "),s("td",[t._v("模板方法、解释器")])]),t._v(" "),s("tr",[s("td",[t._v("对象模式")]),t._v(" "),s("td",[t._v("单例"),s("br"),t._v("原型"),s("br"),t._v("抽象工厂"),s("br"),t._v("建造者")]),t._v(" "),s("td",[t._v("代理"),s("br"),t._v("(对象）适配器"),s("br"),t._v("桥接"),s("br"),t._v("装饰"),s("br"),t._v("外观"),s("br"),t._v("享元"),s("br"),t._v("组合")]),t._v(" "),s("td",[t._v("策略"),s("br"),t._v("命令"),s("br"),t._v("职责链"),s("br"),t._v("状态"),s("br"),t._v("观察者"),s("br"),t._v("中介者"),s("br"),t._v("迭代器"),s("br"),t._v("访问者"),s("br"),t._v("备忘录")])])])]),t._v(" "),s("h4",{attrs:{id:"设计模式的原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的原则"}},[t._v("#")]),t._v(" 设计模式的原则")]),t._v(" "),s("ul",[s("li",[t._v("开闭原则：对扩展开放、对修改关闭")]),t._v(" "),s("li",[s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99",target:"_blank",rel:"noopener noreferrer"}},[t._v("里氏替换原则"),s("OutboundLink")],1),t._v("：如果对父类的调用可以成功，对子类的调用也应该成功，这也是面向对象编程的基础")])]),t._v(" "),s("h4",{attrs:{id:"创建型模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式"}},[t._v("#")]),t._v(" 创建型模式")]),t._v(" "),s("blockquote",[s("p",[t._v("工厂方法：工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("┌─────────────┐      ┌─────────────┐\n│   Product   │      │   Factory   │\n└─────────────┘      └─────────────┘\n       ▲                    ▲\n       │                    │\n┌─────────────┐      ┌─────────────┐\n│ ProductImpl │<─ ─ ─│ FactoryImpl │\n└─────────────┘      └─────────────┘\n")])])]),s("blockquote",[s("p",[t._v("抽象工厂：抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("                                ┌────────┐\n                             ─ >│ProductA│\n┌────────┐    ┌─────────┐   │   └────────┘\n│ Client │─ ─>│ Factory │─ ─\n└────────┘    └─────────┘   │   ┌────────┐\n                   ▲         ─ >│ProductB│\n           ┌───────┴───────┐    └────────┘\n           │               │\n      ┌─────────┐     ┌─────────┐\n      │Factory1 │     │Factory2 │\n      └─────────┘     └─────────┘\n           │   ┌─────────┐ │   ┌─────────┐\n            ─ >│ProductA1│  ─ >│ProductA2│\n           │   └─────────┘ │   └─────────┘\n               ┌─────────┐     ┌─────────┐\n           └ ─>│ProductB1│ └ ─>│ProductB2│\n               └─────────┘     └─────────┘\n")])])]),s("blockquote",[s("p",[t._v("生成器模式（Builder）：使用多个“小型”工厂来最终创建出一个完整对象。")])]),t._v(" "),s("blockquote",[s("p",[t._v("原型模式（Prototype）：创建新对象的时候，根据现有的一个原型来创建。")])]),t._v(" "),s("blockquote",[s("p",[t._v("单例模式（Singleton）：保证在一个进程中，某个类有且仅有一个实例。")])]),t._v(" "),s("h4",{attrs:{id:"结构型模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[t._v("#")]),t._v(" 结构型模式")]),t._v(" "),s("blockquote",[s("p",[t._v("适配器（Adapter）：转换器，即负责将 A 类转换为 B 类的类")])]),t._v(" "),s("p",[s("code",[t._v("InputStreamReader")]),t._v(" 就是 Java 标准库提供的 Adapter，它负责把一个 "),s("code",[t._v("InputStream")]),t._v(" 适配为 "),s("code",[t._v("Reader")]),t._v("。类似的还有 "),s("code",[t._v("OutputStreamWriter")]),t._v("。")]),t._v(" "),s("blockquote",[s("p",[t._v("桥接模式（Bridge）：不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("桥接前：\n\n                   ┌───────┐\n                   │  Car  │\n                   └───────┘\n                       ▲\n    ┌──────────────────┼───────────────────┐\n    │                  │                   │\n┌───────┐          ┌───────┐          ┌───────┐\n│BigCar │          │TinyCar│          │BossCar│\n└───────┘          └───────┘          └───────┘\n    ▲                  ▲                  ▲\n    │                  │                  │\n    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐\n    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │\n    │ └───────────────┘│ └───────────────┘│ └───────────────┘\n    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐\n    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│\n    │ └───────────────┘│ └───────────────┘│ └───────────────┘\n    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐\n    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │\n      └───────────────┘  └───────────────┘  └───────────────┘\n\n桥接后：\n\n       ┌───────────┐\n       │    Car    │\n       └───────────┘\n             ▲\n             │\n       ┌───────────┐       ┌─────────┐\n       │RefinedCar │ ─ ─ ─>│ Engine  │\n       └───────────┘       └─────────┘\n             ▲                  ▲\n    ┌────────┼────────┐         │ ┌──────────────┐\n    │        │        │         ├─│  FuelEngine  │\n┌───────┐┌───────┐┌───────┐     │ └──────────────┘\n│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐\n└───────┘└───────┘└───────┘     ├─│ElectricEngine│\n                                │ └──────────────┘\n                                │ ┌──────────────┐\n                                └─│ HybridEngine │\n                                  └──────────────┘\n")])])]),s("blockquote",[s("p",[t._v("组合（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 添加一个节点为子节点:")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取子节点:")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("children")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 输出为XML:")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("toXml")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。类似于这样的方法 "),s("code",[t._v("A decorator(A a);")]),t._v("。"),s("br"),t._v("\n顺带一提，Python 的装饰器就玩得很好。")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建原始的数据源:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InputStream")]),t._v(" fis "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FileInputStream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test.gz"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 增加缓冲功能:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InputStream")]),t._v(" bis "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BufferedInputStream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 增加解压缩功能:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InputStream")]),t._v(" gis "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GZIPInputStream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 或者一次性写成这样：")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InputStream")]),t._v(" input "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GZIPInputStream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第二层装饰")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BufferedInputStream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一层装饰")]),t._v("\n                            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FileInputStream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test.gz"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 核心功能")]),t._v("\n                        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("外观模式（Facade）：将复杂的流程包装成一个函数并暴露给调用方。")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将 register, openAccount, applyTaxCode 三个步骤包装成一个函数")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Facade")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Company")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("openCompany")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Company")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("admin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("register")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" bankAccount "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bank"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("openAccount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setBankAccount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bankAccount"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" taxCode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("taxation"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("applyTaxCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTaxCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("taxCode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("享元模式（Flyweight）：通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。如 "),s("code",[t._v("Integer.valueOf()")]),t._v("。")])]),t._v(" "),s("blockquote",[s("p",[t._v("代理模式（Proxy）：将 A 接口转换成 A 接口，可在调用 A 的方法前后加一些额外的代码，实现对 A 的控制。")])]),t._v(" "),s("h5",{attrs:{id:"装饰器和代理的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装饰器和代理的区别"}},[t._v("#")]),t._v(" 装饰器和代理的区别")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/97499017",target:"_blank",rel:"noopener noreferrer"}},[t._v("代理模式和装饰器模式的区别 - 知乎"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("装饰器和代理很相似，都是接收 A 接口，返回 A 接口。其区别主要是思想上的区别：")]),t._v(" "),s("p",[s("strong",[t._v("装饰模式")]),t._v("是为装饰的对象"),s("strong",[t._v("增强功能")]),t._v("；")]),t._v(" "),s("p",[t._v("而"),s("strong",[t._v("代理模式")]),t._v("对代理的对象施加"),s("strong",[t._v("控制")]),t._v("，但不对对象本身的功能进行增强；")]),t._v(" "),s("h4",{attrs:{id:"行为型模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式"}},[t._v("#")]),t._v(" 行为型模式")]),t._v(" "),s("blockquote",[s("p",[t._v("责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("     ┌─────────┐\n     │ Request │\n     └─────────┘\n          │\n┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐\n          ▼\n│  ┌─────────────┐  │\n   │ ProcessorA  │\n│  └─────────────┘  │\n          │\n│         ▼         │\n   ┌─────────────┐\n│  │ ProcessorB  │  │\n   └─────────────┘\n│         │         │\n          ▼\n│  ┌─────────────┐  │\n   │ ProcessorC  │\n│  └─────────────┘  │\n          │\n└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘\n          │\n          ▼\n")])])]),s("blockquote",[s("p",[t._v("命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。好处是可以对请求排队、记录请求日志，以及支持可撤销的操作。")])]),t._v(" "),s("blockquote",[s("p",[t._v("解释器模式（Interpreter）：如 Python 解释器、正则表达式匹配等。")])]),t._v(" "),s("blockquote",[s("p",[t._v("迭代器模式（Iterator）")])]),t._v(" "),s("blockquote",[s("p",[t._v("中介模式（Mediator）：在多个组件的相互交互中，添加一个中介，所有组件和中介交互，实现组件间的松耦合。")])]),t._v(" "),s("blockquote",[s("p",[t._v("备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。简单的实现是，编写这个类的 "),s("code",[t._v("getState()")]),t._v(" 和 "),s("code",[t._v("setState()")]),t._v(" 方法，负责导出、导入信息即可。")])]),t._v(" "),s("blockquote",[s("p",[t._v("观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe, Pub/Sub）：发布方搞一个 "),s("code",[t._v("Observer")]),t._v(" 数组；订阅操作就是将订阅者加入数组中；当发布方需要告知订阅者时，对数组中每个对象调用通知方法 "),s("code",[t._v("void onEvent(Event event);")]),t._v(" 即可。")])]),t._v(" "),s("blockquote",[s("p",[t._v("状态（State）")])]),t._v(" "),s("blockquote",[s("p",[t._v("策略（Stategy）：即排序算法时使用的 Comparator")])]),t._v(" "),s("blockquote",[s("p",[t._v("模板方法（Template Method）：使用抽象类定义流程，流程中的部分细节让子类实现")])]),t._v(" "),s("blockquote",[s("p",[t._v("访问者（Visitor）：包含对不同种类东西的访问方法（也可以理解成回调函数），如对文件和文件夹的访问方法")])]),t._v(" "),s("h2",{attrs:{id:"linux-命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux-命令"}},[t._v("#")]),t._v(" Linux 命令")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("命令")]),t._v(" "),s("th",[t._v("用途")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("code",[t._v("top")])]),t._v(" "),s("td",[t._v("任务管理器")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("free")])]),t._v(" "),s("td",[t._v("查看剩余内存等（不过为什么不用 "),s("code",[t._v("top")]),t._v(" 呢）")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("ps")])]),t._v(" "),s("td",[t._v("查看进程，可使用 "),s("code",[t._v("ps aux | grep '<process_name>'")]),t._v(" 查 pid")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("kill -9 <pid>")])]),t._v(" "),s("td",[t._v("杀进程")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("lsof -i:8000")])]),t._v(" "),s("td",[t._v("查看 8000 端口的占用进程")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("nload")])]),t._v(" "),s("td",[t._v("查看流量大小")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("wc")])]),t._v(" "),s("td",[t._v("(word count) 统计文件的字数、行数、字符数")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("tail --follow")])]),t._v(" "),s("td",[t._v("实时输出（日志）文件内容")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("journalctl -f -u <unit.service>")])]),t._v(" "),s("td",[t._v("实时输出日志内容")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("grep word file.txt")])]),t._v(" "),s("td",[t._v("在 "),s("code",[t._v("find.txt")]),t._v(" 查找 "),s("code",[t._v("word")]),t._v(" 字符串，"),s("code",[t._v("-i")]),t._v(" 大小写不敏感")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("find <directory> -name 'file.txt'")])]),t._v(" "),s("td",[t._v("在目录下查找 "),s("code",[t._v("file.txt")])])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("df -h")])]),t._v(" "),s("td",[t._v("查看文件剩余空间")])])])]),t._v(" "),s("h2",{attrs:{id:"低频考点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#低频考点"}},[t._v("#")]),t._v(" 低频考点")]),t._v(" "),s("p",[t._v("以下是低频考点，但是在真实面试中问过一次，读者可以按需掌握。")]),t._v(" "),s("h3",{attrs:{id:"c-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-2"}},[t._v("#")]),t._v(" C++")]),t._v(" "),s("h4",{attrs:{id:"c-语言获取当前文件夹、函数名、行数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-语言获取当前文件夹、函数名、行数"}},[t._v("#")]),t._v(" C 语言获取当前文件夹、函数名、行数")]),t._v(" "),s("p",[t._v("中望龙腾 C++ 岗笔试考过。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<direct.h>")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("using")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("_getcwd")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl                   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取当前文件夹")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"__FUNCSIG__:"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" __FUNCSIG__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取函数完整签名")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"__FUNCTION__:"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" __FUNCTION__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取函数名")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"__LINE__:"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__LINE__")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                 "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取行数")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("输出：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("C:\\Users\\liu\\Desktop\\test\\cpp\n__FUNCSIG__:int __cdecl main(void)\n__FUNCTION__:main\n__LINE__:11\n")])])]),s("h4",{attrs:{id:"c-语言字节对齐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-语言字节对齐"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"/cpp/cpp-grammar/c-byte-alignment"}},[t._v("C 语言字节对齐")])]),t._v(" "),s("h4",{attrs:{id:"cv-限定符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cv-限定符"}},[t._v("#")]),t._v(" cv 限定符")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zh.cppreference.com/w/cpp/language/cv",target:"_blank",rel:"noopener noreferrer"}},[t._v("cv（const 与 volatile）类型限定符 | cppreference.com"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("cv 限定符是 "),s("code",[t._v("const")]),t._v(" 和 "),s("code",[t._v("volatile")]),t._v(" 的合称。")]),t._v(" "),s("p",[s("strong",[t._v("当对象最初被创建")]),t._v("时，所用的 cv 限定符决定对象的常量性或易变性。")]),t._v(" "),s("p",[s("code",[t._v("const")]),t._v(" 大家都懂，就是不能修改的常量 (constant)，直接修改会编译报错，间接修改（如利用 "),s("code",[t._v("const_cast<int&>")]),t._v(" 等手段）为未定义行为。还有一点，就是写为 "),s("code",[t._v("const")]),t._v(" 之后，编译器会进行优化。")]),t._v(" "),s("p",[t._v("而 "),s("code",[t._v("volatile")]),t._v(" 翻译过来是“易变”的，表明该变量可能通过软件甚至硬件方式变化。这会阻止编译器对这个变量进行任何优化，包括但不限于：不会将变量放到寄存器中；不会对 "),s("code",[t._v("const volatile")]),t._v(" 变量当做 "),s("code",[t._v("const")]),t._v(" 进行优化。（不过，CPU 仍可以将变量放入缓存中，因为缓存对程序员是透明的）")]),t._v(" "),s("p",[t._v("代码例子见 "),s("a",{attrs:{href:"#const-cast"}},[t._v("const_cast")]),t._v(" 部分。")]),t._v(" "),s("h4",{attrs:{id:"static-用处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#static-用处"}},[t._v("#")]),t._v(" static 用处")]),t._v(" "),s("p",[t._v("C 语言的 static 有三个用处：")]),t._v(" "),s("ol",[s("li",[t._v("对"),s("code",[t._v("函数内变量")]),t._v("使用，扩展其生存期；")]),t._v(" "),s("li",[t._v("对"),s("code",[t._v("函数外变量")]),t._v("和"),s("code",[t._v("函数")]),t._v("使用，使其他文件不能通过 "),s("code",[t._v("extern")]),t._v(" 访问到该变量/函数（默认是可以的）；")]),t._v(" "),s("li",[t._v("对"),s("code",[t._v("类的成员/方法")]),t._v("使用，使得该变量/函数属于类（其他的都是属于每个对象），可以直接由类名 "),s("code",[t._v("Classname::")]),t._v(" 调用；")])]),t._v(" "),s("h4",{attrs:{id:"禁止继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#禁止继承"}},[t._v("#")]),t._v(" 禁止继承")]),t._v(" "),s("p",[t._v("C++ 11 引入了 "),s("code",[t._v("final")]),t._v(" 关键字。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("B")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// error: 不能选择 final 类作为基类")]),t._v("\n")])])]),s("h4",{attrs:{id:"禁止拷贝构造函数和赋值构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#禁止拷贝构造函数和赋值构造函数"}},[t._v("#")]),t._v(" 禁止拷贝构造函数和赋值构造函数")]),t._v(" "),s("p",[t._v("C++11 加入了 "),s("code",[t._v("= delete")]),t._v(" 控制类默认函数。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thing")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Thing")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Thing"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    Thing"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Thing"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Thing t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// 错误 E0291：类 "Thing" 不存在默认构造函数')]),t._v("\n    Thing "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("t2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// 错误 E1776：无法引用 函数 "Thing::Thing(const Thing &)" (已声明 所在行数:4) -- 它是已删除的函数')]),t._v("\n    Thing t2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// 错误 E1776：无法引用 函数 "Thing::Thing(const Thing &)" (已声明 所在行数:4) -- 它是已删除的函数')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("C++98 前可以定义为 "),s("code",[t._v("private")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thing")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Thing")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Thing "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    Thing "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Thing "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Thing t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    Thing "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("t2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//error C2248: “Thing::Thing”: 无法访问 private 成员")]),t._v("\n    Thing t2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//error C2248: “Thing::Thing”: 无法访问 private 成员")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h4",{attrs:{id:"std-vector-和-std-array"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#std-vector-和-std-array"}},[t._v("#")]),t._v(" std::vector 和 std::array")]),t._v(" "),s("ul",[s("li",[t._v("vector 和 array 都是可以通过 "),s("code",[t._v("[]")]),t._v(" 访问下标对应元素的数组；")]),t._v(" "),s("li",[t._v("vector 是变长数组，可以通过 "),s("code",[t._v("push_back")]),t._v(" "),s("code",[t._v("insert")]),t._v(" 和 "),s("code",[t._v("erase")]),t._v(" 修数组大小。（注意 "),s("code",[t._v("insert")]),t._v(" 和 "),s("code",[t._v("erase")]),t._v(" 都是 "),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("n")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" 的）；")],1),t._v(" "),s("li",[s("a",{attrs:{href:"https://blog.csdn.net/qq_30835655/article/details/60762196",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++ vector 内存分配与回收机制"),s("OutboundLink")],1),t._v("；")]),t._v(" "),s("li",[t._v("array 则是 C++11 引入的、对标准数组的封装，是定长数组。")])]),t._v(" "),s("h4",{attrs:{id:"lambda-捕获值列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lambda-捕获值列表"}},[t._v("#")]),t._v(" Lambda 捕获值列表")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://changkun.de/modern-cpp/zh-cn/03-runtime/index.html#3-1-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("Modern C++ zh-cn"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("分为三种：")]),t._v(" "),s("ol",[s("li",[t._v("值捕获 "),s("code",[t._v("[value]")]),t._v(" 或 "),s("code",[t._v("[=value]")]),t._v("：与参数传值类似，值捕获的前提是变量可以拷贝。不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝。")]),t._v(" "),s("li",[t._v("引用捕获 "),s("code",[t._v("[&value]")]),t._v("：与引用传参类似，引用捕获保存的是引用，值会发生变化。")]),t._v(" "),s("li",[t._v("隐式捕获 "),s("code",[t._v("[=]")]),t._v(" 或 "),s("code",[t._v("[&]")]),t._v("：手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 "),s("code",[t._v("&")]),t._v(" 或 "),s("code",[t._v("=")]),t._v(" 向编译器声明采用引用捕获或者值捕获。（很多地方说的是捕获 "),s("code",[t._v("this")]),t._v("，我觉得还是这个好理解一些，毕竟如果在 main 函数中，也没有 "),s("code",[t._v("this")]),t._v(" 一说）")])]),t._v(" "),s("p",[t._v("总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的"),s("strong",[t._v("最常用")]),t._v("的四种形式可以是：")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("[]")]),t._v(" 空捕获列表")]),t._v(" "),s("li",[s("code",[t._v("[name1, name2, ...]")]),t._v(" 捕获一系列变量")]),t._v(" "),s("li",[s("code",[t._v("[&]")]),t._v(" 引用捕获, 让编译器自行推导引用列表")]),t._v(" "),s("li",[s("code",[t._v("[=]")]),t._v(" 值捕获, 让编译器自行推导值捕获列表")])]),t._v(" "),s("h3",{attrs:{id:"数据结构-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-2"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),s("h4",{attrs:{id:"堆的复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆的复杂度"}},[t._v("#")]),t._v(" 堆的复杂度")]),t._v(" "),s("p",[t._v("面腾讯的时候被问到，建堆的复杂度是多少，还好之前写过"),s("RouterLink",{attrs:{to:"/computer-science/data-structure-and-algorithm/#堆-Heap"}},[t._v("博客")]),t._v("，还有一点点印象不是 "),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("n")]),s("mi",[t._v("log")]),s("mo",[t._v("⁡")]),s("mi",[t._v("n")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n\\log n)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),s("span",{staticClass:"mop"},[t._v("lo"),s("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("，而是 "),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("n")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。回顾了一下博客，果然是，顺便重温了一下证明。")],1),t._v(" "),s("h3",{attrs:{id:"计算机网络-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络-2"}},[t._v("#")]),t._v(" 计算机网络")]),t._v(" "),s("h4",{attrs:{id:"time-wait-快速回收与复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#time-wait-快速回收与复用"}},[t._v("#")]),t._v(" TIME_WAIT 快速回收与复用")]),t._v(" "),s("p",[s("a",{attrs:{href:"http://langos.top/2019/04/07/time-wait%E5%BF%AB%E9%80%9F%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8/",target:"_blank",rel:"noopener noreferrer"}},[t._v("time-wait快速回收与复用 - rosewind的博客 | BY Blog"),s("OutboundLink")],1),s("br"),t._v(" "),s("a",{attrs:{href:"https://ivanzz1001.github.io/records/post/tcpip/2018/04/24/tcpip_timewait#",target:"_blank",rel:"noopener noreferrer"}},[t._v("time_wait的快速回收和重用"),s("OutboundLink")],1),s("br"),t._v(" "),s("a",{attrs:{href:"https://blog.csdn.net/cui918/article/details/52850846",target:"_blank",rel:"noopener noreferrer"}},[t._v("NAT环境下tcp_timestamps问题_〓☆〓 清风徐来918 （QQ:89617663）-CSDN博客_tcp_timestamps"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("这是腾讯主管问的问题，一般第二次考到的概率很小，但作为一个知识了解也不错。")]),t._v(" "),s("p",[t._v("TIME_WAIT 状态产生的原因在上面部分提到了，这里不再赘述。如果 TIME_WAIT 太多，导致无法对外建立新 TCP 连接。")]),t._v(" "),s("p",[t._v("在 Linux 下，可以从系统层面，或从应用程序层面解决这个问题。")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("系统层面上，也有三种方法。")]),t._v(" "),s("p",[t._v("一是提高 "),s("code",[t._v("tcp_max_tw_buckets")]),t._v("，就能接受更多的 TIME_WAIT，但是治标不治本。")]),t._v(" "),s("p",[t._v("二是开启 TIME_WAIT 快速回收 "),s("code",[t._v("tcp_tw_recycle")]),t._v("（需同时开启 "),s("code",[t._v("tcp_timestamps")]),t._v("，系统默认开启）。原理是在 TCP 报文中加入时间戳（时间戳在 TCP 报文中的可选字段），然后系统缓存每个连接最新的时间戳。如果收到的 TCP 报文的时间戳早于缓存值，就丢弃数据包 (RFC1323)。")]),t._v(" "),s("p",[t._v("快速回收的问题在于，搭配 NAT 可能会出现问题。现在很多公司都用 LVS 做负载均衡，通常是前面一台 LVS，后面多台后端服务器，这其实就是 NAT，当请求到达 LVS 后，它修改地址数据后便转发给后端服务器，但不会修改时间戳数据，对于后端服务器来说，请求的源地址就是 LVS 的地址，加上端口会复用，所以从后端服务器的角度看，原本不同客户端的请求经过 LVS 的转发，就可能会被认为是同一个连接，加之不同客户端的时间可能不一致，所以就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的 SYN，但服务端就是不响应 ACK。如果服务器身处 NAT 环境，安全起见，通常要禁止 "),s("code",[t._v("tcp_tw_recycle")]),t._v("，至于TIME_WAIT连接过多的问题，可以通过 TIME_WAIT 复用解决。")]),t._v(" "),s("p",[t._v("三是开启 TIME_WAIT 复用 "),s("code",[t._v("tcp_tw_reuse")]),t._v("（也需要同时开启 "),s("code",[t._v("tcp_timestamps")]),t._v("）另外复用也是也是有条件的：协议认为复用是安全的。与 "),s("code",[t._v("tcp_tw_recycle")]),t._v(" 选项相比，本选项一般不会带来副作用。")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("应用层面上，有两种解决办法：一是将 TCP 短连接改造为长连接，二是快速关闭 socket。")]),t._v(" "),s("h4",{attrs:{id:"http-状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[t._v("#")]),t._v(" HTTP 状态码")]),t._v(" "),s("p",[s("a",{attrs:{href:"/back-end/http-status-code"}},[t._v("HTTP 状态码")])]),t._v(" "),s("ul",[s("li",[t._v("1xx：\n"),s("ul",[s("li",[s("code",[t._v("102 Processing (WebDAV)")]),t._v(" 用于表明 WebDAV 服务器收到了请求，但请求的操作比较费时，服务器正在处理（如遍历当前文件夹）。为了防止客户端 TCP 超时、假设请求丢失，于是服务器可以发送一个没有信息的 102 应答。")])])]),t._v(" "),s("li",[t._v("2xx：\n"),s("ul",[s("li",[s("code",[t._v("200 OK")])]),t._v(" "),s("li",[s("code",[t._v("201 Created")])]),t._v(" "),s("li",[s("code",[t._v("202 Accepted")]),t._v(" 表示正在进行一个异步操作。用于 1. 重置密码时，服务器返回 "),s("code",[t._v("202")]),t._v("，然后将重置邮件发送给邮箱；2. "),s("a",{attrs:{href:"https://docs.microsoft.com/zh-cn/onedrive/developer/rest-api/api/driveitem_createuploadsession?view=odsp-graph-online",target:"_blank",rel:"noopener noreferrer"}},[t._v("Onedrive 分段上传时"),s("OutboundLink")],1),t._v("，如果完成了一部分的上传，会返回 "),s("code",[t._v("202")]),t._v("。")]),t._v(" "),s("li",[s("code",[t._v("204 No Content")])]),t._v(" "),s("li",[s("code",[t._v("206 Partial Content")])])])]),t._v(" "),s("li",[t._v("3xx：\n"),s("ul",[s("li",[t._v("301 302 307 308 见后")]),t._v(" "),s("li",[s("code",[t._v("304 Not Modified")])])])]),t._v(" "),s("li",[t._v("4xx：\n"),s("ul",[s("li",[s("code",[t._v("400 Bad Request")])]),t._v(" "),s("li",[s("code",[t._v("401 Unauthorized")])]),t._v(" "),s("li",[s("code",[t._v("403 Forbidden")])]),t._v(" "),s("li",[s("code",[t._v("404 Not Found")])]),t._v(" "),s("li",[s("code",[t._v("405 Method Not Allowed")])]),t._v(" "),s("li",[s("code",[t._v("409 Conflict")])]),t._v(" "),s("li",[s("code",[t._v("415 Unsupported Media Type")])])])]),t._v(" "),s("li",[t._v("5xx：\n"),s("ul",[s("li",[s("code",[t._v("500 Internal Server Error")])]),t._v(" "),s("li",[s("code",[t._v("502 Bad Gateway")]),t._v(" 常见于 Nginx 反代的服务出锅了")]),t._v(" "),s("li",[s("code",[t._v("504 Gateway Timeout")])])])])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("永久重定向 "),s("code",[t._v("Permanently")])]),t._v(" "),s("th",[t._v("暂时重定向 "),s("code",[t._v("Temporarily")])])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("允许将 "),s("code",[t._v("POST")]),t._v(" 方法改为 "),s("code",[t._v("GET")])]),t._v(" "),s("td",[s("code",[t._v("301 Moved Permanently")])]),t._v(" "),s("td",[s("code",[t._v("302 Moved Temporarily")])])]),t._v(" "),s("tr",[s("td",[t._v("不允许将 "),s("code",[t._v("POST")]),t._v(" 方法改为 "),s("code",[t._v("GET")])]),t._v(" "),s("td",[s("code",[t._v("308 Permanent Redirect")])]),t._v(" "),s("td",[s("code",[t._v("307 Temporary Redirect")])])])])]),t._v(" "),s("h4",{attrs:{id:"https-原理及握手过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-原理及握手过程"}},[t._v("#")]),t._v(" HTTPS 原理及握手过程")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("SSL/TLS协议运行机制的概述 - 阮一峰的网络日志"),s("OutboundLink")],1)]),t._v(" "),s("ol",[s("li",[t._v("客户端发送：ClientHello + 随机数 client random")]),t._v(" "),s("li",[t._v("服务端发送：ServerHello + 随机数 server random + 证书")]),t._v(" "),s("li",[t._v("（客户端验证证书有效性）")]),t._v(" "),s("li",[t._v("客户端发送：随机数 premaster secret (经公钥加密)")]),t._v(" "),s("li",[t._v("（服务器和客户端使用三个随机数生成一个会话密钥）")]),t._v(" "),s("li",[t._v("客户端发送：finished (经会话密钥加密)")]),t._v(" "),s("li",[t._v("服务端发送：finished (经会话密钥加密)")])]),t._v(" "),s("h3",{attrs:{id:"nginx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nginx"}},[t._v("#")]),t._v(" Nginx")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/108031600",target:"_blank",rel:"noopener noreferrer"}},[t._v("Nginx为什么快到根本停不下来？ - 知乎"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/654b6c7ba89678ec0e0725ddffe75a93cac5d4146c22cc8da161bb2a4da9c683.png",alt:"Nginx 的进程模型"}})]),t._v(" "),s("h4",{attrs:{id:"nginx-多进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nginx-多进程"}},[t._v("#")]),t._v(" Nginx 多进程")]),t._v(" "),s("p",[t._v("一个 Master 进程配合多个 Worker 进程")]),t._v(" "),s("ol",[s("li",[t._v("Master 进程：管理 Worker 进程")])]),t._v(" "),s("ul",[s("li",[t._v("对外接口：接收外部的操作（信号）")]),t._v(" "),s("li",[t._v("对内转发：根据外部的操作的不同，通过信号管理 Worker")]),t._v(" "),s("li",[t._v("监控：监控 worker 进程的运行状态，worker 进程异常终止后，自动重启 worker 进程")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("Worker 进程：所有 Worker 进程都是平等的")])]),t._v(" "),s("ul",[s("li",[t._v("实际处理：网络请求，由 Worker 进程处理；")]),t._v(" "),s("li",[t._v("Worker 进程数量：可在 nginx.conf 中配置，一般设置为核心数；")])]),t._v(" "),s("h4",{attrs:{id:"nginx-io-多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nginx-io-多路复用"}},[t._v("#")]),t._v(" Nginx IO 多路复用")]),t._v(" "),s("p",[t._v("Nginx 使用epoll 多路复用")]),t._v(" "),s("h4",{attrs:{id:"nginx-均衡负载算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nginx-均衡负载算法"}},[t._v("#")]),t._v(" Nginx 均衡负载算法")]),t._v(" "),s("p",[t._v("共五种：")]),t._v(" "),s("ol",[s("li",[t._v("轮询 (Round Robin)")]),t._v(" "),s("li",[t._v("加权轮训，权越大表示服务器的能力越强，能承受更大负载")]),t._v(" "),s("li",[t._v("最小连接数 (Least Connections)")]),t._v(" "),s("li",[t._v("IP Hash，保证同 IP 映射到同一服务器，在集群不同享 Session 时很好用")]),t._v(" "),s("li",[t._v("URL Hash，保证同 URL 映射到同一服务器，在有 URL 缓存时效率高")])]),t._v(" "),s("h3",{attrs:{id:"docker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker"}},[t._v("#")]),t._v(" Docker")]),t._v(" "),s("h4",{attrs:{id:"docker-底层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-底层"}},[t._v("#")]),t._v(" Docker 底层")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://xiaoxiami.gitbook.io/docker/docker-de-di-ceng-ji-zhu",target:"_blank",rel:"noopener noreferrer"}},[t._v("Docker 的底层技术"),s("OutboundLink")],1)]),t._v(" "),s("blockquote",[s("p",[t._v("概要：Docker 使用 "),s("strong",[t._v("Linux 命名空间")]),t._v("实现"),s("strong",[t._v("容器的隔离")]),t._v("，使用"),s("strong",[t._v("控制组")]),t._v("实现对容器的"),s("strong",[t._v("资源限制")]),t._v("，使用"),s("strong",[t._v("联合文件系统")]),t._v("提高"),s("strong",[t._v("存储效率")]),t._v("。")])]),t._v(" "),s("p",[t._v("和虚拟机不同，Docker 进程和宿主机进程共用一个内核和某些系统库等。而彼此各个进程的方法是 Linux 上的"),s("strong",[t._v("命名空间 (Namespaces)")]),t._v("。")]),t._v(" "),s("p",[t._v("Docker 使用名称空间来为容器提供隔离的工作空间。当一个容器运行时，Docker 就会为该容器创建一系列的名称空间，并为名称空间提供一层隔离。")]),t._v(" "),s("p",[t._v("Docker 引擎也依赖另一项叫 Control groups (cgroups，控制组) 的技术。控制组可以对程序进行资源限定，并允许 Docker 引擎在容器间进行硬件资源共享以及随时进行限制和约束，如内存等。")]),t._v(" "),s("p",[t._v("联合文件系统 (UnionFS) 是一种分层、轻量级并且高性能的文件系统，它支持将文件系统的修改作为一次提交来一层层地叠加。不同 Docker 容器可以共享基础的文件系统层，与自己独有的改动层一起使用，可以大大提高存储效率。")]),t._v(" "),s("h3",{attrs:{id:"i-o-多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#i-o-多路复用"}},[t._v("#")]),t._v(" I/O 多路复用")]),t._v(" "),s("h3",{attrs:{id:"内存零拷贝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存零拷贝"}},[t._v("#")]),t._v(" 内存零拷贝")])])}),[],!1,null,null,null);a.default=n.exports}}]);