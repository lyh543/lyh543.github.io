(window.webpackJsonp=window.webpackJsonp||[]).push([[234],{626:function(t,a,s){"use strict";s.r(a);var r=s(3),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_2025-11-12-多使用-explain-chatgpt-分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2025-11-12-多使用-explain-chatgpt-分析"}},[t._v("#")]),t._v(" [2025-11-12] 多使用 EXPLAIN + ChatGPT 分析")]),t._v(" "),a("p",[t._v("在 PostgreSQL 中，EXPLAIN 命令可以帮助我们了解查询的执行计划，包括使用什么索引、使用的 JOIN 算法、在哪里耗时最多。")]),t._v(" "),a("p",[t._v("通过结合 ChatGPT，我们即使刚接触 EXPLAIN 也能快速理解执行计划中的各个部分。只需将 EXPLAIN 的输出复制粘贴到 ChatGPT 中，并询问它关于查询性能的建议，ChatGPT 可以帮助我们识别潜在的瓶颈并提供优化建议。")]),t._v(" "),a("h2",{attrs:{id:"_2025-11-12-大表-join-时-同时对两边增加时间范围筛选"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2025-11-12-大表-join-时-同时对两边增加时间范围筛选"}},[t._v("#")]),t._v(" [2025-11-12] 大表 JOIN 时，同时对两边增加时间范围筛选")]),t._v(" "),a("p",[t._v("Postgres 在表关联时，如果表数据量较大，即使表有索引，PostgreSQL 的优化器也会选择 Hash Join，因为它可以避免索引扫描的随机 I/O，性能更高。")]),t._v(" "),a("p",[t._v("如果对表进行筛选（如在左右表同时加上时间范围筛选），可以明显减少扫表的量，性能会有成比例的提升。")]),t._v(" "),a("p",[t._v("这很像是种分区表的一种思想。对于百万行以上的大表 JOIN，如果在某些场景（如统计看板）下确实需要扫表，应该在每个大表上都尽量加上时间范围，来减少扫表 JOIN 的范围，查询速度能够获得数量级的提升。")])])}),[],!1,null,null,null);a.default=e.exports}}]);