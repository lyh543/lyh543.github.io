(window.webpackJsonp=window.webpackJsonp||[]).push([[223],{612:function(e,t,s){"use strict";s.r(t);var a=s(3),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("本篇是《深入剖析 Kubernetes》 的读书笔记，作者为张磊老师。")]),e._v(" "),t("p",[e._v("这几个主题需要介绍的部分都比较少，所以放在一篇博客里了。")]),e._v(" "),t("h2",{attrs:{id:"调度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调度"}},[e._v("#")]),e._v(" 调度")]),e._v(" "),t("h3",{attrs:{id:"资源模型和管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源模型和管理"}},[e._v("#")]),e._v(" 资源模型和管理")]),e._v(" "),t("p",[e._v("Kubernetes 里可以给容器指定分配 CPU 和内存资源的多少。")]),e._v(" "),t("div",{staticClass:"language-yaml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-yaml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("resources")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("requests")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("memory")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"64Mi"')]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("cpu")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"500m"')]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("limits")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("memory")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"128Mi"')]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("cpu")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1"')]),e._v("\n")])])]),t("p",[e._v("从字面上来看，有下面几个概念：")]),e._v(" "),t("ol",[t("li",[e._v("requests 是容器的最小资源需求，Kubernetes 会保证这个资源一直可用。")]),e._v(" "),t("li",[e._v("limits 是容器的最大资源需求，Kubernetes 会限制容器使用的资源不超过这个值。")]),e._v(" "),t("li",[e._v("memory 资源的单位很好理解，就是内存的大小。CPU 资源的单位是 millicores，1m = 1/1000 cores。")])]),e._v(" "),t("p",[e._v("在字面外，还有一些细节：")]),e._v(" "),t("ol",[t("li",[e._v("CPU 资源和内存资源有一个区别，"),t("strong",[e._v("CPU 是可压缩资源，内存是不可压缩资源")]),e._v("。就是说，宿主机的 CPU 不够用了，可以通过时间片轮转的方式，让多个容器共享 CPU。但是内存不行，如果内存不够用了，就只能 OOMKilled 了。所以 CPU 不够用了只会持续 100% 占用，却不会有 "),t("code",[e._v("Out Of CPU Killed")]),e._v(" 这种说法。")]),e._v(" "),t("li",[e._v("为了保证容器的 requests，K8s 会在调度的时候，只会把容器调度到有足够空闲（还没有被 requests）资源的 Node 上。为了保证容器的 limits，如果容器进程申请的内存超过它的 limits 的时候，容器就"),t("strong",[e._v("可能")]),e._v("被杀掉。")]),e._v(" "),t("li",[e._v("K8s 根据 requests 和 limits，可以计算出容器的 QoS 类型，从高优先级到低优先级依次为 "),t("strong",[e._v("Guaranteed、Burstable 和 BestEffort")]),e._v(" 三种。\n"),t("ul",[t("li",[e._v("Guaranteed 是 requests = limits 的情况，Burstable 是 requests != limit 的情况，BestEffort 是什么都没设置的情况。")]),e._v(" "),t("li",[e._v("当宿主的不可压缩资源（内存、宿主机磁盘空间、镜像存储空间）紧张时，会触发 Eviction：1. 优先杀掉 BestEffort 类型的容器；2.然后是 Burstable 且对应资源使用量超过 requests 的容器；3. 最后是 Guaranteed 且对应资源使用量超过 limits 的容器。")]),e._v(" "),t("li",[e._v("Eviction 的触发条件都是可配置的，比如 "),t("code",[e._v("--eviction-hard")]),e._v(" 参数指定硬资源回收的触发条件，"),t("code",[e._v("--eviction-soft")]),e._v(" 和 "),t("code",[e._v("--eviction-soft-grade-period")]),e._v(" 指定软资源回收的触发条件和等待时间。")])])]),e._v(" "),t("li",[e._v("如果一个容器是 Guaranteed 且 CPU request 是整数，K8s 会把相同数量的 CPU 绑定到容器上，这样可以避免 CPU 的频繁切换，提高性能。")])]),e._v(" "),t("p",[e._v("所以"),t("strong",[e._v("对于一个 web 服务，最好是设置为 Guaranteed 类型")]),e._v("，虽然申请过量的 CPU、内存资源会导致资源浪费，但可以保证服务的稳定性，是一种通过牺牲资源利用率换稳定性的思想。")]),e._v(" "),t("h3",{attrs:{id:"默认调度器框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认调度器框架"}},[e._v("#")]),e._v(" 默认调度器框架")]),e._v(" "),t("p",[e._v("K8s 的默认调度器是 "),t("code",[e._v("default-scheduler")]),e._v("。它做的事情就是把 Pod 调度到合适的 Node 上，进行的操作就是将 Pod 的 "),t("code",[e._v("spec.nodeName")]),e._v(" 字段设置为 Node 的名字。")]),e._v(" "),t("p",[e._v("本节介绍的是默认调度器的框架，调度算法在下一节。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/k8s-scheduler-framework.jpeg",alt:"K8s 调度器框架"}})]),e._v(" "),t("p",[e._v("K8s 的调度步骤框架围绕着一个调度队列展开，分为两部分，一部分负责将待调度的 Pod 加入调度队列，另一部分负责从调度队列中取出 Pod 进行调度。")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("调度队列")]),e._v("：调度队列是一个优先级队列，每个 Pod 都有一个优先级，优先级高的 Pod 会先被调度。使用优先队列而非 FIFO 主要是处于调度优先级和抢占的考虑。")]),e._v(" "),t("li",[t("strong",[e._v("Informer Path")]),e._v("：Informer Path 负责将待调度的 Pod 加入调度队列。Informer Path 会监听 K8s 的 API Server，当有 Pod 的状态发生变化时，Informer Path 会将 Pod 加入调度队列。除此之外，Informer Path 还会监听 Node、Service 等资源的 API，以便"),t("strong",[e._v("将集群信息缓存到本地")]),e._v("，方便调度器使用。")]),e._v(" "),t("li",[t("strong",[e._v("Scheduling Path")]),e._v("：Scheduling Path 负责从调度队列中取出 Pod 进行调度。Scheduling Path 会调用调度算法，选择一个 Node，然后将 Pod 的 "),t("code",[e._v("spec.nodeName")]),e._v(" 字段设置为 Node 的名字。最后，Scheduling Path 会调用 K8s 的 API Server，将 Pod 的信息更新到 API Server 中，同时也会更新缓存。")])]),e._v(" "),t("h3",{attrs:{id:"调度策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调度策略"}},[e._v("#")]),e._v(" 调度策略")]),e._v(" "),t("p",[e._v("K8s 为一个 Pod 选择合适的 Node 的策略分为两步：Filter（原为 Predicates）和 Scoring（原为 Priorities）。")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("Filter")]),e._v("：Filter 是一个布尔函数，用来过滤掉不符合条件的 Node，筛选后的结果是可以运行这个 Pod 的 Node。比如，一个 Pod 需要 1G 内存，但是 Node 只有 512M 内存，那么这个 Node 就会被 Filter 函数过滤掉。Filter 函数可以有多个，每个 Filter 函数都会返回一个布尔值，只有当所有的 Filter 函数都返回 true 时，这个 Node 才会被保留下来。")]),e._v(" "),t("li",[t("strong",[e._v("Scoring")]),e._v("：Scoring 是一个打分函数，用来给 Node 打分，分越高表示这个 Node 越适合运行这个 Pod。比如，一个 Node 的 CPU 使用率很高，那么这个 Node 的分数就会很低。Scoring 函数可以有多个，每个 Scoring 函数都会返回一个分数，最后会将所有的分数求加权平均，得到这个 Node 的总分数。最后，调度器会选择分数最高的 Node。Scoring 函数的开关和权重可以通过为 "),t("code",[e._v("kube-scheduler")]),e._v(" 指定配置文件来修改。")])]),e._v(" "),t("p",[e._v("K8s 的调度策略是可插拔的，可以通过配置文件来配置 Filter 和 Scoring 函数。默认的调度策略是 "),t("code",[e._v("default-scheduler")]),e._v("，它的 Filter 函数有 "),t("code",[e._v("PodMatchNodeSelector")]),e._v("、"),t("code",[e._v("NodeAffinity")]),e._v("、"),t("code",[e._v("PodAffinity")]),e._v("、"),t("code",[e._v("PodAntiAffinity")]),e._v(" 等等，Scoring 函数有 "),t("code",[e._v("LeastRequestedPriority")]),e._v("、"),t("code",[e._v("BalancedResourceAllocation")]),e._v("、"),t("code",[e._v("NodePreferAvoidPods")]),e._v(" 等等。")]),e._v(" "),t("p",[e._v("常见的 "),t("a",{attrs:{href:"https://github.com/kubernetes/kubernetes/blob/0a1808a5701d0b2e577a1ba700b11480e09e0ca5/pkg/scheduler/algorithm/predicates/predicates.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("Filter"),t("OutboundLink")],1),e._v(" 有：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("PodMatchNodeSelector")]),e._v("：根据 Pod 的 "),t("code",[e._v("spec.NodeSelector")]),e._v(" 字段，过滤掉不符合条件的 Node。")]),e._v(" "),t("li",[t("code",[e._v("PodFitsResources")]),e._v("：过滤掉没有足够资源的 Node。")]),e._v(" "),t("li",[t("code",[e._v("PodFitsHost")]),e._v("：根据 Pod 的 "),t("code",[e._v("spec.NodeName")]),e._v(" 字段，过滤掉不是指定 Node 的 Node。")]),e._v(" "),t("li",[t("code",[e._v("PodFitsHostPorts")]),e._v("：过滤掉对应端口已经被使用的 Node。")]),e._v(" "),t("li",[t("code",[e._v("NoDiskConflict")]),e._v("：过滤掉对应磁盘已经被使用的 Node。")]),e._v(" "),t("li",[t("code",[e._v("PodToleratesNodeTaints")]),e._v("：过滤掉不符合 Pod 的 "),t("code",[e._v("spec.Tolerations")]),e._v(" 字段的 Node。")]),e._v(" "),t("li",[t("code",[e._v("InterPodAffinityMatches")]),e._v("：根据 Pod 的 "),t("code",[e._v("spec.Affinity")]),e._v(" 字段，过滤掉不符合 affinity/anti-affinity 条件的 Node。")])]),e._v(" "),t("p",[e._v("在具体执行时，调度一个 Pod 时，K8s 调度器会同时启动 16 个 Goroutine 来并发地执行 Filter 函数，最后返回符合条件的 Node。")]),e._v(" "),t("p",[e._v("常见的 "),t("a",{attrs:{href:"https://github.com/kubernetes/kubernetes/tree/0a1808a5701d0b2e577a1ba700b11480e09e0ca5/pkg/scheduler/algorithm/priorities",target:"_blank",rel:"noopener noreferrer"}},[e._v("Scoring"),t("OutboundLink")],1),e._v(" 有：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/kubernetes/kubernetes/blob/0a1808a5701d0b2e577a1ba700b11480e09e0ca5/pkg/scheduler/algorithm/priorities/least_requested.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("LeastRequestScorer"),t("OutboundLink")],1),e._v("：选择 CPU、内存空闲最多的 Node。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/kubernetes/kubernetes/blob/0a1808a5701d0b2e577a1ba700b11480e09e0ca5/pkg/scheduler/algorithm/priorities/balanced_resource_allocation.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("BalancedResourceScorer"),t("OutboundLink")],1),e._v("：选择 CPU、内存、硬盘占用最平均的 Node。算法计算出了三种资源的占用率（request/allocatable），然后算了三个值的方差，方差越小得分越高。")]),e._v(" "),t("li",[e._v("还有 "),t("code",[e._v("NodeAffinity")]),e._v("、"),t("code",[e._v("TaintToleration")]),e._v("、"),t("code",[e._v("InterpodAffinity")]),e._v(" 的 Scoring 算法，满足条件的 Node 得分会更高。")])]),e._v(" "),t("h2",{attrs:{id:"调度中的抢占机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调度中的抢占机制"}},[e._v("#")]),e._v(" 调度中的抢占机制")]),e._v(" "),t("p",[e._v("正常情况下，Node 资源不足时，Pod 会被“搁置”，直到资源足够时再调度。但是有时候，我们希望某些 Pod 能够优先调度，比如重要的服务、紧急的任务等等。这时候就需要抢占机制。")]),e._v(" "),t("p",[e._v("K8s 的抢占机制，可以在 Node 资源不足时，优先调度高优先级的 Pod。抢占机制的实现是通过杀掉一些低优先级的 Pod，释放资源。")]),e._v(" "),t("p",[e._v("定义 Pod 的优先级，需要先定义一个 "),t("code",[e._v("PriorityClass")]),e._v(" 对象，然后在 Pod 的 "),t("code",[e._v("spec.priorityClassName")]),e._v(" 字段指定这个优先级。")]),e._v(" "),t("div",{staticClass:"language-yaml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-yaml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("apiVersion")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" scheduling.k8s.io/v1\n"),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("kind")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" PriorityClass\n"),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("metadata")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" high"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("priority\n"),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("value")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1000000")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("globalDefault")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token boolean important"}},[e._v("false")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("description")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"This priority class should be used for XYZ service pods only."')]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("---")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("---")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("apiVersion")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" v1\n"),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("kind")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" Pod\n"),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("metadata")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" high"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("priority"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("pod\n"),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("spec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("priorityClassName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" high"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("priority\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("containers")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" high"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("priority"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("container\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("image")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" nginx\n")])])]),t("p",[e._v("Kubernetes 的抢占机制的实现，用到了两个队列，一个是 activeQ，另一个是 unschedulableQ。")]),e._v(" "),t("ol",[t("li",[e._v("activeQ 就是下个调度周期要调度的 Pod 队列。所以在创建了一个 Pod 对象后，会先加入 activeQ。调度器也是从 activeQ 里面 pop Pod 对象，然后进行调度。")]),e._v(" "),t("li",[e._v("unschedulableQ 是调度器调度失败的 Pod 队列。在 Pod 进入 unschedulableQ 以后，如果 Pod 对象发生了更新，这个 Pod 会被重新移动到 activeQ 中。")])]),e._v(" "),t("p",[e._v("当高优先级的抢占者 Pod 第一次调度失败后，被挪到 unschedulableQ 后，就会触发调度器为抢占者寻找低优先级的牺牲者 Pod。这个寻找过程是一个模拟算法，模拟把节点里低优先级 Pod 逐一删除，然后检查抢占者是否可以运行。模拟算法会从抢占结果中选择一个最好的（对系统影响最小的，比如抢占的 Pod 数少、优先级低）。然后就会执行抢占操作：")]),e._v(" "),t("ol",[t("li",[e._v("清理牺牲者 Pod 的 "),t("code",[e._v("nominatedNodeName")]),e._v(" 字段。调度器使用 "),t("code",[e._v("nominatedNodeName")]),e._v(" 字段来跟踪为 Pod 保留的资源，同时也向用户提供与集群中抢占相关的信息。")]),e._v(" "),t("li",[e._v("把抢占者 Pod 的 "),t("code",[e._v("nominatedNodeName")]),e._v(" 字段设置为牺牲者的 Node 名字。由于 Pod 信息更新，调度器会把抢占者 Pod 重新加入 activeQ。")]),e._v(" "),t("li",[e._v("遍历牺牲者列表，向 API Server 请求删除这些 Pod。")])]),e._v(" "),t("p",[e._v("然后，调度器会再次调度抢占者 Pod。不过，调度器并不保证这次一定会成功，因为在这个过程中，可能又有新的 Pod 进入 activeQ，导致资源不足。")]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("除了上述核心机制以外，还有一些特殊情况需要单独处理。")]),e._v(" "),t("p",[e._v("在为一个 Pod 和 Node 执行 Filter 算法时，如果满足①待检查的 Node 即将被抢占（即 activeQ 存在一个 Pod，这个 Pod 的 "),t("code",[e._v("nominatedNodeName")]),e._v(" 为该 Node）②抢占者 Pod 的优先级高于或等于待检查的 Pod。为了防止当前 Pod 分配上去后又立即被抢占，会执行两遍 Filter 算法。第一遍检查如果抢占者已经在该节点上运行的情况，第二遍按照正常情况进行检查，即不考虑抢占者运行在该 Node 上运行的情况。最后把两个算法的结果取 and，如果结果为 false，就不会把 Pod 分配到该 Node 上。")]),e._v(" "),t("h2",{attrs:{id:"容器运行时"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器运行时"}},[e._v("#")]),e._v(" 容器运行时")]),e._v(" "),t("p",[e._v("在 Kubernetes 1.6 之前，K8s 直接调用 Docker 的 API 来管理容器。但随着容器技术的发展，K8s 也需要支持更多的容器运行时，比如 rkt、runV（runV 还是基于虚拟化技术的容器，导致 K8s 适配的工作更加复杂）等等，K8s 的维护工作越来越大。所以在 1.6 版本引入了 CRI（Container Runtime Interface，容器运行时接口）来解耦 K8s 和容器运行时。解耦以后，K8s 只需要支持 CRI，而不需要支持具体的容器运行时；容器运行时只需要适配 CRI，就可以和 K8s 通信了，节省了两边的维护成本。")]),e._v(" "),t("p",[e._v("容器运行时适配 CRI 的这一层被称为 CRI shim（CRI 垫片），比如 Docker 的 shim 叫做 dockershim。")]),e._v(" "),t("h3",{attrs:{id:"cri"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cri"}},[e._v("#")]),e._v(" CRI")]),e._v(" "),t("p",[e._v("CRI shim 需要实现两个服务："),t("code",[e._v("RuntimeService")]),e._v(" 和 "),t("code",[e._v("ImageService")]),e._v("。"),t("code",[e._v("RuntimeService")]),e._v(" 主要负责容器的生命周期管理，比如创建、销毁容器；"),t("code",[e._v("ImageService")]),e._v(" 主要负责镜像的管理，比如拉取、删除镜像。")]),e._v(" "),t("div",{staticClass:"language-proto extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// https://github.com/kubernetes/cri-api/blob/master/pkg/apis/runtime/v1/api.proto\n\nservice RuntimeService {\n    rpc Version(VersionRequest) returns (VersionResponse) {}\n    rpc RunPodSandbox(RunPodSandboxRequest) returns (RunPodSandboxResponse) {}\n    rpc StopPodSandbox(StopPodSandboxRequest) returns (StopPodSandboxResponse) {}\n    rpc RemovePodSandbox(RemovePodSandboxRequest) returns (RemovePodSandboxResponse) {}\n    rpc PodSandboxStatus(PodSandboxStatusRequest) returns (PodSandboxStatusResponse) {}\n    rpc ListPodSandbox(ListPodSandboxRequest) returns (ListPodSandboxResponse) {}\n\n    rpc CreateContainer(CreateContainerRequest) returns (CreateContainerResponse) {}\n    rpc StartContainer(StartContainerRequest) returns (StartContainerResponse) {}\n    rpc StopContainer(StopContainerRequest) returns (StopContainerResponse) {}\n    rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse) {}\n    rpc ListContainers(ListContainersRequest) returns (ListContainersResponse) {}\n    rpc ContainerStatus(ContainerStatusRequest) returns (ContainerStatusResponse) {}\n    rpc UpdateContainerResources(UpdateContainerResourcesRequest) returns (UpdateContainerResourcesResponse) {}\n    rpc ReopenContainerLog(ReopenContainerLogRequest) returns (ReopenContainerLogResponse) {}\n\n    rpc ExecSync(ExecSyncRequest) returns (ExecSyncResponse) {}\n    rpc Exec(ExecRequest) returns (ExecResponse) {}\n    rpc Attach(AttachRequest) returns (AttachResponse) {}\n    rpc PortForward(PortForwardRequest) returns (PortForwardResponse) {}\n\n    rpc ContainerStats(ContainerStatsRequest) returns (ContainerStatsResponse) {}\n    rpc ListContainerStats(ListContainerStatsRequest) returns (ListContainerStatsResponse) {}\n\n    rpc PodSandboxStats(PodSandboxStatsRequest) returns (PodSandboxStatsResponse) {}\n    rpc ListPodSandboxStats(ListPodSandboxStatsRequest) returns (ListPodSandboxStatsResponse) {}\n\n    // ...\n}\n\nservice ImageService {\n    rpc ListImages(ListImagesRequest) returns (ListImagesResponse) {}\n    rpc ImageStatus(ImageStatusRequest) returns (ImageStatusResponse) {}\n    rpc PullImage(PullImageRequest) returns (PullImageResponse) {}\n    rpc RemoveImage(RemoveImageRequest) returns (RemoveImageResponse) {}\n    rpc ImageFsInfo(ImageFsInfoRequest) returns (ImageFsInfoResponse) {}\n}\n")])])]),t("h3",{attrs:{id:"安全容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安全容器"}},[e._v("#")]),e._v(" 安全容器")]),e._v(" "),t("p",[e._v("本书还聊到了两个安全容器的技术，一个是 Kata Containers，一个是 gVisor。")]),e._v(" "),t("p",[e._v("Kata Containers 是一个基于虚拟化技术的安全容器，它会使用虚拟机管理程序（VMM，比如 Qemu）为每个 Pod 创建一个虚拟机，这样就可以隔离容器之间的网络、内存、磁盘等资源。Kata Containers 的优点是安全性高，缺点是性能差，因为每个容器都需要一个虚拟机。")]),e._v(" "),t("p",[e._v("而 gVisor 就激进多了，它为容器启动了一个 Sentry 进程，这个进程负责提供一个操作系统内核的能力：运行用户进程，执行系统调用。所以它相当于在模拟一个系统内核。gVisor 的优点是性能高，缺点是很多 Linux 系统调用都还不支持，所以不是所有的应用都能跑在 gVisor 里。")]),e._v(" "),t("h2",{attrs:{id:"监控"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#监控"}},[e._v("#")]),e._v(" 监控")]),e._v(" "),t("p",[e._v("K8s 相关监控现在都是通过 Prometheus 来做的。之前配置 Prometheus + Grafana 的经验写在"),t("a",{attrs:{href:"/posts/2024-04-27-use-grafana-to-monitor-on-kubernetes"}},[e._v("这篇博客")]),e._v(" 了，这里简单摘抄一段架构。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/grafana-collect-k8s-metric.png",alt:"Grafana 收集 K8s 指标的拓扑图"}})]),e._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"https://github.com/google/cadvisor",target:"_blank",rel:"noopener noreferrer"}},[e._v("cAdvisor"),t("OutboundLink")],1),e._v(" 和 "),t("a",{attrs:{href:"https://github.com/kubernetes/kube-state-metrics",target:"_blank",rel:"noopener noreferrer"}},[e._v("kube-state-metrics"),t("OutboundLink")],1),e._v(" 会作为 Kubernetes Daemonset 运行在 Kubernetes 的每个 Node 上，通过 Kubernetes API 收集 Node、Pod 等的实时指标，然后转换成 Prometheus 能理解的数据结构，通过 HTTP API 暴露出来。cAdvisor 和 kube-state-metrics 收集的数据有一些互补，所以推荐两个都部署。")]),e._v(" "),t("li",[e._v("Prometheus 会定时拉取 cAdvisor 和 kube-state-metrics 的数据，然后存储到自己的时间序列数据库中。")]),e._v(" "),t("li",[e._v("Grafana 不会持久化 metric 数据，而是持久化图表的配置，然后通过 PromQL 从 Prometheus 查询数据、展示出来。Grafana 也支持通过 SQL 和其它查询语法从 MySQL、PostgreSQL 等数据源查询数据。")])]),e._v(" "),t("h2",{attrs:{id:"日志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#日志"}},[e._v("#")]),e._v(" 日志")]),e._v(" "),t("p",[e._v("K8s 日志收集的几个方案：")]),e._v(" "),t("ol",[t("li",[e._v("如果应用将日志输出到 stdout 和 stderr，宿主机会将这些日志收集到 "),t("code",[e._v("/var/log/pods/<namespace>_<pod_name>_<pod_id>/<container_name>/<container_id>.log")]),e._v(" 文件中。只需要部署一个 logging-agent 的 daemonset，比如 Fluentd 或者 Filebeat，就可以将这些日志收集到中心化的地方，比如 ELK 或者 Loki。这个方案的优点是简单、对代码和 Pod 配置都没有侵入性，缺点是要求容器将日志输出到 stdout 和 stderr。这应该是最常用的方案。")]),e._v(" "),t("li",[e._v("如果应用将日输出到文件，可以通过 sidecar 容器将文件重新输出到 stdout 和 stderr（比如 "),t("code",[e._v("tail -f file.log")]),e._v("），然后按照方案 1 收集。这个方案的优点是无需修改应用，缺点是需要修改 Pod 的配置，增加 sidecar 容器，以及日志会占两倍空间，一倍在应用的输出，一倍在宿主机的 log 目录下。")]),e._v(" "),t("li",[e._v("如果应用将日志输出到文件，还可以通过 sidecar 容器将这些日志直接收集到中心化的地方。相较于方案二，这个方案的优点是不会占用两倍空间。")]),e._v(" "),t("li",[e._v("如果应用层有日志收集的 SDK，可以直接将日志发送到中心化的地方。这个方案就是让应用层处理日志收集，而非在 K8s 层做了，适合于已经有日志收集 SDK 的大公司。这个方案的优点是适用于任何环境的部署，缺点是对代码有侵入性。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);