(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{627:function(s,t,n){"use strict";n.r(t);var e=n(3),a=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("最近看《Unix 编程艺术》的时候看到一段，")]),s._v(" "),t("blockquote",[t("p",[s._v("也许 Unix 最持久的异议恰恰来自 Unix 哲学的一个特性，这一条特性是 X window 设计者首先明确提出的。X 致力于提供一套“机制，而不是策略”，以支持一套极端通用的图形操作，从而把使用工具箱和界面的“观感”（策略）推后到应用层。 Unix 其它系统级的服务也有类似的倾向：行为的最终逻辑被尽可能推后到使用端。Unix用户可以在多种 shell 中进行选择。而 Unix 应用程序通常会提供很多的行为选项和令人眼花缭乱的定制功能。")])]),s._v(" "),t("p",[s._v("于是我想要尝试一些 zsh 以外的 shell。让豆包推荐了几个 shell 以后，选择了跨平台的 Nushell，作为老 Windows 用户不得不支持一下。")]),s._v(" "),t("p",[s._v("豆包推荐的几个里很有特色的：")]),s._v(" "),t("ol",[t("li",[s._v("Nushell (Nu) — 最现代、数据型 Shell\n"),t("ul",[t("li",[s._v("主打：像写代码一样用 Shell，结构化数据")]),s._v(" "),t("li",[s._v("输出不是纯文本，是表格 / JSON / 对象")]),s._v(" "),t("li",[s._v("天生支持：ls 彩色、语法高亮、自动补全")]),s._v(" "),t("li",[s._v("跨平台：Linux/macOS/Windows 完全一致")]),s._v(" "),t("li",[s._v("语法干净、现代，比 Bash 强太多")]),s._v(" "),t("li",[s._v("适合：开发者、喜欢清爽结构化命令的人")])])]),s._v(" "),t("li",[s._v("Xonsh — Python 风格的 Shell\n"),t("ul",[t("li",[s._v("主打：Python + Shell 混合写")]),s._v(" "),t("li",[s._v("直接在命令行写 Python 代码")]),s._v(" "),t("li",[s._v("兼容 Bash 命令")]),s._v(" "),t("li",[s._v("可高度可编程")]),s._v(" "),t("li",[s._v("适合：Python 开发者")])])])]),s._v(" "),t("p",[s._v("但是 Nushell 也有缺点：")]),s._v(" "),t("ul",[t("li",[s._v("Nushell 不兼容 POSIX 标准，导致不支持 "),t("code",[s._v("export")]),s._v(" "),t("code",[s._v("source")]),s._v(" "),t("code",[s._v("eval")]),s._v(" 等语法，"),t("strong",[s._v("无法直接使用 "),t("code",[s._v("source ~/.profile")]),s._v(" 完全无痛迁移 shell 通用的配置")]),s._v("，一些工具链配置 shell 环境的时候也会有问题。Nushell 文档里提供了一个函数来导入其它脚本的变量，可以参考"),t("a",{attrs:{href:"https://www.nushell.sh/zh-CN/cookbook/foreign_shell_scripts.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("官方文档"),t("OutboundLink")],1),s._v("。")])]),s._v(" "),t("p",[t("img",{attrs:{src:"/images/nushell-preview.png",alt:"Preview Nushell"}})]),s._v(" "),t("h2",{attrs:{id:"安装-nushell"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装-nushell"}},[s._v("#")]),s._v(" 安装 Nushell")]),s._v(" "),t("ul",[t("li",[s._v("Linux：从包管理器安装，或者从 "),t("a",{attrs:{href:"https://github.com/nushell/nushell/releases",target:"_blank",rel:"noopener noreferrer"}},[s._v("GitHub"),t("OutboundLink")],1),s._v(" 下载。")]),s._v(" "),t("li",[s._v("Windows："),t("code",[s._v("choco install -y nushell starship")]),s._v("，或者从 "),t("a",{attrs:{href:"https://github.com/nushell/nushell/releases",target:"_blank",rel:"noopener noreferrer"}},[s._v("GitHub"),t("OutboundLink")],1),s._v(" 下载。安装以后重启终端，Nushell 就出现在终端 App 的选项里了。")])]),s._v(" "),t("h2",{attrs:{id:"nushell-启动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nushell-启动"}},[s._v("#")]),s._v(" Nushell 启动")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("nu\n")])])]),t("h2",{attrs:{id:"nushell-导入其它-shell-的环境变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nushell-导入其它-shell-的环境变量"}},[s._v("#")]),s._v(" Nushell 导入其它 Shell 的环境变量")]),s._v(" "),t("p",[s._v("以下摘自"),t("a",{attrs:{href:"https://www.nushell.sh/zh-CN/cookbook/foreign_shell_scripts.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("官方文档"),t("OutboundLink")],1),s._v("：")]),s._v(" "),t("blockquote",[t("p",[s._v("nu 的一个常见问题是，其他应用程序将环境变量或功能导出为 shell 脚本，这些脚本期望由你的 shell 运行。\n但许多应用程序只考虑最常用的 shell，如 bash 或 zsh。不幸的是，nu 与这些 shell 的语法完全不兼容，因此无法直接运行或 source 这些脚本。\n通常，通过调用 zsh 本身（如果已安装）来运行 zsh 脚本没有任何障碍。但不幸的是，这将不允许 nu 访问导出的环境变量：")])]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v('# 这可以工作，使用 zsh 打印 "Hello"')]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'echo Hello'")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("zsh")]),s._v(" -c "),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$in")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 这会退出并报错，因为 $env.VAR 未定义")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'export VAR=\"Hello\"'")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("zsh")]),s._v(" -c "),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$in")]),s._v("\nprint "),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$env")]),s._v(".VAR\n")])])]),t("p",[s._v("文档提供了一个函数来解决这个问题。它的原理是启动一个 shell 来运行脚本，捕获运行前后的环境变量，然后比较两者的差异来确定哪些变量被更改了，最后把这些更改的变量导入到 nushell 的环境中。")]),s._v(" "),t("h2",{attrs:{id:"更新-nushell-配置文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更新-nushell-配置文件"}},[s._v("#")]),s._v(" 更新 Nushell 配置文件")]),s._v(" "),t("p",[s._v("我的配置文件做了几件事：")]),s._v(" "),t("ol",[t("li",[s._v("通过文档提供的函数 "),t("code",[s._v("capture-foreign-env")]),s._v("，捕获 "),t("code",[s._v("~/.profile")]),s._v(" 的内容，追加到了 "),t("code",[s._v("$nu.config-path")]),s._v(" 里，这样每次启动 Nushell 的时候就会自动导入 "),t("code",[s._v("~/.profile")]),s._v(" 里的环境变量了。")]),s._v(" "),t("li",[s._v("因为 "),t("code",[s._v("PATH")]),s._v(" 变量在 "),t("code",[s._v("~/.profile")]),s._v(" 里是一个字符串，而 Nushell 期望它是一个列表，所以这里做了特殊处理，把它转换成列表。")]),s._v(" "),t("li",[s._v("手动设置了 "),t("code",[s._v("LANG")]),s._v(" 和 "),t("code",[s._v("LC_ALL")]),s._v(" 变量，解决了 Nushell 的 locale 错误问题。")])]),s._v(" "),t("p",[s._v("下面的命令行直接把这些配置写入了 "),t("code",[s._v("$nu.config-path")]),s._v("。")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'def capture-foreign-env [\n    --shell (-s): string = /bin/sh\n    # 运行脚本的 shell\n    #（必须支持 '")]),s._v("-c"),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("' 参数和 POSIX '")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("env")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'、'")]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'、'")]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("eval")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("' 命令）\n    --arguments (-a): list<string> = []\n    # 传递给外部 shell 的额外命令行参数\n] {\n    let script_contents = $in;\n    let env_out = with-env { SCRIPT_TO_SOURCE: $script_contents } {\n        ^$shell ...$arguments -c `\n        env\n        echo '")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("ENV_CAPTURE_EVAL_FENCE"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'\n        eval \"$SCRIPT_TO_SOURCE\"\n        echo '")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("ENV_CAPTURE_EVAL_FENCE"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'\n        env -0 -u _ -u _AST_FEATURES -u SHLVL` # 过滤掉已知的更改变量\n    }\n    | split row '")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("ENV_CAPTURE_EVAL_FENCE"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'\n    | {\n        before: ($in | first | str trim | lines)\n        after: ($in | last | str trim | split row (char --integer 0))\n    }\n\n    # 不幸的假设：\n    # 没有更改的环境变量包含换行符（无法干净解析）\n    $env_out.after\n    | where { |line| $line not-in $env_out.before } # 只获取更改的行\n    | parse \"{key}={value}\"\n    | transpose --header-row --as-record\n    | if $in == [] { {} } else { $in }\n}\n\nif ('")]),s._v("~/.profile"),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("' | path exists) {load-env (open ~/.profile | capture-foreign-env --shell bash)}\nif (($env.PATH | describe) == '")]),s._v("string"),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('\') { $env.PATH = $env.PATH | split row (char esep) }  # PATH 变量需要特殊处理，因为它是一个字符串，而 nushell 期望它是一个列表\n\n$env.LANG = "zh_CN.UTF-8"\n$env.LC_ALL = "zh_CN.UTF-8"\n\'')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" save -f "),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$nu")]),s._v(".config-path\n")])])]),t("h2",{attrs:{id:"nushell-配置图标-starship"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nushell-配置图标-starship"}},[s._v("#")]),s._v(" Nushell 配置图标 (Starship)")]),s._v(" "),t("ul",[t("li",[s._v("Windows 安装：如果上面没有用 choco 安装的话，还可以用 winget 安装：\n"),t("code",[s._v("winget install --id Starship.Starship")])]),s._v(" "),t("li",[s._v("Linux 安装：从包管理器安装 starship，或者 "),t("code",[s._v("curl -sS https://starship.rs/install.sh | sh")])])]),s._v(" "),t("p",[s._v("安装好以后，执行下面的命令来配置 Nushell 的 Starship：")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("mkdir")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$nu")]),s._v(".data-dir "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" path "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("join")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"vendor/autoload"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\nstarship init nu "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" save -f "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$nu")]),s._v(".data-dir "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" path "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("join")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"vendor/autoload/starship.nu"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'eval \"$(starship init bash)\"'")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" save -f ~/.bashrc  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 顺便配置一下 bash 的 starship")]),s._v("\n\nnu  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 重启 Nushell")]),s._v("\n")])])]),t("p",[s._v("我个人喜欢在 Git Status 里显示数量，所以在 "),t("code",[s._v("~/.config/starship.toml")]),s._v(" 里添加了下面的配置：")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'[git_status]\ndisabled = false\nformat = '")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("\\")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$all_status")]),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$ahead_behind")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("\\")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$style")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'\nstyle = \"red bold\"\nstashed = '")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("\\")]),s._v("$"),t("span",{pre:!0,attrs:{class:"token variable"}},[s._v("${count}")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('\'\nahead = "⇡${count}"\nbehind = "⇣${count}"\ndiverged = "⇕${count}"\nconflicted = "=${count}"\ndeleted = "✘${count}"\nrenamed = "»${count}"\nmodified = "!${count}"\nstaged = "+${count}"\nuntracked = "?${count}"\n\'')]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" save -f ~/.config/starship.toml\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);