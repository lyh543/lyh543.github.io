(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{569:function(e,t,o){"use strict";o.r(t);var s=o(3),a=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ol",[t("li",[e._v("所有异步函数在主线程里使用，所有耗时的同步函数在子线程里使用")]),e._v(" "),t("li",[e._v("Django ASGIHandler 自动区分了这一点，因此不用担心同步 View 和异步 View 混用的问题")]),e._v(" "),t("li",[e._v("Python 异步模型类似于 JavaScript 的 Promise 模型（调用异步函数返回一个对象，可以向对象查询执行结果、或者 await），但有一点区别是，Python 创建的 "),t("code",[e._v("coroutine")]),e._v(" 对象只有在被 "),t("code",[e._v("await")]),e._v(" 或 "),t("code",[e._v("create_task")]),e._v(" 调用时才会被执行，而 JavaScript 的 Promise 对象在创建时就会立即执行。")])]),e._v(" "),t("h2",{attrs:{id:"为什么异步卡住了"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么异步卡住了"}},[e._v("#")]),e._v(" 为什么异步卡住了")]),e._v(" "),t("p",[e._v("大概率是主线程在运行 I/O 阻塞的代码（如 "),t("code",[e._v("time.sleep()")]),e._v("、"),t("code",[e._v("requests.get()")]),e._v("、大文件 "),t("code",[e._v("f.read()")]),e._v("）。因为 Python 兼容性问题，还有大量代码是使用阻塞 I/O 的。")]),e._v(" "),t("p",[e._v("注意一个坑点："),t("code",[e._v("asgiref.sync.sync_to_async")]),e._v(" 这个函数可以把同步函数转换为异步函数，但它有一个参数 "),t("code",[e._v("thread_sensitive")]),e._v("，默认值为 "),t("code",[e._v("True")]),e._v("，表示如果同步函数是线程敏感的（如使用了线程锁、Django ORM），则会在子线程中运行，否则会在主线程中运行。这个参数的默认值可能会导致异步函数卡住。所以如果同步函数有 I/O 阻塞的代码，需要调用 "),t("code",[e._v("sync_to_async(func, thread_sensitive=False)")]),e._v(" 来确保它在子线程中运行，这样就等价于 "),t("code",[e._v("loop.run_in_executor(None, func)")]),e._v("。")]),e._v(" "),t("p",[e._v("现在事件循环被同步函数卡住的问题还是很麻烦，没有显式的警告或错误提示，只能靠开发者的经验和对代码的熟悉程度来判断。")]),e._v(" "),t("h2",{attrs:{id:"异步的好处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步的好处"}},[e._v("#")]),e._v(" 异步的好处")]),e._v(" "),t("p",[e._v("这里收集了一些关于 Python 异步编程的观点，关于我们为什么需要异步。")]),e._v(" "),t("blockquote",[t("p",[e._v("Async IO doesn't necessarily speeds up your code, it just reduces the server resources usage for concurrent tasks by leveraging concurrent network IO in a single-threaded application.")])]),e._v(" "),t("blockquote",[t("p",[e._v("I think this misses the main appeal of async. It's not about speed but about the programming model. Async makes it much easier to work with and compose concurrency compared to the thread based model. Just the fact that you can cancel tasks makes it trivial to do proper timeouts, which nobody gets right in sync applications, for example."),t("br"),e._v("\n我认为这忽略了异步的主要吸引力。异步的魅力不在于速度，而在于编程模型。与基于线程的模型相比，异步使得并发处理和编写更加容易。仅仅因为可以取消任务，就使得实现适当的超时变得轻而易举，而这在同步应用程序中是很难做到的。")]),e._v(" "),t("p",[e._v("It also allows things like structured concurrency."),t("br"),e._v("\n它还允许诸如结构化并发之类的事情。"),t("br"),e._v("\n-- https://www.reddit.com/r/Python/comments/x9x8pb/comment/inqvsi0/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button")])]),e._v(" "),t("p",[e._v("2025.10.15 更新：")]),e._v(" "),t("p",[e._v("最近在写 Python 后端和数据处理任务的时候，有一个死锁问题一直困惑着我。原先的代码逻辑大概是任务开始时，使用 ThreadPoolExecutor 并发处理每一条数据，在处理每条数据时又启用了 ThreadPoolExecutor 去 ls 网络上的磁盘。按理说使用 ThreadPoolExecutor 不需要自己去使用锁实现并发控制，不会因为我自己水平太菜、代码写出死锁，但线上还是出现了多次死锁的情况，并且死锁的地方全是在 ThreadPoolExecutor 结束时等待 executor 结束。加上我们使用的是比较老的 Python 3.8，以及项目依赖比较庞大，有使用 billiard 这一类的 monkey patch，所以我怀疑可能是 Python 或者框架层面的 bug。")]),e._v(" "),t("p",[e._v("后面我用异步编程重新实现了这一块的逻辑，基本上就是把同步的依赖用相同功能的异步依赖替代掉，或者 "),t("code",[e._v("sync_to_async")]),e._v(" 包装一下，就奇迹般地好了。")]),e._v(" "),t("p",[e._v("问了 ChatGPT，ChatGPT 说这是有可能的，"),t("strong",[e._v("因为相较于多线程编程时需要靠锁实现并发时的数据安全， Python 的协程是无锁的，协程之间的切换是函数主动（使用 "),t("code",[e._v("await")]),e._v("）让出的，既然没有锁就不会有死锁的问题了")]),e._v("（不过在控制并发任务数时仍然使用了 "),t("code",[e._v("asyncio.Semaphore")]),e._v("，并不能说是完全无锁，但是对锁的使用上已经少很多了）。")]),e._v(" "),t("p",[e._v("所以如果你在 Python 里遇到多线程死锁的疑难杂症，可以尝试用异步编程重新实现一遍。")])])}),[],!1,null,null,null);t.default=a.exports}}]);