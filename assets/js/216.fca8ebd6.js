(window.webpackJsonp=window.webpackJsonp||[]).push([[216],{603:function(t,a,_){"use strict";_.r(a);var v=_(3),e=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://ubuntu.com/engage/ota-updates-iot-guide",target:"_blank",rel:"noopener noreferrer"}},[t._v("白皮书入口"),a("OutboundLink")],1),t._v(" | "),a("a",{attrs:{href:"https://pages.ubuntu.com/rs/066-EOV-335/images/How_Ubuntu_Core_transforms_OTA_updates_for_IoT_WP_02_02_23.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("下载链接"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"ota-的目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ota-的目标"}},[t._v("#")]),t._v(" OTA 的目标")]),t._v(" "),a("p",[t._v("OTA 的场景，和边缘计算有一定重合。Ubuntu 的这篇文章讲的就是 IoT 设备的 OTA。现实生活中的已经比较常见的 OTA 例子有：Windows 更新、手机系统 OTA、汽车智能系统 OTA。这些场景的共同特点是：")]),t._v(" "),a("ul",[a("li",[t._v("设备网络不稳定；")]),t._v(" "),a("li",[t._v("设备电源不稳定：又不是在机房里能保证 24 小时持续供电，OTA 更新到一半没电了是必须考虑到的场景；")]),t._v(" "),a("li",[t._v("工程师几乎无法远程调试和运维：机房里机器更新挂了还可以 SSH 连上去运维，无网环境根本没有办法运维；")]),t._v(" "),a("li",[t._v("设备基数大。而且设备基数越大，做好 OTA 能带来的收益就越可观。反过来说，前期设备基数小的时候，其实不一定需要投入特别多精力来实现一个特别完备的 OTA")])]),t._v(" "),a("blockquote",[a("p",[t._v("实现一个 OTA 需要做到以下几点：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("更新是自动的")])]),t._v(" "),a("li",[a("strong",[t._v("提供恢复机制")]),t._v("：如果更新失败，能够自动恢复；就算系统启动不了，也要能够恢复")]),t._v(" "),a("li",[a("strong",[t._v("更新有优先级")]),t._v("：高优先级的更新（如关键更新）能够在其它更新之前完成更新")]),t._v(" "),a("li",[a("strong",[t._v("提供冗余机制")]),t._v("：如果更新失败，能把宕机时间降到最低")])])]),t._v(" "),a("h2",{attrs:{id:"snap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#snap"}},[t._v("#")]),t._v(" Snap")]),t._v(" "),a("blockquote",[a("p",[t._v("Snap 是 Ubuntu 主推的包安装器。其特点有：")]),t._v(" "),a("ul",[a("li",[t._v("无依赖。Linux 现在主流的包管理器（apt、yum、pacman 等）安装包的时候会有很多依赖。共用依赖的好处是节省网络流量和存储成本。虽然大部分时候依赖不会出问题，但是依赖一出问题就是大问题。显然 OTA 失败后不可能让工程师连到设备上一个一个解依赖问题，零依赖相当于是用空间换取系统的稳定性。")]),t._v(" "),a("li",[t._v("容器化，保证系统和应用、应用和应用之间、应用和其数据的隔离性。但如果应用申请权限，又可以做到精细粒度的授权和控制。这一步是在 snapd 使用 cgroups、Sccomp、AppArmor 等技术实现的。")]),t._v(" "),a("li",[t._v("安装过程是事务的。如果没成功，系统会自动回滚，除了错误日志以外，不留下任何错误的痕迹。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/7e273e304998a27eb948f655643bc774a0440ebfa3b885ca68081ca0c3a11806.png",alt:"Ubuntu Core 架构图"}})]),t._v(" "),a("p",[t._v("Ubuntu Core 将大部分系统组件都拆成了 Snap，包括内核和 Ubuntu Core 本身。也就是说，如果我想要更新内核或者 Ubuntu Core 系统，我只需要更新其 Snap 包就可以了，这个更新过程能享受到 Snap 里的所有优点。不过有一个问题我不太理解，整个系统是否存在不是 Snap 的部分？如果有，这部分怎么更新呢？")]),t._v(" "),a("blockquote",[a("p",[t._v("Ubuntu Core 的系统底层只有内核、"),a("code",[t._v("init")]),t._v(" 进程、必要的工具和 "),a("code",[t._v("snapd")]),t._v(" 进程（Snap 的守护进程）。")])]),t._v(" "),a("blockquote",[a("p",[t._v("在没有显式授权的情况下，Snap 包不能修改其它用户、新增用户、访问硬件、更改安全策略、修改系统、修改内核运行变量，以及别的能够让系统挂掉的操作。")])]),t._v(" "),a("blockquote",[a("p",[t._v("除了预装的 Snap 包以外，所有包都是从具有签名的可信源获取。")])]),t._v(" "),a("blockquote",[a("p",[t._v("Ubuntu 提供了一个 Snapcraft build tool，用于将其它 app 修改为 Snap 包。大部分 app 只需要添加一个配置文件声明其需要的东西，就可以了。")])]),t._v(" "),a("h2",{attrs:{id:"更新策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新策略"}},[t._v("#")]),t._v(" 更新策略")]),t._v(" "),a("p",[t._v("Snap app 的升级是事务的。为了做到这一点，Snap 在更新 app 时，会复制 app 需要的用户数据，以供回滚。这点利用了 Snap app 的设计：app 被限制为只能访问某些目录的数据。另外，我理解升级只在 app 不工作时进行，否则数据可能会有不一致性。")]),t._v(" "),a("p",[t._v("对于内核级 snap app，除了会复制用户数据以外，还会在系统启动失败后自动回滚。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/transactional-updates-in-ubuntu-core.png",alt:"Transactional updates in Ubuntu Core"}})]),t._v(" "),a("p",[t._v("默认情况下，Ubuntu Core 会保留两个旧版本的 app（以及其数据）。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("如果 app 出现了大版本升级（大幅度的配置变化和数据格式变化等），Ubuntu Core 引入了 Epochs 的概念。")]),t._v(" "),a("ul",[a("li",[t._v("每个大版本对应一个 Epoch。")]),t._v(" "),a("li",[t._v("厂商需要提供 Epoch 升级的方法（如更新数据格式）。")]),t._v(" "),a("li",[t._v("厂商可以控制每个 app 上 Epoch 升级的时机。")]),t._v(" "),a("li",[t._v("跨 Epoch 的 app 升级同样是事务的、可以回滚的。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/epochs-in-ubuntu-core.png",alt:"Epochs in Ubuntu Core"}})]),t._v(" "),a("h2",{attrs:{id:"恢复系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#恢复系统"}},[t._v("#")]),t._v(" 恢复系统")]),t._v(" "),a("p",[t._v("Recovery 部分，Ubuntu 有 Recovery system，可以在启动时进入，或者通过 API 远程启动。Recovery system 中，可以创建 snapshot 和回滚 snapshot。snapshot 的内容是设置和 apps 的集合。（看来 Ubuntu Core 需要足够简单，才能在有限的设置和 apps 上跑通）")]),t._v(" "),a("h2",{attrs:{id:"snap-delta-增量更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#snap-delta-增量更新"}},[t._v("#")]),t._v(" Snap Delta 增量更新")]),t._v(" "),a("p",[t._v("OTA 的这篇文章里放了 Snap Delta 增量更新的链接，不过文章内容也更多是讲 Snap Delta 的操作无感，以及用实例来表明 Snap Delta 能解决 30%-40% 的流量，并没有对技术细节进行展开。Snap Delta 文章入口在 "),a("a",{attrs:{href:"https://ubuntu.com/engage/snap-deltas",target:"_blank",rel:"noopener noreferrer"}},[t._v("Optimising IoT bandwidth with delta updates | Ubuntu"),a("OutboundLink")],1),t._v("，也有"),a("a",{attrs:{href:"https://pages.ubuntu.com/rs/066-EOV-335/images/Snap_Delta_WP_Canonical_Final.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("下载直链"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"增量更新生成流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增量更新生成流程"}},[t._v("#")]),t._v(" 增量更新生成流程")]),t._v(" "),a("p",[t._v("和 Android 厂商需要"),a("a",{attrs:{href:"https://source.android.com/docs/core/ota/tools?hl=zh-cn#incremental-updates",target:"_blank",rel:"noopener noreferrer"}},[t._v("跑工具生成 OTA 包"),a("OutboundLink")],1),t._v(" 不同的是，Snap 开发者只需要把包提交到 Snap Store 后，Snap Store 会负责生成增量更新包，开发者不需要改变现有工作流就能支持增量 OTA。这也合理，毕竟 Android 厂商是自己负责分发 OTA，而 Snap 全量包/增量包的生成和分发工作交给 Snap Store 就好，开发者不用操心。")]),t._v(" "),a("p",[t._v("Snap 也支持上传增量包，用以节省上传流量。Snap 把生成增量包和上传的步骤封装到了 Snapcraft 的 push 里，所以对于开发者也是无感的。")]),t._v(" "),a("h3",{attrs:{id:"snap-delta-性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#snap-delta-性能"}},[t._v("#")]),t._v(" Snap Delta 性能")]),t._v(" "),a("p",[t._v("在下面的例子中，Snap Delta 的压缩率在 1~56% 不等。文档里表明是在 30% 左右，也有 Delta 包甚至大于全量包的，这种情况下 Snap Store 会直接分发全量包。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Snap name")]),t._v(" "),a("th",[t._v("Full download size")]),t._v(" "),a("th",[t._v("Delta download size")]),t._v(" "),a("th",[t._v("Delta size")]),t._v(" "),a("th",[t._v("Time to apply delta"),a("br"),t._v("(Broadcom BCM2837 Quad Core ARM Cortex-A53 USB storage)")]),t._v(" "),a("th",[t._v("Time to apply delta"),a("br"),t._v("(Intel Core i7-4500U CPU @ 1.80GHz SSD storage)")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("alsa-utils")]),t._v(" "),a("td",[t._v("6.5MiB")]),t._v(" "),a("td",[t._v("62.8KiB")]),t._v(" "),a("td",[t._v("0.94%")]),t._v(" "),a("td",[t._v(".45s")]),t._v(" "),a("td",[t._v("0.045s")])]),t._v(" "),a("tr",[a("td",[t._v("nextcloud")]),t._v(" "),a("td",[t._v("197MiB")]),t._v(" "),a("td",[t._v("112MiB")]),t._v(" "),a("td",[t._v("56.85%")]),t._v(" "),a("td",[t._v("24.0s")]),t._v(" "),a("td",[t._v("1.16s")])]),t._v(" "),a("tr",[a("td",[t._v("core")]),t._v(" "),a("td",[t._v("87.9MiB")]),t._v(" "),a("td",[t._v("27.55MiB")]),t._v(" "),a("td",[t._v("31.34%")]),t._v(" "),a("td",[t._v("10.75s")]),t._v(" "),a("td",[t._v("0.42s")])]),t._v(" "),a("tr",[a("td",[t._v("pc-kernel")]),t._v(" "),a("td",[t._v("154.77MiB")]),t._v(" "),a("td",[t._v("54.20MiB")]),t._v(" "),a("td",[t._v("35.01%")]),t._v(" "),a("td",[t._v("18.9s")]),t._v(" "),a("td",[t._v(".788s")])])])]),t._v(" "),a("p",[t._v("文章后面举了很多嵌入式和 PC 的实例，数据表明整体更新的压缩率在 30-40% 左右。")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("Canonical 先是推出了 Snap，对 app 的权限和文件目录等加以限制。然后基于 Snap app 的这些限制，实现了软件包安装的事务性。管理软件包版本、升级和回滚、保证系统稳定从而变得容易。")]),t._v(" "),a("p",[t._v("跑个题，这个思想其实和 bazel 很相似。")]),t._v(" "),a("ul",[a("li",[t._v("Snap 限制了 app 的权限和能读写的数据目录等。在这些限制下，实现一个稳定的系统，变得容易得多；")]),t._v(" "),a("li",[t._v("bazel 限制了编译指令的输入和输出等。在这些限制下，实现一个幂等的、可并行的、缓存命中率高的编译系统，也会容易很多。")])]),t._v(" "),a("p",[t._v("在做一个管理资源的框架时，资源的权限并不是越多越好。限制被管理的资源的权限后，性能和稳定性优化的空间就更大，所以在设计之初就需要对二者做权衡。")])])}),[],!1,null,null,null);a.default=e.exports}}]);