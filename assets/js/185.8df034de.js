(window.webpackJsonp=window.webpackJsonp||[]).push([[185],{540:function(t,v,_){"use strict";_.r(v);var r=_(3),a=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"系列目录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系列目录"}},[t._v("#")]),t._v(" 系列目录")]),t._v(" "),_("ul",[_("li",[_("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/1-transactions.html"}},[t._v("数据库并发控制 (1) -- 事务")])],1),t._v(" "),_("li",[_("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/2-innodb-mvcc.html"}},[t._v("数据库并发控制 (2) -- InnoDB 并发控制")])],1),t._v(" "),_("li",[_("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/3-innodb-locks.html"}},[t._v("数据库并发控制 (3) -- InnoDB 锁")])],1),t._v(" "),_("li",[_("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/4-distributed-locks-design.html"}},[t._v("数据库并发控制 (4) -- 分布式锁的设计")])],1)]),t._v(" "),_("h2",{attrs:{id:"参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://tech.meituan.com/2014/08/20/innodb-lock.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Innodb中的事务隔离级别和锁的关系 - 美团技术团队"),_("OutboundLink")],1)])]),t._v(" "),_("h2",{attrs:{id:"innodb-锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#innodb-锁"}},[t._v("#")]),t._v(" InnoDB 锁")]),t._v(" "),_("p",[t._v("数据库遵循的是"),_("strong",[t._v("两段锁协议")]),t._v("，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）")]),t._v(" "),_("ul",[_("li",[t._v("加锁阶段：在该阶段可以进行加锁操作。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。")]),t._v(" "),_("li",[t._v("解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。")])]),t._v(" "),_("p",[t._v("这种方式虽然"),_("strong",[t._v("无法避免死锁")]),t._v("，但是两段锁协议"),_("strong",[t._v("可以保证事务的并发调度是串行化")]),t._v("（串行化很重要，尤其是在数据恢复和备份的时候）的。")]),t._v(" "),_("h2",{attrs:{id:"行锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[t._v("#")]),t._v(" 行锁")]),t._v(" "),_("p",[t._v("InnoDB 实现了两种类型的行级锁：")]),t._v(" "),_("ul",[_("li",[t._v("共享锁 (S)：在对任何数据进行读操作之前要申请并获得 S 锁。其它事务可以继续加共享锁，但不能加排它锁；")]),t._v(" "),_("li",[t._v("独占锁 (X)：在进行写操作之前要申请并获得 X 锁。其它事务不能再获得任何锁；")])]),t._v(" "),_("h2",{attrs:{id:"表锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[t._v("#")]),t._v(" 表锁")]),t._v(" "),_("p",[t._v("InnoDB 支持多粒度锁，因此 S 和 X 锁还可以锁表（如使用 "),_("code",[t._v("ALTER TABLE")]),t._v(" 等语句会给表上 X 锁）。")]),t._v(" "),_("p",[t._v("另外还设计了两个意向锁，注意"),_("strong",[t._v("意向锁都是表级的")]),t._v("：")]),t._v(" "),_("ul",[_("li",[t._v("意向共享锁 (IS)：表明事务即将给表中的行设置 S 锁。事务给行加 S 锁前必须获得该表的 IS 锁。")]),t._v(" "),_("li",[t._v("意向排它锁 (IX)：表明事务即将给表中的行设置 X 锁。事务给行加 X 锁前必须获得该表的 IX 锁。")])]),t._v(" "),_("p",[t._v("综上，MySQL 支持两种行锁和四种表锁。")]),t._v(" "),_("p",[t._v("四种表锁的兼容表如下：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("锁类型")]),t._v(" "),_("th",[t._v("X")]),t._v(" "),_("th",[t._v("IX")]),t._v(" "),_("th",[t._v("S")]),t._v(" "),_("th",[t._v("IS")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("X")]),t._v(" "),_("td",[t._v("冲突")]),t._v(" "),_("td",[t._v("冲突")]),t._v(" "),_("td",[t._v("冲突")]),t._v(" "),_("td",[t._v("冲突")])]),t._v(" "),_("tr",[_("td",[t._v("IX")]),t._v(" "),_("td",[t._v("冲突")]),t._v(" "),_("td",[t._v("兼容")]),t._v(" "),_("td",[t._v("冲突")]),t._v(" "),_("td",[t._v("兼容")])]),t._v(" "),_("tr",[_("td",[t._v("S")]),t._v(" "),_("td",[t._v("冲突")]),t._v(" "),_("td",[t._v("冲突")]),t._v(" "),_("td",[t._v("兼容")]),t._v(" "),_("td",[t._v("兼容")])]),t._v(" "),_("tr",[_("td",[t._v("IS")]),t._v(" "),_("td",[t._v("冲突")]),t._v(" "),_("td",[t._v("兼容")]),t._v(" "),_("td",[t._v("兼容")]),t._v(" "),_("td",[t._v("兼容")])])])]),t._v(" "),_("p",[t._v("总结一下就是：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("意向锁")]),t._v("之间相互不冲突")]),t._v(" "),_("li",[_("code",[t._v("互斥锁")]),t._v("和所有锁都冲突")]),t._v(" "),_("li",[_("code",[t._v("共享锁")]),t._v("和"),_("code",[t._v("互斥意向锁")]),t._v("冲突")])]),t._v(" "),_("h2",{attrs:{id:"行锁的算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#行锁的算法"}},[t._v("#")]),t._v(" 行锁的算法")]),t._v(" "),_("ul",[_("li",[t._v("Record Locks：锁（单条）记录")]),t._v(" "),_("li",[t._v("Rocord Gaps：锁范围")]),t._v(" "),_("li",[t._v("Next-Key Locks：锁范围+锁记录")])])])}),[],!1,null,null,null);v.default=a.exports}}]);