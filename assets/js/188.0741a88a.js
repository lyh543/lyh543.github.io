(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{547:function(t,v,_){"use strict";_.r(v);var r=_(3),o=Object(r.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"系列目录"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系列目录"}},[t._v("#")]),t._v(" 系列目录")]),t._v(" "),v("ul",[v("li",[v("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/1-transactions.html"}},[t._v("数据库并发控制 (1) -- 事务")])],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/2-innodb-mvcc.html"}},[t._v("数据库并发控制 (2) -- InnoDB 并发控制")])],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/3-innodb-locks.html"}},[t._v("数据库并发控制 (3) -- InnoDB 锁")])],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/4-distributed-locks-design.html"}},[t._v("数据库并发控制 (4) -- 分布式锁的设计")])],1)]),t._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://en.wikipedia.org/wiki/Isolation_%28database_systems",target:"_blank",rel:"noopener noreferrer"}},[t._v("Isolation (database systems) - Wikipedia"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL :: MySQL 8.0 Reference Manual :: 15.7.4 Phantom Rows"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://docs.oracle.com/cd/B12037_01/server.101/b10743/consist.htm#sthref1919",target:"_blank",rel:"noopener noreferrer"}},[t._v("13 Data Concurrency and Consistency - Oracle Docs"),v("OutboundLink")],1)])]),t._v(" "),v("h2",{attrs:{id:"事务概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务概念"}},[t._v("#")]),t._v(" 事务概念")]),t._v(" "),v("p",[t._v("数据库事务 (transaction) 是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。")]),t._v(" "),v("p",[t._v("最常见的例子是转帐：从帐户 A 转 100 元到帐户 B 上，该事务的操作有：")]),t._v(" "),v("ol",[v("li",[t._v("A 账户中减 100 元；")]),t._v(" "),v("li",[t._v("B 账户中加 100 元。")])]),t._v(" "),v("p",[t._v("这两个步骤，要么全做，要么全不做。")]),t._v(" "),v("p",[t._v("事务全做完以后，需要进行"),v("strong",[t._v("提交")]),t._v("(commit)。提交以后，事务做的修改就会被永久记录在数据库中，即使发生故障也能恢复。")]),t._v(" "),v("p",[t._v("如果事务做到一半，不想做了/做不下去了，可以"),v("strong",[t._v("回滚")]),t._v("(roll back)，回到什么都没做的状态。")]),t._v(" "),v("h2",{attrs:{id:"事务的-acid"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的-acid"}},[t._v("#")]),t._v(" 事务的 ACID")]),t._v(" "),v("p",[t._v("ACID，是指数据库管理系统 (DBMS) 在写入或更新资料的过程中，为保证事务 (transaction) 是正确可靠的，所必须具备的四个特性：")]),t._v(" "),v("ul",[v("li",[t._v("原子性 (atomicity)：一个事务要么全做要么全不做；InnoDB 通过 undo log 保证回滚时能找到之前的数据。")]),t._v(" "),v("li",[v("strong",[t._v("一致性")]),t._v(" (consistency)：任何时刻，数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。还是转账的例子：从帐户 A 转 100 元到帐户 B 上，如果帐户 A 上的钱减少了，而帐户 B 上的钱却没有增加，那么我们认为此时数据处于不一致的状态；InnoDB 通过 crash recovery 和 double write buffer 保证。（todo: cache recovery, double write buffer）")]),t._v(" "),v("li",[t._v("隔离性 (isolation)：一个事务不影响其他事务的运行效果；下面会详细聊。")]),t._v(" "),v("li",[t._v("持久性 (durability)：事务一旦提交，则其结果就是永久性的，即使故障也能恢复；InnoDB 通过 redo log 保证提交的数据一定不丢失。")])]),t._v(" "),v("h2",{attrs:{id:"事务的原子性和持久性的保证"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的原子性和持久性的保证"}},[t._v("#")]),t._v(" 事务的原子性和持久性的保证")]),t._v(" "),v("ol",[v("li",[t._v("将所有事务开始、提交、终止，以及数据的更新操作（记录数据更新前的值即前像，或更新后的值即后像）计入 log")]),t._v(" "),v("li",[t._v("系统崩溃后重启，先读取日志对已提交的事务进行 redo（保证持久性）")]),t._v(" "),v("li",[t._v("然后对尚未提交的的事务进行 undo（保证原子性）")])]),t._v(" "),v("h2",{attrs:{id:"innodb-事务隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb-事务隔离级别"}},[t._v("#")]),t._v(" InnoDB 事务隔离级别")]),t._v(" "),v("p",[t._v("SQL 标准定义了四种隔离，隔离程度"),v("strong",[t._v("由低到高")]),t._v("依次为：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("读未提交")]),t._v("/"),v("strong",[t._v("脏读")]),t._v("（Read Uncommitted）：事务会查询到其他"),v("strong",[t._v("未提交")]),t._v("事务影响的数据，也被称为脏读；")]),t._v(" "),v("li",[v("strong",[t._v("读提交")]),t._v("/"),v("strong",[t._v("不可重复读")]),t._v("（Read Committed，Oracle 默认）：事务只会查询到其他"),v("strong",[t._v("已提交")]),t._v("事务影响的数据；但多次查询同一个数据，其结果可能变化（如果一个事务两次读"),v("strong",[t._v("同一个")]),t._v("数据之间，某个事务对这个数据修改并提交了，读事务会发现两次读到的东西不一样），这就被称为不可重复读。")]),t._v(" "),v("li",[v("strong",[t._v("可重复读")]),t._v("（Repeatable Read，InnoDB 默认，Oracle 不支持）：事务只会查询到"),v("strong",[t._v("在当前事务开始前已提交")]),t._v("事务影响的数据；但在插入数据时会查询到当前事务开始后提交的事务影响的数据（当前事务查询到不存在 "),v("code",[t._v("id=1")]),t._v(" 的数据，过程中其他事务增加 "),v("code",[t._v("id=1")]),t._v(" 的数据并提交，当前事务插入 "),v("code",[t._v("id=1")]),t._v(" 时报错冲突，但的确又查不到 "),v("code",[t._v("id=1")]),t._v(" 的数据），被称为幻读。")]),t._v(" "),v("li",[v("strong",[t._v("序列化")]),t._v("（Serializable）：如果要彻底完全解决上面的三种问题，就只能让事务串行化了，也就是把多个事务变成一个序列。")])]),t._v(" "),v("p",[t._v("从数据一致性的角度来讲，隔离程度越高越好；但是性能的角度来讲，隔离程度越高，事务并发度更低，且更容易死锁。所以，在实际中可能需要根据实际情况，选择性能和隔离性的一个平衡点。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("有/无问题")]),t._v(" "),v("th",[t._v("脏读")]),t._v(" "),v("th",[t._v("不可重复读")]),t._v(" "),v("th",[t._v("幻读")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("读未提交")]),t._v(" "),v("td",[t._v("有")]),t._v(" "),v("td",[t._v("有")]),t._v(" "),v("td",[t._v("无")])]),t._v(" "),v("tr",[v("td",[t._v("读提交")]),t._v(" "),v("td",[t._v("无")]),t._v(" "),v("td",[t._v("有")]),t._v(" "),v("td",[t._v("无")])]),t._v(" "),v("tr",[v("td",[t._v("可重复读")]),t._v(" "),v("td",[t._v("无")]),t._v(" "),v("td",[t._v("无")]),t._v(" "),v("td",[t._v("有*")])]),t._v(" "),v("tr",[v("td",[t._v("序列化")]),t._v(" "),v("td",[t._v("无")]),t._v(" "),v("td",[t._v("无")]),t._v(" "),v("td",[t._v("无")])])])]),t._v(" "),v("p",[t._v("* InnoDB 提供了在可重复读下回避幻读的方法：如果在可重复读下进行了 "),v("code",[t._v("SELECT ... FOR UPDATE")]),t._v(" 或 "),v("code",[t._v("UPDATE")]),t._v(" 或 "),v("code",[t._v("DELETE")]),t._v("，InnoDB 会"),v("strong",[t._v("锁住当前最新已提交的数据")]),t._v("（而不是当前事务开始前已提交的数据），并在查询、更新、删除过程中使用最新已提交的数据。（代价是，加锁后读的值和加锁前读的值不同，即不可重复读）。-- "),v("a",{attrs:{href:"https://stackoverflow.com/questions/68443220/how-mvcc-works-with-lock-in-mysql",target:"_blank",rel:"noopener noreferrer"}},[t._v("locking - How MVCC works with Lock in MySql? - Stack Overflow"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("img",{attrs:{src:"/images/89d50dce3a86ddf8781ceba795d290541965e80243005f5415c14ae1b83d0b5e.png",alt:"picture 3"}})])])}),[],!1,null,null,null);v.default=o.exports}}]);