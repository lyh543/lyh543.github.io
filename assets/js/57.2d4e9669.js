(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{416:function(t,s,a){"use strict";a.r(s);var n=a(3),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"继承和派生"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#继承和派生"}},[t._v("#")]),t._v(" 继承和派生")]),t._v(" "),s("p",[t._v("派生，就是从原来的大类，通过增加新的东西、特性、条件，变成了新的小类。如，从哺乳动物通过增加特性（汪汪叫、喵喵叫），派生到狗、猫。")]),t._v(" "),s("p",[t._v("狗和猫，都继承了哺乳动物的特点（胎生等），派生的时候，狗、猫都会自动继承哺乳动物有的特点，无需重复声明。")]),t._v(" "),s("p",[t._v("名称上，被派生的（哺乳动物）叫基类（父类），派生出来的猫、狗叫做派生类（子类）。他们间的继承关系，是由派生类到大类。")]),t._v(" "),s("p",[t._v("（貌似继承和派生是反义词）")]),t._v(" "),s("p",[t._v("在 C++ 中，除了单继承，还可以多继承（狗同时继承了哺乳动物和岸生动物的特点）。")]),t._v(" "),s("p",[t._v("派生类的功能：")]),t._v(" "),s("ol",[s("li",[t._v("继承了基类的所有成员；")]),t._v(" "),s("li",[t._v("可以改造基类的成员；")]),t._v(" "),s("li",[t._v("添加新的成员。")])]),t._v(" "),s("h3",{attrs:{id:"继承类的定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#继承类的定义"}},[t._v("#")]),t._v(" 继承类的定义")]),t._v(" "),s("p",[t._v("定义继承类的语法格式如下：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Dog")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("继承方式"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Terrestrial")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("继承方式"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Mammalia")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//定义派生新增加的成员")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("继承方式分为：公有继承（public）、私有继承（private，默认）、保护继承（private），后面有详细解释。")]),t._v(" "),s("h3",{attrs:{id:"保护成员-和-继承方式-公有继承、私有继承、保护继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#保护成员-和-继承方式-公有继承、私有继承、保护继承"}},[t._v("#")]),t._v(" 保护成员 和 继承方式：公有继承、私有继承、保护继承")]),t._v(" "),s("p",[t._v("无论使用那种继承，基类的对象及其成员都会成为派生类的一部分，但是成员的属性可能发生变化。\n"),s("strong",[t._v("但是，无论使用哪种继承，基类的私有成员在派生类不能直接访问")]),t._v("，必须通过基类提供的公有函数、保护函数访问。")]),t._v(" "),s("p",[t._v("于是产生了保护成员：")]),t._v(" "),s("p",[s("code",[t._v("公有成员")]),t._v(" 对于 派生类 和 类外部 都是可见的；\n"),s("code",[t._v("私有成员")]),t._v(" 对于 派生类 和 类外部 都是不可见的；\n"),s("code",[t._v("保护成员")]),t._v(" 是二者的一个中和，他对于 派生类 是可见的，对于 类外部 是不可见的。")]),t._v(" "),s("p",[t._v("说完保护成员，三种继承的区别就很简短了：")]),t._v(" "),s("ul",[s("li",[t._v("公有继承（public）：公有继承是 "),s("code",[t._v("is a")]),t._v(" 的关系，基类的 "),s("code",[t._v("public")]),t._v(" 和 "),s("code",[t._v("protected")]),t._v(" 成员属性都不会改变。这是最常用的。")]),t._v(" "),s("li",[t._v("私有继承（private）：他是一个 "),s("code",[t._v("has a")]),t._v(" 的关系。基类的 "),s("code",[t._v("public")]),t._v(" 和 "),s("code",[t._v("protected")]),t._v(" 成员都会变为 "),s("code",[t._v("private")]),t._v("。")]),t._v(" "),s("li",[t._v("保护继承（protected）：是私有继承的变体。基类的 "),s("code",[t._v("public")]),t._v(" 和 "),s("code",[t._v("protected")]),t._v(" 成员都会变为 "),s("code",[t._v("protected")]),t._v("。")])]),t._v(" "),s("p",[t._v("也可以用下面的表格来说明：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("基类")]),t._v(" "),s("th",[t._v("public 成员")]),t._v(" "),s("th",[t._v("protected 成员")]),t._v(" "),s("th",[t._v("private 成员")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("public 继承")]),t._v(" "),s("td",[t._v("public")]),t._v(" "),s("td",[t._v("protected")]),t._v(" "),s("td",[t._v("不可见")])]),t._v(" "),s("tr",[s("td",[t._v("protected 继承")]),t._v(" "),s("td",[t._v("protected")]),t._v(" "),s("td",[t._v("protected")]),t._v(" "),s("td",[t._v("不可见")])]),t._v(" "),s("tr",[s("td",[t._v("private 继承")]),t._v(" "),s("td",[t._v("private")]),t._v(" "),s("td",[t._v("private")]),t._v(" "),s("td",[t._v("不可见")])])])]),t._v(" "),s("p",[t._v("另外，"),s("code",[t._v("struct")]),t._v(" 也是可以继承的：")]),t._v(" "),s("blockquote",[s("p",[t._v("In C++, a structure's inheritance is the same as a class except the following differences: When deriving a struct from a class/struct, the default access-specifier for a base class/struct is public. And when deriving a class, the default access specifier is private.\n-- Struct inheritance in C++ - Stack Overflow")])]),t._v(" "),s("p",[t._v("实际开发中，私有继承和保护继承有多少应用场景呢？")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.zhihu.com/question/36133278/answer/66070708",target:"_blank",rel:"noopener noreferrer"}},[t._v("知乎"),s("OutboundLink")],1),t._v("上有这么一个问题，可见其实用的真的很少，很多私有继承可以用类的组合来代替，而 Java 直接就把私有和保护两种继承给砍掉了。")]),t._v(" "),s("h4",{attrs:{id:"私有继承和类的组合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#私有继承和类的组合"}},[t._v("#")]),t._v(" 私有继承和类的组合")]),t._v(" "),s("p",[t._v("私有继承和"),s("RouterLink",{attrs:{to:"/notes/cpp/cpp-grammar/cpp-class-and-object.html#类的组合"}},[t._v("类的组合")]),t._v("都有一个类（下称 Y 类）能用到另一个类（下称 X 类）的 "),s("code",[t._v("public")]),t._v(" 成员和函数，而不能使用 "),s("code",[t._v("private")]),t._v(" 成员的特性，开发时，具体选择哪个使用呢？")],1),t._v(" "),s("p",[t._v("一般来说，C++ 程序员更喜欢类的组合，一是理解起来容易，二是 Y 类可以使用 X 类的多个对象（继承不能）。")]),t._v(" "),s("p",[t._v("但是，如果有使用 X 类的 "),s("code",[t._v("private")]),t._v(" 成员，或者需要2使用 "),s("a",{attrs:{href:"#%E8%99%9A%E5%87%BD%E6%95%B0"}},[t._v("虚函数")]),t._v("，就需要使用私有继承。")]),t._v(" "),s("p",[t._v("个人感觉，如果有继承的层次感（如哺乳动物 -> 狗）的结构，建议使用继承；否则使用类的组合（线段有两个点 "),s("code",[t._v("class Point")]),t._v("）。")]),t._v(" "),s("h3",{attrs:{id:"派生类的构造和析构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#派生类的构造和析构"}},[t._v("#")]),t._v(" 派生类的构造和析构")]),t._v(" "),s("p",[t._v("派生类的构造函数理论上只需要给新的成员提供初始化顺序，而父类的成员只需要用父类的构造函数即可（如果是私有成员，是必须使用构造函数）。具体语法如下：")]),t._v(" "),s("blockquote",[s("p",[t._v("简要介绍背景：一个 "),s("code",[t._v("ShoppingCard")]),t._v(" 类，存了用户的钱钱数；"),s("br"),t._v("\n有一个 "),s("code",[t._v("MemberCard")]),t._v(" 类继承了 "),s("code",[t._v("ShoppingCard")]),t._v("，并增加了一个 "),s("code",[t._v("cardid")]),t._v(" 成员。")])]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MemberCard")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ShoppingCard")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" cardid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" score"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MemberCard")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" _cardid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v(" _money"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ShoppingCard")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_money"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//, <更多的父类>(<参数>)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("strcpy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cardid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("_cardid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("在 "),s("code",[t._v("<更多的父类>")]),t._v(" 处，除了写更多的父类，还可以写：")]),t._v(" "),s("ol",[s("li",[t._v("对象成员（即成员是另一个类的对象），这样就可以也把对象成员初始化了；")]),t._v(" "),s("li",[t._v("甚至，可以写基本数据类型的变量（如 "),s("code",[t._v("score(0)")]),t._v("），因为 C++ 可以使用类似的方法对他们赋初值。")])]),t._v(" "),s("p",[t._v("调用构造函数的时候，成员初始化列表 "),s("code",[t._v("ShoppingCard(_money)")]),t._v(" 先被执行，再执行派生类的构造函数 "),s("code",[t._v("strcpy(cardid,_cardid);")]),t._v("。相反地，调用析构函数时，先调用派生类的析构函数，再按"),s("strong",[t._v("构造函数中提到的父类的逆序")]),t._v("调用父类的析构函数。也就是说，析构函数直接就是 "),s("code",[t._v("~MemberCard(){/*Some Codes*/}")]),t._v("，没有 "),s("code",[t._v(":ShoppingCard(_money)")]),t._v(" 部分。")]),t._v(" "),s("p",[t._v("如果省略基类构造函数，则默认调用基类的默认构造函数 "),s("code",[t._v("ShoppingCard()")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"派生类重载基类的成员函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#派生类重载基类的成员函数"}},[t._v("#")]),t._v(" 派生类重载基类的成员函数")]),t._v(" "),s("p",[t._v("一句话，其实直接重定义（写一个和父类函数的名字、参数完全相同的函数），即可覆盖父类继承来的函数。"),s("br"),t._v("\n而如果又想调用基类里已经被重定义的函数，那么调用时加 "),s("code",[t._v("基类名::函数名()")]),t._v(" 即可。如：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MemberCard")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ShoppingCard")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("consume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" money"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("A"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("consume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//调用继承类MemberCard::consume()")]),t._v("\nA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ShoppingCard")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("consume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//调用父类ShoppingCard::consume()")]),t._v("\n")])])]),s("h3",{attrs:{id:"使用不同基类的同名对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用不同基类的同名对象"}},[t._v("#")]),t._v(" 使用不同基类的同名对象")]),t._v(" "),s("p",[s("code",[t._v("基类名::成员")]),t._v(" 同样适用于不同类的对象的同名成员。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Inheri")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test2")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" B"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//编译错误：有歧义")]),t._v("\nB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Test1"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//正确")]),t._v("\n")])])]),s("h2",{attrs:{id:"多继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多继承"}},[t._v("#")]),t._v(" 多继承")]),t._v(" "),s("p",[t._v("多继承才是混乱的开始。（逃")]),t._v(" "),s("h3",{attrs:{id:"多继承类的定义、构造函数、析构函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多继承类的定义、构造函数、析构函数"}},[t._v("#")]),t._v(" 多继承类的定义、构造函数、析构函数")]),t._v(" "),s("p",[t._v("定义多继承类、构造及析构函数的语法上面已经提到过了。只是再强调一下构造和析构函数的执行顺序：")]),t._v(" "),s("ul",[s("li",[t._v("构造函数：顺序执行 "),s("code",[t._v(":")]),t._v(" 后面的所有构造函数、再执行 "),s("code",[t._v("{ }")]),t._v(" 里的部分（即"),s("strong",[t._v("从上往下执行")]),t._v("）")]),t._v(" "),s("li",[t._v("析构函数：先顺序执行 "),s("code",[t._v("{ }")]),t._v(" 里的部分，再"),s("strong",[t._v("逆序")]),t._v("执行 "),s("code",[t._v(":")]),t._v(" 后的所有构造函数。")])]),t._v(" "),s("h3",{attrs:{id:"多继承的二义性-虚基类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多继承的二义性-虚基类"}},[t._v("#")]),t._v(" 多继承的二义性 虚基类")]),t._v(" "),s("p",[t._v("上面提到，不同基类的同名对象，可以通过 "),s("code",[t._v("基类名::函数名()")]),t._v(" 准确调用。可是，如果是同一个类的同名对象呢？")]),t._v(" "),s("p",[t._v("这个问题的产生，还和 C/C++ 编译有关。C/C++ 编译类的时候，实际上是把类的内容全部复制了一份到对象里面（详见另一篇"),s("RouterLink",{attrs:{to:"/notes/cpp/cpp-grammar/c-course.html#多文件编写"}},[t._v("博客")]),t._v("）。")],1),t._v(" "),s("p",[t._v("因此，如果有下图的继承结构，编译以后 "),s("code",[t._v("AMCar")]),t._v(" 里就会出现两份 "),s("code",[t._v("Car")]),t._v(" 的成员。")]),t._v(" "),s("p",[s("img",{attrs:{src:"AMCar.svg",alt:"AMCar"}})]),t._v(" "),s("p",[t._v("虽然我们知道两个 "),s("code",[t._v("Car")]),t._v(" 等价的，但是编译器却认为这是不等价的。（摊手）")]),t._v(" "),s("p",[t._v("于是，就引入了一个新概念，叫 "),s("code",[t._v("虚基类")]),t._v("。")]),t._v(" "),s("p",[t._v("虚基类要实现的效果是这样的。")]),t._v(" "),s("p",[s("img",{attrs:{src:"AMCar_2.png",alt:"虚基类 AMCar"}})]),t._v(" "),s("p",[t._v("实现的时候，要修改 "),s("code",[t._v("ACar")]),t._v(" 和 "),s("code",[t._v("MCar")]),t._v(" 的代码，将公共父类 "),s("code",[t._v("Car")]),t._v(" 声明为 "),s("code",[t._v("virtual")]),t._v(" 虚基类。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MCar")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("virtual")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Car")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* */")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ACar")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("virtual")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Car")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* */")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AMCar")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ACar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MCar")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("code",[t._v("public")]),t._v(" 和 "),s("code",[t._v("virtual")]),t._v(" 的顺序无关紧要。")]),t._v(" "),s("p",[t._v("这样以后，就会只存在一个 "),s("code",[t._v("Car")]),t._v(" 了。但是继承路径是怎样的呢（"),s("code",[t._v("Car")]),t._v(" 是谁的真基类呢）？"),s("br"),t._v("\n这取决于 "),s("code",[t._v("AMCar")]),t._v(" "),s("strong",[t._v("声明")]),t._v(" "),s("code",[t._v("ACar")]),t._v(" 和 "),s("code",[t._v("MCar")]),t._v(" 的顺序。"),s("code",[t._v("Car")]),t._v(" 是"),s("strong",[t._v("第一个声明它的真基类")]),t._v("。对于上面的情况，"),s("code",[t._v("Car")]),t._v(" 是 "),s("code",[t._v("ACar")]),t._v(" 的真基类，是 "),s("code",[t._v("MCar")]),t._v(" 的假基类。")]),t._v(" "),s("p",[t._v("对于构造函数执行时的顺序，同层次虚基类先于非虚基类。"),s("br"),t._v("\n不同层次的，遵守“先生成基类，再生成派生类”的规定。")]),t._v(" "),s("h2",{attrs:{id:"多态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[t._v("#")]),t._v(" 多态")]),t._v(" "),s("blockquote",[s("p",[t._v("在许多情况下，我们希望同一个函数的行为随调用的上下文而有所不同，这种情况称为多态。"),s("br"),t._v("\n如果“调用的上下文”是在程序编译阶段确定下来，这叫静态多态；如果“调用的上下文”在程序运行阶段才能确定，这叫动态多态。")]),t._v(" "),s("p",[t._v("在编译的阶段，编译器的一个重要的工作就是解释函数调用语句，要把这句函数调用语句和某个可执行代码块绑定起来，这个过程叫做绑定（Binding）。")])]),t._v(" "),s("p",[t._v("说了一堆看不懂的话。")]),t._v(" "),s("p",[t._v("不过看样子，静态多态就是函数重载，这又分为根据参数不同的函数重载，和派生类中对基类的同名函数的重载。"),s("br"),t._v("\n另外提一句，由于运算符重载属于成员函数重载，于是也属于静态多态。")]),t._v(" "),s("p",[t._v("运算符重载更多内容可见另一篇"),s("RouterLink",{attrs:{to:"/notes/cpp/cpp-grammar/struct.html#运算符重载"}},[t._v("博客")]),t._v("。")],1),t._v(" "),s("h3",{attrs:{id:"赋值兼容规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#赋值兼容规则"}},[t._v("#")]),t._v(" 赋值兼容规则")]),t._v(" "),s("p",[t._v("通常情况下，C++ 不允许不同类型的变量的指针、引用赋值给其他类型的指针、引用。")]),t._v(" "),s("p",[t._v("但是，继承类是个特例。只要兼容一定规则，就可以在基类和派生类之间赋值。这种规则被称为"),s("strong",[t._v("赋值兼容规则")]),t._v("。")]),t._v(" "),s("blockquote",[s("ol",[s("li",[t._v("可以把派生类的对象赋给基类的对象")]),t._v(" "),s("li",[t._v("可以把基类的指针、引用指向派生类")])])]),t._v(" "),s("p",[t._v("在"),s("s",[t._v("猫猫狗狗")]),t._v("继承的意思上理解的话，可以把猫猫狗狗的信息当做普通动物的信息用，而不能反过来把普通动物的信息当做猫猫狗狗用（不然问起来这个动物一天吃多少鱼就很奇怪了啊）；"),s("br"),t._v("\n在代码实现层面上理解，是可以"),s("strong",[t._v("舍弃派生类额外的数据")]),t._v("实现转换；而如果反过来了，派生类的"),s("strong",[t._v("新增的变量就没有定义")]),t._v("了。")]),t._v(" "),s("p",[t._v("戴波老师用一句很精炼的话来总结：")]),t._v(" "),s("blockquote",[s("p",[t._v("所有的狗都是动物，但不是所有的动物都是狗——所有的派生类对象都是基类的对象。")])]),t._v(" "),s("p",[t._v("以上转化是由派生类向基类的强制转换，叫做向上强制转换 "),s("code",[t._v("Upcasting")]),t._v("。由于其合理性，可以进行"),s("strong",[t._v("隐式转换")]),t._v("。"),s("br"),t._v("\n反过来，如果先把基类转为派生类，这叫向下强制转换 "),s("code",[t._v("Downcasting")]),t._v("。虽然不大合理，但是可以"),s("strong",[t._v("显式转换")]),t._v("。但转换以后，应当格外小心，不要访问到一些未初始化的成员。")]),t._v(" "),s("h3",{attrs:{id:"动态多态-虚函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态多态-虚函数"}},[t._v("#")]),t._v(" 动态多态——虚函数")]),t._v(" "),s("p",[t._v("虚函数的产生，其实是因为上面提到的，指针居然可以指向不同于指针类型的类型。这就会产生一个问题，我就想用基类指针指向的派生对象的派生函数，那咋办嘛。")]),t._v(" "),s("p",[t._v("于是，虚函数，就是在执行的时候，才会根据其指针指向的对象是基类还是派生类，来进行对应的重载。这也正是动态重载的定义——在执行的时候，再进行重载。")]),t._v(" "),s("p",[t._v("举个栗子，现有 "),s("code",[t._v("ShoppingCard")]),t._v(" 与其派生类 "),s("code",[t._v("MemberCard")]),t._v("，想对一个 "),s("code",[t._v("ShoppingCard")]),t._v(" 实现虚函数，具体的代码如下：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1. 父类成员函数加 virtual")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ShoppingCard")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("virtual")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("consume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v(" money"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2. 派生类函数名、参数、返回值完全一致")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MemberCard")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ShoppingCard")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("consume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v(" money"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//3. 对派生类的对象使用基类的引用/指针")]),t._v("\nShoppingCard "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" card "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" MemberCard"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nMemberCard"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("consume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("注意虚函数有条件：他不能为以下函数之一：")]),t._v(" "),s("ul",[s("li",[t._v("静态成员函数")]),t._v(" "),s("li",[t._v("全局函数")]),t._v(" "),s("li",[t._v("友元函数")])]),t._v(" "),s("h4",{attrs:{id:"虚函数的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚函数的实现"}},[t._v("#")]),t._v(" 虚函数的实现")]),t._v(" "),s("p",[t._v("该部分不难，不过仅作了解。")]),t._v(" "),s("p",[t._v("简单的来说，就是两句话：")]),t._v(" "),s("ol",[s("li",[t._v("编译时，每个定义了虚函数的类会有其对应的 "),s("strong",[t._v("虚函数表")]),t._v(" VTABLE，存有该类中。（派生类的存在派生类里）")]),t._v(" "),s("li",[t._v("创建对象时，每个对象会获得指向其"),s("strong",[t._v("对应的 VTABLE")]),t._v(" 的指针。")])]),t._v(" "),s("h4",{attrs:{id:"虚构造函数和析构函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚构造函数和析构函数"}},[t._v("#")]),t._v(" 虚构造函数和析构函数")]),t._v(" "),s("p",[t._v("虚构造函数是不存在的。该问题等价于 "),s("code",[t._v("先有鸡还是先有蛋")]),t._v("。（想想，为什么？）")]),t._v(" "),s("p",[t._v("而虚析构函数就没有这个问题，其本质和其他虚函数是一样的。")]),t._v(" "),s("h3",{attrs:{id:"纯虚函数和抽象类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#纯虚函数和抽象类"}},[t._v("#")]),t._v(" 纯虚函数和抽象类")]),t._v(" "),s("p",[t._v("此节开篇一句：")]),t._v(" "),s("blockquote",[s("p",[t._v("基类往往表示一种抽象的概念，提供一些公共的接口，而这些接口往往不需要实现。")])]),t._v(" "),s("p",[t._v("醍醐灌顶。")]),t._v(" "),s("p",[t._v("虚函数在定义后加 "),s("code",[t._v("=0")]),t._v(" 即表示纯虚函数，不需要有实现。如上例的代码：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ShoppingCard")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("virtual")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("consume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v(" money"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("即可以把基类函数改为纯虚函数。")]),t._v(" "),s("p",[t._v("抽象类的概念就是开篇的那句说的“只提供公共接口，不需要实现”的类。"),s("br"),t._v("\n这个概念不涉及到 C++ 语法，具体做的时候，把成员函数定义为纯虚函数即可。")]),t._v(" "),s("p",[t._v("但是我在实际写代码（环境为 Visual Studio 2019）的过程中，注意到了几个点：")]),t._v(" "),s("ul",[s("li",[t._v("抽象类"),s("strong",[t._v("不能")]),t._v("实例化；")]),t._v(" "),s("li",[t._v("只要有一个虚函数没有实现，他就是一个抽象类；")]),t._v(" "),s("li",[t._v("如果派生类没有实现基类的虚函数，那么这个派生类也是抽象类。")])]),t._v(" "),s("p",[t._v("所以，如果基类有虚函数，派生类要想有实例化（即能定义该类的对象），必须实现这个函数。")]),t._v(" "),s("p",[t._v("这是为了防止一个父类的指针指向了子类，调用父类虚函数时，发现该子类没有定义函数体的情况。")]),t._v(" "),s("p",[t._v("而如果子类确实不需要这个函数，解决办法可以是写一个对应名字和参数的空函数 "),s("code",[t._v("void foo(){}")]),t._v(" 来实现。")]),t._v(" "),s("h3",{attrs:{id:"多态的意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多态的意义"}},[t._v("#")]),t._v(" 多态的意义")]),t._v(" "),s("p",[t._v("说了那么多，那动态多态有什么用嘛，还搞得好复杂，甚至还可能出现漏洞。")]),t._v(" "),s("p",[t._v("于是我去知乎搜了一下：")]),t._v(" "),s("blockquote",[s("p",[t._v("首先需要明确多态性的用途，是为了"),s("strong",[t._v("接口的最大程度复用")]),t._v("，以及其定义：")]),t._v(" "),s("p",[t._v("多态性的定义，可以简单地概括为“"),s("strong",[t._v("一个接口，多种方法")]),t._v("”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。多态分为静态多态和动态多态。"),s("br"),t._v("\n静态多态是通过重载和模板技术实现，在编译的时候确定。"),s("br"),t._v("\n动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。\n——https://zhuanlan.zhihu.com/p/47057750")])]),t._v(" "),s("p",[t._v("静态多态能实现接口的很大程度的复用，而动态多态就可以最大化复用的程度吧。")]),t._v(" "),s("blockquote",[s("p",[t._v("2020.1.6 更新：在写了一个大实验以后，我发现了动态多态在实战中的用途。")])]),t._v(" "),s("p",[t._v("简单的来说，现在有 "),s("code",[t._v("class A")]),t._v(" 为基类，其有派生类 "),s("code",[t._v("A1")]),t._v("、"),s("code",[t._v("A2")]),t._v("、"),s("code",[t._v("A3")]),t._v(" 等。我们定义 "),s("code",[t._v("std::vector<A*>")]),t._v("，里面的指针可能指向 "),s("code",[t._v("A1")]),t._v("、"),s("code",[t._v("A2")]),t._v("、"),s("code",[t._v("A3")]),t._v("。")]),t._v(" "),s("p",[t._v("使用动态多态的话，可以实现：将"),s("strong",[t._v("多个不同的派生类 "),s("code",[t._v("Ai")]),t._v(" 装在一个集合中")]),t._v("，但是调用的时候却是"),s("strong",[t._v("调用 "),s("code",[t._v("Ai")]),t._v(" 各自派生类的成员函数")]),t._v("。")]),t._v(" "),s("p",[t._v("静态多态则做不到，在 "),s("code",[t._v("Ai")]),t._v(" 转为 "),s("code",[t._v("A")]),t._v(" 的一瞬间，他就失去了他的派生成员。如下程序：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<vector>")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("using")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("virtual")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"A"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"A1"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//尝试静态多态")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tA a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tA1 a1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tvector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("A"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" vA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tvA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tvA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("auto")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" vA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t\ti"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//动态多态")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tA "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" A"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tA1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" A1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tvector"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("A"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" vA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tvA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tvA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_back")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("auto")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" vA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t\ti"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\tcout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("该程序的输出为：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("A\nA\n\nA\nA1\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);