(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{432:function(_,v,e){"use strict";e.r(v);var o=e(3),t=Object(o.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status",target:"_blank",rel:"noopener noreferrer"}},[_._v("MDN Web Docs"),e("OutboundLink")],1),_._v(" "),e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81",target:"_blank",rel:"noopener noreferrer"}},[_._v("维基百科"),e("OutboundLink")],1)]),_._v(" "),e("h2",{attrs:{id:"_1xx-请求已被接受-需要继续处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1xx-请求已被接受-需要继续处理"}},[_._v("#")]),_._v(" 1xx 请求已被接受，需要继续处理")]),_._v(" "),e("p",[_._v("1 打头的其实不是很常用。")]),_._v(" "),e("p",[_._v("不过有一个 "),e("code",[_._v("102 Processing (WebDAV)")]),_._v(" 挺有意思，用于表明 WebDAV 服务器收到了请求，但请求的操作比较费时，服务器正在处理（如遍历当前文件夹）。为了防止客户端 TCP 超时、假设请求丢失，于是服务器可以发送一个没有信息的 "),e("code",[_._v("102")]),_._v(" 应答。")]),_._v(" "),e("h2",{attrs:{id:"_2xx-请求已被服务器接收、理解、并接受"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2xx-请求已被服务器接收、理解、并接受"}},[_._v("#")]),_._v(" 2xx 请求已被服务器接收、理解、并接受")]),_._v(" "),e("p",[_._v("最常用的就是 "),e("code",[_._v("200 OK")]),_._v(" 了，这是绝大多数 "),e("code",[_._v("GET")]),_._v(" 方法、以及部分 "),e("code",[_._v("POST")]),_._v(" "),e("code",[_._v("PUT")]),_._v(" "),e("code",[_._v("PATCH")]),_._v(" 成功后的返回值。它表示（一般时获取或修改）请求成功了，应答中会包含 "),e("code",[_._v("GET")]),_._v(" 所请求的 Object，或者 "),e("code",[_._v("POST")]),_._v(" "),e("code",[_._v("PUT")]),_._v(" "),e("code",[_._v("PATCH")]),_._v(" 成功后新的 Object。")]),_._v(" "),e("p",[e("code",[_._v("201 Created")]),_._v(" 也非常常用，这主要用于 "),e("code",[_._v("POST")]),_._v(" 创建一个 Object 这类请求的应答。它表示创建的请求成功了，应答中会包含 Object 的内容，或者应答的 "),e("code",[_._v("Location")]),_._v(" 首部会包含这个 Object 的链接。")]),_._v(" "),e("p",[e("code",[_._v("202 Accepted")]),_._v(" 表示服务器端已经收到了请求，但是还没有处理。一个非常典型的场景就是用户忘记了密码，申请重置密码。服务器应当发送一份邮件到用户的邮箱，但发送邮箱是一个很慢的过程，因此服务器可以在收到用户的请求后，立即响应 "),e("code",[_._v("202")]),_._v("，同时尝试发送邮件。"),e("code",[_._v("202")]),_._v(" 同时意味着，发送邮件到底有没有成功，用户是无法得知的，服务器并不能通过 HTTP 协议告知用户成功与否。再换句话说，就是服务器不保证请求的处理结果。这和 "),e("code",[_._v("102")]),_._v(" 有点像，区别在于服务器发送 "),e("code",[_._v("102")]),_._v(" 以后，可以稍后再发送一个应答说明情况，而 "),e("code",[_._v("202")]),_._v(" 就不能了。")]),_._v(" "),e("p",[_._v("除此之外还有 "),e("code",[_._v("204 No Content")]),_._v(" 表示没有返回信息，这是绝大多数 "),e("code",[_._v("DELETE")]),_._v(" 方法成功后（以及 "),e("code",[_._v("PUT")]),_._v(" 请求更新资源，但是不需要改变当前的用户页面）的返回值。如果想要改变 "),e("code",[_._v("PUT")]),_._v(" 请求的用户的当前页面，应当选用 "),e("code",[_._v("201")]),_._v(" 或 "),e("code",[_._v("202")]),_._v("。")]),_._v(" "),e("p",[_._v("以及 "),e("code",[_._v("206 Partial Content")]),_._v(" 表示报文包含的是请求的内容的一部分，这一般用于上传/下载的文件相当大的时候（下载的时候抓一下包就能看到很多的 "),e("code",[_._v("206")]),_._v("）。")]),_._v(" "),e("h2",{attrs:{id:"_3xx-客户端需要进一步操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3xx-客户端需要进一步操作"}},[_._v("#")]),_._v(" 3xx 客户端需要进一步操作")]),_._v(" "),e("p",[_._v("通常来说，“进一步操作”就是指的重定向，因此最常用的也就是 "),e("code",[_._v("301")]),_._v(" "),e("code",[_._v("302")]),_._v(" "),e("code",[_._v("307")]),_._v(" "),e("code",[_._v("308")]),_._v(" 这四个。")]),_._v(" "),e("p",[_._v("即 "),e("code",[_._v("301 Moved Permanently")]),_._v("、"),e("code",[_._v("302 Found")]),_._v(" (或 "),e("code",[_._v("302 Moved Temporarily")]),_._v(")、"),e("code",[_._v("307 Temporary Redirect")]),_._v("、"),e("code",[_._v("308 Permanent Redirect")]),_._v("。")]),_._v(" "),e("p",[e("a",{attrs:{href:"https://stackoverflow.com/a/42138726/12208030",target:"_blank",rel:"noopener noreferrer"}},[_._v("Stack Overflow"),e("OutboundLink")],1),_._v(" 上有一个表格非常形象：")]),_._v(" "),e("table",[e("thead",[e("tr",[e("th"),_._v(" "),e("th",[_._v("永久重定向 "),e("code",[_._v("Permanently")])]),_._v(" "),e("th",[_._v("暂时重定向 "),e("code",[_._v("Temporarily")])])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("允许将 "),e("code",[_._v("POST")]),_._v(" 方法改为 "),e("code",[_._v("GET")])]),_._v(" "),e("td",[e("code",[_._v("301 Moved Permanently")])]),_._v(" "),e("td",[e("code",[_._v("302 Moved Temporarily")])])]),_._v(" "),e("tr",[e("td",[_._v("不允许将 "),e("code",[_._v("POST")]),_._v(" 方法改为 "),e("code",[_._v("GET")])]),_._v(" "),e("td",[e("code",[_._v("308 Permanent Redirect")])]),_._v(" "),e("td",[e("code",[_._v("307 Temporary Redirect")])])])])]),_._v(" "),e("p",[_._v("何谓 "),e("code",[_._v("Permanently")]),_._v(" 和 "),e("code",[_._v("Temporarily")]),_._v("?")]),_._v(" "),e("ul",[e("li",[_._v("字面上理解："),e("code",[_._v("Permanently")]),_._v(" 指的是用户访问的网站永久迁移到新网址了，而 "),e("code",[_._v("Temporarily")]),_._v(" 指的是用户访问的网站暂时（可能是 24-48 小时内）迁移到新网址；")]),_._v(" "),e("li",[_._v("对于浏览器：\n"),e("ul",[e("li",[_._v("对于 "),e("code",[_._v("Permanently")]),_._v(" 的结果，浏览器会缓存 "),e("code",[_._v("original_url")]),_._v(" 和 "),e("code",[_._v("redirect_url1")]),_._v("。下次用户访问 "),e("code",[_._v("original_url")]),_._v(" 时，浏览器会直接向 "),e("code",[_._v("redirect_url1")]),_._v(" 发送请求（而不会请求 "),e("code",[_._v("original_url")]),_._v("）")]),_._v(" "),e("li",[_._v("对于 "),e("code",[_._v("Temporarily")]),_._v("，浏览器不会缓存。下次用户访问 "),e("code",[_._v("original_url")]),_._v(" 时，浏览器仍会向 "),e("code",[_._v("original_url")]),_._v(" 发送请求")])])]),_._v(" "),e("li",[_._v("对于搜索引擎：\n"),e("ul",[e("li",[_._v("对于 "),e("code",[_._v("Permanently")]),_._v(" 的结果，搜索引擎会记录跳转后的网址和内容；")]),_._v(" "),e("li",[_._v("对于 "),e("code",[_._v("Temporarily")]),_._v(" 则有些尴尬，搜索引擎不知道应该记录跳转后还是跳转前的网址（比如 A 网址很短，但是它做了一个 "),e("code",[_._v("302")]),_._v(" 重定向到 B 网址，而 B 网址是一个很长的乱七八糟的 URL，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而 B 网址既难看，又不用户友好；Google 家就选择记录 A 网址）这样就导致了 "),e("strong",[_._v("网址 URL 劫持")]),_._v("：B 网站的很好的内容在 Google 上却显示的是网址 A。")])])])]),_._v(" "),e("p",[_._v("所以，尽量选择 "),e("code",[_._v("Permanently")]),_._v(" 吧。")]),_._v(" "),e("p",[_._v("除此之外，还有 "),e("code",[_._v("304 Not Modified")]),_._v("，一般是缓存服务器向目标服务器请求，询问请求的资源是否和缓存的版本一致（请求头中加上 "),e("code",[_._v("If-Modified-Since")]),_._v("），服务器返回 "),e("code",[_._v("304")]),_._v(" 表示确实没有修改过，这种情况下，由于缓存服务器仍然具有以前下载的副本，因此不需要重新传输资源。")]),_._v(" "),e("h2",{attrs:{id:"_4xx-客户端错误"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4xx-客户端错误"}},[_._v("#")]),_._v(" 4xx 客户端错误")]),_._v(" "),e("p",[_._v("这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("400 Bad Request")]),_._v(" 是明显的客户端错误（例如，请求格式错误，size 太大，无效的请求消息或欺骗性路由请求）。")]),_._v(" "),e("li",[e("code",[_._v("401 Unauthorized")]),_._v(" 表示需要客户端验证。与 "),e("code",[_._v("403")]),_._v(" 不同的是，对于 "),e("code",[_._v("401")]),_._v("，客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。在测试的时候，我们可以使用 "),e("code",[_._v("http://username:password@domain.com/")]),_._v(" 来提交验证信息。")]),_._v(" "),e("li",[e("code",[_._v("403 Forbidden")]),_._v(" 表示服务器已经理解请求，但是拒绝执行它。与 "),e("code",[_._v("401")]),_._v(" 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。当然服务器也可以返回一个 "),e("code",[_._v("404")]),_._v(" 响应，假如它不希望让客户端获得任何信息。")]),_._v(" "),e("li",[e("code",[_._v("404 Not Found")]),_._v(" 就是请求失败。需要注意的是，当服务器不想揭示为什么请求被拒绝、或者没有其他适合的响应可用的情况下，也可能返回 "),e("code",[_._v("404")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("405 Method Not Allowed")]),_._v(" 对于一个只支持 "),e("code",[_._v("POST")]),_._v(" 方法的 URI，如果使用 "),e("code",[_._v("GET")]),_._v(" "),e("code",[_._v("PUT")]),_._v(" 等方法访问它，就可以返回一个 "),e("code",[_._v("405")]),_._v("。")])]),_._v(" "),e("h2",{attrs:{id:"_5xx-服务器错误"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5xx-服务器错误"}},[_._v("#")]),_._v(" 5xx 服务器错误")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("500 Internal Server Error")]),_._v("：我也不知道出了什么错，是服务器错误的通用错误消息")]),_._v(" "),e("li",[e("code",[_._v("502 Bad Gateway")]),_._v("：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。如 Nginx 将 "),e("code",[_._v("example.com")]),_._v(" 反向代理到了 "),e("code",[_._v("localhost:8080")]),_._v("，而 8080 端口并没有软件运行，此时访问 "),e("code",[_._v("example.com")]),_._v(" 就会收到 "),e("code",[_._v("502")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("504 Gateway Timeout")]),_._v("：作为网关或者代理工作的服务器，未能"),e("strong",[_._v("及时")]),_._v("从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器（如 "),e("code",[_._v("V2Ray")]),_._v("）在DNS查询超时时会返回 "),e("code",[_._v("400")]),_._v(" 或者 "),e("code",[_._v("500")]),_._v(" 错误。")])]),_._v(" "),e("h2",{attrs:{id:"如何选择最合适的状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何选择最合适的状态码"}},[_._v("#")]),_._v(" 如何选择最合适的状态码")]),_._v(" "),e("p",[_._v("这是一个非常宏大的问题，只能说具体情形具体分析。")]),_._v(" "),e("p",[_._v("一个方法是参考现有的代码或后端框架等等，如 Django REST Framework 提供的通用模板中，对象创建成功用 "),e("code",[_._v("201 Created")]),_._v("；登录成功返回 "),e("code",[_._v("200 OK")]),_._v(" 以及登录信息；删除成功返回 "),e("code",[_._v("204 No Content")]),_._v("。")]),_._v(" "),e("p",[_._v("还有一个方法就是在 Stack Overflow 上搜索你的行为 + "),e("code",[_._v("REST API")]),_._v(" 或 "),e("code",[_._v("http status code")]),_._v("，会出现大量的结果供参考，如 "),e("code",[_._v("logout http status code")]),_._v(" 会搜到关于注销应当返回什么，返回的状态码是否有意义这类问题。")]),_._v(" "),e("h2",{attrs:{id:"rest-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rest-api"}},[_._v("#")]),_._v(" REST API")]),_._v(" "),e("p",[_._v("了解了 HTTP Status Code 后，另一个问题就是 "),e("a",{attrs:{href:"/back-end/restful-api-standard"}},[_._v("REST API")]),_._v(" 了。")])])}),[],!1,null,null,null);v.default=t.exports}}]);