(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{524:function(v,_,t){"use strict";t.r(_);var r=t(3),a=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"系列目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#系列目录"}},[v._v("#")]),v._v(" 系列目录")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"./1-transactions"}},[v._v("数据库并发控制 (1) -- 事务")])]),v._v(" "),t("li",[t("a",{attrs:{href:"./2-innodb-mvcc"}},[v._v("数据库并发控制 (2) -- InnoDB 并发控制")])]),v._v(" "),t("li",[t("a",{attrs:{href:"./3-innodb-locks"}},[v._v("数据库并发控制 (3) -- InnoDB 锁")])]),v._v(" "),t("li",[t("a",{attrs:{href:"./4-distributed-locks-design"}},[v._v("数据库并发控制 (4) -- 分布式锁的设计")])])]),v._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://tech.meituan.com/2014/08/20/innodb-lock.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("Innodb中的事务隔离级别和锁的关系 - 美团技术团队"),t("OutboundLink")],1)])]),v._v(" "),t("h2",{attrs:{id:"innodb-锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#innodb-锁"}},[v._v("#")]),v._v(" InnoDB 锁")]),v._v(" "),t("p",[v._v("数据库遵循的是"),t("strong",[v._v("两段锁协议")]),v._v("，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）")]),v._v(" "),t("ul",[t("li",[v._v("加锁阶段：在该阶段可以进行加锁操作。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。")]),v._v(" "),t("li",[v._v("解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。")])]),v._v(" "),t("p",[v._v("这种方式虽然"),t("strong",[v._v("无法避免死锁")]),v._v("，但是两段锁协议"),t("strong",[v._v("可以保证事务的并发调度是串行化")]),v._v("（串行化很重要，尤其是在数据恢复和备份的时候）的。")]),v._v(" "),t("h2",{attrs:{id:"行锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[v._v("#")]),v._v(" 行锁")]),v._v(" "),t("p",[v._v("InnoDB 实现了两种类型的行级锁：")]),v._v(" "),t("ul",[t("li",[v._v("共享锁 (S)：在对任何数据进行读操作之前要申请并获得 S 锁。其它事务可以继续加共享锁，但不能加排它锁；")]),v._v(" "),t("li",[v._v("独占锁 (X)：在进行写操作之前要申请并获得 X 锁。其它事务不能再获得任何锁；")])]),v._v(" "),t("h2",{attrs:{id:"表锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[v._v("#")]),v._v(" 表锁")]),v._v(" "),t("p",[v._v("InnoDB 支持多粒度锁，因此 S 和 X 锁还可以锁表（如使用 "),t("code",[v._v("ALTER TABLE")]),v._v(" 等语句会给表上 X 锁）。")]),v._v(" "),t("p",[v._v("另外还设计了两个意向锁，注意"),t("strong",[v._v("意向锁都是表级的")]),v._v("：")]),v._v(" "),t("ul",[t("li",[v._v("意向共享锁 (IS)：表明事务即将给表中的行设置 S 锁。事务给行加 S 锁前必须获得该表的 IS 锁。")]),v._v(" "),t("li",[v._v("意向排它锁 (IX)：表明事务即将给表中的行设置 X 锁。事务给行加 X 锁前必须获得该表的 IX 锁。")])]),v._v(" "),t("p",[v._v("综上，MySQL 支持两种行锁和四种表锁。")]),v._v(" "),t("p",[v._v("四种表锁的兼容表如下：")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("锁类型")]),v._v(" "),t("th",[v._v("X")]),v._v(" "),t("th",[v._v("IX")]),v._v(" "),t("th",[v._v("S")]),v._v(" "),t("th",[v._v("IS")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("X")]),v._v(" "),t("td",[v._v("冲突")]),v._v(" "),t("td",[v._v("冲突")]),v._v(" "),t("td",[v._v("冲突")]),v._v(" "),t("td",[v._v("冲突")])]),v._v(" "),t("tr",[t("td",[v._v("IX")]),v._v(" "),t("td",[v._v("冲突")]),v._v(" "),t("td",[v._v("兼容")]),v._v(" "),t("td",[v._v("冲突")]),v._v(" "),t("td",[v._v("兼容")])]),v._v(" "),t("tr",[t("td",[v._v("S")]),v._v(" "),t("td",[v._v("冲突")]),v._v(" "),t("td",[v._v("冲突")]),v._v(" "),t("td",[v._v("兼容")]),v._v(" "),t("td",[v._v("兼容")])]),v._v(" "),t("tr",[t("td",[v._v("IS")]),v._v(" "),t("td",[v._v("冲突")]),v._v(" "),t("td",[v._v("兼容")]),v._v(" "),t("td",[v._v("兼容")]),v._v(" "),t("td",[v._v("兼容")])])])]),v._v(" "),t("p",[v._v("总结一下就是：")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("意向锁")]),v._v("之间相互不冲突")]),v._v(" "),t("li",[t("code",[v._v("互斥锁")]),v._v("和所有锁都冲突")]),v._v(" "),t("li",[t("code",[v._v("共享锁")]),v._v("和"),t("code",[v._v("互斥意向锁")]),v._v("冲突")])]),v._v(" "),t("h2",{attrs:{id:"行锁的算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行锁的算法"}},[v._v("#")]),v._v(" 行锁的算法")]),v._v(" "),t("ul",[t("li",[v._v("Record Locks：锁（单条）记录")]),v._v(" "),t("li",[v._v("Rocord Gaps：锁范围")]),v._v(" "),t("li",[v._v("Next-Key Locks：锁范围+锁记录")])])])}),[],!1,null,null,null);_.default=a.exports}}]);