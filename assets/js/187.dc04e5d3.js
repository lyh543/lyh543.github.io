(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{542:function(t,s,a){"use strict";a.r(s);var r=a(3),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),s("p",[t._v("前面聊到的是数据库自带的那些并发控制机制。最后我们来聊聊在数据库自带的事务、锁、多版本并发控制等的基础上，自己写的锁。")]),t._v(" "),s("ul",[s("li",[t._v("乐观锁，又称乐观并发控制（Optimistic CC, OCC）")]),t._v(" "),s("li",[t._v("悲观锁，又称悲观并发控制（Pessimistic CC, PCC）")]),t._v(" "),s("li",[t._v("多版本并发控制（Multi Version CC, MVCC）")])]),t._v(" "),s("p",[t._v("乐观锁和悲观锁不是具体的并发控制方法，而是两种并发控制的思想，由这两种思想会产生基于这两种思想的很多种方法。")]),t._v(" "),s("h2",{attrs:{id:"系列目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#系列目录"}},[t._v("#")]),t._v(" 系列目录")]),t._v(" "),s("ul",[s("li",[s("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/1-transactions.html"}},[t._v("数据库并发控制 (1) -- 事务")])],1),t._v(" "),s("li",[s("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/2-innodb-mvcc.html"}},[t._v("数据库并发控制 (2) -- InnoDB 并发控制")])],1),t._v(" "),s("li",[s("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/3-innodb-locks.html"}},[t._v("数据库并发控制 (3) -- InnoDB 锁")])],1),t._v(" "),s("li",[s("RouterLink",{attrs:{to:"/posts/2021-07-21-database-concurrency-control/4-distributed-locks-design.html"}},[t._v("数据库并发控制 (4) -- 分布式锁的设计")])],1)]),t._v(" "),s("h2",{attrs:{id:"悲观并发控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#悲观并发控制"}},[t._v("#")]),t._v(" 悲观并发控制")]),t._v(" "),s("p",[t._v("悲观并发控制（又称悲观锁）是悲观地假设，事务间的读写冲突/写写冲突很多。因此，在并发控制设计的方法上，就会倾向于在冲突很多的场景下提升性能。")]),t._v(" "),s("p",[t._v("悲观并发控制的一种实现就是利用数据库锁，在数据库层对数据进行上锁，别的进程就不能读写上了锁的数据，非常简洁地保证了一致性。其缺点是并发度会降低，在写多读少的情形下为了保证一致性，降低并发度是必要的，但在读多写少的情形下性能损失就会很大了。且可能发生死锁。")]),t._v(" "),s("p",[t._v("一个简单的实现如下：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 加锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" methodLock "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" method_name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" xxx "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SHARE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("MODE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" methodLock "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" method_name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" xxx "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FOR")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 提交事务，自动解锁")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMIT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"乐观并发控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#乐观并发控制"}},[t._v("#")]),t._v(" 乐观并发控制")]),t._v(" "),s("p",[t._v("乐观并发控制（又称乐观锁）是"),s("strong",[t._v("乐观地假设，事务间的竞争没有那么多")]),t._v("。乐观并发控制多用于"),s("strong",[t._v("读多写少")]),t._v("的场景，由于没有上锁解锁（此处指数据库锁）的过程，读的性能会很高；但在读少写多的场景，由于需要反复回滚重做，所以效率会变低。")]),t._v(" "),s("p",[t._v("乐观并发控制的一种实现是基于版本号。为每一个表加上一个 "),s("code",[t._v("version")]),t._v(" 字段，在读出一条记录时会一并读出 "),s("code",[t._v("version")]),t._v("。修改完数据后、提交事务时，需要检查一下 "),s("code",[t._v("version")]),t._v(" 值是否变化：如果 "),s("code",[t._v("version")]),t._v(" 值没变，说明事务开始后没有别的事务修改了该数据并进行提交，本次提交成功；如果有就放弃本次修改并回滚，准备重做。")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 定义数据表时需要增加一行 version")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" mothodLock "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" method_name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" xxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 更新时比对 version 是否正确")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 如果更新了 0 行，表示更新错误，需要回滚重做")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" methodLock\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" val "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xxx'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" method_name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" xxx "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xxx'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"乐观锁、悲观锁和-mysql-mvcc-的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁、悲观锁和-mysql-mvcc-的关系"}},[t._v("#")]),t._v(" 乐观锁、悲观锁和 MySQL MVCC 的关系")]),t._v(" "),s("p",[t._v("MySQL MVCC 可以说是 MySQL 内核实现层面上的概念。MySQL 利用 MVCC 和锁实现了数据库层面上的 Read Committed、Repeatable Read 和 Serializable 事务隔离级别。")]),t._v(" "),s("p",[t._v("我们在使用乐观锁和悲观锁，一般指的是在业务代码里使用乐观锁和悲观锁，是在业务层面上的概念。如果使用悲观锁的话，就需要在项目代码中启动 MySQL 事务。使用乐观锁的话，就不需要借助 MySQL 事务，直接进行读写操作就行。当然我们也可以实现一个 MVCC，但是显然没有这个必要哈哈哈哈。")]),t._v(" "),s("h2",{attrs:{id:"并发控制方法对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发控制方法对比"}},[t._v("#")]),t._v(" 并发控制方法对比")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("并发控制方法")]),t._v(" "),s("th",[t._v("乐观并发控制（以版本号实现为例）")]),t._v(" "),s("th",[t._v("悲观并发控制（以锁为例）")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("读多写少的情形下")]),t._v(" "),s("td",[t._v("避免读时的加锁过程")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("避免加锁、解锁的过程")]),t._v(" "),s("td",[t._v("避免更新失败回滚的过程")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("其他")]),t._v(" "),s("td",[t._v("可能会反复回滚")]),t._v(" "),s("td",[t._v("可能会死锁")])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);