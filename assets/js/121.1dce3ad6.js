(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{653:function(t,s,a){"use strict";a.r(s);var r=a(3),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("前面聊到的是数据库自带的那些并发控制机制。最后我们来聊聊在数据库自带的事务、锁、多版本并发控制等的基础上，自己写的锁。")]),t._v(" "),a("ul",[a("li",[t._v("乐观锁，又称乐观并发控制（Optimistic CC, OCC）")]),t._v(" "),a("li",[t._v("悲观锁，又称悲观并发控制（Pessimistic CC, PCC）")])]),t._v(" "),a("p",[t._v("乐观锁和悲观锁不是具体的并发控制方法，而是两种并发控制的思想，由这两种思想会产生基于这两种思想的很多种方法。")]),t._v(" "),a("h2",{attrs:{id:"系列目录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系列目录"}},[t._v("#")]),t._v(" 系列目录")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"./1-transactions"}},[t._v("数据库并发控制 (1) -- 事务")])]),t._v(" "),a("li",[a("a",{attrs:{href:"./2-innodb-mvcc"}},[t._v("数据库并发控制 (2) -- InnoDB 并发控制")])]),t._v(" "),a("li",[a("a",{attrs:{href:"./3-innodb-locks"}},[t._v("数据库并发控制 (3) -- InnoDB 锁")])]),t._v(" "),a("li",[a("a",{attrs:{href:"./4-distributed-locks-design"}},[t._v("数据库并发控制 (4) -- 分布式锁的设计")])])]),t._v(" "),a("h2",{attrs:{id:"悲观并发控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#悲观并发控制"}},[t._v("#")]),t._v(" 悲观并发控制")]),t._v(" "),a("p",[t._v("悲观并发控制（又称悲观锁）是悲观地假设，事务间的读写冲突/写写冲突很多。因此，在并发控制设计的方法上，就会倾向于在冲突很多的场景下提升性能。")]),t._v(" "),a("p",[t._v("悲观并发控制的一种实现就是利用数据库锁，在数据库层对数据进行上锁，别的进程就不能读写上了锁的数据，非常简洁地保证了一致性。其缺点是并发度会降低，在写多读少的情形下为了保证一致性，降低并发度是必要的，但在读多写少的情形下性能损失就会很大了。且可能发生死锁。")]),t._v(" "),a("p",[t._v("一个简单的实现如下：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 加锁")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" methodLock "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" method_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" xxx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SHARE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("MODE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" methodLock "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" method_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" xxx "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FOR")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 提交事务，自动解锁")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMIT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h2",{attrs:{id:"乐观并发控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#乐观并发控制"}},[t._v("#")]),t._v(" 乐观并发控制")]),t._v(" "),a("p",[t._v("乐观并发控制（又称乐观锁）是"),a("strong",[t._v("乐观地假设，事务间的竞争没有那么多")]),t._v("。乐观并发控制多用于"),a("strong",[t._v("读多写少")]),t._v("的场景，由于没有上锁解锁（此处指数据库锁）的过程，读的性能会很高；但在读少写多的场景，由于需要反复回滚重做，所以效率会变低。")]),t._v(" "),a("p",[t._v("乐观并发控制的一种实现是基于版本号。为每一个表加上一个 "),a("code",[t._v("version")]),t._v(" 字段，在读出一条记录时会一并读出 "),a("code",[t._v("version")]),t._v("。修改完数据后、提交事务时，需要检查一下 "),a("code",[t._v("version")]),t._v(" 值是否变化：如果 "),a("code",[t._v("version")]),t._v(" 值没变，说明事务开始后没有别的事务修改了该数据并进行提交，本次提交成功；如果有就放弃本次修改并回滚，准备重做。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 定义数据表时需要增加一行 version")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" mothodLock "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" method_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" xxx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 更新时比对 version 是否正确")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 如果更新了 0 行，表示更新错误，需要回滚重做")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" methodLock\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" val "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xxx'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" version "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" version "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" method_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" xxx "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" version "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xxx'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h2",{attrs:{id:"基于唯一索引的锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于唯一索引的锁"}},[t._v("#")]),t._v(" 基于唯一索引的锁")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("并发控制方法")]),t._v(" "),a("th",[t._v("乐观并发控制（以版本号实现为例）")]),t._v(" "),a("th",[t._v("悲观并发控制（以锁为例）")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("读多写少的情形下")]),t._v(" "),a("td",[t._v("避免读时的加锁过程")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("避免加锁、解锁的过程")]),t._v(" "),a("td",[t._v("避免更新失败回滚的过程")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("其他")]),t._v(" "),a("td",[t._v("可能会反复回滚")]),t._v(" "),a("td",[t._v("可能会死锁")])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);