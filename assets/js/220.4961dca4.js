(window.webpackJsonp=window.webpackJsonp||[]).push([[220],{608:function(e,t,r){"use strict";r.r(t);var o=r(3),a=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("本篇是《深入剖析 Kubernetes》 的读书笔记，作者为张磊老师。")]),e._v(" "),t("p",[e._v("第五章《Kubernetes 编排原理》讲的内容都还比较实用，基本上都是在使用 Kubernetes 中就会接触到的概念和功能。")]),e._v(" "),t("h2",{attrs:{id:"kubectl-cheatsheet"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubectl-cheatsheet"}},[e._v("#")]),e._v(" Kubectl Cheatsheet")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("创建/更新一个 yaml 文件："),t("code",[e._v("kubectl apply -f xxx.yaml")])])]),e._v(" "),t("li",[t("p",[e._v("查询资源列表："),t("code",[e._v("kubectl get pods")]),e._v("，然后可以接 "),t("code",[e._v("grep")])])]),e._v(" "),t("li",[t("p",[e._v("查询资源详情："),t("code",[e._v("kubectl describe pod xxx")])])]),e._v(" "),t("li",[t("p",[e._v("导出 secret 的 yaml："),t("code",[e._v("kubectl get secret <secret-name> -o yaml > secret.yaml")])])]),e._v(" "),t("li",[t("p",[e._v("启动一个临时的 pod："),t("code",[e._v("kubectl run -it --rm --image=busybox --restart=Never debug -- sh")])])]),e._v(" "),t("li",[t("p",[e._v("回滚更新："),t("code",[e._v("kubectl rollout undo deployment nginx-deployment")])])])]),e._v(" "),t("h2",{attrs:{id:"pod"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pod"}},[e._v("#")]),e._v(" Pod")]),e._v(" "),t("p",[e._v("一个 Pod 会有多个容器。同 Pod 的所有容器会在一台机器上运行。")]),e._v(" "),t("p",[t("strong",[e._v("Pod <-> 机器，管理容器、Namespace，以及网络、Volume 等资源")]),t("br"),e._v(" "),t("strong",[e._v("Container <-> 用户进程")])]),e._v(" "),t("p",[e._v("每个 Pod 会有一个 Infra 容器，使用 pause 镜像，负责占据 Network、Namespace、Volume 等资源，然后给同 Pod 的其它容器使用。Infra 容器的生命周期和 Pod 的生命周期一致。")]),e._v(" "),t("p",[e._v("Pod 的一些配置，看到名字都能大概猜出来是什么意思。知道干嘛的就好，具体用的时候再来细查。不少配置在生产环境中很有用：")]),e._v(" "),t("ul",[t("li",[e._v("VolumeMounts")]),e._v(" "),t("li",[e._v("InitContainers")]),e._v(" "),t("li",[e._v("HostAliases & Hostnames")]),e._v(" "),t("li",[e._v("ImagePullPolicy (Always, IfNotPresent, Never)")]),e._v(" "),t("li",[e._v("Lifecycle.PostStart & PreEnd")]),e._v(" "),t("li",[e._v("Status & Condition (PodScheduled, Ready, Initialized, Unschedulable)")]),e._v(" "),t("li",[e._v("ProjectedVolumes: Secret, ConfigMap, Downward API, ServiceAccountToken")]),e._v(" "),t("li",[e._v("RestartPolicy (Always, OnFailure, Never)")]),e._v(" "),t("li",[e._v("LivenessProbe & ReadinessProbe")]),e._v(" "),t("li",[e._v("PodPreset")]),e._v(" "),t("li",[e._v("Tolerations")])]),e._v(" "),t("h2",{attrs:{id:"taint-toleration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#taint-toleration"}},[e._v("#")]),e._v(" Taint & Toleration")]),e._v(" "),t("p",[e._v("Taint（污点）和 Toleration（容忍）是一个很有意思的模型。这两个词乍一看，和计算机科学没什么关系，以至于我第一时间完全不知道是什么功能。但是明白用处以后，又会觉得这两个词很生动形象。")]),e._v(" "),t("p",[e._v("简单来说，我们都知道 K8s 的核心工作之一是把 Pod 调度到 Node 上运行，而 Taint 和 Toleration 是定义一组规则来控制哪些 Pod 可以运行在哪些 Node 上。")]),e._v(" "),t("p",[e._v("Taint 是 Node 上的属性，它负责“污染” Node，让 Pod 不愿意运行在这个 Node 上。而 Toleration 是 Pod 的属性，它负责“容忍” Taint，让 Pod 可以运行在被污染的 Node 上。Taint 和 Toleration 模型的思想其实就是这两行。")]),e._v(" "),t("p",[e._v("Taint 和 Toleration 的用法，本文就不具体展开了。感兴趣的读者可以看看 K8s 官方文档。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/",target:"_blank",rel:"noopener noreferrer"}},[e._v("污点和容忍度 | Kubernetes"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/393572345",target:"_blank",rel:"noopener noreferrer"}},[e._v("kubernetes扩展：污点和容忍 - 知乎"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"persistentvolumeclaim-persistentvolume"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#persistentvolumeclaim-persistentvolume"}},[e._v("#")]),e._v(" PersistentVolumeClaim & PersistentVolume")]),e._v(" "),t("p",[t("strong",[e._v("Pod -> PVC -> PV")])]),e._v(" "),t("p",[e._v("PVC 是定义接口（大小、AccessModes 等），PV 是实现（实际存储位置、认证信息等）。而 Pod 只需要在配置里面把 PVC 挂载到指定路径就行。")]),e._v(" "),t("h2",{attrs:{id:"statefulset-主从-pod"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#statefulset-主从-pod"}},[e._v("#")]),e._v(" StatefulSet & 主从 Pod")]),e._v(" "),t("p",[e._v("StatefulSet 是一个用起来比较复杂的概念，它解决的运维问题本身也比较复杂。简单来说，StatefulSet 可以用来部署“有状态应用”。")]),e._v(" "),t("p",[e._v("我对“有状态应用”的理解是：应用的状态是持久化的，且关键在于有一定的顺序性（拓扑结构），比如一主多从的 MySQL 集群。在部署这种集群时，每个节点需要知道自己的拓扑位置（节点是主还是从），可能还需要根据自己的位置做不同的初始化工作。")]),e._v(" "),t("p",[e._v("在 StatefulSet 中，Pod 的名字是有序的，比如 "),t("code",[e._v("mysql-0")]),e._v("、"),t("code",[e._v("mysql-1")]),e._v("、"),t("code",[e._v("mysql-2")]),e._v("。这样就可以通过 Pod 的名字来确定 Pod 的位置。在初始化时，可能需要在 yaml 里写 shell：")]),e._v(" "),t("div",{staticClass:"language-yaml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-yaml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("initContainers")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" init"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("mysql\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("image")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" mysql"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("5.7")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("command")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n      "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" bash\n      "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"-c"')]),e._v("\n      "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),t("span",{pre:!0,attrs:{class:"token scalar string"}},[e._v("\n        [[ `hostname` =~ -([0-9]+)$ ]] || exit 1\n        ordinal=${BASH_REMATCH[1]}\n        if [ $ordinal -eq 0 ]; then\n          # 初始化主节点\n        else\n          # 初始化从节点")]),e._v("\n")])])]),t("h2",{attrs:{id:"daemonset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#daemonset"}},[e._v("#")]),e._v(" DaemonSet")]),e._v(" "),t("p",[e._v("和 ReplicaSet、StatefulSet 一样，DaemonSet 控制了一堆 Pods。不同的是，DaemonSet 控制的 Pod 有一个特点："),t("strong",[e._v("DaemonSet 保证每个 Node 上有且只有一个 DaemonSet 对应的 Pod")]),e._v("。")]),e._v(" "),t("p",[e._v("所以 DaemonSet 适合部署一些需要在每个 Node 上运行的服务，比如日志收集、监控等。")]),e._v(" "),t("h2",{attrs:{id:"job-cronjob"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#job-cronjob"}},[e._v("#")]),e._v(" Job & CronJob")]),e._v(" "),t("p",[e._v("ReplicaSet、StatefulSet 和 DaemonSet 都运行了一些需要一直运行的 Pod，如果挂了会自动重启。而 Job 和 CronJob 则是运行一些一次性任务，运行完了会自动退出，状态变成 Completed；失败了以后可以配置自动重试，或者直接 Fail 掉。")]),e._v(" "),t("p",[e._v("Job 也有一些常用配置：")]),e._v(" "),t("ul",[t("li",[e._v("RestartPolicy (OnFailure：失败后重启容器；Never：失败后创建新的 Pod)")]),e._v(" "),t("li",[e._v("BackoffLimit")]),e._v(" "),t("li",[e._v("ActiveDeadlineSeconds")]),e._v(" "),t("li",[e._v("Parallelism")]),e._v(" "),t("li",[e._v("Completions")])]),e._v(" "),t("p",[e._v("CronJob 则是定时任务，可以配置 Cron 表达式。除了 Cron 以外，它还可以配置：")]),e._v(" "),t("ul",[t("li",[e._v("ConcurrencyPolicy (Allow, Forbid, Replace) - 到时间点时，如果上一个任务还没执行完，这个任务是允许、禁止还是替换上一个任务")])]),e._v(" "),t("h2",{attrs:{id:"rbac"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rbac"}},[e._v("#")]),e._v(" RBAC")]),e._v(" "),t("p",[e._v("如果要在 Pod 里通过 Kubernetes API Server 读写 Pod 或者各种资源的信息（典型的例子是 Prometheus 这类性能监控），需要给这个 Pod 加权限。这时候就需要用到 RBAC。")]),e._v(" "),t("p",[e._v("Service Account <-> RoleBinding (ClusterRoleBinding) <-> Role (ClusterRole)")]),e._v(" "),t("h2",{attrs:{id:"自定义-controller、operator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义-controller、operator"}},[e._v("#")]),e._v(" 自定义 Controller、Operator")]),e._v(" "),t("p",[e._v("从这里开始就需要写点代码了。书里用的是 go，不过官方也支持使用 Python SDK 访问 Custom Resource，所以也可以写 Python。")]),e._v(" "),t("hr"),e._v(" "),t("p",[t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/",target:"_blank",rel:"noopener noreferrer"}},[e._v("定制资源 | Kubernetes"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("K8s 支持以插件的形式自定义资源（Custom Resource Definition，CRD），定义资源的时候需要启动这个资源的控制器（Controller），来处理这个资源的增删改查。")]),e._v(" "),t("p",[e._v("书中的例子定义了一个名为 network 的资源，启动 Controller 以后，使用这个资源的方法和其它资源一样：")]),e._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[e._v("kubectl get network\nkubectl describe network my-network\nkubectl apply -f example/example-network.yaml\n")])])]),t("p",[e._v("关于 Controller 的架构，张磊老师把书里的原图放到了 "),t("a",{attrs:{href:"https://twitter.com/resouer/status/1009996649832185856",target:"_blank",rel:"noopener noreferrer"}},[e._v("Twitter"),t("OutboundLink")],1),e._v(" 上。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/k8s-controller-workflow.jpg",alt:"Controller 架构"}})]),e._v(" "),t("p",[e._v("虚线框里是一个 Controller 的架构，包含 Informer、Work Queue 和最右边的业务逻辑实现（"),t("code",[e._v("runWorker()")]),e._v(" 函数）。")]),e._v(" "),t("p",[e._v("在声明式 API 中，用户提交的 yaml 文件里包含了用户声明的所有资源。Informer 负责从 Kubernetes API Server 拿到用户声明资源的变化，然后把变化（增/删/改）的资源的 key（"),t("code",[e._v("namespace/name")]),e._v("）放到 Work Queue 里。Work Queue 里的任务会被 "),t("code",[e._v("runWorker()")]),e._v(" 函数异步处理，处理完以后把 key 从队列里丢掉。")]),e._v(" "),t("p",[e._v("看起来很复杂，但是大部分代码都是可以自动生成的，只有最后 "),t("code",[e._v("runWorker()")]),e._v(" 里的业务逻辑需要自己写。")]),e._v(" "),t("hr"),e._v(" "),t("p",[t("a",{attrs:{href:"https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/operator/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Operator 模式 | Kubernetes"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("Operator 和自定义控制器很像，都是通过编程来实现更复杂、yaml 实现不了的资源管理。不过 Controller 更倾向于定义并管理一种新的资源，Operator 更倾向于把一堆运维步骤打包、自动化。")]),e._v(" "),t("p",[e._v("不过这块的实现真的很重。配环境、查文档、编程实现、测试 debug、部署运维，都是一大堆工作。还是等 yaml 配置不够用了再考虑吧。")])])}),[],!1,null,null,null);t.default=a.exports}}]);