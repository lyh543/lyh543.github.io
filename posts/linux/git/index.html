<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Git笔记 | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/theme/favicon.png">
    <meta name="description" content="

常用命令可查表：Git-CheatSheet

官方文档 也是很好的学习的手段。

[GitHub 词汇表](https://help.github.com/cn/github/getting-started-with-github/github-glossar ...">
    
    <link rel="preload" href="/assets/css/0.styles.11427f6f.css" as="style"><link rel="preload" href="/assets/js/app.c6df116d.js" as="script"><link rel="preload" href="/assets/js/173.ea30093e.js" as="script"><link rel="preload" href="/assets/js/4.c36cbde9.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.11427f6f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><div class="content__default"><h2 id="常用链接"><a href="#常用链接" class="header-anchor">#</a> 常用链接</h2> <p>常用命令可查表：<a href="/blob/git/git-cheatsheet.pdf">Git-CheatSheet</a></p> <p><a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="noopener noreferrer">官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 也是很好的学习的手段。</p> <p><a href="https://help.github.com/cn/github/getting-started-with-github/github-glossary" target="_blank" rel="noopener noreferrer">GitHub 词汇表<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://github.github.com/training-kit/downloads/zh_CN/github-git-cheat-sheet/" target="_blank" rel="noopener noreferrer">GitHub 备忘清单<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>本博客参考链接：https://www.liaoxuefeng.com/wiki/896043488029600</p></blockquote> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>先说一个概念：Git 是目前最流行的<strong>版本管理系统</strong>，学会 Git 几乎成了开发者的必备技能。</p> <p>如果你看不懂这句话，你可以从字面意思理解“版本管理系统”：多个开发者在同一个软件的基础上，开发了不同的版本，他们可以通过 Git 方便、严谨的实现上传、下载、比对、合并代码间的冲突等操作。</p> <p>而我们最常用的把代码放到 GitHub（或其他 Git 服务器）上的操作，可以把远程服务器也看做一个开发者（虽然他什么也不会修改），我们每次开发完以后，就会将代码上传给他。</p> <h2 id="git-入门"><a href="#git-入门" class="header-anchor">#</a> Git 入门</h2> <h3 id="在本地-git-新建仓库"><a href="#在本地-git-新建仓库" class="header-anchor">#</a> 在本地 Git 新建仓库</h3> <p>入门，首先就是新建一个仓库了。对于这第一个概念，<code>仓库</code>，可以从字面理解为存代码的仓库，往往将一个项目的完整代码放在一个仓库。</p> <p>有两种方法：一是在本地新建一个 Git 仓库，另一种是在 GitHub 上新建库，然后下载到本地。</p> <p>如果你打算将代码放到 GitHub 上，这里推荐第二种方法。因为在 GitHub 新建了库以后，可能会有一些初始文件、初始设置，可能和本地不同。如果使用使问题更复杂，在初学阶段，可以先跳过这些麻烦的东西。</p> <p>首先假设你已经在 GitHub 网站上建立了库（或者你想把别人的库下载到本机），链接为 <code>https://github.com/lyh543/lyh543.github.io/</code>。现在想要在当前文件夹中，新建 <code>lyh543.github.io</code> 文件夹，并将仓库下载到本地：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> clone https://github.com/lyh543/lyh543.github.io/
</code></pre></div><p>本地就多了一个文件夹 <code>lyh543.github.io</code>，内容和网站上的一致。</p> <p>你也可以使用不同于 <code>HTTPS</code> 协议的 <code>SSH</code> 协议（如果你明白这是什么），将上面 clone 的 <code>HTTPS</code> 链接修改为 <code>SSH</code> 链接即可。</p> <p>顺便提一下，在本地新建仓库的方法如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> lyh543.github.io
<span class="token builtin class-name">cd</span> lyh543.github.io
<span class="token function">git</span> init
</code></pre></div><h3 id="git-上传三连"><a href="#git-上传三连" class="header-anchor">#</a> Git 上传三连</h3> <p>在建立好库以后，每次写完代码，就可以按照下面的<a href="#git-%E4%B8%8A%E4%BC%A0%E4%B8%89%E8%BF%9E">上传三连</a>了。如果该项目只有你的一台设备进行开发（即不会出现不同步的情况），在 99% 的情况，你只会用到以下三条语句。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 如果本地、服务器端不一致，需要先 git pull，将服务器的内容拉取下来</span>

<span class="token function">git</span> <span class="token function">add</span> --all <span class="token comment"># 单文件是 git add &lt;file&gt;</span>

<span class="token comment"># git status # 这句可以看到到底 add 了哪些东西</span>

<span class="token function">git</span> commit -m <span class="token string">&quot;upload 2 files.&quot;</span> <span class="token comment"># 用文字说明这一次更新了什么东西，推荐写</span>

<span class="token function">git</span> push
</code></pre></div><p>上传完以后，你就可以看到 GitHub 上的代码已经更新。</p> <h4 id="一键三连"><a href="#一键三连" class="header-anchor">#</a> 一键三连</h4> <p>在很熟悉三连操作以后，就会感到有点麻烦了。于是用 <code>alias</code> 实现了一个命令缩写。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">alias</span> <span class="token assign-left variable">commit</span><span class="token operator">=</span><span class="token string">'git_commit() { git add --all &amp;&amp; git commit -m &quot;$1&quot; &amp;&amp; git push;}; git_commit'</span>`
</code></pre></div><p>但是因为 <code>alias</code> 不是开机自启的，要想开机自启，可以看 <a href="/posts/linux-daily-command/#alias-简化命令">另一篇博客</a>，此略。</p> <h2 id="git-使用-ssh-协议"><a href="#git-使用-ssh-协议" class="header-anchor">#</a> Git 使用 SSH 协议</h2> <p>Git for Linux 如果操作 HTTPS 协议链接的仓库，是不能保存密码的，每次 push 都需要输入账号密码，很烦。（Git for Windows 貌似可以走网页认证，好像可以保存）</p> <p>一个选择是 ssh 协议，使用这个协议可以保存用户信息，很方便。
第二个方案是走 https，不过让 Git 明文保存密码（不推荐）</p> <p>多 ssh 秘钥部署可以看链接：https://www.awaimai.com/2200.html</p> <h3 id="在-linux-下-git-使用-ssh-密钥"><a href="#在-linux-下-git-使用-ssh-密钥" class="header-anchor">#</a> 在 Linux 下 Git 使用 ssh 密钥</h3> <p>大概分为三步走：</p> <ol><li>本地生成密钥对；</li> <li>设置 GitHub 上的公钥；</li> <li>修改 Git 的 remote url 为 <code>SSH</code> 协议。</li></ol> <h4 id="linux-下本地生成密钥对"><a href="#linux-下本地生成密钥对" class="header-anchor">#</a> Linux 下本地生成密钥对</h4> <p><code>$ ssh-keygen -t rsa -C &quot;lyh543@github.com&quot;</code></p> <p>passphrase 可留空<s>因为太懒，不然以后每次 push 都要输这个 passphrase</s></p> <p><code>The key fingerprint is: SHA256:QtXXXXXXXXXXXXXXXXXXXXXXXXXXXXlk lyh543@github.com</code></p> <h4 id="设置-github-上的公钥"><a href="#设置-github-上的公钥" class="header-anchor">#</a> 设置 github 上的公钥</h4> <ol><li>查看你的公钥</li></ol> <div class="language- extra-class"><pre class="language-text"><code>$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXmp lyh543@github.com
</code></pre></div><ol start="2"><li>登陆你的<code>github</code>帐户。然后 <code>Account Settings</code> -&gt; 左栏点击 <code>SSH Keys</code> -&gt; 点击 <code>Add SSH key</code></li> <li>然后你复制上面的公钥内容，粘贴进“Key”文本域内。 <code>title</code>域，你随便填一个都行。</li> <li>完了，点击 <code>Add key</code>。</li> <li>测试一下这个key。</li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">ssh</span> -T git@github.com
The authenticity of <span class="token function">host</span> <span class="token string">'github.com (52.74.223.119)'</span> can<span class="token string">'t be established.
RSA key fingerprint is SHA256:nTXXXXXXXXXXXXXXXXXXXXXXX8.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '</span>github.com,52.74.223.119<span class="token string">' (RSA) to the list of known hosts.
Hi lyh543! You'</span>ve successfully authenticated, but GitHub does not provide shell access.
</code></pre></div><p>看到最后一句就是OK了。</p> <h4 id="修改-git-的-remote-url-从-https-改为-ssh"><a href="#修改-git-的-remote-url-从-https-改为-ssh" class="header-anchor">#</a> 修改 Git 的 remote url 从 <code>https</code> 改为 <code>ssh</code></h4> <p>查看当前（git仓库下的）的remote url</p> <div class="language- extra-class"><pre class="language-text"><code># 需要到仓库根目录下
$ git remote -v
origin  https://github.com/lyh543/lyh543.github.io.git (fetch)
origin  https://github.com/lyh543/lyh543.github.io.git (push)
</code></pre></div><p>修改 remote url</p> <div class="language- extra-class"><pre class="language-text"><code>git remote set-url origin git@github.com:lyh543/lyh543.github.io.git
</code></pre></div><h3 id="题外话-把-ssh-密钥给服务器"><a href="#题外话-把-ssh-密钥给服务器" class="header-anchor">#</a> 题外话：把 ssh 密钥给服务器</h3> <p>使用 ssh 远程登录服务器的时候，每次都要输入密钥。其实也可以使用 ssh 密钥进行登录。而且甚至没有 git 这么麻烦，还要去官网上加入公钥。</p> <p>直接一句：</p> <div class="language- extra-class"><pre class="language-text"><code>ssh-keygen
ssh-copy-id -i ~/.ssh/id_rsa.pub  root@192.168.x.xxx -p22
</code></pre></div><p>即可。</p> <h3 id="windows-下-git-使用-ssh-密钥"><a href="#windows-下-git-使用-ssh-密钥" class="header-anchor">#</a> Windows 下 git 使用 ssh 密钥</h3> <p>Windows 下也可以生成 ssh 密钥对，但是需要使用第三方软件：PuTTYgen，在 Tortoise Git 中自带。由于方法不同，可以在 Windows 和 Linux 使用不同的 ssh Key。</p> <ol><li>本地生成密钥对；</li> <li>设置github上的公钥；</li> <li>设置本地git使用的密钥。</li></ol> <h4 id="windows-下本地生成密钥对"><a href="#windows-下本地生成密钥对" class="header-anchor">#</a> Windows 下本地生成密钥对</h4> <p>进入软件，点<code>Generate</code>，然后就开始生成。由于生成时的随机数据是采集鼠标指针的移动，因此务必在生成过程中移动鼠标。</p> <p><img src="/blob/git/PuTTYgen_1.jpg" alt="PuTTYgen_1"></p> <p>大约1分钟以后，生成完成，如图2。</p> <p><img src="/blob/git/PuTTYgen_2.jpg" alt="PuTTYgen_2"></p> <p>然后 <code>Save Private Key</code> 把密钥文件存下来。<br>
文本框中的内容是公钥，按照<a href="#%E8%AE%BE%E7%BD%AEgithub%E4%B8%8A%E7%9A%84%E5%85%AC%E9%92%A5">上面的方法</a>设置github上的密钥。</p> <h4 id="设置本地-git-使用的密钥"><a href="#设置本地-git-使用的密钥" class="header-anchor">#</a> 设置本地 git 使用的密钥</h4> <p>由于笔者使用 Tortoise Git，在一个 reporisitory 中 push 的时候选中<code>自动加载 PuTTY密钥</code>即可。</p> <p>命令行 Git 另有实现方法。</p> <h3 id="linux-git-保存密码"><a href="#linux-git-保存密码" class="header-anchor">#</a> (Linux) Git 保存密码</h3> <blockquote><p>参考博客：https://blog.csdn.net/xx326664162/article/details/49686241<br>
https://www.crifan.com/git_remember_record_user_and_password_no_need_input_again/</p></blockquote> <p>Git的凭据存储有 cache、store、manager 三种方式。可以通过</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config --global credential.helper store
</code></pre></div><p>切换。</p> <p>其中，如果使用 <code>store</code>，密码将被会明文保存在 <code>~/.git-credentials</code>。感觉不大好。</p> <p>如果使用 <code>cache</code> 密码会在内存中保存一段时间。密码永远不会被存储在磁盘中，并且默认在15分钟后从内存中清除。不过时间是可以修改的。</p> <p>于是，就有人想到把这个时间设置为一个月 <code>2592000</code> 。</p> <p>注销以后密码也会被清除，毕竟是存在内存里的。不过每次开机输一次密码也能接受。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config --global credential.helper cache
<span class="token function">git</span> config credential.helper <span class="token string">'cache --timeout=1000000000'</span>
</code></pre></div><p>还有一种在 <code>remote.url</code> 中加入自己的用户名和密码，更危险，就不表了。</p> <h2 id="git-代理"><a href="#git-代理" class="header-anchor">#</a> Git 代理</h2> <p>经常会有挂上代理，浏览器访问 Github 快到飞起的，但是 Git Clone 却慢死的经历。awsl。</p> <p>以下方法收集自知乎的同一问题：<a href="https://www.zhihu.com/question/27159393/answer/141047266" target="_blank" rel="noopener noreferrer">git clone一个github上的仓库，太慢，经常连接失败，但是github官网流畅访问，为什么？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="shadowsocks-对-github-进行-https-代理"><a href="#shadowsocks-对-github-进行-https-代理" class="header-anchor">#</a> Shadowsocks 对 Github 进行 HTTPS 代理</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config --global http.https://github.com.proxy socks5://127.0.0.1:1080
<span class="token function">git</span> config --global https.https://github.com.proxy socks5://127.0.0.1:1080
</code></pre></div><p>也要注意 <code>1080</code> 是 Shadowsocks 代理的端口，可能需要根据自己的代理配置进行修改。<br>
另外使用该方法以后，需要用 HTTPS 协议（而不是 SSH）进行传输。</p> <h3 id="ssh-代理"><a href="#ssh-代理" class="header-anchor">#</a> ssh 代理</h3> <h4 id="linux-wsl-1"><a href="#linux-wsl-1" class="header-anchor">#</a> Linux/WSL 1</h4> <p>Linux 的 ssh 代理可以通过<a href="https://gist.github.com/chuyik/02d0d37a49edc162546441092efae6a1" target="_blank" rel="noopener noreferrer">macOS 给 Git(Github) 设置代理（HTTP/SSH）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的方法。</p> <h4 id="wsl-2"><a href="#wsl-2" class="header-anchor">#</a> WSL 2</h4> <p>注意如果是 wsl 2，因为 wsl 2 实际上是一个 Hyper-V 虚拟机，因此 Windows 上的代理如果想要被 Linux 使用，上面填 ip 的地方应该填 Windows 在 wsl 网络下的 ip（命令行输入 <code>ipconfig</code>，看到 <code>以太网适配器 vEthernet (WSL)</code> 的就是）。另外还需要代理软件“允许局域网的连接”。</p> <p>而且目前 wsl 2 由于是由 Hyper-V 实现的，每次重启 windows，windows 和 wsl 的 ip 都会变，目前没有方法改为静态 ip，只能每次改 ip 了。（</p> <h4 id="windows"><a href="#windows" class="header-anchor">#</a> Windows</h4> <p>如果是 Windows 下的 Git，可以参考：<a href="https://www.zhihu.com/question/27159393/answer/809693236" target="_blank" rel="noopener noreferrer">git clone一个github上的仓库，太慢，经常连接失败，但是github官网流畅访问，为什么？ - 戈登走過去的回答 - 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>不过注意，如果你的 OpenSSH 是通过 <code>Windows 10 设置</code> - <code>应用与功能</code> - <code>可选功能</code> 安装的，此法可能会使 Windows 下 <code>ssh</code> 出现如下错误：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>C:<span class="token punctuation">\</span>Tools<span class="token punctuation">\</span>Git<span class="token punctuation">\</span><span class="token operator">&gt;</span>ssh -T git@github.com
CreateProcessW failed error:87
posix_spawn: Unknown error
</code></pre></div><p>这个 bug 不影响 Git 的使用，并且可以通过卸载后从此处安装解决：https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH</p> <p>bug 相关可参见：https://github.com/microsoft/vscode-remote-release/issues/1887</p> <h3 id="改-hosts"><a href="#改-hosts" class="header-anchor">#</a> 改 hosts</h3> <p>还有一个方法是修改 Hosts 文件。对于没有代理的开发者，会有一点帮助（都是开发者了为什么还没有代理）。</p> <div class="language- extra-class"><pre class="language-text"><code>151.101.72.249 github.http://global.ssl.fastly.net
192.30.253.112 github.com
</code></pre></div><h2 id="git-基础"><a href="#git-基础" class="header-anchor">#</a> Git 基础</h2> <p>对于刚入门 Git 的萌新，<code>clone</code> <code>pull</code> <code>add</code> <code>commit</code> <code>push</code> 已经够用了。然而，如果要发挥 Git 全部的功能，还需要了解更多的东西。</p> <h3 id="回溯版本"><a href="#回溯版本" class="header-anchor">#</a> 回溯版本</h3> <h4 id="git-status-diff-checkout-查看当前状态"><a href="#git-status-diff-checkout-查看当前状态" class="header-anchor">#</a> git status/diff/checkout 查看当前状态</h4> <blockquote><p>学习链接：https://www.liaoxuefeng.com/wiki/896043488029600/896954074659008#0</p></blockquote> <p>下面只是对上述博客的一些简短的笔记。</p> <p>使用 <code>git status</code> 可查看目前 Git 的状态（什么文件被修改过之类的……）</p> <p>使用 <code>git diff readme.txt</code> 可查看 <code>readme.txt</code> 的还没有被 commit 的修改。</p> <p>对于只是修改了 <code>readme.txt</code> 文件，还没有进行任何 Git 操作的，可以 <code>git checkout -- readme.txt</code> 恢复为之前 <code>add</code> 过的文件。</p> <p>更多的情况可看<a href="https://www.cnblogs.com/liuq/p/9203087.html" target="_blank" rel="noopener noreferrer">Git 之 恢复修改的文件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="git-log-reflog-reset-版本回退"><a href="#git-log-reflog-reset-版本回退" class="header-anchor">#</a> git log/reflog/reset 版本回退</h4> <p>使用 <code>git log</code> 可查看当前分支的<strong>所有</strong> commit 日志。
可搭配 <code>--pretty=oneline</code> 简略显示。</p> <div class="language- extra-class"><pre class="language-text"><code>$ git log --pretty=oneline
a4a32854a37319561d16f1618cd9c20e0b3290bf (HEAD -&gt; master, origin/master) append GPL
f4d84ec5d20e8be8f7ef70802b1ba6e654986197 add distributed
d5fd90e99d8a1d91a34d7aef9e615d122d2a2904 new readme.txt
65a146ab6bc8b27dbaaed4d0c200d7d0ee8b6b65 add Hello world
</code></pre></div><p>前面的一串是 SHA1 值。</p> <p>回退到上一个版本：<code>git reset --hard HEAD^</code><br>
回退到上两个版本：<code>git reset --hard HEAD^^</code> 或 <code>HEAD~2</code><br>
回退/前进到指定版本：<code>git reset --hard a4a3</code>（到 <code>append GPL</code> 版本）</p> <p>如果回退以后想再前进，却忘了 SHA1 值，可以使用 <code>git reflog</code>。</p> <p>注意至少要写四位，否则会报错：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git reset --hard 65a
fatal: ambiguous argument '65a': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'
</code></pre></div><h4 id="相关概念浅析-工作区、暂存区"><a href="#相关概念浅析-工作区、暂存区" class="header-anchor">#</a> 相关概念浅析：工作区、暂存区</h4> <ul><li>工作区 <code>working tree</code>：（对于 test 项目）test 文件夹（<code>tree</code> 翻译成目录比较好）</li> <li>版本库 <code>Repository</code>：<code>test/.git</code> 文件夹</li> <li>暂存区 <code>stage/index</code>：在版本库中（Git 文档中凡是出现 <code>stage</code> 和 <code>index</code> 都是暂存区的意思）</li> <li><code>master</code>：第一个分支，也在版本库中</li> <li><code>HEAD</code>：指向 <code>master</code> 的指针</li></ul> <p>其逻辑关系如下：</p> <div class="language- extra-class"><pre class="language-text"><code>test 文件夹
 │
 ├─工作区 working tree
 │
 └─版本库 .git 文件夹
     │
     ├─ 暂存区
     │
     ├─ master 分支
     │
     └─ 其他分支
</code></pre></div><ul><li><code>git add</code>：将文件修改添加进暂存区</li> <li><code>git commit</code>：将暂存区的东西 commit 到当前分支。（在这之后用 <code>git status</code> 会显示 <code>working tree clean</code>）</li></ul> <h4 id="git-diff-checkout-reset-笔记"><a href="#git-diff-checkout-reset-笔记" class="header-anchor">#</a> git diff/checkout/reset 笔记</h4> <p>diff 只能比较两份文件，如果是操作中是新建文件/删除文件，<code>git diff</code> 会提示“没有差异”。</p> <p>各 diff 的区别：</p> <ul><li><code>git diff</code>：显示工作区和暂存区的差异（即未 add 的内容）</li> <li><code>git diff --cached</code>：显示暂存区和 <code>HEAD</code> 的差异（即未 commit 的内容）</li> <li><code>git diff HEAD</code>：显示工作区和 <code>HEAD</code> 的差异（即未 add 或 commit 的内容）</li></ul> <p>在命令后可加文件名，指定比对某文件。</p> <ul><li><p><code>git checkout -- &lt;file&gt;</code> 可以认为是反向 add，是将暂存区的文档修改覆盖工作区的文档；</p> <ul><li>使用不带参数的 <code>git checkout</code> 可以查看工作区和暂存区的文件差异。</li> <li><code>--</code> 表示这条命令要无视 <code>--</code> 后的所有参数（实战中貌似也是可以去掉的）</li></ul></li> <li><p><code>git reset HEAD &lt;file&gt;</code> 可以认为是反向 commit，是用当前分支的文档覆盖暂存区。（并不会覆盖工作区）</p> <ul><li>加上 <code>--hard</code> 参数，<code>git reset --hard HEAD &lt;file&gt;</code> 就会覆盖工作区了</li></ul></li></ul> <p><img src="/blob/git/git-checkout-reset-diff.jpg" alt="Git checkout/reset/diff 对比"></p> <h4 id="远程库操作"><a href="#远程库操作" class="header-anchor">#</a> 远程库操作</h4> <p>在本地 <code>git init</code> 了一个库以后，如果需要上传到远程库，就需要设置远程库的地址（地址可以在 GitHub 网页上获取）：</p> <div class="language- extra-class"><pre class="language-text"><code>git remote add origin git@github.com:lyh543/test.git
</code></pre></div><p>Git 规定，要给每一台远程主机命名。这里的 <code>origin</code> 就是 Git 给远程库的默认名字。虽然可以用别的名字，但是推荐 <code>origin</code>。</p> <p>然后，进行 push：</p> <div class="language- extra-class"><pre class="language-text"><code>git push -u origin master
</code></pre></div><p>push 命令将本地的当前分支上传到 origin 的 master 分支（简写 origin/master）。<br> <code>-u</code>（或 <code>--set-upstream</code>）参数，还顺便将本地的 master 分支和 origin/master 分支进行关联（track），以后就不用指定。</p> <h3 id="branch-分支管理"><a href="#branch-分支管理" class="header-anchor">#</a> branch 分支管理</h3> <p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954848507552#0" target="_blank" rel="noopener noreferrer">学习链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="/blob/git/branch-management.png" alt="分支管理"></p> <p>其他版本控制系统如 SVN 等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p> <p>但 Git 的分支 <code>branch</code> 是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。</p> <h4 id="创建和合并分支"><a href="#创建和合并分支" class="header-anchor">#</a> 创建和合并分支</h4> <h5 id="相关概念"><a href="#相关概念" class="header-anchor">#</a> 相关概念</h5> <p>复习一下，<code>master</code> 是 Git 默认创建的分支，<code>HEAD</code> 是指向 <code>master</code> 的一个指针。</p> <p>其实，分支，是一条 commit 线。</p> <p>也就是说，Git 中的每一个状态，其实指的是每一次 commit，而分支就是将 commit 串起来了（然后 <code>HEAD</code> 又指向了当前分支的头）。</p> <p><img src="/blob/git/branch.png" alt="分支"></p> <p>所以创建分支的本质就是添加一条线，更改一下 <code>HEAD</code>，很快的。而删除分支，就是删一条线（并不删除 commit），也很快。</p> <h5 id="代码"><a href="#代码" class="header-anchor">#</a> 代码</h5> <p>新建 <code>dev</code> 分支并切换到该分支：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> branch dev   <span class="token comment"># 从当前分支新建 dev 分支</span>
<span class="token function">git</span> checkout dev <span class="token comment"># 切换到 dev 分支</span>
</code></pre></div><p>上述两个过程也可以用一行替代：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> checkout -b dev
</code></pre></div><p>实现的效果如图：</p> <p><img src="/blob/git/branch-1.png" alt="新建 dev 分支并切换到该分支"></p> <p>顺便一提， <code>git checkout</code> 的确是有两个功能，一是切换分支，二是将暂存区的某文件修改覆盖工作区的对应文件，不过二需要使用 <code>git branch --</code>。</p> <p>这之后，就可以在 <code>dev</code> 分支上修改，然后三连了。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token builtin class-name">echo</span> <span class="token string">&quot;We are working on a new branch&quot;</span> <span class="token operator">&gt;&gt;</span> readme.txt
<span class="token function">git</span> <span class="token function">add</span> readme.txt
<span class="token function">git</span> commit -m <span class="token string">&quot;commit on dev branch&quot;</span>
</code></pre></div><p>这之后，我们的仓库状态如下图：</p> <p><img src="/blob/git/branch-2.png" alt="在 dev 上三连后的仓库"></p> <p>接下来，将 <code>dev</code> 上的 commit merge 进 <code>master</code>。</p> <p>由上图可以看到，直接将 <code>master</code> 分支线延长至 <code>dev</code> 即可，所以 Git 能够轻松完成 merge 操作。</p> <p>这种 merge 又叫 <code>fast-forward merge</code>：</p> <blockquote><p>A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch.<br>
Instead of “actually” merging the branches, all Git has to do to integrate the histories is move (i.e., “fast forward”) the current branch tip up to the target branch tip. -- <a href="https://www.atlassian.com/git/tutorials/using-branches/git-merge" target="_blank" rel="noopener noreferrer">Git Merge | Atlassian Git Tutorial<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <blockquote><p>When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. This is the default behavior. -- <code>git merge --help</code></p></blockquote> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> checkout master <span class="token comment"># 从 dev 切回 master 分支</span>
<span class="token function">git</span> merge dev       <span class="token comment"># 将 dev 分支的内容合并到当前分支</span>
</code></pre></div><p>提一句，merge 本质也是一次 commit，其也可以使用 <code>-m &lt;msg&gt;</code> 来设定 commit 信息，而不是在弹出的文本编辑器中。</p> <p>最后删除 dev 分支：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> branch -d dev <span class="token comment"># 删除已经完成合并的 dev 分支</span>
</code></pre></div><h4 id="no-fast-forward-merge"><a href="#no-fast-forward-merge" class="header-anchor">#</a> no-fast-forward merge</h4> <p>fast-forward merge 的好处是相当快，并且 commit 线简洁，但是简洁的坏处就是丢失了一些信息。</p> <p>在这种模式下，删除分支后，会丢掉分支信息。</p> <p><code>git merge</code> 默认使用 fast-forward 模式。如果要强制禁用 fast-forward 模式，Git就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。</p> <p>使用方法很简单，就是在 <code>git merge</code> 时增加一个参数：</p> <div class="language- extra-class"><pre class="language-text"><code>git merge --no-ff dev
</code></pre></div><blockquote><p>2020.8.26 更新：在团队合作时，将自己写的代码 <code>merge</code> 到合作的分支（如 <code>master</code> 或 <code>dev</code>）上时，推荐使用 <code>--no-ff</code>，这样 commit 线上会出现分叉，不同人的 commit 会更加明显。</p></blockquote> <h4 id="删除分支"><a href="#删除分支" class="header-anchor">#</a> 删除分支</h4> <p>有三种情况：在本地删除某分支；在远端删除某分支（即将本地删除分支的操作 push 到远端）；在本地删除远端分支（即远端的已经被其他小伙伴删除，需要删除之前拉取到本地的远端分支）。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 在本地删除分支</span>
<span class="token function">git</span> branch -d lyh543

<span class="token comment"># 在 origin 远端删除分支</span>
<span class="token function">git</span> push -d origin lyh543
<span class="token comment"># or 'git push origin :lyh543'</span>
<span class="token comment"># see: https://stackoverflow.com/questions/7303687/why-git-use-the-colon-branch-to-delete-remote-branch</span>

<span class="token comment"># 在本地删除远端的分支</span>
<span class="token function">git</span> branch -dr origin/lyh543
</code></pre></div><h4 id="解决冲突"><a href="#解决冲突" class="header-anchor">#</a> 解决冲突</h4> <p>上面的分支图都是很简单的(linear)，如果复杂一点，比如两个分支都有自己的提交，<code>git merge</code> 就不能进行 <code>fast-forward merge</code> 了。</p> <p><img src="/blob/git/branch-3.png" alt="两个分支都有新的提交"></p> <p>对于简单的情况（两个分支只有文件增添，没有文件修改的冲突），Git 仍然可以实现自动合并，如：</p> <ul><li>在 <code>feature1</code> 删除了 a.txt</li> <li>在 <code>master</code> 新增了 b.txt</li></ul> <p>将 <code>feature1</code> 合并进 <code>master</code> 后，<code>master</code> 分支会呈现删除 a.txt，新增 b.txt 的状态。</p> <p>但是，也会有复杂的情况。如两个分支的某文件内容不同：</p> <p>在 <code>master</code> 分支的 <code>branch.txt</code> 如下：</p> <div class="language- extra-class"><pre class="language-text"><code>branch:
master
</code></pre></div><p>在 <code>dev</code> 分支的 <code>branch.txt</code> 如下：</p> <div class="language- extra-class"><pre class="language-text"><code>branch:
dev
</code></pre></div><p>在 <code>master</code> 分支下进行 <code>git merge dev</code> 会报失败：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git merge dev
Auto-merging branch.txt
CONFLICT (content): Merge conflict in branch.txt
Automatic merge failed; fix conflicts and then commit the result.
</code></pre></div><p>这时查看 <code>branch.txt</code>，会是这样：</p> <div class="language- extra-class"><pre class="language-text"><code>branch:
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
master
=======
dev
&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev
</code></pre></div><p>上面标注了两个版本的区别。</p> <p>现在我们有两个方案：一是放弃合并操作；二是进行合并。</p> <p>如果想放弃合并操作，只需一句 <code>git merge --abort</code>，就可以回到 <code>git merge dev</code> 之前的状态（一切都没发生过.jpg）；</p> <p>如果想进行合并，只需要在当前状态下，修改 <code>branch.txt</code> 到想要的样子，然后 add 和 commit：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> <span class="token function">add</span> branch.txt
<span class="token function">git</span> commit -m <span class="token string">&quot;fix merge confict&quot;</span>
</code></pre></div><p>就完成了 merge 和解决冲突。如何验证呢？可以用带图的 <code>git log</code></p> <div class="language- extra-class"><pre class="language-text"><code>git log --graph --pretty=oneline
</code></pre></div><h4 id="分支管理策略"><a href="#分支管理策略" class="header-anchor">#</a> 分支管理策略</h4> <p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p> <p>首先，<code>master</code> 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p> <p>那在哪干活呢？干活都在 <code>dev</code> 分支上，也就是说，<code>dev</code> 分支是不稳定的，到某个时候，比如 1.0 版本发布时，再把 <code>dev</code> 分支合并到 <code>master</code> 上，在 <code>master</code> 分支发布 1.0 版本；</p> <p>你和你的小伙伴们每个人都在 <code>dev</code> 分支上干活，每个人都有自己的分支，时不时地往 <code>dev</code>分支上合并就可以了（向 <code>dev</code> 合并自己的代码的时候推荐 <code>--no-ff</code>，从 <code>dev</code> 分支将小伙伴的代码合并到自己的代码时推荐默认的 <code>--ff</code>）。</p> <p>所以，团队合作的分支看起来就像这样：</p> <p><img src="/blob/git/branch-4.png" alt="团队合作的分支"></p> <p>而对于一个小 bug 或者一个 issue-101，也可以通过开一个 <code>issue-101</code> 临时分支，写完、merge 以后，再将临时分支删掉。</p> <h4 id="git-stash-工作区暂存"><a href="#git-stash-工作区暂存" class="header-anchor">#</a> git stash 工作区暂存</h4> <p>在当前分支的修改还有没 commit 的情况下，切换到其他分支后，这些修改会依然存在。</p> <blockquote><p><code>git checkout [&lt;branch&gt;]</code><br>
To prepare for working on &lt;branch&gt;, switch to it by updating the index and the files in the working tree, and by pointing HEAD at the branch. <strong>Local modifications to the files in the working tree are kept</strong>, so that they can be committed to the &lt;branch&gt;.
-- <a href="https://git-scm.com/docs/git-checkout#Documentation/git-checkout.txt-emgitcheckoutemltbranchgt" target="_blank" rel="noopener noreferrer">git checkout<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>如果我们既不想 commit（当前工作还没做完），也不想将当前分支的修改带到别的分支里，应该怎么做呢？</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> stash
</code></pre></div><p>使用这句命令，我们就可以把工作区的修改暂存起来，然后让工作区呈现修改前的状态。这之后，使用 <code>git status</code> 会显示 <code>working tree clean</code>。</p> <p>然后我们就可以用 <code>git checkout</code> 切换分支，在别的分支进行工作了。</p> <p>在别的分支工作完，并切回该分区以后，如何找回来呢？</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> stash list  <span class="token comment"># 列出当前的 stash</span>

<span class="token function">git</span> stash apply <span class="token comment"># 将最近的 stash 找回</span>
<span class="token function">git</span> stash drop  <span class="token comment"># 将最近的 stash 删除</span>

<span class="token function">git</span> stash pop   <span class="token comment"># 将最近的 stash 找回并删除</span>
<span class="token function">git</span> stash pop stash@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token comment"># 还可以指定 stash</span>
</code></pre></div><h3 id="remote-远端管理"><a href="#remote-远端管理" class="header-anchor">#</a> remote 远端管理</h3> <p>这一节的内容其实和分支管理有一些交集，毕竟远端管理其本质也是在管理远端的分支。</p> <h4 id="git-remote-查看远程库的信息"><a href="#git-remote-查看远程库的信息" class="header-anchor">#</a> git remote 查看远程库的信息</h4> <p>查看远程库的信息：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">git</span> remote
origin

$ <span class="token function">git</span> remote -v <span class="token comment"># 详细信息</span>
origin  git@github.com:lyh543/test.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>
origin  git@github.com:lyh543/test.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span>
</code></pre></div><p>上面显示了可以抓取 fetch 和推送 push 的 origin 的地址。如果没有推送权限，就看不到 push 的地址。</p> <h4 id="git-push-推送分支"><a href="#git-push-推送分支" class="header-anchor">#</a> git push 推送分支</h4> <p>推送分支，就是把该分支上的所有本地提交推送到远程库。</p> <p>推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> push origin master
</code></pre></div><p>如果要推送其他分支，比如 <code>dev</code>，就改成：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> push origin dev
</code></pre></div><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p> <ul><li><code>master</code> 分支是主分支，因此要时刻与远程同步；</li> <li><code>dev</code> 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li> <li><code>bug</code> 分支只用于在本地修复 bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个 bug；</li> <li><code>feature</code> 分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul> <p>总之，就是在 Git 中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p> <h4 id="git-fetch-从远端拉取"><a href="#git-fetch-从远端拉取" class="header-anchor">#</a> git fetch 从远端拉取</h4> <p><code>git clone</code> 只会获取远程的 <code>master</code> 分支，如果要获取 <code>dev</code> 分支，我们应该从 <code>origin/dev</code> 新建 <code>dev</code> 分支：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> checkout dev

<span class="token comment"># 等价于 git checkout -b dev origin/dev，见下</span>
</code></pre></div><blockquote><p><code>git checkout [&lt;branch&gt;]</code>
If <code>&lt;branch&gt;</code> is not found but there does exist a tracking branch in exactly one remote (call it <code>&lt;remote&gt;</code>) with a matching name and --no-guess is not specified, treat as equivalent to
<code>$ git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</code>
-- <a href="https://git-scm.com/docs/git-checkout#Documentation/git-checkout.txt-emgitcheckoutemltbranchgt" target="_blank" rel="noopener noreferrer">git-checkout Documentation - Git<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>这也太贴心了吧~ 那就不用记麻烦的了。</p> <p>然后就可以愉快的在 <code>dev</code> 分支上进行修改了。</p> <p>如果远端的内容更新了（比如你的小伙伴向远端 commit 了），但本地还没有更新，可以使用</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> fetch
<span class="token function">git</span> merge

<span class="token comment"># 或</span>

<span class="token function">git</span> pull <span class="token comment"># 两句的等价形式</span>
</code></pre></div><p>来进行拉取（fetch）。</p> <p>如果 merge 或 pull 中有冲突，需要按照 <a href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81">解决冲突</a> 的套路来合并冲突。</p> <h4 id="git-rebase-变基"><a href="#git-rebase-变基" class="header-anchor">#</a> git rebase 变基</h4> <p><code>git rebase</code> 通过修改 commit 的顺序使得某些情况下的分支图更简洁。</p> <p>比如以下场景：</p> <p>小伙伴 A 和 B 在合作开发同一个项目。</p> <ul><li>小伙伴 A 添加了 <code>a.txt</code>，并进行了 commit  和 push；</li> <li>小伙伴 B 在没有 fetch 的情况下添加了 <code>b.txt</code>，并进行了 commit 和 push。当然，这里 push 会失败，提示需要 fetch。</li> <li>小伙伴 B fetch 并 merge，完成了 merge 的过程，可以进行 pull 了。但是……</li></ul> <p>此时的 <code>git log --graph --pretty=oneline</code> 出现了分叉！</p> <div class="language- extra-class"><pre class="language-text"><code>$ git log --graph --pretty=oneline
*   d2232e76aad5009a86a66399b0d4a1e3feb9e6ef (HEAD -&gt; master) Merge branch 'master' of github.com:lyh543/test
|\
| * 98946ab30bbaf2fbc60531450731a8e840bdf62a (origin/master, origin/HEAD) add a.txt
* | 2eb60148822f268aa3510304fa409c1bdd2ec9b4 add b.txt
|/
*   591c9b045b7b84e75710fa96b1f77cb92ee82a85 remove dev.txt
</code></pre></div><p>这也没什么问题。<br>
但是，从理论上，这个分叉完全可以避免：只要 B 能在 commit 前进行 fetch 就可以少一次 merge 了。</p> <p>于是，这时 B 拍出了 <code>git rebase</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git rebase
First, rewinding head to replay your work on top of it...
Applying: add b.txt
</code></pre></div><p>（这里的 rebase 过程比较简单，如果 A B 对同一文件进行了修改，rebase 过程会稍微复杂，但同样能达到效果）</p> <p>之后，工作区和暂存区都没有什么变化，但是 <code>git log --graph --pretty=oneline</code> 发生变化了：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git log --graph --pretty=oneline
* 3b3769ddfea3f6ddc0a36e3d5784bd676386030e (HEAD -&gt; master) add b.txt
* 98946ab30bbaf2fbc60531450731a8e840bdf62a (origin/master, origin/HEAD) add a.txt
* 591c9b045b7b84e75710fa96b1f77cb92ee82a85 remove dev.txt
</code></pre></div><p>分支线的分叉消失了！</p> <p>也就是说，<code>git rebase</code> 能通过修改 commit 顺序，使得分支线简单，但是会减少一个 merge 的 commit。</p> <p>接下来就可以 push 了。</p> <h3 id="tag-标签管理"><a href="#tag-标签管理" class="header-anchor">#</a> tag 标签管理</h3> <p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener noreferrer">学习链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>Git 可以给历史中的某一个提交打上标签，以示重要。
比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p></blockquote> <p>标签也是一个指针，指向 commit 的。</p> <p>标签有 轻量标签 <code>lightweight</code> 和 附注标签 <code>annotated</code>。</p> <blockquote><p>一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。
然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p></blockquote> <p>添加轻量标签：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">git</span> tag v1.0      <span class="token comment"># 为 HEAD 添加 v1.0 的标签</span>
<span class="token function">git</span> tag v1.0 366e <span class="token comment"># 为 commit 366e 添加 v1.0 的标签</span>
</code></pre></div><p>添加附注标签，加一个 <code>-a</code> 开关就可以。</p> <div class="language- extra-class"><pre class="language-text"><code>git tag -a v1.4 -m &quot;my version 1.4&quot;
</code></pre></div><p>列出已有标签：<code>git tag</code></p> <p>查看标签对应的 commit：<code>git show v1.0</code></p> <p>注意，标签默认不会被 push 至远程服务器（clone 和 fetch 时是会获得的）。</p> <p>需要显式地 push 标签：<code>git push origin v1.0</code><br>
或 push 时带上 <code>--tags</code>：<code>git push origin --tags</code></p> <p>删除标签可以使用 <code>git tag -d v1.0</code>。</p> <p>但是，将删除标签推送至远端就有点复杂了： <code>git push origin :refs/tags/v1.0</code>。</p> <p>查看标签所指的文件版本： <code>git checkout v1.0</code></p> <p>注意这之后会进入 <code>detached HEAD</code> 的状态，不再有 <code>HEAD</code> 的概念。<br>
在这个状态下会进行 commit 有一定副作用（具体见手册），推荐新开一个 branch 来进行操作。</p> <h3 id="看完了"><a href="#看完了" class="header-anchor">#</a> 看完了？</h3> <p>如果看完了，推荐去看看 <a href="http://git-scm.com" target="_blank" rel="noopener noreferrer">git-scm.com<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的教程和手册，这里有官方对命令的解释，你对命令和概念的理解会更加精确。如 <a href="https://git-scm.com/docs/git-checkout" target="_blank" rel="noopener noreferrer">git checkout<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="git-小技巧"><a href="#git-小技巧" class="header-anchor">#</a> Git 小技巧</h2> <h3 id="git-rm"><a href="#git-rm" class="header-anchor">#</a> git rm</h3> <p>以下三种命令等价，都是从工作区删除并提交到暂存区</p> <ol><li><code>rm readme.txt</code> <code>git add readme.txt</code></li> <li><code>rm readme.txt</code> <code>git rm readme.txt</code></li> <li><code>git rm readme.txt</code></li></ol> <p>而从工作区删除，但是想恢复，只能在使用 <code>rm readme.txt</code> 的前提下 <code>git checkout -- readme.txt</code>。</p> <h3 id="amend-修改上次-commit"><a href="#amend-修改上次-commit" class="header-anchor">#</a> --amend 修改上次 commit</h3> <p>可以使用 <code>git commit --amend -m &quot;xxx&quot;</code> 以修改上次的 commit。</p> <p>如果已经 push 了，下次就需要 <code>git push -f</code> 强制推送。如果还没有 <code>push</code>，就相当于之前的 commit 没发生过，直接 <code>git push</code> 就行。</p> <h3 id="git-修改设置"><a href="#git-修改设置" class="header-anchor">#</a> git 修改设置</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> config <span class="token punctuation">[</span>--local<span class="token punctuation">]</span> --list <span class="token comment"># 查看设置；--local 用于本地库</span>
<span class="token function">git</span> config --local remote.origin.url git@github.com:lyh543/lyh543.github.io.git <span class="token comment"># 修改设置，项和名用空格间隔</span>
</code></pre></div><h3 id="git-修改远端"><a href="#git-修改远端" class="header-anchor">#</a> git 修改远端</h3> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> remote -v <span class="token comment"># 查看所有远端</span>
<span class="token function">git</span> remote set-url origin git@github.com:lyh543/lyh543.github.io.git <span class="token comment"># 修改远端</span>
</code></pre></div><p>更多的命令，可以随便敲一个不存在的命令，如 <code>git remote hhh</code> 来查看所有命令。</p> <h3 id="当你在-branch-外-commit-后"><a href="#当你在-branch-外-commit-后" class="header-anchor">#</a> 当你在 branch 外 commit 后</h3> <p>如果你在 branch 外 commit，然后立即切回 branch，你的 commit 就会掉。</p> <p>有两个解决方案：</p> <ol><li>将 commit 的内容变为一个新的 branch，然后在原来的 branch 中 merge 新的 branch；</li> <li>用下面的 cherry-pick 命令在 branch 中把对应的 commit 捡回来。</li></ol> <h4 id="cherry-pick-捡-commit"><a href="#cherry-pick-捡-commit" class="header-anchor">#</a> cherry-pick 捡 commit</h4> <p><code>git cherry-pick</code> 是一个“捡” commit 的命令。可以把任意（非当前 branch 的） <code>commit</code> 拉到本 branch 来。</p> <p>非当前 branch 的 <code>commit</code> 可以通过 <code>git reflog</code> 查看。</p> <h2 id="git-大文件版本管理-git-lfs"><a href="#git-大文件版本管理-git-lfs" class="header-anchor">#</a> Git 大文件版本管理：git-lfs</h2> <p><a href="https://git-lfs.github.com/" target="_blank" rel="noopener noreferrer">git-lfs 官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://help.github.com/cn/github/managing-large-files/versioning-large-files" target="_blank" rel="noopener noreferrer">GitHub 中文帮助页面<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Git LFS 是 Github 开发的一个 Git 的扩展，他能够处理 Git 仓库里的大文件（如图片、视频等等），其原理是将 Git 仓库中的大文件替换为一个指针，然后将大文件存在另一个服务器上。这样做的好处有：</p> <ul><li>可让您存储最大 2 GB 的文件</li> <li>使得 Git 仓库的容量更大</li> <li>更快的 Cloning 和 Fetching（大概用的服务器更快）</li> <li>操作和工作流等和原来完全一样</li></ul> <p>以上是官方的，个人感觉可能还会使得每次更新大文件时，他不会再保存在 <code>.git</code> 文件夹，占取大量硬盘空间了。</p> <h3 id="git-lfs-安装"><a href="#git-lfs-安装" class="header-anchor">#</a> git-lfs 安装</h3> <p>Windows 上官网就行。Ubuntu 下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> git-lfs
</code></pre></div><h3 id="git-lfs-配置"><a href="#git-lfs-配置" class="header-anchor">#</a> git-lfs 配置</h3> <p>对于每个仓库下，第一次需要配置一下（如需要用 git-lfs 管理 psd 和 mp4 文件）</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> lfs <span class="token function">install</span>
<span class="token function">git</span> lfs track <span class="token string">&quot;*.psd&quot;</span>
<span class="token function">git</span> lfs track <span class="token string">&quot;*.mp4&quot;</span>
<span class="token function">git</span> <span class="token function">add</span> .gitattributes
</code></pre></div><p>以后就和常规 <a href="#git-%E4%B8%8A%E4%BC%A0%E4%B8%89%E8%BF%9E">git 上传三连</a> 相同了。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">add</span> file.psd
<span class="token function">git</span> commit -m <span class="token string">&quot;Add design file&quot;</span>
<span class="token function">git</span> push origin master
</code></pre></div><h2 id="github-使用技巧"><a href="#github-使用技巧" class="header-anchor">#</a> GitHub 使用技巧</h2> <h3 id="下载最新的-release"><a href="#下载最新的-release" class="header-anchor">#</a> 下载最新的 release</h3> <p>阅读他人的教程博客时，经常会看到给出 GitHub Release 的某版本的下载链接（下面第一行），但该版本可能已经过时。实际上，GitHub 提供了能重定向到最新版的链接（下面第二行）：</p> <div class="language- extra-class"><pre class="language-text"><code>https://github.com/canton7/SyncTrayzor/releases/download/v1.1.24/SyncTrayzorSetup-x64.exe
https://github.com/canton7/SyncTrayzor/releases/latest/download/SyncTrayzorSetup-x64.exe
</code></pre></div><p>在写下这篇博客时，第二行链接能正确地被重定向到第一行：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">curl</span> -I https://github.com/canton7/SyncTrayzor/releases/latest/download/SyncTrayzorSetup-x64.exe
HTTP/1.1 <span class="token number">302</span> Found
date: Wed, 07 Oct <span class="token number">2020</span> <span class="token number">10</span>:22:26 GMT
content-type: text/html<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-8
server: GitHub.com
status: <span class="token number">302</span> Found
vary: X-PJAX, Accept-Encoding, Accept, X-Requested-With, Accept-Encoding
location: https://github.com/canton7/SyncTrayzor/releases/download/v1.1.24/SyncTrayzorSetup-x64.exe
</code></pre></div></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2021</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"><div id="pwa-snackbar" class="v-snack v-snack--bottom v-snack--has-background v-snack--right v-snack--vertical" data-v-fec8b358><div class="v-snack__wrapper v-sheet theme--dark" style="display:none;"><div role="status" aria-live="polite" class="v-snack__content">
    博客已更新！
    </div><div class="v-snack__action "><button type="button" id="pwa-button" class="v-btn v-btn--has-bg theme--dark v-size--default v-snack__btn"><span class="v-btn__content">
        刷新
      </span></button></div></div></div></div></div>
    <script src="/assets/js/app.c6df116d.js" defer></script><script src="/assets/js/173.ea30093e.js" defer></script><script src="/assets/js/4.c36cbde9.js" defer></script>
  </body>
</html>
