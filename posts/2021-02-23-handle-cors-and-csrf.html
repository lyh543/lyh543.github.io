<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>和 CSRF 与 CORS 斗智斗勇 | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/theme/favicon.png">
    <link rel="alternate" type="application/rss+xml" href="https://blog.lyh543.cn/rss.xml" title="小灰灰灰灰的博客 RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://blog.lyh543.cn/feed.atom" title="小灰灰灰灰的博客 Atom Feed">
    <link rel="alternate" type="application/json" href="https://blog.lyh543.cn/feed.json" title="小灰灰灰灰的博客 JSON Feed">
    <meta name="description" content="写前后端的时候遇到了这个问题，花了三天时间解决，就还是简单地写一写。写到最后才发现，这里面涉及的知识量也太大了，也请各位读者耐心阅读。

前言

CORS 和 CSRF 这两个概念很容易混淆，即使我在这篇博客前也不是很清楚二者的区别，于是就再搜了一下，顺便把另外两个概念也聊一聊。

浏览器、前端和后端的关系大概是：前端 ` 浏览器 ` 后端。前端告诉浏览器它需要访问什么，浏览 ...">
    
    <link rel="preload" href="/assets/css/0.styles.832ac33f.css" as="style"><link rel="preload" href="/assets/js/app.ab6adf2a.js" as="script"><link rel="preload" href="/assets/js/175.b95721b2.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.832ac33f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><container class="article-column-container"><div class="article-column"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><div class="v-card v-sheet theme--light"><div class="container"><div itemprop="articleBody" class="markdown-body content__default"><p>写前后端的时候遇到了这个问题，花了三天时间解决，就还是简单地写一写。写到最后才发现，这里面涉及的知识量也太大了，也请各位读者耐心阅读。</p> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>CORS 和 CSRF 这两个概念很容易混淆，即使我在这篇博客前也不是很清楚二者的区别，于是就再搜了一下，顺便把另外两个概念也聊一聊。</p> <p>浏览器、前端和后端的关系大概是：前端 <code>&lt;-&gt;</code> 浏览器 <code>&lt;-&gt;</code> 后端。前端告诉浏览器它需要访问什么，浏览器就向后端发请求，然后把应答给前端。</p> <p>而同源策略、CORS、CSRF、HttpOnly 和 SameSite 都在围绕一件事情：如何防止<strong>恶意前端</strong>误导用户和<strong>浏览器</strong>，在用户不知情的情况下以用户的身份恶意访问<strong>后端</strong>（删除数据、转账等等）。</p> <h2 id="同源策略"><a href="#同源策略" class="header-anchor">#</a> 同源策略</h2> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener noreferrer">浏览器的同源策略 - Web 安全| MDN<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>同源：两个 Protocol、Port 和 Host 都相同的 URL 是同源的；
跨域：两个 Protocol、Port 和 Host 不都相同的 URL 是跨域的；</p></blockquote> <p>MDN 上举了几个同源和跨域的例子，这里不再赘述。</p> <p>同源策略是一个比较笼统的概念，它是为了限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。就是说，它限制 <code>baidu.com</code> 的脚本不能访问到 <code>taobao.com</code> 的资源。</p> <p>现代浏览器同时采用了两种同源策略：</p> <ol><li>DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。</li> <li>XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。</li></ol> <p>可见，同源策略就是<strong>浏览器</strong>用来防止<strong>恶意前端</strong>的策略。</p> <p>不过请注意，浏览器并不限制 <code>&lt;img&gt;</code> <code>&lt;tag&gt;</code> <code>&lt;form&gt;</code> 等标签等进行跨域访问。</p> <h2 id="cookie-的源"><a href="#cookie-的源" class="header-anchor">#</a> Cookie 的源</h2> <p>Cookie 也有源的概念，但它的“源”和同源策略的“源”念有所区别。</p> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E8%B7%A8%E6%BA%90%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE" target="_blank" rel="noopener noreferrer">MDN 文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>Cookie 的 set：一个页面可以为本域和其父域设置 cookie，只要是父域不是公共后缀（public suffix）即可。<br>
Cookie 的 get：浏览器都允许给定的域以及其任何子域名 (sub-domains) <strong>访问</strong> cookie。当你设置 cookie 时，你可以使用 <code>Domain</code>、<code>Path</code>、<code>Secure</code>、和 HttpOnly 标记来限定其可<strong>访问</strong>性。</p></blockquote> <p>理解起来有点绕，可以用一个例子来解释。假设前端域名为 <code>app.example.com</code>，后端域名为 <code>api.example.com</code>：</p> <ol><li>如果后端对发来的域名不加以设置，后端的 cookie 的 domain 就是默认的 <code>api.example.com</code>。此时，前端并不能<strong>访问</strong>该 cookie，因为前端域名不是后端域名（或其子域名）；</li> <li>正确的解决办法是，<strong>后端把 cookie 的 domain 设置为 <code>example.com</code></strong>（一个页面可以为父域设置 cookie）然后发给前端，前端也可以<strong>访问</strong>到这个 cookie（浏览器都允许 <code>example.com</code> 的子域名 (sub-domains) <strong>访问</strong> 这个 cookie）</li></ol> <p>上面的<strong>访问</strong>都进行了加粗，注意到这个访问的含义是：前端使用 <code>document.cookie</code> 可以看到这个 cookie。在实际操作中，可能你虽然看不到这个 cookie，但是发 XMLHttpRequest 时浏览器会提交这个 cookie，这不叫<strong>访问</strong>。</p> <h2 id="cors-跨域资源共享"><a href="#cors-跨域资源共享" class="header-anchor">#</a> CORS 跨域资源共享</h2> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener noreferrer">跨源资源共享（CORS）- HTTP | MDN<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>同源策略屏蔽了所有的跨域访问。但是，并不是所有跨域访问都是恶意的，比如 <code>tmall.com</code> 前端想要向 <code>taobao.com</code> 后端发起 HTTP 请求这种情况，该怎么处理呢？</p> <p>所以，CORS（Cross-Origin Resource Sharing，跨域资源共享）出现了。CORS 由一系列 HTTP 头组成，当<strong>前端</strong>想要<strong>跨域访问后端</strong>时，<strong>浏览器</strong>将会利用这些 HTTP 头与<strong>后端</strong>交互，让<strong>后端</strong>告诉<strong>浏览器</strong>决定是否阻止<strong>前端</strong>获取跨域请求的响应。</p> <p>在 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CORS" target="_blank" rel="noopener noreferrer">MDN<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 可以看到，CORS 一共只规定了九个 HTTP 头，除掉 <code>Origin</code> 以外，其余的全部以 <code>Access-Control-</code> 打头。</p> <p>下面是一次跨域请求的示例，前端 <code>localhost:8080</code> 向后端 <code>uestcmsc-webapp.lyh543.cn</code> 发出了 HTTP 请求。浏览器使用了两次请求，第一次被称为<strong>预请求</strong>，第二次被称为<strong>正式请求</strong>：</p> <p><img src="/images/002a229b9263643bc576ec37992275e9ca2f79f9d63137b018cb5a216a1475cc.png" alt="浏览器第一次预请求"></p> <p><strong>浏览器</strong>首先在预请求中告诉<strong>后端</strong>：正式请求中的 HTTP 方法是 <code>access-control-request-method: POST</code> 以及会用到的报头为 <code>access-control-request-headers: content-type</code>，还有<strong>前端</strong>的源是 <code>origin: http://localhost:8080</code>。后端的应答中表明允许的源、报头、HTTP 方法，还有一个允许携带认证信息 <code>access-control-allow-credentials: true</code>（认证信息有三类，包含 Cookie、authorization 头和 TLS 客户端证书）。</p> <p><img src="/images/977d9413f8c1915937444167bd92d95b78109093c0da52490ba8c2871e0c0a4f.png" alt="浏览器第二次正式请求"></p> <p>收到后端的报文后，<strong>浏览器</strong>立刻向后端发出 CORS 的正式请求。在正式请求中，浏览器使用了 <code>POST</code> 和 <code>content-type</code>，以及 <code>origin: http://localhost:8080</code>，后端返回 <code>access-control-allow-credentials: true</code> <code>access-control-allow-origin: http://localhost:8080</code></p> <hr> <p>从上面可以看出，如果需要支持 CORS，主要是后端需要进行单独配置。前端没有什么要配置的，但是因为：</p> <blockquote><p>Credentials必须在前后端都被配置（即the Access-Control-Allow-Credentials header 和 XHR 或Fetch request中都要配置）才能使带credentials的CORS请求成功。-- <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials" target="_blank" rel="noopener noreferrer">MDN<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>前端需要配置的只有这一个点。</p> <p>前端的配置很简单，对于 axios 来说，就是加上一行 <code>withCredentials: true</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">&quot;axios&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> service <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'https://uestcmsc-webapp.lyh543.cn/api'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>                <span class="token comment">// 请求的超时时间</span>
  <span class="token literal-property property">withCredentials</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment">// 允许携带 cookie sessionid 做认证</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> service<span class="token punctuation">;</span>
</code></pre></div><p>后端 Django 配置就要麻烦一些了，需要安装 <code>django-cors-headers</code>，然后在 <code>settings.py</code> 里添加：</p> <div class="language-py extra-class"><pre class="language-py"><code>INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token comment"># ...</span>
    <span class="token string">'corsheaders'</span><span class="token punctuation">,</span>
    <span class="token comment">#...</span>
<span class="token punctuation">]</span>

MIDDLEWARE <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">'corsheaders.middleware.CorsMiddleware'</span><span class="token punctuation">,</span>  <span class="token comment"># CORS 中间件，需注意与其他中间件顺序，这里放在最前面即可</span>
    <span class="token comment">#...</span>
<span class="token punctuation">]</span>

<span class="token comment"># CORS headers</span>
<span class="token comment"># 这里的 CORS 策略是允许所有源的前端跨站访问</span>
<span class="token comment"># 也可以根据自己需要设置 CORS 源白名单，然后阻止白名单以外的</span>
CORS_ORIGIN_ALLOW_ALL <span class="token operator">=</span> <span class="token boolean">True</span>
CORS_ALLOW_CREDENTIALS <span class="token operator">=</span> <span class="token boolean">True</span>
CORS_ALLOW_METHODS <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token string">'DELETE'</span><span class="token punctuation">,</span>
    <span class="token string">'GET'</span><span class="token punctuation">,</span>
    <span class="token string">'OPTIONS'</span><span class="token punctuation">,</span>
    <span class="token string">'PATCH'</span><span class="token punctuation">,</span>
    <span class="token string">'POST'</span><span class="token punctuation">,</span>
    <span class="token string">'PUT'</span><span class="token punctuation">,</span>
    <span class="token string">'VIEW'</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
CORS_ALLOW_HEADERS <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token string">'XMLHttpRequest'</span><span class="token punctuation">,</span>
    <span class="token string">'X_FILENAME'</span><span class="token punctuation">,</span>
    <span class="token string">'accept-encoding'</span><span class="token punctuation">,</span>
    <span class="token string">'authorization'</span><span class="token punctuation">,</span>
    <span class="token string">'content-type'</span><span class="token punctuation">,</span>
    <span class="token string">'dnt'</span><span class="token punctuation">,</span>
    <span class="token string">'origin'</span><span class="token punctuation">,</span>
    <span class="token string">'user-agent'</span><span class="token punctuation">,</span>
    <span class="token string">'x-csrftoken'</span><span class="token punctuation">,</span>
    <span class="token string">'x-requested-with'</span><span class="token punctuation">,</span>
    <span class="token string">'Pragma'</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre></div><p>配置好以后就可以了。</p> <h2 id="csrf-跨站伪造请求攻击"><a href="#csrf-跨站伪造请求攻击" class="header-anchor">#</a> CSRF 跨站伪造请求攻击</h2> <p>CSRF（Cross-site request forgery）跨站请求伪造，是一种常见的攻击方式。是指 A （前端、后端）网站正常登陆后，cookie 正常保存，恶意<strong>前端</strong>网站 B 通过某种方式访问 A 网站的<strong>后端</strong>进行操作，而<strong>浏览器</strong>向 A <strong>后端</strong>请求时会自动带上 Cookie、造成危害的攻击方式。</p> <p>好，到这里我就懵了，同源策略不就是用来防止 B 前端访问到 A 后端的吗？但请注意以下两点：</p> <ol><li>同源策略不限制通过 <code>&lt;img&gt;</code> <code>&lt;tag&gt;</code> <code>&lt;form&gt;</code> 加载/上传跨域资源</li> <li>一个公共的后端 API 应当允许所有人使用，但它应当恶意前端误导用户的情况（如 Google Mail 就曾因为没有配置 CSRF 导致恶意前端诱导用户发送邮件），同源策略 + CORS 显然不能做到这一点</li></ol> <p>所以，仅有同源策略 + CORS 是不够的，还需要有 CSRF 防御。</p> <hr> <p>针对 CSRF 这种攻击行为的防御方式有很多种，其实很常见的要求输入验证码等也能算作一种。Django 采用的<a href="https://docs.djangoproject.com/zh-hans/3.1/ref/csrf/" target="_blank" rel="noopener noreferrer">策略<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>如下所述：</p> <ol><li>默认对 HTTP GET、HEAD、OPTIONS 或 TRACE 这类<strong>安全请求</strong>不要求 CSRF 检查，对其他请求要求 CSRF 检查。可以通过 <code>@csrf_exempt</code> 和 <code>@csrf_protect</code> 自定义这个白名单；</li> <li>在登录成功的应答中，会有 <code>Set-Cookie</code> 报头，除了给会话的 <code>sessionid</code> 以外，还会给 <code>csrftoken</code>，如下图所示；</li></ol> <p><img src="/images/3a698b89e8ec02e29f9ea925aec7df27531ee5f97771d5d99a0662d4d53ecc23.png" alt="登录成功给 csrftoken"></p> <p>有了 <code>Set-Cookie</code> 报头，浏览器会自动把 <code>csrftoken</code>，以及 <code>sessionid</code> 存为 Cookie，在 Chrome 很容易就能看到，如下图所示。</p> <p><img src="/images/99f9ded49439a328d22b93c583821c7f2d67c258f71a14348fd2430b5e90ae60.png" alt="Chrome 查看 Cookie"></p> <ol start="3"><li>在需要 CSRF 检查的请求，前端应当做以下几件事情：
<ol><li>在请求报头添加 <code>csrftoken</code> 的 Cookie；</li> <li>在请求报头添加 <code>X-CSRFToken</code> 字段，其内容等同于 <code>csrftoken</code> Cookie（注：在实际操作中不一定要相等，只需要保证 cookie 和报头都是有效的 CSRF Token 即可）；</li> <li>对于 HTTPS 请求，还需要包含 <code>Referer</code> 报头，一般来说都是自带了的，不会出问题。等实际出问题的时候（我怎么这么惨，什么 bug 都能遇见），我们再讨论 <a href="#referer-%E5%92%8C-referrer-policy">Referer 和 Referrer Policy</a>。</li></ol></li></ol> <p><img src="/images/1ad0dafffa8c800b9322f597e9f19d0e84f38ed14e1b419519a3a667c6680a62.png" alt="HTTP 请求通过 CSRF 检查"></p> <p>对了对了，为什么 Cookie 还不够，还需要在报文添加 <code>X-CSRFToken</code> 字段呢？CSRF 开头举的例子说到，浏览器向 A 后端请求时会自动带上 A 的 Cookie，所以光有 <code>csrftoken</code> Cookie 是没有用的，恶意的 B 前端来请求，也会带上 <code>csrftoken</code> Cookie。但是，B 前端读不了 A 后端为 A 前端设置的 Cookie（见 <a href="#cookie-%E7%9A%84%E6%BA%90">Cookie 的源</a>）。没办法读 csrftoken，也就没有办法设置 <code>X-CSRFToken</code> 为有效值了。</p> <hr> <p>前端响应地要做如下改变：</p> <ol><li>设置 Cookie，对于 axios 添加 <code>withCredentials: true</code> 就可以了，和上面 CORS 是一样的；</li> <li>在请求报头添加 <code>X-CSRFToken</code> 字段， axios 也有提供配置，但由于各后端的 Cookie 名和报头名不同，所以自己手动设定一下名字即可；</li> <li><code>Referer</code> 报头一般不需要自己配置，默认即可（实际上，在特殊的情况下会出错，这个放到 <a href="#referer-%E5%92%8C-referrer-policy">Referer 和 Referrer Policy</a> 部分讨论）。</li></ol> <p>修改的代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">&quot;axios&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> service <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'https://uestcmsc-webapp.lyh543.cn/api'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>                <span class="token comment">// 请求的超时时间</span>
  <span class="token literal-property property">withCredentials</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment">// 允许携带 cookie: sessionid &amp; csrftoken 做认证</span>
  <span class="token literal-property property">xsrfCookieName</span><span class="token operator">:</span> <span class="token string">'csrftoken'</span><span class="token punctuation">,</span>  <span class="token comment">// 添加 CSRF token</span>
  <span class="token literal-property property">xsrfHeaderName</span><span class="token operator">:</span> <span class="token string">'X-CSRFToken'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> service<span class="token punctuation">;</span>
</code></pre></div><hr> <p>然后是后端的配置。如果没有跨域需求，配置比较简单，只需要把 csrf 加入 <code>settings.py</code> 就行了，这个其实在 <code>django-admin startproject</code> 时已经默认生成了：</p> <div class="language-py extra-class"><pre class="language-py"><code>MIDDLEWARE <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">'django.middleware.csrf.CsrfViewMiddleware'</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
</code></pre></div><hr> <p>对于有跨域需求的情况，我们还需要将前端域名加入 <code>CSRF_TRUSTED_ORIGINS</code>：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token comment"># settings.py</span>
CSRF_TRUSTED_ORIGINS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'.uestc-msc.com'</span><span class="token punctuation">]</span>
</code></pre></div><p>如果前后端的跨域拥有相同的根域名（设为 <code>.uestc-msc.com</code>），那么还可以设置 <code>CSRF_COOKIE_DOMAIN</code>（还可以顺便把 <code>SESSION_COOKIE_DOMAIN</code> 也设置了）：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token comment"># settings.py</span>
CSRF_TRUSTED_ORIGINS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'.uestc-msc.com'</span><span class="token punctuation">]</span>
<span class="token keyword">if</span> <span class="token keyword">not</span> DEBUG<span class="token punctuation">:</span>
    CSRF_COOKIE_DOMAIN <span class="token operator">=</span> FRONTEND_TRUSTED_ORIGINS<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    SESSION_COOKIE_DOMAIN <span class="token operator">=</span> FRONTEND_TRUSTED_ORIGINS<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre></div><p>前后端不拥有相同根域名（如 <code>a.com</code> 和 <code>b.com</code>）的情况，<strong>不建议这种情况直接进行跨域访问</strong>，原因见<a href="#%E5%90%8E%E8%AE%B0%E4%B8%89%E6%96%B9-cookie-%E7%9A%84%E5%8E%BB%E8%B7%AF">文末</a>。</p> <hr> <p>另外，后端还要把 <code>X-CSRFToken</code> 放入 <code>CORS_ALLOW_HEADERS</code>。不过，这一点我们在配置 CORS 的时候就顺便做了。</p> <h2 id="samesite-的源"><a href="#samesite-的源" class="header-anchor">#</a> SameSite 的源</h2> <p>上面的一切看上去都是那么完美，对于同源的前后端就只有以上这么一点，但对于非同源的前后端，麻烦事才刚刚开始。</p> <hr> <p>在本地开发环境下非常完美，但是一部署到生产环境就开始出锅，表现在登录成功后，任何 POST/PATCH 操作（修改信息、登出）均显示未登录。</p> <p>检查一下 Cookie，发现什么都没有！</p> <p><img src="/images/615c1b2369975169d37ea47e0af169d536665dea8ab1b7036020403163e18042.png" alt="没有 Cookie"></p> <p>是 <code>Set-Cookie</code> 没有成功吗？查一下登录的应答，发现 Chrome 提示：</p> <blockquote><p>This Set-Cookie was blocked because it had the &quot;SameSite=Lax&quot; ...</p></blockquote> <p><img src="/images/d04294d53ad8838922bc67cad78911e61c1ade9706ce517ffec58a0624ca6fc8.png" alt="Set-Cookie 失败"></p> <p>是这个 SameSite 的问题！</p> <hr> <p>有关 SameSite 的知识可以参考 <a href="https://zhuanlan.zhihu.com/p/103420328" target="_blank" rel="noopener noreferrer">即将到来的Chrome新的Cookie策略 - 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite" target="_blank" rel="noopener noreferrer">SameSite cookies - MDN - Mozilla<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>所以，SameSite（同站）是和 Same Origin（同源）不同的概念。</p> <blockquote><p>同源：两个 Protocol、Port 和 Host 都相同的 URL 是同源的；
跨域：两个 Protocol、Port 和 Host 不都相同的 URL 是跨域的；
同站：两个 eTLD+1 相同的网站是同站的。同站设置的 Cookie 称为一方 Cookie；
跨站：两个 eTLD+1 不同的网站是跨站的。跨站设置的 Cookie 称为三方 Cookie。</p></blockquote> <p>eTLD(effective Top Level Domain) 指的是 <code>.com</code> <code>.cn</code> <code>.xyz</code> <code>.com.cn</code> 这类域名。而 eTLD+1 指的就是 <code>baidu.com</code> <code>pconline.com.cn</code> 这类域名。</p> <p>缕清 SameSite 的概念以后，我们再来说 Set-Cookie 中 SameSite 的作用。</p> <p>一个 Cookie 的 SameSite 属性决定了是否限制跨站请求携带这个 Cookie。SameSite 有三种取值：</p> <ol><li><code>None</code>，即不限制，所有跨站请求（前端和后端跨站的请求）都会携带这个 Cookie；</li> <li><code>Strict</code>，这种情况下，所有跨站请求都不会携带这个 Cookie，只有同站请求可以携带；</li> <li><code>Lax</code>，某些跨站请求（导航到目标网址的 GET 请求，包括链接，预加载请求和 GET 表单）可以携带，其他跨站请求不能携带。</li></ol> <p>需要注意一个细节是，如果要设置 <code>SameSite=None</code>，需要同时给 Cookie 加上 Secure 属性，否则 SameSite=None 失效。而 Secure 意味着后端必须启用了 https。</p> <p>另外，SameSite 也是一个 CSRF 防御的方案。依旧是针对 <a href="#csrf">CSRF</a> 开头举的例子，如果 A 的认证 Cookie 设置了 SameSite 为 <code>Strict</code> 或 <code>Lax</code>，B 前端再向 A 后端发送请求时就不会携带这个 Cookie 了。</p> <p>具体到代码上，在 Django <code>settings.py</code> 加上以下代码即可：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">if</span> <span class="token keyword">not</span> DEBUG<span class="token punctuation">:</span>
    CSRF_COOKIE_SAMESITE <span class="token operator">=</span> <span class="token string">'None'</span>
    CSRF_COOKIE_SECURE <span class="token operator">=</span> <span class="token boolean">True</span>
    LANGUAGE_COOKIE_SAMESITE <span class="token operator">=</span> <span class="token string">'None'</span>
    LANGUAGE_COOKIE_SECURE <span class="token operator">=</span> <span class="token boolean">True</span>
    SESSION_COOKIE_SAMESITE <span class="token operator">=</span> <span class="token string">'None'</span>
    SESSION_COOKIE_SECURE <span class="token operator">=</span> <span class="token boolean">True</span>
</code></pre></div><h2 id="csrf-和跨站-cookie"><a href="#csrf-和跨站-cookie" class="header-anchor">#</a> CSRF 和跨站 Cookie</h2> <p>如果你以为上面的配置就可以了，那你就大错特错了。</p> <p>在进行了上面的配置以后，发现 Django 提示 <code>CSRF cookie not set.</code>。读取</p> <h2 id="csrf-和-session"><a href="#csrf-和-session" class="header-anchor">#</a> CSRF 和 session</h2> <p>不会给 CSRFtoken</p> <h2 id="referer-和-referrer-policy"><a href="#referer-和-referrer-policy" class="header-anchor">#</a> Referer 和 Referrer Policy</h2> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>zh<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- ... --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>referrer<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>strict-origin-when-cross-origin<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- ... --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="后记-三方-cookie-的去路"><a href="#后记-三方-cookie-的去路" class="header-anchor">#</a> 后记：三方 Cookie 的去路</h2> <p>上面似乎解决了所有问题，但是，还有一个问题，是越来越多的浏览器开始默认禁用第三方 Cookie 了，现在有 Safari、Firefox，以后估计还会有更多。</p> <p>禁用三方 Cookie，意味着你即使完成了上面所有配置，也不能将跨域后端的 Cookie 存到浏览器中，这套认证方法直接失效。毕竟，各种广告商也是通过三方 Cookie 定位用户然后精准投放广告的。</p> <p>从长久考虑，可以采用其他方法替代：</p> <ol><li>使用同一个根域名（如使用 <code>app.test.com</code> 和 <code>api.test.com</code>）。这样虽然是同源策略下的跨域，但不是 Cookie 概念下的跨域。把后端的 Cookie 域设置为 <code>test.com</code> 后，前端就可以直接读取、修改了；</li> <li>如果前端服务器支持反代，可以把后端 api 反向代理到 <code>app.test.com/api/</code> 下，这样就是完全同源了。后端服务器支持反代的话也是同理；</li> <li>不使用 Session 认证，因为 Session 是基于 Cookie 的；可以改为 Token（如 JSON Web Token）等认证方案，这样的认证方式就完全不需要 Cookie，可以回避跨域 Cookie 引发的一系列问题。</li></ol></div> <hr role="separator" aria-orientation="horizontal" class="ma-4 v-divider theme--light"> <div data-v-54a1e472><script src="https://giscus.app/client.js" async="async" service="giscus" data-repo="lyh543/blog-comments" data-repo-id="R_kgDOHIb2Zg" data-category="Announcements" data-category-id="DIC_kwDOHIb2Zs4COh2z" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" data-v-54a1e472></script></div></div></div></article></div> <!----></container> <div class="v-dialog__container"><button type="button" role="button" aria-haspopup="true" aria-expanded="false" class="v-btn v-btn--bottom v-btn--is-elevated v-btn--fab v-btn--fixed v-btn--has-bg v-btn--right v-btn--round theme--dark v-size--default primary"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-information-variant theme--dark"></i></span></button><!----></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2024</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ab6adf2a.js" defer></script><script src="/assets/js/175.b95721b2.js" defer></script>
  </body>
</html>
