<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>实际开发中借助 React Profiler 调试 React Web app 性能问题 | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/theme/favicon.png">
    <link rel="alternate" type="application/rss+xml" href="https://blog.lyh543.cn/rss.xml" title="小灰灰灰灰的博客 RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://blog.lyh543.cn/feed.atom" title="小灰灰灰灰的博客 Atom Feed">
    <link rel="alternate" type="application/json" href="https://blog.lyh543.cn/feed.json" title="小灰灰灰灰的博客 JSON Feed">
    <meta name="description" content="最近写 React 遇到一个性能问题，调试了一段时间都没什么思路。后来以尝试的心态玩了玩
React Developer Tools 的 React Profiler，得到了一点线索，最终找到了问题 ...">
    
    <link rel="preload" href="/assets/css/0.styles.94ecd5c7.css" as="style"><link rel="preload" href="/assets/js/app.19519f5f.js" as="script"><link rel="preload" href="/assets/js/210.d2bf0285.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.94ecd5c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><div class="container"><div class="row justify-center"><div class="col-sm-9 col-12"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><div class="v-card v-sheet theme--light"><div class="container"><div itemprop="articleBody" class="markdown-body content__default"><p>最近写 React 遇到一个性能问题，调试了一段时间都没什么思路。后来以尝试的心态玩了玩
<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener noreferrer">React Developer Tools<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的 React Profiler，得到了一点线索，最终找到了问题<s>是自己写屎了</s>。</p> <hr> <p>编写的页面结构是这样的：页面上有一个表单 <code>Form</code> 和一个地图 <code>Map</code> 组件，地图组件里除了用到百度地图 <a href="https://huiyan.baidu.com/github/react-bmapgl/" target="_blank" rel="noopener noreferrer">React-BMapGL<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，还有一个组件负责在地图上渲染 70 万个点，还写了一个工具箱组件用于控制点的颜色等（其实工具箱也是一个表单）。</p> <p><img src="/images/db2a9de943eb7357f208564aa9f6cc53204fadd95df7c231ea9c69d1dd0cc91a.png" alt="1111"></p> <p>70 万个点对于 Web 前端可不是一个小数目。React-BMapGL 提供的在地图上渲染点的 API，其实现是在地图上直接添加 DOM 元素，实测一秒只能渲染 2 万左右个点（相当于一秒钟添加 2 万个 DOM 元素，DOM 的性能本身也很烂）。要想在 Web 前端渲染 70 万个点，肯定不能基于 DOM 来做。常见的思路是基于 WebGL。百度地图 JS API 没有直接提供在地图上渲染海量点的 API，但提供了 <a href="https://lbsyun.baidu.com/solutions/mapvdata" target="_blank" rel="noopener noreferrer">MapVGL<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 库来间接实现渲染海量点。测试了一下，可以使用 WebGL 在地图上渲染 2000 万个点（再多就超过 4G 内存、浏览器 OOM 了）。</p> <p>回到正题，70 万个点数量很大，在加载、处理、渲染的时候都需要注意性能和内存使用问题，如果优化不到位，很容易出现掉帧、卡顿等性能问题。</p> <p>本次的主角是一个 <code>Switch</code> 开关组件，它放在 <code>Toolbox</code> 里，负责修改 <code>PointCollection</code> 的颜色等配置，所以需要在 <code>Map</code> 组件里创建了一个 state 名为 <code>pointCollectionConfigState</code>，将这个 state 传给 <code>Toolbox</code> 和 <code>PointCollection</code>，<code>Toolbox</code> 负责修改 state（也会读取 state 用于展示 <code>Switch</code> 状态），<code>PointCollection</code> 负责读取 state。这样写下来没有什么问题，切换 <code>Switch</code> 状态没有出现卡顿的情况。</p> <p><img src="/images/c4a3e7caf2e39fe63ccb1748ab5dbba5a33634545a326b186eee5cce60789f87.png" alt="picture 2"></p> <p>后来业务上需要把这个 <code>Switch</code> 放到 <code>Form</code> 里，于是把这个 state 提升到 <code>Page</code> 里，这样就可以传给 <code>Form</code> 和 <code>Map</code>，<code>Map</code> 再传给 <code>PointCollection</code>。<strong>如此操作以后，发现切换 <code>Switch</code> 状态时会出现明显的卡顿</strong>。</p> <p><img src="/images/f5fc625e2172851034b0e38e259850ee88c55592bf3b7aaa4355b42f4b90b4b4.png" alt="picture 3"></p> <p><code>Page</code> 里面有一个从后端获取数据的 hook，但是数据加载完成后把结果做了一层简单的缓存。<code>Switch</code> 状态变化后，这个 hook 不会再次从后端获取数据，所以这个 hook 不会消耗太多时间。除此之外 <code>Page</code> 没有其它逻辑，所以 <code>Page</code> 这一层不像会有瓶颈。</p> <p>上面有提到，70 万个点的场景下，优化不到位就很容易可能出现卡顿问题，所以我花了一些精力优化 <code>Map</code> 和 <code>PointCollection</code> 的实现。尝试了一些方案，诸如：</p> <ol><li>将 <code>Toolbox</code> 从百度地图 DOM 的 children 移动到和百度地图同级</li> <li>每次 <code>PointCollection</code> 的 Props 变化时，从销毁、重建 MapVGL 图层刷新改为修改图层选项</li> <li>为 <code>PointCollection</code> 实现了 <code>hide</code> 的 Props，当上层需要隐藏 <code>PointCollection</code> 时，不需要销毁 <code>PointCollection</code>，只需要设置 <code>hide=true</code>，<code>PointCollection</code> 调用 <code>hideLayer</code> 隐藏图层。</li></ol> <p>这些方案都能减少重新渲染图层的次数，在不需要重新渲染的场景下，不再做无意义的重复渲染数十万个点。</p> <p>然而 <code>Switch</code> 切换卡顿的问题仍然存在。我甚至差点考虑给组件加 <a href="https://react.dev/reference/react/memo" target="_blank" rel="noopener noreferrer">React.memo()<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来跳过一些重复渲染。</p> <p>后来我打开了 React Profiler，尝试从 profile 中找到一些线索。Profiler 的使用很简单，打开 Chrome Devtools，切换到 <code>React Profiler</code> 的 tab，点击开始录制，然后复现一遍卡顿的情形（这里就是切换一下 <code>Switch</code> 状态），点击结束录制。这样就能看到录制的这段时间里，React 框架在哪些操作上耗时较多。</p> <p><img src="/images/24d1333fac0ae5b2f2c8c31656c89bd4fcf72f873a69218098f0102bc31dc100.png" alt="picture 5"></p> <p><strong>从录制结果里可以看到，这段时间里 <code>PointCollection</code> 的 passive effect 占了大头，大约 700ms</strong>。我也做了一下对照实验，使用之前 <code>Switch</code> 放在 <code>Toolbox</code> 的代码进行 profile，测试下来同样是 <code>PointCollection</code> 的 passive effect 占大头，但只有 150ms。虽然并不清楚具体是哪个 passive effect 耗时，但是至少有一点方向了：耗时的代码不在 <code>Page</code> 或者 <code>Map</code>，而是在 <code>PointCollection</code>。</p> <p><code>PointCollection</code> 的代码是一堆 <code>useEffect</code>，只有当 Props 变化时才会触发 <code>useEffect</code> 函数执行，而这些函数都很耗时。不过，在代码修改中，我只是挪动了一下 state 的位置，为什么会影响到 <code>useEffect</code> 的执行时间？</p> <p>所以这次，我给 <code>PointCollection</code> 例的每个 useEffect 都加了一个 <code>console.log()</code>，来观察切换 Switch 后哪些属性发生变化了（或许有直接通过 React Devtools 查看的方法，不过我习惯 console.log 了），结果发现切换 Switch 以后，<code>points</code> 变化了。要知道这个 Switch 不会影响到 <code>points</code> 数据，这些 <code>points</code> 数据完全来自于 Page 中负责加载数据的 hook。难道说？</p> <p>发现这一点后，我从 <code>PointCollection</code> 开始往上检查了 <code>points</code> 的数据流，发现 <code>Map</code> 和 <code>Page</code> 都是直接传递数据，中间并没有修改过，而 <code>Page</code> 中负责加载数据的那个 hook，创建 <code>points</code> 数组时并没有加 <code>useMemo</code>！<strong>也就是说，每次 Page 重新渲染时调用这个 hook，而 hook 返回的 <code>points</code> 都是一个重新创建的、全新的数组，导致 <code>PointCollection</code> 认为 <code>points</code> 每次都发生了变化、重新渲染一遍所有点</strong>。在之前的代码版本里，由于 state 是在 Map 里定义的，修改 state 只会触发 Map 重渲染，Page 不会重渲染，从而不会触发这个 bug。</p> <div class="language-diff extra-class"><pre class="language-diff"><code><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> export function useLoadData(...) {
</span><span class="token prefix unchanged"> </span><span class="token line">   const result = useMemo(() =&gt; ..., [...]);
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   const points = result.filter(...);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   const points = useMemo(() =&gt; result.filter(...), [result]);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   return {
</span><span class="token prefix unchanged"> </span><span class="token line">     points,
</span><span class="token prefix unchanged"> </span><span class="token line">     ...
</span><span class="token prefix unchanged"> </span><span class="token line">   };
</span><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span></code></pre></div><p>所以真的就是代码写屎了。解决方法也很简单，给 hook 里的 <code>points</code>（和 <code>points</code> 的依赖）套一层 <code>useMemo</code>，保证以相同参数重复调用 hook 时不会创建新的 <code>points</code> 数组即可。</p> <hr> <p>在这段调试过程中，说实话并没有很深入地使用到 React Profiler。但这个例子中可以体会到 React Profiler 有什么能力，在什么场景下很有帮助。具体来说，<strong>出现性能问题时，React Profiler 能够帮助定位到是哪个组件的 passive effect（以及渲染哪个组件时）消耗了大量时间，帮助开发者将调试范围从整个页面、整个组件树缩小到具体的某一个组件</strong>。</p></div> <hr role="separator" aria-orientation="horizontal" class="ma-4 v-divider theme--light"> <div data-v-5794ffe6><script src="https://giscus.app/client.js" async="async" service="giscus" data-repo="lyh543/blog-comments" data-repo-id="R_kgDOHIb2Zg" data-category="Announcements" data-category-id="DIC_kwDOHIb2Zs4COh2z" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" data-v-5794ffe6></script></div></div></div></article></div> <!----></div></div> <div class="v-dialog__container"><button type="button" role="button" aria-haspopup="true" aria-expanded="false" class="v-btn v-btn--bottom v-btn--is-elevated v-btn--fab v-btn--fixed v-btn--has-bg v-btn--right v-btn--round theme--dark v-size--default primary"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-information-variant theme--dark"></i></span></button><!----></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2024</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.19519f5f.js" defer></script><script src="/assets/js/210.d2bf0285.js" defer></script>
  </body>
</html>
