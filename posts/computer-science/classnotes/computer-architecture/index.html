<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机系统结构 复习笔记 | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/theme/favicon.png">
    <meta name="description" content="
引言

处理器惊人的性能改进

处理器惊人的性能改进

分析：
每年 25%（1978-1986）: 性能增长主要依赖实现技术的进步
每年 52%（1986-2003）: 性能增长依赖两方面：
  系统结 ...">
    
    <link rel="preload" href="/assets/css/0.styles.60b80ac7.css" as="style"><link rel="preload" href="/assets/js/app.3ee1271d.js" as="script"><link rel="preload" href="/assets/js/41.d3dd01f6.js" as="script"><link rel="preload" href="/assets/js/4.c36cbde9.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60b80ac7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><div class="content__default"><h2 id="第一章-量化设计与分析基础"><a href="#第一章-量化设计与分析基础" class="header-anchor">#</a> 第一章 量化设计与分析基础</h2> <h3 id="引言"><a href="#引言" class="header-anchor">#</a> 引言</h3> <h4 id="处理器惊人的性能改进"><a href="#处理器惊人的性能改进" class="header-anchor">#</a> 处理器惊人的性能改进</h4> <p><img src="/images/c41ef765f8191573d0e90137e7fc29f14f38ff83ce79065843de8b497190bc2b.png" alt="处理器惊人的性能改进"></p> <p>分析：</p> <ul><li>每年 25%（1978-1986）: 性能增长主要依赖实现技术的进步</li> <li>每年 52%（1986-2003）: 性能增长依赖两方面：
<ul><li>系统结构革新（<strong>RISC</strong>，<strong>指令级并行</strong> (ILP) 技术与Cache）；</li> <li>实现技术的进步</li></ul></li> <li>每年 22%（2004-2010）: ILP 开发的限制，功耗限制，因此其后性能提升手段出现了以下趋势：
<ul><li>ILP  变为 <strong>TLP and DLP</strong>（线程级并行和数据级并行）</li> <li>更快的单核处理器 变为 <strong>单芯片多处理器</strong>（多核）</li> <li>隐含在编译器和硬件的硬件级并行处理 变为 显示的<strong>程序级并行</strong></li></ul></li></ul> <h3 id="计算机的分类"><a href="#计算机的分类" class="header-anchor">#</a> 计算机的分类</h3> <h4 id="基于指令流和数据流数量分类-xixd"><a href="#基于指令流和数据流数量分类-xixd" class="header-anchor">#</a> 基于指令流和数据流数量分类 (XIXD)</h4> <h4 id="基于市场分类"><a href="#基于市场分类" class="header-anchor">#</a> 基于市场分类</h4> <h3 id="计算机系统结构定义与计算机的设计任务"><a href="#计算机系统结构定义与计算机的设计任务" class="header-anchor">#</a> 计算机系统结构定义与计算机的设计任务</h3> <h4 id="计算机系统结构-原始定义"><a href="#计算机系统结构-原始定义" class="header-anchor">#</a> 计算机系统结构（原始定义）</h4> <p>计算机系统结构的原始慨念：</p> <blockquote><p>由程序员看见的计算机系统，就是<strong>慨念性结构</strong>和<strong>功能行为</strong>，以区分数据流动和控制逻辑设计的组成及物理实现。  -- Amdahl, Blaaw, and Brooks, 1964</p></blockquote> <p><img src="/images/e210f27c2af7a036b31d165446e01c6f0da4ffc97fe7f6eae9c7870a1f73fd96.png" alt="指令系统"></p> <p>下面讨论<strong>计算机系统结构</strong>、<strong>计算机组成</strong>和<strong>物理实现</strong>及其关系关系。</p> <blockquote><p>经典的<strong>计算机系统结构</strong>是机器语言程序员所看到的传统机器级所具有的<strong>属性</strong>。它确定计算机系统的软、硬件界面。
<strong>计算机组成</strong>指的是计算机系统结构的<strong>逻辑实现</strong>，包括五大功能部件组成以及逻辑设计等。它着眼于机器级内各事件的排序方式与控制方式，各部件的功能以及各部件的联系。
<strong>计算机实现</strong>指的是计算机组成的<strong>物理实现</strong>，包括处理机、主存等部件的物理结构，器件的集成度和速度功耗，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。它着眼于器件技术和微组装技术，其中器件技术在实现技术中占主导作用。</p></blockquote> <blockquote><p>① 主存容量与编址方式(按位、按字节、按字访问等)的确定属于计算机系统结构。
② 为达到所定性能价格比，主存速度应多快，在逻辑结构上需采用什么措施(如多体交叉存储等)属于计算机组成。
③ 主存系统的物理实现，如存储器器件的选定、逻辑电路的设计、微组装技术的选定属于计算机实现。</p></blockquote> <blockquote><p>具有<strong>相同计算机系统结构</strong>(指令系统相同)的计算机，因为速度要求不同等因素可以采用<strong>不同的计算机组成</strong>。例如，AMD Opteron 64与 Intel Pentium 4的指令系统相同，即两者的系统结构相同；但内部组成不同，流水线和Cache结构是完全不同的，相同的程序在两个机器上的的运行时间可能不同。
<strong>一种计算机组成</strong>可以采用多种<strong>不同的计算机实现</strong>。例如，主存器件可以采用SRAM芯片，也可以采用DRAM芯片。</p></blockquote> <blockquote><p><strong>系列机</strong>（family machine）：是指由一个制造商生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的计算机。
主要缺点：系列机为了保证软件的向后兼容，要求体系结构基本不改变，这无疑又妨碍了计算机体系结构的发展。</p></blockquote> <blockquote><p><strong>软件兼容性</strong>：同一个软件可以不加修改地运行于系统结构相同的各档机器上，而且运行结果一样，差别只是运行时间不同。
向<strong>后</strong>兼容：在某一时间生产的机器上运行的目标软件能够直接运行于更晚生产的机器上。
向<strong>上</strong>兼容：在低档机器上运行的目标软件能够直接运行于高档机器上。</p></blockquote> <h4 id="计算机系统结构-现代定义"><a href="#计算机系统结构-现代定义" class="header-anchor">#</a> 计算机系统结构（现代定义）</h4> <blockquote><p>计算机系统结构（现代定义）：是在满足功能、性能和价格目标的条件下，设计、选择和互连硬件部件构成计算机。</p></blockquote> <p>系统结构覆盖了：</p> <ul><li>指令系统设计</li> <li>组成（Organization）：计算机设计方面的高层次
<ul><li>CPU内部结构、存储器、I/O系统、多处理器、网络</li> <li>硬件: 计算机的具体实现技术</li> <li>详细逻辑设计、封装、冷却系统、板级设计，功耗等</li></ul></li></ul> <p><img src="/images/9c121277140d7e947db4dafc4fbe194bbe6240111b553e771bd8b4a3ed553a96.png" alt="计算机系统结构（单处理器）"></p> <p>绿色部分 (ILP) 本课程不讲，只讲黄色部分。</p> <p><img src="/images/99f94e94f25e5063eb6023b9342c3649169d261960d030194256612cfccb64ad.png" alt="计算机系统结构（多处理器）"></p> <h2 id="第三章"><a href="#第三章" class="header-anchor">#</a> 第三章</h2> <h3 id="结构冒险"><a href="#结构冒险" class="header-anchor">#</a> 结构冒险</h3> <h3 id="数据冒险"><a href="#数据冒险" class="header-anchor">#</a> 数据冒险</h3> <p>解决办法：</p> <ol><li>软件方法：编译器插入NOP（暂停相关流水线）</li> <li>硬件方法1：硬件插入 stall（暂停相关流水线）</li> <li>硬件方法2：内部前推</li> <li>硬件方法3：stall+内部前推（针对 store 指令）</li></ol> <h4 id="硬件插入-stall"><a href="#硬件插入-stall" class="header-anchor">#</a> 硬件插入 stall</h4> <p>核心：ID 指令等前面的指令走完 WB （写寄存器）以后再继续（读寄存器）</p> <p><strong>停顿条件：(ID 级指令 rs1/2 == EXE/MEM 级指令 rd) &amp;&amp; (EXE/MEM 级指令要写寄存器) &amp;&amp; (ID 级要读寄存器)</strong></p> <div class="language- extra-class"><pre class="language-text"><code>DEPEN=(ID_rs1==EXE_rd)(EXE_WREG==1)(ID_rs1IsReg)+
      (ID_rs1==MEM_rd)(MEM_WREG==1)(ID_rs1IsReg)+
      (ID_rs2==EXE_rd)(EXE_WREG==1)(ID_rs2IsReg)+
       (ID_rd==EXE_rd)(EXE_WREG==1)(store)+
      (ID_rs2==MEM_rd)(MEM_WREG==1)(ID_rs2IsReg)+
       (1D_rd==MEM_rd)(MEM_WREG==1)(store)
</code></pre></div><ul><li><code>ID_rs1IsReg</code> 条件是为了排除转移指令</li></ul> <div class="language- extra-class"><pre class="language-text"><code>ID_rs1IsReg=and+andi+or+ori+add+addi+sub+subi+load+store
ID_rs2IsReg=and+or+add+sub（排除立即数运算指令）
</code></pre></div><hr> <p>进行简单改写：</p> <div class="language- extra-class"><pre class="language-text"><code>DEPEN = A_DEPEN + B_DEPEN
A_DEPEN = EXE_A_DEPEN + MEM_A_DEPEN
B_DEPEN = EXE_B_DEPEN + MEM_B_DEPEN

EXE_A_DEPEN = (ID_rs1==EXE_rd)(EXE_WREG==1)(ID_rs1IsReg)
MEM_A_DEPEN = (ID_rs1==MEM_rd)(MEM_WREG==1)(ID_rs1IsReg)
EXE_B_DEPEN = (ID_rs2==EXE_rd)(EXE_WREG==1)(ID_rs2IsReg) +
               (ID_rd==EXE_rd)(EXE_WREG==1)(store)
MEM_B_DEPEN = (ID_rs2==MEM_rd)(MEM_WREG==1)(ID_rs2IsReg)
               (1D_rd==MEM_rd)(MEM_WREG==1)(store)
</code></pre></div><h4 id="内部前推-forwading"><a href="#内部前推-forwading" class="header-anchor">#</a> 内部前推 forwading</h4> <p><img src="/images/544c090f1945ced01ccdaadf6ea9ab5e2191e910329a21859f6a334ca859170e.png" alt="内部前推 初版"></p> <p><img src="/images/0fd1ae059c05b774d2917c4426db53ae4f6fea81d0bd7384cc82ee49585b0556.png" alt="内部前推 时序图"></p> <p><strong>注意时序图里 forwarding 箭头的写法！</strong></p> <p>上一个计算结果可以直接从 ALU 里拿出来，至于多路选择哪个值，就是 <code>ADEPEN</code> 和 <code>BDEPEN</code> 的事情了。</p> <table><thead><tr><th>MEM_WREG</th> <th>EXE_rs1=MEM_rd</th> <th>WB_WREG</th> <th>EXE_rs1=WB_rd</th> <th>ADEPEN</th> <th>ALU 输入选择(A端)</th></tr></thead> <tbody><tr><td>1</td> <td>1</td> <td>x</td> <td>x</td> <td>2</td> <td>MEM_R</td></tr> <tr><td>1</td> <td>0</td> <td>1</td> <td>1</td> <td>3</td> <td>WB_C</td></tr> <tr><td>0</td> <td>x</td> <td>1</td> <td>1</td> <td>3</td> <td>WB_C</td></tr> <tr><td>其他情况</td> <td></td> <td></td> <td></td> <td>0</td> <td>A</td></tr></tbody></table> <p>还是比较显然的。</p> <p>B 端就比 A 端多一个条件：当 <code>EXE_rs2IsReg</code> 成立时就走立即数 (<code>BDEPEN=2</code>)；其他情况下，按 A 端规则进行判断。</p> <hr> <p>和 stall 不同的是：</p> <ol><li>forwarding 考虑的是 EXE 指令和 MEM/WB 指令的关系，stall 考虑的是 ID 指令和 EXE/MEM 指令的关系</li> <li>forwading 不需要考虑转移指令，因为这类指令走不到 EXE 级</li></ol> <hr> <p>进行改进：将检测数据相关的时间从 EXE 级提前到 ID 级。</p> <p><img src="/images/ab09b1e3bea2268297c3226b1629bb925fde236fa25387fecedc877a9eff1a0b.png" alt="内部前推 改进"></p> <h4 id="处理-load-指令-stall-forwarding"><a href="#处理-load-指令-stall-forwarding" class="header-anchor">#</a> 处理 load 指令: stall + forwarding</h4> <p>1 stall + 1 forwading 可以解决 EXE 级 store 和 ID 级 ALU 的数据冲突（称为 <code>load 冒险</code>）。</p> <p>0 stall + 1 forwading 可以解决 MEM 级 store 和 ID 级 ALU 的数据冲突。</p> <p><img src="/images/58622010cfae339191b479b4f6260bc01a94cd25ea7b7e37f1e9fdb21f834bd6.png" alt="stall + forwarding"></p> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <table><thead><tr><th>指令</th> <th>stall/nop</th> <th>forwarding</th></tr></thead> <tbody><tr><td>ALU 指令</td> <td>2 stalls</td> <td>0 stalls + 1 forwarding</td></tr> <tr><td>store 指令</td> <td>2 stalls</td> <td>1 stall + 1 forwarding</td></tr></tbody></table> <h3 id="控制冒险"><a href="#控制冒险" class="header-anchor">#</a> 控制冒险</h3> <p>三种解决方法</p> <ol><li>暂停流水线（插 nop 或使用硬件方法）</li> <li>假定转移不发生（针对条件转移）</li></ol> <h4 id="暂停流水线"><a href="#暂停流水线" class="header-anchor">#</a> 暂停流水线</h4> <p>使用软件方法的话，<code>beq</code> <code>bne</code>需要前插 1 个 nop，后插一个 nop；<code>branch</code> 需要后插一个 nop。</p> <p><img src="/images/53296300cbab5a770b9e0caef8648ea3533020ee966447cdacfd5456a97dd777.png" alt="插入 nop"></p> <hr> <p>使用硬件方法就要麻烦一些了。</p> <p>首先要终止后面一条指令的执行，不然转移发生的时候，后一条指令已经到 ID 了，还将继续执行。</p> <p>解决办法和 stall 类似，封锁指令的 WZ、WMEM、WREG。</p> <p><img src="/images/e19c3ed2a48466a604bee97c2c86752f2d8c63cac9287a5aa27b12c80af449d4.png" alt="解决办法"></p> <h4 id="假定转移不发生"><a href="#假定转移不发生" class="header-anchor">#</a> 假定转移不发生</h4> <p>这个其实很简单，就是在装流水线的时候，假设转移不发生，该咋装咋装。</p> <p>所以，如果真的没有转移，1 次停顿都不会有；如果真的转移了，此时在流水线的指令全部要停掉（这个时候，其实就是硬件方法暂停流水线）。</p> <h5 id="例题"><a href="#例题" class="header-anchor">#</a> 例题</h5> <blockquote><p>假设某机器的流水线，转移目标地址计算需要2个流水段，转移条件形成需要3个流水段，完成一个流水段的操作用一个时钟周期。假定解决控制冒险有三种方法：停顿流水线、转移预测未选中、转移选中。试计算条件转移指令采用这三种方法在转移发生与转移不发生所产生的停顿时钟周期数</p></blockquote> <table><thead><tr><th>停顿周期数</th> <th>条件转移发生</th> <th>条件转移未发生</th></tr></thead> <tbody><tr><td>停顿流水线</td> <td>2</td> <td>2</td></tr> <tr><td>预测转移未选中</td> <td>2</td> <td>0</td></tr> <tr><td>预测转移选中</td> <td>1</td> <td>2</td></tr></tbody></table> <h4 id="延迟转移"><a href="#延迟转移" class="header-anchor">#</a> 延迟转移</h4> <p>注意到 <strong>branch/beq/neq 后的代码一定会被执行</strong>。前面的解决办法是在这个位置放一个 nop 或 stall 解决问题禁止它产生效果。但是能不能利用这个特性，让它在这个时候执行一点代码呢？</p> <p>这个就和没有流水线的 MIPS 有点不一样了：</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>Lop： load     <span class="token register variable">r1</span>, <span class="token number">20</span>(<span class="token register variable">r2</span>)
      nop
      addi     <span class="token register variable">r3</span>, <span class="token register variable">r1</span>, <span class="token number">30</span>
      store    <span class="token register variable">r3</span>, <span class="token number">40</span>(<span class="token register variable">r4</span>)
      subicc   <span class="token register variable">r5</span>, <span class="token register variable">r5</span>, <span class="token number">1</span>
      nop
      bne      lop   ；如果Z标志为<span class="token number">0</span>，即<span class="token register variable">r6</span>的内容不为<span class="token number">0</span>，则转Lop
      nop
</code></pre></div><p>上面没有优化的代码需要 3 个 nop。（假设除了 <code>subicc</code> 以外，其他指令不修改标志位，所以 <code>subicc</code> 不需要放在 <code>bne</code> 前）优化以后，一个 nop 都不需要！</p> <div class="language-nasm extra-class"><pre class="language-nasm"><code>Lop： load     <span class="token register variable">r1</span>, <span class="token number">20</span>(<span class="token register variable">r2</span>)
      subicc   <span class="token register variable">r5</span>, <span class="token register variable">r5</span>, <span class="token number">1</span>
      addi     <span class="token register variable">r3</span>, <span class="token register variable">r1</span>, <span class="token number">30</span>
      bne      lop   ；如果Z标志为<span class="token number">0</span>，即<span class="token register variable">r6</span>的内容不为<span class="token number">0</span>，则转Lop
      store    <span class="token register variable">r3</span>, <span class="token number">40</span>(<span class="token register variable">r4</span>)
</code></pre></div><p>非常神奇的是，<strong>store 指令摆在 bne 以后，但每次跳转仍然会被执行</strong>。这是和单周期 CPU 非常不同的一点。</p></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2021</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"><div id="pwa-snackbar" class="v-snack v-snack--bottom v-snack--has-background v-snack--right v-snack--vertical" style="padding-bottom:0px;padding-top:0px;" data-v-fec8b358><div class="v-snack__wrapper v-sheet theme--dark" style="display:none;"><div role="status" aria-live="polite" class="v-snack__content">
    博客已更新！
    </div><div class="v-snack__action "><button type="button" id="pwa-button" class="v-btn v-btn--has-bg theme--dark v-size--default v-snack__btn"><span class="v-btn__content">
        刷新
      </span></button></div></div></div></div></div>
    <script src="/assets/js/app.3ee1271d.js" defer></script><script src="/assets/js/41.d3dd01f6.js" defer></script><script src="/assets/js/4.c36cbde9.js" defer></script>
  </body>
</html>
