<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>并行计算 课程笔记 | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/theme/favicon.png">
    <link rel="alternate" type="application/rss+xml" href="https://blog.lyh543.cn/rss.xml" title="小灰灰灰灰的博客 RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://blog.lyh543.cn/feed.atom" title="小灰灰灰灰的博客 Atom Feed">
    <link rel="alternate" type="application/json" href="https://blog.lyh543.cn/feed.json" title="小灰灰灰灰的博客 JSON Feed">
    <meta name="description" content="
什么是并行计算

并行计算 (parallel computing)：在同一个计算机体系的多个处理器/电脑一起工作解决一个问题
分布式计算 (distributed computing)：分布在多个计算机体系（异地）的处理器/电脑一起工作解决一个问题
并行计算机 (parallel computer)：一个多核的计算机系统
  并行计算机分为多计算机系统 ...">
    
    <link rel="preload" href="/assets/css/0.styles.05080bcb.css" as="style"><link rel="preload" href="/assets/js/app.c07ccffd.js" as="script"><link rel="preload" href="/assets/js/44.26ac42e2.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.05080bcb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><div class="container"><div class="row justify-center"><div class="col-sm-9 col-12"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><div class="v-card v-sheet theme--light"><div class="container"><div itemprop="articleBody" class="markdown-body content__default"><h2 id="_1-introduction"><a href="#_1-introduction" class="header-anchor">#</a> 1 Introduction</h2> <h3 id="什么是并行计算"><a href="#什么是并行计算" class="header-anchor">#</a> 什么是并行计算</h3> <ul><li>并行计算 (parallel computing)：在<strong>同一个</strong>计算机体系的多个处理器/电脑一起工作解决一个问题</li> <li>分布式计算 (distributed computing)：分布在<strong>多个</strong>计算机体系（异地）的处理器/电脑一起工作解决一个问题</li> <li>并行计算机 (parallel computer)：一个多核的计算机系统
<ul><li>并行计算机分为多计算机系统和中心化多处理器</li> <li>多计算机系统 (multicomputer)：多个计算机通过<strong>内部网络</strong>连接</li> <li>中心化多处理器 (centralized/symmetrical multiprocessor, SMP)：一个计算机系统，其中所有 CPU 共享一个全局<strong>内存</strong></li></ul></li></ul> <p>并行计算多用于科学计算，分布式计算多用于可靠性、可用性、性价比高的计算。</p> <h3 id="为什么需要并行计算"><a href="#为什么需要并行计算" class="header-anchor">#</a> 为什么需要并行计算</h3> <ul><li>微处理器性能增长越来越慢</li> <li>同样的性能下，并行系统功耗更低</li></ul> <h3 id="并行计算关心的问题"><a href="#并行计算关心的问题" class="header-anchor">#</a> 并行计算关心的问题</h3> <p>不懂的地方都给出英文原文……</p> <ul><li>架构上的问题：
<ul><li>Pipline, ILP...</li> <li>缓存一致性</li> <li>单共享总线 or 网络</li> <li>UMA, NUMA, CC-NUMA, Cluster...</li></ul></li> <li>编程模型上的问题：
<ul><li>单寻址空间 or 多寻址空间</li> <li>进程使用锁、消息传递 or 其他方法进行同步</li> <li>分布式 or 中心化内存</li> <li>故障可靠性</li></ul></li> <li>性能表现上的问题：
<ul><li>指标：规模、加速比、可扩展性</li> <li>Models: PRAM，BSP，PPRAM...</li> <li>并行计算的评价方法</li></ul></li> <li>其他问题：
<ul><li>编程语言</li> <li>编程工具</li> <li>可移植性</li> <li>Automatic programming of parallel computers</li> <li>Education of parallel computing philosophy</li></ul></li></ul> <h3 id="如何编写并行程序"><a href="#如何编写并行程序" class="header-anchor">#</a> 如何编写并行程序</h3> <ul><li>需要明确告诉不同处理器如何分工</li> <li>需要把串行程序改写为并行</li> <li>有时候直接改写的效率非常低，需要设计全新的算法</li></ul> <h4 id="举个栗子"><a href="#举个栗子" class="header-anchor">#</a> 举个栗子</h4> <p>例子：求 n 个函数值的和，其串行算法如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token function">compute_next_value</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sum <span class="token operator">+=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>假设我们有 p 个核 (p &lt; n)，每个核计算一部分：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>my_sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
my_first_i <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
my_last_i <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>my_i <span class="token operator">=</span> my_first_i<span class="token punctuation">;</span> my_i <span class="token operator">&lt;</span> my_last_i<span class="token punctuation">;</span> my_i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    my_x <span class="token operator">=</span> <span class="token function">compute_next_value</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    my_sum <span class="token operator">+=</span> my_x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>计算后的结果存在私有变量 <code>my_sum</code> 中。</p> <p>所有核计算完成后，他们将结果发送至班长（一般就设 0 号核为班长），班长负责计算最终的总和。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>I am the master core<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">=</span> my_x<span class="token punctuation">;</span>
    <span class="token keyword">for</span> each core other than myself <span class="token punctuation">{</span>
        receive value from core<span class="token punctuation">;</span>
        sum <span class="token operator">+=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    send my_x to the master<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <p>更好的并行策略是，不要让班长核做所有的合并工作，而是均摊高每个核上。</p> <p>对于这个问题，可以两两组合：</p> <blockquote><p>Work with odd and even numbered pairs of cores. Pair the cores so that core 0 adds its result with core 1's result，Core 2 adds its result with core 3's result, etc.
Repeat the process now with only the evenly ranked cores. Core 0 adds result from core 2. Core 4 adds the result from core 6, etc.
Now cores divisible by 4 repeat the process, and so forth, until core 0 has the final result.</p></blockquote> <p><img src="/images/41c0ee131a061af3d800556179d029af72591aaedc55c8ea27e9de65d708f35e.png" alt="两两组合的求和算法"></p> <p>这种算法中，班长只进行了 3 次通信 + 3 次求和，相较刚开始的 7 次通信 + 3 次求和。如果核数更多，这样优化的效果会更加显著。</p> <p>但是，越复杂的问题，并行的难度会更大（比如翻译程序）。所以我们需要编写并行程序来提高多核的利用率。</p> <h4 id="并行程序的编写方向"><a href="#并行程序的编写方向" class="header-anchor">#</a> 并行程序的编写方向</h4> <ol><li>任务并行：将整个任务分成很多不同的小任务</li> <li>数据并行：将数据进行分块，每个核在自己分到的数据上做相似的任务</li></ol> <hr> <p>例子：3 个老师（A、B、C）批改 300 张试卷，每张试卷 15 题。</p> <ul><li>任务并行（将试卷按题目进行划分）：A 老师批改 1-5 题，B 老师批改 6-10 题，C 老师批改 11-15 题</li> <li>数据并行（将试卷按张数进行划分）：每位老师各批改 100 张试卷</li></ul> <h3 id="习题"><a href="#习题" class="header-anchor">#</a> 习题</h3> <p>在求和的栗子中，设计一个分配任务的函数（该函数负责计算每个核的 <code>my_first_i</code> 和 <code>my_last_i</code>），使得 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个任务尽量均匀地分布在 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span> 个核上。</p> <p>（这个题目后面应该会讲）</p> <p>一个优秀的算法是：</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>m</mi><msub><mi>y</mi><mi>f</mi></msub><mi>i</mi><mi>r</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>i</mi><mo>∗</mo><mi>n</mi></mrow><mi>p</mi></mfrac><mo stretchy="false">⌋</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>m</mi><msub><mi>y</mi><mi>l</mi></msub><mi>a</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>n</mi></mrow><mi>p</mi></mfrac><mo stretchy="false">⌋</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
my_first_i &amp;= \lfloor\frac{i*n}{p}\rfloor \\
my_last_i &amp;= \lfloor\frac{(i+1)*n}{p}\rfloor - 1
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:5.1244em;vertical-align:-2.3122em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8122em;"><span style="top:-4.90268em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.2952400000000006em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3122em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8122em;"><span style="top:-4.90268em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span><span style="top:-2.2952400000000006em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3122em;"><span></span></span></span></span></span></span></span></span></span></span></span></div></section><p>其中 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 为当前核的下标，从 0 开始。</p> <p><code>my_last_i</code> 比较好理解，因为任务分配是连续的，<code>my_last_i</code> 就是 下一个核的 <code>my_first_i</code> 减 1。</p> <p>至于 <code>my_first_i</code> 的由来我也没想清楚，但是它可以保证<strong>所有任务的数量差不超过 1</strong>，很均匀。</p> <p>各位不妨写一个程序模拟一下分配情况，看看每个在不同的 <code>n</code>、<code>p</code> 下，每个核被分了多少个任务、规律是怎么样的。如，在 <code>n=30</code>，<code>p=9</code> 时，该算法会这样分配：</p> <div class="language-txt extra-class"><pre class="language-txt"><code>3 3 4 3 3 4 3 3 4
</code></pre></div><h2 id="_2-parallel-programming-platform"><a href="#_2-parallel-programming-platform" class="header-anchor">#</a> 2 Parallel Programming Platform</h2> <h3 id="对冯诺依曼体系的改进"><a href="#对冯诺依曼体系的改进" class="header-anchor">#</a> 对冯诺依曼体系的改进</h3> <p><img src="/images/a7978bdb70dab368cd8bb46bcc422c604eee9caaa01740bbc643e67898c4c566.png" alt="冯诺依曼体系"></p> <p>冯诺依曼的核心是：存储程序，顺序执行。</p> <p>该体系的瓶颈一般是 CPU 和内存分离。</p> <p>改进分为三个方向：</p> <ol><li>缓存</li> <li>虚拟存储</li> <li>底层的并行（指令集并行、线程级并行）</li></ol> <h4 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h4> <p>缓存：比主存更快的存储。一版用户存放物理上接近、且经常使用的数据和指令。</p> <p>局部性原理略。</p> <p>缓存分为 3 级。</p> <p><img src="/images/65b9ee8cb161a9922d4ea87c47372cd33c7e3e8e174e1406b20ffa7d24a20786.png" alt="3 级缓存"></p> <p>Cache 命中（Cache hit）和不命中（Cache miss）</p> <h5 id="缓存的写策略"><a href="#缓存的写策略" class="header-anchor">#</a> 缓存的写策略</h5> <p>当 CPU 更新缓存的数据时，缓存数据可能会和主存不同。此时有两种策略：</p> <ol><li>Write-through（写直达）：更新缓存的同时更新主存；缓存和主存始终一致，但每次写缓存的速度会变慢。</li> <li>Write-back（写回）：更新缓存时标记缓存为<strong>脏数据（dirty）</strong>，当该行缓存被替换时，脏数据会被写回至主存；写缓存的速度不受影响，但缓存替换时的速度会变慢。</li></ol> <h5 id="缓存的映射方法"><a href="#缓存的映射方法" class="header-anchor">#</a> 缓存的映射方法</h5> <ol><li>全映射：每行内存可以映射在缓存的任意位置</li> <li>直接映射：每行内存只能映射在缓存的固定位置（一般是内存行数下标 % 缓存总行数）</li> <li>n 路组相联映射：将缓存每 n 行分为一组，每行内存可以映射在缓存的固定的组的 n 行中任意一行（一般组号 = 内存行数下标 % 缓存总行数 % n）</li></ol> <p>使用全映射或 n 路组相联映射，还需要考虑替换策略，常见的可以使用 LRU。</p> <h5 id="缓存优化的技巧"><a href="#缓存优化的技巧" class="header-anchor">#</a> 缓存优化的技巧</h5> <p>缓存对于应用程序和程序员是透明的（不能直接控制缓存），但如果知道局部性原理，可以通过改变程序顺序、间接控制缓存，进而优化速度。</p> <ol><li>合并数组（data merge）：通过将两个独立数组合并为一个复合元素的数组来改进空间局部性</li> <li>循环交换（loop interchange）：通过改变循环嵌套来按序访问存储器中存储的数据</li> <li>循环合并（loop fusion）：将两个具有相同循环类型且有一些变量重叠的独立循环合并</li> <li>块化（blocking）：通过不断使用一些数据块（而不是完整地遍历一行和一列）来改进时间局部性</li></ol> <hr> <p><img src="/images/1bd8fa4ca6b97a525fc7df525d418279fb70e3bba08fd46a2c0bcf10b0c120c6.png" alt="循环优化前后的代码"></p> <p>假设缓存大小为 4。第一种循环会发生 4 次缓存未命中、第二种循环会发生 16 次缓存未命中。（注：缓存的机制是，每次缓存不命中会将所在行的 4 个元素全部装进缓存）</p> <h4 id="虚拟内存"><a href="#虚拟内存" class="header-anchor">#</a> 虚拟内存</h4> <p>虚拟内存的大小大于主存，会将不活跃的程序换到磁盘，活跃的程序放到主存，加快速度。</p> <h5 id="指令级并行"><a href="#指令级并行" class="header-anchor">#</a> 指令级并行</h5> <ol><li>流水线技术，参考计算机系统结构</li> <li>某些情况下，多条指令也可以被同时发射</li> <li>分支预测</li></ol> <h5 id="线程级并行"><a href="#线程级并行" class="header-anchor">#</a> 线程级并行</h5> <p>略。</p> <h3 id="并行计算的硬件"><a href="#并行计算的硬件" class="header-anchor">#</a> 并行计算的硬件</h3> <ol><li>SISD（传统冯诺依曼模型）</li> <li>SIMD：对多个数据进行相同操作，1 个控制单元 + 多个 ALU</li> <li>MISD（尚未开发）</li> <li>MIMD：使用多个指令流同时操作多个数据流，多个独立操作单元 + 各自的 ALU</li></ol> <h4 id="mimd-物理组织"><a href="#mimd-物理组织" class="header-anchor">#</a> MIMD 物理组织</h4> <p>从上到下越来越离散：</p> <ol><li>共享缓存架构（Shared Cache Architecture），多为单芯片多处理器</li></ol> <p><img src="/images/b31c842db22a88cc5310ad83dfc800482945582e71cf6fff064d3ebb85e8b8bb.png" alt="共享缓存架构"></p> <ol start="2"><li>统一内存寻址（Uniform Memory Access，UMA）</li></ol> <p><img src="/images/b302fae7a7e7cede86e5fcac13f2f1a1fc688e04e5f29dbcb0e33c9b3bccec73.png" alt="统一内存寻址（UMA）"></p> <ol start="3"><li>独立内存寻址（Non-Uniform Memory Access，NUMA）</li></ol> <p>NUMA 并不是处理器完全不能访问其他块的内存，而是处理器可以直接访问一部分内存+通过处理器内置的特殊硬件访问其他内存。</p> <p><img src="/images/ab410d9b708998ffb51f3aefd91effb7ca4b354f3d760f195c1777f0a985e5bf.png" alt="独立内存寻址（NUMA）"></p> <ol start="4"><li>分布式系统/内存、集群（Distributed System/Memory）</li></ol> <p><img src="/images/5474103543a1e0d0d127a9ed24803072a3fdf677114fb71fa7ad7bec245ee6da.png" alt="分布式系统/内存"></p> <h4 id="共享内存系统"><a href="#共享内存系统" class="header-anchor">#</a> 共享内存系统</h4> <p>略。</p> <h4 id="互连网络"><a href="#互连网络" class="header-anchor">#</a> 互连网络</h4> <p>网络的类型、网络的性能指标的一堆概念略。</p> <h4 id="多维-mesh-网络"><a href="#多维-mesh-网络" class="header-anchor">#</a> 多维 Mesh 网络</h4> <p>Mesh：将一维线性的网络拓展到二维、三维或更高维度，结点之间只能和邻居进行交流。</p> <h4 id="超立方体结构"><a href="#超立方体结构" class="header-anchor">#</a> 超立方体结构</h4> <p>超立方体结构：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span></span> 维的超立方体有 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><msup><mn>2</mn><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">p=2^d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span></span> 个结点。</p> <p>对超立方体进行编号，可以按照如图的规律：</p> <p><img src="/images/b65f17eaafed3888ffdcde84eb1ad84aeaa2ae1687221694405d9c3e95f57d35.png" alt="三维及以下的超立方体"></p> <p>每个 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span></span> 维的超立方体可以分成两个相同的 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">d-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span> 维超立方体，编号分别以 0 和 1 开头，且两个子超立方体对应结点的编号除第一位外相同。</p> <p>按此法可以构造出四维超立方体。</p> <p><img src="/images/c1bb7fbb09828fa72ab8beb097f6e15ec05193210b10f5bc86a6e5e5b08ed1d1.png" alt="四维超立方体"></p> <p>该编号方案还有一个性质：两个结点的距离等于这两个结点的汉明距离（不同的位的数量）。如在图中，0110 和 0101 的距离为 2。该性质在使用超立方体构造并行算法时会很有用。</p> <h4 id="缓存一致性"><a href="#缓存一致性" class="header-anchor">#</a> 缓存一致性</h4> <p>缓存的写策略有 Write-back 和 Write-through。在 UMA 架构下，多个处理器有各自的缓存，共用内存。</p> <p><img src="/images/721e9e82756be134c4d86d06a1c54c0586d1c6b0dd82209f63b5674f24e07ec6.png" alt="UMA 架构下的缓存一致性协议"></p> <p>于是，出现了两个新的概念：</p> <ul><li>Write Invalidate：处理器写自己的缓存时，使其他缓存失效；Write-through 下还需要更新内存，Write-back 下需要使内存失效。</li> <li>Write Update：处理器写自己的缓存时，立即更新其他缓存；Write-through 下还需要更新内存，Write-back 下需要标记缓存为脏，在缓存失效的时候写回内存。</li></ul> <p>两种策略在什么情况下性能更好？（猜测是在不同核频繁更新不同数据时，写失效更好；多个核都在频繁写同一个数据时，写更新更好。）</p> <p>现代计算机都默认使用写失效策略。（猜测是因为局部性原理，多核读不同数据的情况更多）</p> <h5 id="写失效协议"><a href="#写失效协议" class="header-anchor">#</a> 写失效协议</h5> <p>三种状态：<strong>Shared</strong>、<strong>Invalid</strong>、<strong>Modified</strong>（MSI）</p> <ul><li><code>Shared</code>：存在多份有效的数据（写会导致其他失效）</li> <li><code>Modified</code>：只有当前数据有效（写不会导致其他失效）</li> <li><code>Invalidate</code>：数据无效（读会请求数据）</li></ul> <p><img src="/images/3c4ac3aecb36f6b3c4d21e5dd1d9250b30fd54850fea0183b01b9de03169024e.png" alt="三状态转换图"></p> <hr> <p>硬件条件：所有核共享一个总线，可以用于广播。当 0 号处理器更新了 <code>x</code>，会广波这个消息，其他核听到（snoop）以后就会把自己的 <code>x</code> 标记为 <code>Invalid</code>。</p> <hr> <ol><li>当一个数据是 <code>Modified</code> 后，所有操作都直接在本地进行，无需向外部广播。</li> <li>多个核读入一个数据时，所有缓存的内容都会变为 <code>Shared</code>，随后所有的读操作都直接在本地进行，无需向外部广播。</li> <li>多个核同时读和写时，会出现（在带宽上的）瓶颈</li></ol> <h5 id="基于目录的缓存一致性协议"><a href="#基于目录的缓存一致性协议" class="header-anchor">#</a> 基于目录的缓存一致性协议</h5> <ul><li>基于目录：共享的状态都存储在（位于内存的）“目录”</li> <li>目录里用一位表示 shared/dirty 状态（State）</li> <li>目录里用一个 bitmap 表示数据被缓存在哪些处理器（Presence Bits）</li></ul> <p><img src="/images/d2e14b80fbeca0d08d21fe3fdf5587d834a10f3ea523529ee3cf1765014c2e45.png" alt="目录"></p> <ol><li>处理器 0 和处理器 1 读 x，此时状态为 shared，0 和 1 的 presence bits 均为 1</li> <li>处理器 0 写变量，状态变为 dirty，1 的 presence bits 为 0</li> <li>处理器 2 读变量，将会请求处理器 0 写回，随后 0 和 2 的 presence bits 均为 1</li></ol> <hr> <p>该方案的开销主要是通信开销、以及可能出现频繁的争端。</p> <p>如果一个并行程序需要大量的一致性操作（大量的读/写共享数据块），目录最终会限制它的并行性能。</p> <hr> <p>还可以分布式的目录系统，但是这里就学了。</p> <h5 id="false-sharing"><a href="#false-sharing" class="header-anchor">#</a> False Sharing</h5> <p>不懂</p> <h3 id="并行计算的软件"><a href="#并行计算的软件" class="header-anchor">#</a> 并行计算的软件</h3> <p>并行软件也有区别：</p> <ul><li>内存共享系统上，一个进程 fork 出多个线程</li> <li>分布式系统上，需要多个进程</li></ul> <p>SPMD: single program multiple data，MPI 和 CUDA 都是用的都是这种。</p> <p>解决并行软件的不一致性：给数据加锁</p> <p>SPMD 的写法：</p> <div class="language- extra-class"><pre class="language-text"><code>char message [ 1 0 0 ] ;
. . .
my_rank = Get_rank ( ) ;
if ( my_rank == 1) {
     sprintf ( message , &quot;Greetings from process 1&quot; ) ;
     Send ( message , MSG_CHAR , 100 , 0 ) ;
} else if ( my_rank == 0) {
     Receive ( message , MSG_CHAR , 100 , 1 ) ;
     printf ( &quot;Process 0 &gt; Received: %s\n&quot; , message ) ;
}
</code></pre></div><h3 id="输入输出"><a href="#输入输出" class="header-anchor">#</a> 输入输出</h3> <p>Google 翻译 yyds</p> <p>当我们的并行程序需要进行 I/O 时，做出这些假设并遵循这些规则：
在分布式内存程序中，仅进程0将访问stdin。 在共享内存程序中，只有主线程或线程 0 会访问 stdin。
在分布式内存和共享内存程序中，所有进程/线程都可以访问 stdout 和 stderr。
然而，由于输出到 stdout 的顺序不确定，在大多数情况下，除了调试输出之外，只有一个进程/线程将用于所有输出到 stdout。
调试输出应始终包括生成输出的进程/线程的等级或 ID。
只有单个进程/线程会尝试访问除 stdin、stdout 或 stderr 之外的任何单个文件。 因此，例如，每个进程/线程都可以打开自己的私有文件进行读取或写入，但没有两个进程/线程会打开同一个文件。</p> <h2 id="_3-parallel-program-design"><a href="#_3-parallel-program-design" class="header-anchor">#</a> 3 Parallel Program Design</h2> <h3 id="foster-四步走"><a href="#foster-四步走" class="header-anchor">#</a> Foster 四步走</h3> <p>注意这四步，是设计算法的过程的四步，而不是并行算法的先后步骤。</p> <ul><li>Partitioning：分块</li> <li>Communication：通信</li> <li>Agglomeration：组合</li> <li>Mapping：映射</li></ul> <p><img src="/images/0fb7fe40d8f55adf8f33169950b557a2106404164470c41751be8f754651da33.png" alt="Foster's Design Methodology"></p> <h3 id="分块"><a href="#分块" class="header-anchor">#</a> 分块</h3> <p>Domain vs. Functional Decomposition</p> <p>其实就是数据并行 vs. 任务并行</p> <h3 id="通信"><a href="#通信" class="header-anchor">#</a> 通信</h3> <p>通信方法可以分为局部通信和邻居通信</p> <p><img src="/images/d454a01f5f3d9d2e3792416ef7d268d42b8d85f0ad663a09d591cc9c584babc7.png" alt="Local communication"></p> <p><img src="/images/bf0a0208fc6f11abc4703791e2338bb9a6dd02818f75764d4050b19e0d882b58.png" alt="Global communication"></p> <hr> <p>例子：对求和问题进行分治，只需要 logN 步</p> <p><img src="/images/252f55fa41156f6b15c36df9b59b46c0584bfa1af1e50f32a9507402d2f869de.png" alt="分治求和问题"></p> <hr> <p>通信方法也可以分为结构化通信（通信网络有一定结构）和非结构化通信（通信网络可能是任意图）。</p> <p>如果通信网络还在变化，负载均衡算法就必须频繁地更新。</p> <p><img src="/images/83e66b2afd4e1eddf9ef8e602988951cacccb828c479fef3facb01da8d8e2293.png" alt="Unstructured communication"></p> <h3 id="聚合"><a href="#聚合" class="header-anchor">#</a> 聚合</h3> <p>聚合可以减少通信成本：任务的通信需求与其操作的子域的表面成正比，而计算需求与子域的体积成正比。有时我们可以权衡复制计算以减少通信需求和/或执行时间。</p> <h3 id="映射"><a href="#映射" class="header-anchor">#</a> 映射</h3> <p>映射：将任务映射到处理器上。</p> <p>目标：最大化处理器利用（即负载均衡） &amp; 最小化处理器间通信（即需要通信的进程可以映射到同一处理器）</p> <p><img src="/images/a4680869e38463b763dd6a09111297235619f61afeda946b208a47cdd74005e9.png" alt="奇奇怪怪的图的一种映射方法"></p> <p>不同情况下映射策略：略。</p> <hr> <p><img src="/images/fcb65523957abd252aa1b01ab2c7c87d797a121a106ba9e64a1ff91ac8aaebbc.png" alt="Agglomeration 例题"></p> <p>公式：</p> <ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi></mrow><annotation encoding="application/x-tex">\chi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">χ</span></span></span></span></span>：更新一个元素的时间</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span></span>：一个元素通信的时间</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>：结点数</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>：需要的迭代次数</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>：处理器数</li></ul> <p>有一下结论：</p> <ul><li>串行执行时间：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>χ</mi></mrow><annotation encoding="application/x-tex">m(n-1)\chi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">χ</span></span></span></span></span></li> <li>并行执行时间：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">⌈</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>p</mi><mo stretchy="false">⌉</mo><mo>+</mo><mn>2</mn><mi>λ</mi></mrow><annotation encoding="application/x-tex">m\lceil(n-1)/p\rceil+2\lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">⌈</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">λ</span></span></span></span></span></li></ul> <p>有点不懂。是在这个问题下的时间公式吗？</p> <h2 id="_4-performance"><a href="#_4-performance" class="header-anchor">#</a> 4 Performance</h2> <p>性能指标：运行时间、加速比、效率、可扩展性等</p> <h3 id="加速比和效率指标"><a href="#加速比和效率指标" class="header-anchor">#</a> 加速比和效率指标</h3> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub><mo>=</mo><mfrac><msub><mi>T</mi><mi>s</mi></msub><msub><mi>T</mi><mi>p</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">S_p = \frac{T_s}{T_p}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.332438em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div></section><ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：串行时间</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">T_p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span> 个进程时的并行时间（按最长时间的进程计算）</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">S_p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span> or <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi(n, p)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span>：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span> 个进程时的加速比 (Speedup)</li></ul> <p><strong>加速比是速度的正比，是时间的反比</strong></p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>≤</mo><mfrac><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>p</mi><mo>+</mo><mi>κ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\psi(n, p) \leq \frac{\sigma(n)+\varphi(n)}{\sigma(n)+\varphi(n) / p+\kappa(n, p)}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">κ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div></section><p>好的加速比：（相较进程数）线性加速、亚线性加速、超线性加速</p> <p><img src="/images/807e384221a9eee87727e5c72b4e2397487d61877a61d664087eccc2f54b72a6.png" alt="好的加速比"></p> <p>超线性加速出现在：多级内存、缓存影响、DFS 遍历树算法等。</p> <hr> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>≤</mo><mfrac><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>p</mi><mo>+</mo><mi>κ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\psi(n, p) \leq \frac{\sigma(n)+\varphi(n)}{\sigma(n)+\varphi(n) / p+\kappa(n, p)}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">κ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div></section><ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>：不能被并行执行的的串行时间</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>：可以被并行执行的串行时间</li> <li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\kappa(n, p)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">κ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span>：并行执行带来的通信时间</li></ul> <p>比较显然，公式的意思是：并行算法的时间为：<code>串行时间+并行部分/p+通行时间</code></p> <p><strong>这个公式一定要记住，后面的推导都是基于这个公式！</strong></p> <hr> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>p</mi></msub><mo>=</mo><mfrac><msub><mi>S</mi><mi>p</mi></msub><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">E_p=\frac{S_p}{p}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.2407700000000004em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div></section><ul><li><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">E_p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span> or <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varepsilon(n, p)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span>：效率</li></ul> <p>线性加速比程序的效率为 100%。</p> <p>将 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">S_p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span> 代入即有：</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>≤</mo><mfrac><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mi>p</mi><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>p</mi><mi>κ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\varepsilon(n, p) \leq \frac{\sigma(n)+\varphi(n)}{p\sigma(n)+\varphi(n)+p\kappa(n, p)}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">κ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div></section><p>可以推出 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>ε</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \leq \varepsilon(n, p) \leq 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ε</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>。</p> <h4 id="amdahl-定律"><a href="#amdahl-定律" class="header-anchor">#</a> Amdahl 定律</h4> <p>Amdahl 定律和 Gustafson-Barsis 定律都把通信成本放缩掉了。两个求的都是加速比，但是注意条件不一样（一个是 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span></span> 一个是 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></span>）</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>≤</mo><mfrac><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>p</mi><mo>+</mo><mi>κ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\psi(n, p) \leq \frac{\sigma(n)+\varphi(n)}{\sigma(n)+\varphi(n) / p+\kappa(n, p)}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">κ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div></section><p>令 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span></span> 为串行部分占比（占改进之前的比），即 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mfrac><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">f=\frac{\sigma(n)}{\sigma(n)+\varphi(n)}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>，有：</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo>≤</mo><mfrac><mn>1</mn><mrow><mi>f</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>p</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\psi \leq \frac{1}{f+(1-f)/p}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div></section><p><strong>加速比不大于“串行占比+p倍并行占比”的反比</strong></p> <hr> <blockquote><p>例题：95% of a program's execution time occurs inside a loop that can be executed in parallel. What is the maximum speedup we should expect from a parallel version of the program executing on 8 CPUs?</p></blockquote> <p>注意题目说的是串行在改进前需要执行 5% 的时间，这就符合 Amdahl 的条件。答案是 5.9。</p> <h4 id="gustafson-barsis-定律"><a href="#gustafson-barsis-定律" class="header-anchor">#</a> Gustafson-Barsis 定律</h4> <p>令 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 为串行部分占比（占改进之后的比），即 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mfrac><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>p</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">s = \frac{\sigma(n)}{\sigma(n)+\varphi(n)/p}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>，有：</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo>≤</mo><mi>p</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">\psi \leq p + (1-p)s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mord mathdefault">s</span></span></span></span></span></div></section><p>可以看到，如果 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></span> 小，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo>≈</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\psi \approx p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>，并行效率很好。</p> <hr> <blockquote><p>例题：An application running on 10 processors spends 3% of its time in serial code. What is the scaled speedup of the application?</p></blockquote> <p>注意题目说的是串行代码在改进后需要执行 3% 的时间，这就符合 Gustafson-Barsis 的条件。答案是 9.73。</p> <h4 id="karp-flatt-metric-指标"><a href="#karp-flatt-metric-指标" class="header-anchor">#</a> Karp-Flatt Metric 指标</h4> <p>Amdahl 和 Gustafson-Barsis 都忽略了通信成本，会高估放大比。Karp-Flatt 从另一个角度来进行分析。</p> <p>但是这个公式起手就很怪异。</p> <p>令<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mfrac><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>κ</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">e = \frac{\sigma(n) + \kappa(n,p)}{\sigma(n)+\varphi(n)}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">κ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">p</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p> <p><code>串行时间 + 通信时间 / 串行时间 + 可并行的时间</code>？</p> <p>能够推出</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>ψ</mi><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>p</mi></mrow><mrow><mn>1</mn><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>p</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">e = \frac{1/\psi - 1/p}{1 - 1/p}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div></section><hr> <p>这个公式很奇怪，结合例题我大概看懂了：</p> <p>结论 1：注意到 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 一定的情况下，<code>串行时间</code>、<code>可并行的时间</code> 是恒定的，所以 <strong><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span> 和 <code>通信时间</code> 的增长趋势是一样的</strong>。<br>
即，<strong>在不同的 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span> 下，如果 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span> 恒定，说明通信时间恒定；<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span> 稳定增长，说明通信时间也稳定增长。</strong></p> <p>结论 2：随 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span> 的增大，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span> 不能先增大后减小（只能一直增大/不变或一直减小/不变：一直增大是次线性加速比，而一直减小就是超线性加速比）</p> <hr> <p>例 1：</p> <table><thead><tr><th><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span></th> <th>2</th> <th>3</th> <th>4</th> <th>5</th> <th>6</th> <th>7</th> <th>8</th></tr></thead> <tbody><tr><td><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span></span></span></span></span></td> <td>1.8</td> <td>2.5</td> <td>3.1</td> <td>3.6</td> <td>4.0</td> <td>4.4</td> <td>4.7</td></tr> <tr><td>计算可得 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span></td> <td>0.1</td> <td>0.1</td> <td>0.1</td> <td>0.1</td> <td>0.1</td> <td>0.1</td> <td>0.1</td></tr></tbody></table> <p>为什么 8 核的加速比只有 4.7？注意到 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span> 不随 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span> 变化，说明问题不是通信成本，是串行代码耗时太高。</p> <hr> <p>例 2：</p> <table><thead><tr><th><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span></th> <th>2</th> <th>3</th> <th>4</th> <th>5</th> <th>6</th> <th>7</th> <th>8</th></tr></thead> <tbody><tr><td><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span></span></span></span></span></td> <td>1.9</td> <td>2.6</td> <td>3.2</td> <td>3.7</td> <td>4.1</td> <td>4.5</td> <td>4.7</td></tr> <tr><td>计算可得 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span></td> <td>0.07</td> <td>0.075</td> <td>0.08</td> <td>0.085</td> <td>0.09</td> <td>0.095</td> <td>0.1</td></tr></tbody></table> <p>为什么 8 核的加速比只有 4.7？注意到 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span> 不随 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span> 变化，说明问题不是通信成本，是串行代码耗时太高。</p> <hr> <p>例 3：</p> <table><thead><tr><th><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span></th> <th>4</th> <th>8</th> <th>12</th></tr></thead> <tbody><tr><td><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ψ</span></span></span></span></span></td> <td>3.9</td> <td>6.5</td> <td>？</td></tr></tbody></table> <p><code>?</code> 处能否为 10？</p> <p>假设 <code>?=10</code>，算得 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span> 先增大后减小，不可能。</p> <h3 id="等效率"><a href="#等效率" class="header-anchor">#</a> 等效率</h3> <p>不会，看 PPT</p> <h3 id="可扩展性"><a href="#可扩展性" class="header-anchor">#</a> 可扩展性</h3> <p>不会，看 PPT</p> <h2 id="_5-message-passing-programming"><a href="#_5-message-passing-programming" class="header-anchor">#</a> 5 Message-Passing Programming</h2> <p>MPI 常用函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//First MPI function called by each process</span>
<span class="token function">MPI_Init</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// First argument is communicator</span>
<span class="token comment">// Number of processes returned through second argument</span>
<span class="token function">MPI_Comm_size</span> <span class="token punctuation">(</span>MPI_COMM_WORLD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Process rank (in range 0, 1, …, p-1) returned through second argument</span>
<span class="token function">MPI_Comm_rank</span> <span class="token punctuation">(</span>MPI_COMM_WORLD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Call after all other MPI library calls</span>
<span class="token function">MPI_Finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// reduce 操作</span>
<span class="token keyword">int</span> <span class="token function">MPI_Reduce</span> <span class="token punctuation">(</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>operand<span class="token punctuation">,</span>      <span class="token comment">/* addr of 1st reduction element */</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>result<span class="token punctuation">,</span>       <span class="token comment">/* addr of 1st reduction result, only root get result */</span>
    <span class="token keyword">int</span> count<span class="token punctuation">,</span>          <span class="token comment">/* reductions to perform */</span>
    MPI_Datatype type<span class="token punctuation">,</span>  <span class="token comment">/* type of elements */</span>
    MPI_Op <span class="token keyword">operator</span><span class="token punctuation">,</span>    <span class="token comment">/* reduction operator */</span>
    <span class="token keyword">int</span> root<span class="token punctuation">,</span>           <span class="token comment">/* process getting result(s) */</span>
    MPI_Comm comm       <span class="token comment">/* communicator */</span>
<span class="token punctuation">)</span>
<span class="token function">MPI_Reduce</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>global_count<span class="token punctuation">,</span> MPI_INT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MPI_COMM_WORLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Benchmarking the Program</span>
<span class="token keyword">double</span> elapsed_time<span class="token punctuation">;</span>
<span class="token function">MPI_Init</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MPI_Barrier</span> <span class="token punctuation">(</span>MPI_COMM_WORLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
elapsed_time <span class="token operator">=</span> <span class="token operator">-</span> <span class="token function">MPI_Wtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token function">MPI_Reduce</span> <span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>
elapsed_time <span class="token operator">+=</span> <span class="token function">MPI_Wtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="附-mpich-中文教程"><a href="#附-mpich-中文教程" class="header-anchor">#</a> 附 MPICH 中文教程</h3> <p>https://scc.ustc.edu.cn/zlsc/cxyy/200910/MPICH/</p> <h2 id="_6-the-sieve-of-eratosthenes"><a href="#_6-the-sieve-of-eratosthenes" class="header-anchor">#</a> 6 The Sieve of Eratosthenes</h2> <p>因为这部分做了实验，所以不多说算法原理了。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">MPI_Bcast</span> <span class="token punctuation">(</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span>           <span class="token comment">/* Addr of 1st element */</span>
    <span class="token keyword">int</span> count<span class="token punctuation">,</span>              <span class="token comment">/* # elements to broadcast */</span>
    MPI_Datatype datatype<span class="token punctuation">,</span>  <span class="token comment">/* Type of elements */</span>
    <span class="token keyword">int</span> root<span class="token punctuation">,</span>               <span class="token comment">/* ID of root process */</span>
    MPI_Comm comm<span class="token punctuation">)</span>          <span class="token comment">/* Communicator */</span>
<span class="token function">MPI_Bcast</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> MPI_INT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MPI_COMM_WORLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="分块算法"><a href="#分块算法" class="header-anchor">#</a> 分块算法</h3> <p>这个问题需要按数据分块。可以使用循环分配，可以按块分配。</p> <p>使用循环分配，</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>m</mi><mi>y</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>i</mi><mo>∗</mo><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mi>p</mi></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>m</mi><mi>y</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mi>p</mi></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">⌊</mo><mfrac><mi>j</mi><mrow><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>p</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">⌋</mo><mo separator="true">,</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>j</mi><mo>−</mo><mi>r</mi></mrow><mrow><mo stretchy="false">⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>p</mi><mo stretchy="false">⌋</mo></mrow></mfrac><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
my\_first\_i &amp;= i * \lfloor\frac{n}{p}\rfloor + \min(i,r) \\
my\_last\_i &amp;= (i+1)* \lfloor\frac{n}{p}\rfloor + \min(i+1,r) - 1 \\
count &amp;= \min(\lfloor \frac{j}{\lfloor n / p \rfloor+1}\rfloor, \lfloor \frac{j-r}{\lfloor n / p \rfloor}\rfloor)
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:7.14852em;vertical-align:-3.3242599999999998em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.8242600000000007em;"><span style="top:-6.0532200000000005em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span></span></span><span style="top:-3.7652200000000002em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span></span></span><span style="top:-1.2482600000000006em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.3242599999999998em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.8242600000000007em;"><span style="top:-6.0532200000000005em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span><span style="top:-3.7652200000000002em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-1.2482600000000006em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">⌊</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">⌊</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mclose">⌋</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.3242599999999998em;"><span></span></span></span></span></span></span></span></span></span></span></span></div></section><p>使用按块分配，就是第一章的<a href="#%E4%B9%A0%E9%A2%98">习题</a>中提到的：</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>m</mi><mi>y</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>i</mi><mo>∗</mo><mi>n</mi></mrow><mi>p</mi></mfrac><mo stretchy="false">⌋</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>m</mi><mi>y</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>n</mi></mrow><mi>p</mi></mfrac><mo stretchy="false">⌋</mo><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mo stretchy="false">⌋</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
my\_first\_i &amp;= \lfloor\frac{i*n}{p}\rfloor \\
my\_last\_i &amp;= \lfloor\frac{(i+1)*n}{p}\rfloor - 1 \\
count &amp;= \lfloor \frac{p(j+1)-1}{n}\rfloor
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:7.5374em;vertical-align:-3.518699999999999em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.018700000000001em;"><span style="top:-6.10918em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span></span></span><span style="top:-3.5017400000000016em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span></span></span><span style="top:-0.8943000000000011em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.518699999999999em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.018700000000001em;"><span style="top:-6.10918em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span><span style="top:-3.5017400000000016em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-0.8943000000000011em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.518699999999999em;"><span></span></span></span></span></span></span></span></span></span></span></span></div></section><p>两种算法都可以，后面一种表达式更简单，所以选择这一种。</p> <h3 id="算法性能分析"><a href="#算法性能分析" class="header-anchor">#</a> 算法性能分析</h3> <p><img src="/images/88adda06e90b6e2c1c35fe8d2aad587701b90083324719108b918b9cc6902d4b.png" alt="时间复杂度"></p> <h2 id="_7-floyd-s-algorithm"><a href="#_7-floyd-s-algorithm" class="header-anchor">#</a> 7 Floyd's Algorithm</h2> <p>Floyd 算法伪代码：</p> <div class="language- extra-class"><pre class="language-text"><code>for k = 0 to n-1
	for i = 0 to n-1
		for j = 0 to n-1
			a[i,j] = min (a[i,j], a[i,k] + a[k,j])
		endfor
	endfor
endfor
</code></pre></div><h3 id="分块-2"><a href="#分块-2" class="header-anchor">#</a> 分块</h3> <p>把矩阵 A 的每个元素视为一个任务，分解成 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 个任务。</p> <h3 id="通信-2"><a href="#通信-2" class="header-anchor">#</a> 通信</h3> <p><img src="/images/4d969f0f01de0dbe26625734319141343aa94a3d757408bcdac3dab1d47851ae.png" alt="通信"></p> <h3 id="聚合和映射"><a href="#聚合和映射" class="header-anchor">#</a> 聚合和映射</h3> <p><img src="/images/bd034b3575872b50830cff9eb155eda3ef522efb0552aed853a65cf98ee25494.png" alt="按行或者按列聚合"></p> <p>按行或者按列聚合。最后选择按行聚合，在读文件的时候会容易的多。</p> <h3 id="点对点通信"><a href="#点对点通信" class="header-anchor">#</a> 点对点通信</h3> <p><img src="/images/747c86c5ddb798561512cd64ff6699014e62dec235a4b397dad4b97e6dd7ccd9.png" alt="点对点通信"></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">MPI_Send</span> <span class="token punctuation">(</span>
    <span class="token keyword">void</span>         <span class="token operator">*</span>message<span class="token punctuation">,</span>
    <span class="token keyword">int</span>           count<span class="token punctuation">,</span>
    MPI_Datatype  datatype<span class="token punctuation">,</span>
    <span class="token keyword">int</span>           dest<span class="token punctuation">,</span>
    <span class="token keyword">int</span>           tag<span class="token punctuation">,</span>
    MPI_Comm      comm
<span class="token punctuation">)</span>

<span class="token keyword">int</span> <span class="token function">MPI_Recv</span> <span class="token punctuation">(</span>
    <span class="token keyword">void</span>         <span class="token operator">*</span>message<span class="token punctuation">,</span>
    <span class="token keyword">int</span>           count<span class="token punctuation">,</span>
    MPI_Datatype  datatype<span class="token punctuation">,</span>
    <span class="token keyword">int</span>           source<span class="token punctuation">,</span>
    <span class="token keyword">int</span>           tag<span class="token punctuation">,</span>
    MPI_Comm      comm<span class="token punctuation">,</span>
    MPI_Status   <span class="token operator">*</span>status
<span class="token punctuation">)</span>
</code></pre></div><p>Send 和 Recv 需要约定相同的 tag，以及对方的 id (作为自己的 source/dest)。</p> <p><img src="/images/3468470bf9dc8be793b76a0e6cc744b6731b8c0d269058acd9c65a240b03f856.png" alt="send/recv 原理"></p> <ul><li><code>MPI_Send</code> 函数会一直阻塞直至 message_buffer 空了。</li> <li><code>MPI_Recv</code> 函数会一直阻塞直至收到消息。</li></ul> <p>这就很容易造成死锁。</p> <h4 id="死锁"><a href="#死锁" class="header-anchor">#</a> 死锁</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">MPI_Recv</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">MPI_Send</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   c <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">MPI_Recv</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">MPI_Send</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   c <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>Process 0 blocks waiting for message from 1, but 1 blocks waiting for a message from 0.
Deadlock!</p> <hr> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">MPI_Send</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">1</span><span class="token punctuation">,</span>MPI_COMM_WORLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">MPI_Recv</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">1</span><span class="token punctuation">,</span> MPI_COMM_WORLD<span class="token punctuation">,</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
	c <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">MPI_Send</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">,</span>MPI_COMM_WORLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">MPI_Recv</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">,</span> MPI_COMM_WORLD<span class="token punctuation">,</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
	c <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Both processes send before they try to receive, but they still deadlock.  Why?
The tags are wrong. Process 0 is trying to receive a tag of 1, but Process 1 is sending a tag of 0.</p> <h4 id="ssend"><a href="#ssend" class="header-anchor">#</a> Ssend</h4> <p>依赖 buffer 的 <code>MPI_send</code> 是不安全的，因为 MPI 标准允许 <code>MPI_Send</code> 可以提供/不提供 buffer。</p> <p>两种问题可能会出问题：</p> <ol><li>双方都是先发后收，并且发的数据都很大</li> <li>生产者/消费者问题，且生产者生产的比消费者块</li></ol> <p>MPI 标准定义了 <code>MPI_Ssend</code>，保证发送会被阻塞（<code>s</code> 表 <code>synchronous</code>）。</p> <h4 id="sendrecv"><a href="#sendrecv" class="header-anchor">#</a> SendRecv</h4> <p>如果需要同时发送接收，可以通过代码逻辑使大家按照某种顺序，避免死锁，但也可以使用 <code>MPI_SendRecv</code> 同时发送和接收，中间的调度由 MPI 实现。</p> <p><img src="/images/c72afb5b5bac41c8bfcdb01a5fe8d35fc3fc79f5fa0b40f4643b66fcfa75fc3c.png" alt="MPI_SendRecv"></p> <h3 id="并行-floyd-算法"><a href="#并行-floyd-算法" class="header-anchor">#</a> 并行 Floyd 算法</h3> <p><img src="/images/79faaecb53a6c844f6ecccd9db9105a37912b1708a911b5d1c1179d1c0d7a8d7.png" alt="核心部分"></p> <ul><li>计算时间复杂度：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mi mathvariant="normal">/</mi><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^3/p)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></li> <li>通信时间复杂度：<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi>log</mi><mo>⁡</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n^2 \log p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span></span></li> <li>执行时间（其中 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span></span> 是显存带宽，其他变量见第三章）：</li></ul> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">⌈</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>p</mi><mo stretchy="false">⌉</mo><mi>n</mi><mi>χ</mi><mo>+</mo><mi>n</mi><mo stretchy="false">⌈</mo><mi>log</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">⌉</mo><mo stretchy="false">(</mo><mi>λ</mi><mo>+</mo><mn>4</mn><mi>n</mi><mi mathvariant="normal">/</mi><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n \lceil n / p \rceil n \chi +
n \lceil \log p \rceil (\lambda + 4n / \beta)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">⌈</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mclose">⌉</span><span class="mord mathdefault">n</span><span class="mord mathdefault">χ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">⌈</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">⌉</span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span></span></div></section><h2 id="cuda-部分"><a href="#cuda-部分" class="header-anchor">#</a> CUDA 部分</h2> <h3 id="结构"><a href="#结构" class="header-anchor">#</a> 结构</h3> <ul><li>Thread -- Register</li> <li>Warp</li> <li>Block -- 对应一个 Streming Multiprocessors，Shared Memory</li> <li>Grid -- 对应一个 Kernel</li> <li>Device -- Global Memory</li></ul> <h3 id="代码思路"><a href="#代码思路" class="header-anchor">#</a> 代码思路</h3> <p>用  Block 处理二维图像：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>__global__ <span class="token keyword">void</span> <span class="token function">PictureKernel</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span> d_Pin<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> d_Pout<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> Row <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>y<span class="token operator">*</span>blockDim<span class="token punctuation">.</span>y <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
  <span class="token keyword">int</span> Col <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x<span class="token operator">*</span>blockDim<span class="token punctuation">.</span>x <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Row <span class="token operator">&lt;</span> height<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>Col <span class="token operator">&lt;</span> width<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    d_Pout<span class="token punctuation">[</span>Row<span class="token operator">*</span>width<span class="token operator">+</span>Col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2.0</span><span class="token operator">*</span>d_Pin<span class="token punctuation">[</span>Row<span class="token operator">*</span>width<span class="token operator">+</span>Col<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  dim3 <span class="token function">DimGrid</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">16</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">16</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  dim3 <span class="token function">DimBlock</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  PictureKernel<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span>DimGrid<span class="token punctuation">,</span>DimBlock<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>d_Pin<span class="token punctuation">,</span> d_Pout<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="block-大小"><a href="#block-大小" class="header-anchor">#</a> Block 大小</h3> <p>For Matrix Multiplication using multiple blocks, should I use 8X8, 16X16 or 32X32 blocks for Fermi?</p> <ul><li>For 8X8, we have 64 threads per Block. Since each SM can take up to 1536 threads, which translates to 24 Blocks. However, each SM can only take up to 8 Blocks, only 512 threads will go into each SM!</li> <li>For 16X16, we have 256 threads per Block. Since each SM can take up to 1536 threads, it can take up to 6 Blocks and achieve full capacity unless other resource considerations overrule.</li> <li>For 32X32, we would have 1024 threads per Block. Only one block can fit into an SM for Fermi. Using only 2/3 of the thread capacity of an SM.</li></ul> <h3 id="cgma"><a href="#cgma" class="header-anchor">#</a> CGMA</h3> <p>CGMA = 从全局内存中取一个数，多少次运算用到了这个数</p> <p>CGMA 越大越好</p> <h3 id="shared-memory-and-threading"><a href="#shared-memory-and-threading" class="header-anchor">#</a> Shared Memory And Threading</h3> <p><img src="/images/63f9b6471890380c4f186f2bd8b45e8e7b8d3e765ad9fb38ee2a2049736909bd.png" alt="Shared Memory And Threading"></p> <h2 id="openacc-部分"><a href="#openacc-部分" class="header-anchor">#</a> OpenACC 部分</h2> <h3 id="gpu-占用率"><a href="#gpu-占用率" class="header-anchor">#</a> GPU 占用率</h3> <blockquote><p>GPU Occupancy is:</p> <ul><li>How much parallelism is running / How much parallelism the hardware could run</li> <li>100% occupancy is not required for, nor does it guarantee best performance.</li> <li>Less than 50% occupancy is often a red flag</li></ul></blockquote></div> <hr role="separator" aria-orientation="horizontal" class="ma-4 v-divider theme--light"> <!----></div></div></article></div> <!----></div></div> <div role="dialog" class="v-dialog__container"><button type="button" role="button" aria-haspopup="true" aria-expanded="false" class="v-btn v-btn--bottom v-btn--is-elevated v-btn--fab v-btn--fixed v-btn--has-bg v-btn--right v-btn--round theme--dark v-size--default primary"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-information-variant theme--dark"></i></span></button><!----></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2022</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c07ccffd.js" defer></script><script src="/assets/js/44.26ac42e2.js" defer></script>
  </body>
</html>
