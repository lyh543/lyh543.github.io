<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《深入剖析 Kubernetes》 笔记 - 容器和 Pod | 小灰灰灰灰的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/theme/favicon.png">
    <link rel="alternate" type="application/rss+xml" href="https://blog.lyh543.cn/rss.xml" title="小灰灰灰灰的博客 RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://blog.lyh543.cn/feed.atom" title="小灰灰灰灰的博客 Atom Feed">
    <link rel="alternate" type="application/json" href="https://blog.lyh543.cn/feed.json" title="小灰灰灰灰的博客 JSON Feed">
    <meta name="description" content="本篇是《深入剖析 Kubernetes》 的读书笔记，作者为张磊老师。

第五章《Kubernetes 编排原理》讲的内容都还比较实用，基本上都是在使用 Kubernetes 中就会接触到的概念和功能。

Kubectl Cheatsheet

创建/更新一个 yaml 文件：kubectl apply -f xxx.yaml
查询资源列表：kubectl get pods， ...">
    
    <link rel="preload" href="/assets/css/0.styles.832ac33f.css" as="style"><link rel="preload" href="/assets/js/app.596ee27b.js" as="script"><link rel="preload" href="/assets/js/220.a3266b82.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.832ac33f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="v-application v-application--is-ltr theme--light"><div class="v-application--wrap"><!----> <main id="main-content" class="v-main" style="padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-main__wrap"><div><container class="article-column-container"><div class="article-column"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><div class="v-card v-sheet theme--light"><div class="container"><div itemprop="articleBody" class="markdown-body content__default"><p>本篇是《深入剖析 Kubernetes》 的读书笔记，作者为张磊老师。</p> <p>第五章《Kubernetes 编排原理》讲的内容都还比较实用，基本上都是在使用 Kubernetes 中就会接触到的概念和功能。</p> <h2 id="kubectl-cheatsheet"><a href="#kubectl-cheatsheet" class="header-anchor">#</a> Kubectl Cheatsheet</h2> <ul><li><p>创建/更新一个 yaml 文件：<code>kubectl apply -f xxx.yaml</code></p></li> <li><p>查询资源列表：<code>kubectl get pods</code>，然后可以接 <code>grep</code></p></li> <li><p>查询资源详情：<code>kubectl describe pod xxx</code></p></li> <li><p>导出 secret 的 yaml：<code>kubectl get secret &lt;secret-name&gt; -o yaml &gt; secret.yaml</code></p></li> <li><p>启动一个临时的 pod：<code>kubectl run -it --rm --image=busybox --restart=Never debug -- sh</code></p></li> <li><p>回滚更新：<code>kubectl rollout undo deployment nginx-deployment</code></p></li></ul> <h2 id="pod"><a href="#pod" class="header-anchor">#</a> Pod</h2> <p>一个 Pod 会有多个容器。同 Pod 的所有容器会在一台机器上运行。</p> <p><strong>Pod &lt;-&gt; 机器，管理容器、Namespace，以及网络、Volume 等资源</strong><br> <strong>Container &lt;-&gt; 用户进程</strong></p> <p>每个 Pod 会有一个 Infra 容器，使用 pause 镜像，负责占据 Network、Namespace、Volume 等资源，然后给同 Pod 的其它容器使用。Infra 容器的生命周期和 Pod 的生命周期一致。</p> <p>Pod 的一些配置，看到名字都能大概猜出来是什么意思。知道干嘛的就好，具体用的时候再来细查。不少配置在生产环境中很有用：</p> <ul><li>VolumeMounts</li> <li>InitContainers</li> <li>HostAliases &amp; Hostnames</li> <li>ImagePullPolicy (Always, IfNotPresent, Never)</li> <li>Lifecycle.PostStart &amp; PreEnd</li> <li>Status &amp; Condition (PodScheduled, Ready, Initialized, Unschedulable)</li> <li>ProjectedVolumes: Secret, ConfigMap, Downward API, ServiceAccountToken</li> <li>RestartPolicy (Always, OnFailure, Never)</li> <li>LivenessProbe &amp; ReadinessProbe</li> <li>PodPreset</li> <li>Tolerations</li></ul> <h2 id="taint-toleration"><a href="#taint-toleration" class="header-anchor">#</a> Taint &amp; Toleration</h2> <p>Taint（污点）和 Toleration（容忍）是一个很有意思的模型。这两个词乍一看，和计算机科学没什么关系，以至于我第一时间完全不知道是什么功能。但是明白用处以后，又会觉得这两个词很生动形象。</p> <p>简单来说，我们都知道 K8s 的核心工作之一是把 Pod 调度到 Node 上运行，而 Taint 和 Toleration 是定义一组规则来控制哪些 Pod 可以运行在哪些 Node 上。</p> <p>Taint 是 Node 上的属性，它负责“污染” Node，让 Pod 不愿意运行在这个 Node 上。而 Toleration 是 Pod 的属性，它负责“容忍” Taint，让 Pod 可以运行在被污染的 Node 上。Taint 和 Toleration 模型的思想其实就是这两行。</p> <p>Taint 和 Toleration 的用法，本文就不具体展开了。感兴趣的读者可以看看 K8s 官方文档。</p> <p><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/" target="_blank" rel="noopener noreferrer">污点和容忍度 | Kubernetes<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://zhuanlan.zhihu.com/p/393572345" target="_blank" rel="noopener noreferrer">kubernetes扩展：污点和容忍 - 知乎<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="persistentvolumeclaim-persistentvolume"><a href="#persistentvolumeclaim-persistentvolume" class="header-anchor">#</a> PersistentVolumeClaim &amp; PersistentVolume</h2> <p><strong>Pod -&gt; PVC -&gt; PV</strong></p> <p>PVC 是定义接口（大小、AccessModes 等），PV 是实现（实际存储位置、认证信息等）。而 Pod 只需要在配置里面把 PVC 挂载到指定路径就行。</p> <h2 id="statefulset-主从-pod"><a href="#statefulset-主从-pod" class="header-anchor">#</a> StatefulSet &amp; 主从 Pod</h2> <p>StatefulSet 是一个用起来比较复杂的概念，它解决的运维问题本身也比较复杂。简单来说，StatefulSet 可以用来部署“有状态应用”。</p> <p>我对“有状态应用”的理解是：应用的状态是持久化的，且关键在于有一定的顺序性（拓扑结构），比如一主多从的 MySQL 集群。在部署这种集群时，每个节点需要知道自己的拓扑位置（节点是主还是从），可能还需要根据自己的位置做不同的初始化工作。</p> <p>在 StatefulSet 中，Pod 的名字是有序的，比如 <code>mysql-0</code>、<code>mysql-1</code>、<code>mysql-2</code>。这样就可以通过 Pod 的名字来确定 Pod 的位置。在初始化时，可能需要在 yaml 里写 shell：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">initContainers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> init<span class="token punctuation">-</span>mysql
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>
    <span class="token key atrule">command</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> bash
      <span class="token punctuation">-</span> <span class="token string">&quot;-c&quot;</span>
      <span class="token punctuation">-</span> <span class="token punctuation">|</span><span class="token scalar string">
        [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
        ordinal=${BASH_REMATCH[1]}
        if [ $ordinal -eq 0 ]; then
          # 初始化主节点
        else
          # 初始化从节点</span>
</code></pre></div><h2 id="daemonset"><a href="#daemonset" class="header-anchor">#</a> DaemonSet</h2> <p>和 ReplicaSet、StatefulSet 一样，DaemonSet 控制了一堆 Pods。不同的是，DaemonSet 控制的 Pod 有一个特点：<strong>DaemonSet 保证每个 Node 上有且只有一个 DaemonSet 对应的 Pod</strong>。</p> <p>所以 DaemonSet 适合部署一些需要在每个 Node 上运行的服务，比如日志收集、监控等。</p> <h2 id="job-cronjob"><a href="#job-cronjob" class="header-anchor">#</a> Job &amp; CronJob</h2> <p>ReplicaSet、StatefulSet 和 DaemonSet 都运行了一些需要一直运行的 Pod，如果挂了会自动重启。而 Job 和 CronJob 则是运行一些一次性任务，运行完了会自动退出，状态变成 Completed；失败了以后可以配置自动重试，或者直接 Fail 掉。</p> <p>Job 也有一些常用配置：</p> <ul><li>RestartPolicy (OnFailure：失败后重启容器；Never：失败后创建新的 Pod)</li> <li>BackoffLimit</li> <li>ActiveDeadlineSeconds</li> <li>Parallelism</li> <li>Completions</li></ul> <p>CronJob 则是定时任务，可以配置 Cron 表达式。除了 Cron 以外，它还可以配置：</p> <ul><li>ConcurrencyPolicy (Allow, Forbid, Replace) - 到时间点时，如果上一个任务还没执行完，这个任务是允许、禁止还是替换上一个任务</li></ul> <h2 id="rbac"><a href="#rbac" class="header-anchor">#</a> RBAC</h2> <p>如果要在 Pod 里通过 Kubernetes API Server 读写 Pod 或者各种资源的信息（典型的例子是 Prometheus 这类性能监控），需要给这个 Pod 加权限。这时候就需要用到 RBAC。</p> <p>Service Account &lt;-&gt; RoleBinding (ClusterRoleBinding) &lt;-&gt; Role (ClusterRole)</p> <h2 id="自定义-controller、operator"><a href="#自定义-controller、operator" class="header-anchor">#</a> 自定义 Controller、Operator</h2> <p>从这里开始就需要写点代码了。书里用的是 go，不过官方也支持使用 Python SDK 访问 Custom Resource，所以也可以写 Python。</p> <hr> <p><a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/" target="_blank" rel="noopener noreferrer">定制资源 | Kubernetes<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>K8s 支持以插件的形式自定义资源（Custom Resource Definition，CRD），定义资源的时候需要启动这个资源的控制器（Controller），来处理这个资源的增删改查。</p> <p>书中的例子定义了一个名为 network 的资源，启动 Controller 以后，使用这个资源的方法和其它资源一样：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>kubectl get network
kubectl describe network my-network
kubectl apply -f example/example-network.yaml
</code></pre></div><p>关于 Controller 的架构，张磊老师把书里的原图放到了 <a href="https://twitter.com/resouer/status/1009996649832185856" target="_blank" rel="noopener noreferrer">Twitter<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 上。</p> <p><img src="/images/k8s-controller-workflow.jpg" alt="Controller 架构"></p> <p>虚线框里是一个 Controller 的架构，包含 Informer、Work Queue 和最右边的业务逻辑实现（<code>runWorker()</code> 函数）。</p> <p>在声明式 API 中，用户提交的 yaml 文件里包含了用户声明的所有资源。Informer 负责从 Kubernetes API Server 拿到用户声明资源的变化，然后把变化（增/删/改）的资源的 key（<code>namespace/name</code>）放到 Work Queue 里。Work Queue 里的任务会被 <code>runWorker()</code> 函数异步处理，处理完以后把 key 从队列里丢掉。</p> <p>看起来很复杂，但是大部分代码都是可以自动生成的，只有最后 <code>runWorker()</code> 里的业务逻辑需要自己写。</p> <hr> <p><a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/operator/" target="_blank" rel="noopener noreferrer">Operator 模式 | Kubernetes<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Operator 和自定义控制器很像，都是通过编程来实现更复杂、yaml 实现不了的资源管理。不过 Controller 更倾向于定义并管理一种新的资源，Operator 更倾向于把一堆运维步骤打包、自动化。</p> <p>不过这块的实现真的很重。配环境、查文档、编程实现、测试 debug、部署运维，都是一大堆工作。还是等 yaml 配置不够用了再考虑吧。</p></div> <hr role="separator" aria-orientation="horizontal" class="ma-4 v-divider theme--light"> <div data-v-54a1e472><script src="https://giscus.app/client.js" async="async" service="giscus" data-repo="lyh543/blog-comments" data-repo-id="R_kgDOHIb2Zg" data-category="Announcements" data-category-id="DIC_kwDOHIb2Zs4COh2z" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" data-v-54a1e472></script></div></div></div></article></div> <!----></container> <div class="v-dialog__container"><button type="button" role="button" aria-haspopup="true" aria-expanded="false" class="v-btn v-btn--bottom v-btn--is-elevated v-btn--fab v-btn--fixed v-btn--has-bg v-btn--right v-btn--round theme--dark v-size--default primary"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-information-variant theme--dark"></i></span></button><!----></div></div></div></main> <footer id="footer" class="v-footer v-sheet theme--light v-footer--absolute v-footer--padless v-footer--inset" style="left:0px;right:0px;bottom:0px;"><div class="lighten-1 text-center v-card v-sheet theme--light rounded-0" style="width:100%;"><div class="v-card__text"><a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-github theme--light" style="font-size:24px;"></i></span></a><a href="https://blog.lyh543.cn/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-web theme--light" style="font-size:24px;"></i></span></a><a href="mailto:lyh543@outlook.com" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-email theme--light" style="font-size:24px;"></i></span></a><a href="https://weibo.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-sina-weibo theme--light" style="font-size:24px;"></i></span></a><a href="https://weixin.qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-wechat theme--light" style="font-size:24px;"></i></span></a><a href="https://qq.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><i aria-hidden="true" class="v-icon notranslate mdi mdi-qqchat theme--light" style="font-size:24px;"></i></span></a><a href="https://bilibili.com/" target="_blank" class="mx-4 v-btn v-btn--icon v-btn--round theme--light v-size--default"><span class="v-btn__content"><div class="v-image v-responsive theme--light" style="max-width:24px;"><div class="v-image__image v-image__image--preload v-image__image--cover" style="background-image:;background-position:center center;"></div><div class="v-responsive__content"></div></div></span></a></div> <hr role="separator" aria-orientation="horizontal" class="v-divider theme--light"> <div class="v-card__text"><span class="footer-text">lyh543 © 2019 - 2024</span>
        |
      <a href="https://beian.miit.gov.cn/" target="_blank" class="footer-link">蜀ICP备19034464号</a>
        |
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" class="footer-link">署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
        |
       <span class="footer-text">
        Theme
        <a href="https://github.com/lyh543/vuepress-theme-blog-material/" target="_blank" class="footer-link">
          vuepress-theme-blog-material
        </a></span></div></div></footer></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.596ee27b.js" defer></script><script src="/assets/js/220.a3266b82.js" defer></script>
  </body>
</html>
